<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>html,body{background:#000;margin:0;padding:0}</style>
    <title>Crust</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
        }
        
        canvas {
            display: block;
            image-rendering: auto;
        }
        
        #ui {
            position: absolute;
            top: 15px;
            left: 15px;
            color: white;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.85), rgba(20, 20, 40, 0.9));
            padding: 20px;
            border-radius: 12px;
            font-size: 16px;
            pointer-events: none;
            min-width: 250px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 100;
        }
        
        .stat-container {
            margin: 12px 0;
        }
        
        .stat-label {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.9;
        }
        
        .stat-bar {
            position: relative;
            background: rgba(0, 0, 0, 0.5);
            height: 24px;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .stat-fill {
            height: 100%;
            transition: none;
            position: relative;
            overflow: hidden;
        }
        
        .stat-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.3), transparent);
        }
        
        .stat-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 11px;
            font-weight: bold;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
            z-index: 1;
        }
        
        .health-bar {
            background: linear-gradient(90deg, #c0392b, #e74c3c);
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.5);
        }
        
        .hunger-bar {
            background: linear-gradient(90deg, #d68910, #f39c12);
            box-shadow: 0 0 15px rgba(243, 156, 18, 0.5);
        }
        
        .thirst-bar {
            background: linear-gradient(90deg, #2874a6, #3498db);
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.5);
        }
        
        .stamina-bar {
            background: linear-gradient(90deg, #16a085, #1abc9c);
            box-shadow: 0 0 15px rgba(26, 188, 156, 0.5);
        }

        @keyframes staminaFlash {
            0%   { background: linear-gradient(90deg, #7f0000, #c0392b); box-shadow: 0 0 20px rgba(220,50,50,0.9); }
            50%  { background: linear-gradient(90deg, #c0392b, #e74c3c); box-shadow: 0 0 30px rgba(255,80,80,1); }
            100% { background: linear-gradient(90deg, #7f0000, #c0392b); box-shadow: 0 0 20px rgba(220,50,50,0.9); }
        }
        .stamina-exhausted {
            animation: staminaFlash 0.5s ease-in-out infinite !important;
        }
        
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            pointer-events: none;
            opacity: 0.8;
            z-index: 10;
        }
        
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.8), 0 0 8px rgba(255, 255, 255, 0.3);
        }
        
        #crosshair::before {
            width: 2px;
            height: 24px;
            left: 11px;
        }
        
        #crosshair::after {
            width: 24px;
            height: 2px;
            top: 11px;
        }
        
        #pistol-crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 3px;
            height: 3px;
            background: red;
            border-radius: 50%;
            pointer-events: none;
            opacity: 0.9;
            box-shadow: 0 0 4px rgba(255, 0, 0, 0.8), 0 0 8px rgba(255, 0, 0, 0.5);
            z-index: 10;
        }
        
        #pistol-crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 0, 0, 0.6);
            border-radius: 50%;
            box-shadow: 0 0 6px rgba(255, 0, 0, 0.4);
        }
        
        #ammo-counter {
            position: absolute;
            bottom: 140px;
            right: 40px;
            color: white;
            font-size: 32px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.9), 0 0 20px rgba(255, 0, 0, 0.5);
            pointer-events: none;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.7), rgba(40, 0, 0, 0.8));
            padding: 15px 25px;
            border-radius: 10px;
            border: 2px solid rgba(255, 0, 0, 0.4);
            backdrop-filter: blur(5px);
        }
        
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 40, 0.95));
            padding: 25px 40px;
            border-radius: 15px;
            text-align: center;
            max-width: 900px;
            font-size: 14px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.7);
            z-index: 10000;
        }
        
        #crafting-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(10, 10, 30, 0.98), rgba(20, 20, 40, 0.98));
            color: white;
            padding: 25px;
            border-radius: 15px;
            display: none;
            width: 850px;
            max-height: 85vh;
            overflow-y: auto;
            pointer-events: auto;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.8);
        }
        
        #workbench-menu, #furnace-menu, #recycler-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(10, 10, 30, 0.98), rgba(20, 20, 40, 0.98));
            color: white;
            padding: 25px;
            border-radius: 12px;
            display: none;
            width: 750px;
            max-height: 85vh;
            overflow-y: auto;
            pointer-events: auto;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.8);
            z-index: 2000;
        }
        
        #crafting-menu::-webkit-scrollbar, #workbench-menu::-webkit-scrollbar, #furnace-menu::-webkit-scrollbar, #recycler-menu::-webkit-scrollbar {
            width: 8px;
        }
        
        #crafting-menu::-webkit-scrollbar-track, #workbench-menu::-webkit-scrollbar-track, #furnace-menu::-webkit-scrollbar-track, #recycler-menu::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        
        #crafting-menu::-webkit-scrollbar-thumb, #workbench-menu::-webkit-scrollbar-thumb, #furnace-menu::-webkit-scrollbar-thumb, #recycler-menu::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }
        
        .menu-title {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 20px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        #workbench-menu .menu-title,
        #furnace-menu .menu-title {
            font-size: 20px;
            margin-bottom: 15px;
        }
        
        .craft-item, .build-item {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.05));
            padding: 15px;
            margin: 12px 0;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        .craft-item::before, .build-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }
        
        .craft-item:hover::before, .build-item:hover::before {
            left: 100%;
        }
        
        .craft-item:hover, .build-item:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.1));
            transform: translateX(5px);
            box-shadow: 0 4px 20px rgba(52, 152, 219, 0.3);
        }
        
        .craft-item.disabled, .build-item.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }
        
        .craft-item.disabled:hover, .build-item.disabled:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.05));
            box-shadow: none;
        }
        
        /* Category Grid Layout */
        .menu-category {
            margin-bottom: 25px;
        }
        
        .category-title {
            font-size: 16px;
            font-weight: bold;
            color: #3498db;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid rgba(52, 152, 219, 0.3);
        }
        
        .category-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 12px;
        }
        
        .grid-item {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.05));
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.1);
            text-align: center;
            position: relative;
            overflow: hidden;
            min-height: 90px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .grid-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }
        
        .grid-item:hover::before {
            left: 100%;
        }
        
        .grid-item:hover {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.3), rgba(41, 128, 185, 0.3));
            transform: translateY(-2px);
            border-color: rgba(52, 152, 219, 0.6);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }
        
        .grid-item.disabled {
            opacity: 0.35;
            cursor: not-allowed;
        }
        
        .grid-item.disabled:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.05));
            transform: none;
            border-color: rgba(255, 255, 255, 0.1);
            box-shadow: none;
        }
        
        .grid-item-icon {
            width: 40px;
            height: 40px;
            margin-bottom: 6px;
            margin-left: auto;
            margin-right: auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .grid-item-icon svg { display: block; width: 100%; height: 100%; border-radius: 4px; }
        
        .grid-item-name {
            font-weight: bold;
            font-size: 13px;
            margin-bottom: 4px;
            color: #fff;
        }
        
        .grid-item-cost {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.3;
        }
        
        .time-display {
            position: fixed;
            top: 15px;
            right: 15px;
            color: white;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.85), rgba(20, 20, 40, 0.9));
            padding: 15px 20px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            z-index: 50;
        }
        
        #message {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.95), rgba(192, 57, 43, 0.95));
            padding: 12px 24px;
            border-radius: 10px;
            display: none;
            z-index: 1000;
            font-weight: 600;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            animation: slideDown 0.3s ease-out;
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translate(-50%, -20px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }
        
        #build-info {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(20, 20, 40, 0.95));
            padding: 15px 25px;
            border-radius: 10px;
            display: none;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .menu-button {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            margin-top: 15px;
            cursor: pointer;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .menu-button:hover {
            background: linear-gradient(135deg, #34495e, #2c3e50);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
            transform: translateY(-2px);
        }
        
        #death-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.9), rgba(192, 57, 43, 0.85));
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }
        
        #death-screen h1 {
            color: white;
            font-size: 84px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.8), 0 0 40px rgba(255, 0, 0, 0.5);
            animation: pulse 2s infinite;
            text-transform: uppercase;
            letter-spacing: 4px;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        #death-screen p {
            color: white;
            font-size: 24px;
            margin-bottom: 40px;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
        }
        
        #respawn-button {
            padding: 20px 60px;
            font-size: 24px;
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6);
            transition: all 0.3s ease;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        #respawn-button:hover {
            background: linear-gradient(135deg, #c0392b, #a93226);
            transform: scale(1.1) translateY(-5px);
            box-shadow: 0 12px 40px rgba(231, 76, 60, 0.6);
        }
        
        #hotbar {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.85), rgba(20, 20, 40, 0.9));
            padding: 15px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            z-index: 100;
        }
        
        .hotbar-slot {
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.03));
            border: 2px solid rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 11px;
            position: relative;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .hotbar-slot:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.08));
            transform: translateY(-5px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }
        
        .hotbar-slot.selected {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.4), rgba(41, 128, 185, 0.4));
            border-color: #3498db;
            box-shadow: 0 0 20px rgba(52, 152, 219, 0.6), inset 0 0 10px rgba(52, 152, 219, 0.3);
            transform: translateY(-5px);
        }
        
        .hotbar-slot-number {
            position: absolute;
            top: 4px;
            left: 5px;
            font-size: 10px;
            font-weight: bold;
            opacity: 0.8;
            background: rgba(0, 0, 0, 0.6);
            padding: 1px 4px;
            border-radius: 3px;
            z-index: 2;
            line-height: 1.4;
        }
        
        .hotbar-slot-icon {
            position: absolute;
            inset: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .hotbar-slot-icon svg { display: block; width: 100%; height: 100%; border-radius: 4px; }
        
        .hotbar-slot-count {
            position: absolute;
            bottom: 3px;
            right: 4px;
            font-size: 10px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.75);
            padding: 1px 4px;
            border-radius: 3px;
            z-index: 2;
            line-height: 1.4;
        }
        
        #hotbar-tooltip {
            position: fixed;
            bottom: 130px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 40, 0.95));
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
            z-index: 1000;
            white-space: nowrap;
        }
        
        #hotbar-tooltip.visible {
            opacity: 1;
        }
        
        #inventory-ui {
            position: fixed;
            bottom: 120px;
            right: 20px;
            z-index: 100;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.85), rgba(20, 20, 40, 0.9));
            padding: 20px;
            border-radius: 12px;
            color: white;
            max-width: 300px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        #inventory-ui h3 {
            margin: 0 0 15px 0;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            border-bottom: 2px solid rgba(52, 152, 219, 0.5);
            padding-bottom: 8px;
        }
        
        .inventory-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 10px;
            margin: 6px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.2s ease;
        }
        
        .inventory-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }
        
        .inventory-item-name {
            font-weight: 500;
        }
        
        .inventory-item-count {
            font-weight: bold;
            color: #3498db;
        }
        
        #minimap {
            position: fixed;
            top: 15px;
            right: 15px;
            width: 180px;
            height: 180px;
            background: rgba(0, 0, 0, 0.85);
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            margin-top: 50px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            z-index: 50;
        }
        
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a1e, #1a1a2e);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            opacity: 1;
            transition: opacity 1s ease-out;
        }
        
        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-title {
            font-size: 48px;
            color: white;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 4px;
            text-shadow: 0 0 20px rgba(52, 152, 219, 0.8);
        }
        
        .loading-bar {
            width: 400px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        
        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 20px rgba(52, 152, 219, 0.8);
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        
        #inventory-panel {
            position: fixed;
            top: calc(50% - 65px);
            left: 50%;
            transform: translate(-50%, -50%);
            width: clamp(320px, 90vw, 850px);
            max-height: calc(100vh - 160px);
            overflow: hidden;
            background: linear-gradient(135deg, rgba(10, 10, 30, 0.98), rgba(20, 20, 40, 0.98));
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 0;
            backdrop-filter: blur(15px);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.8);
            z-index: 1500;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
        }
        
        #inventory-content {
            display: flex;
            position: relative;
        }
        
        #storage-panel {
            position: fixed;
            top: 50%;
            left: 25%;
            transform: translate(-50%, -50%);
            width: 520px;
            background: linear-gradient(135deg, rgba(40, 30, 10, 0.98), rgba(60, 45, 20, 0.98));
            border: 2px solid rgba(255, 200, 100, 0.3);
            border-radius: 12px;
            padding: 0;
            backdrop-filter: blur(15px);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.8);
            z-index: 1500;
            pointer-events: auto;
        }
        #backpack-panel {
            position: fixed;
            top: 50%;
            left: 25%;
            transform: translate(-50%, -50%);
            width: 520px;
            background: linear-gradient(135deg, rgba(15, 8, 3, 0.98), rgba(40, 20, 8, 0.98));
            border: 2px solid rgba(200, 100, 30, 0.7);
            border-radius: 12px;
            padding: 0;
            backdrop-filter: blur(15px);
            box-shadow: 0 12px 48px rgba(0,0,0,0.9), 0 0 30px rgba(200,80,20,0.25);
            z-index: 1500;
            pointer-events: auto;
            display: none;
        }
        #backpack-header {
            background: linear-gradient(135deg, rgba(120, 55, 10, 0.6), rgba(160, 80, 20, 0.6));
            padding: 15px 20px;
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            border-bottom: 2px solid rgba(200, 100, 30, 0.5);
        }
        #backpack-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 6px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        #inventory-header {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.3), rgba(41, 128, 185, 0.3));
            padding: 15px 20px;
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            cursor: move;
            user-select: none;
            border-bottom: 2px solid rgba(52, 152, 219, 0.5);
        }
        
        #storage-header {
            background: linear-gradient(135deg, rgba(139, 105, 20, 0.4), rgba(184, 134, 11, 0.4));
            padding: 15px 20px;
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            cursor: move;
            user-select: none;
            border-bottom: 2px solid rgba(218, 165, 32, 0.5);
        }
        
        /* Furnace and Campfire Menus */
        #furnace-menu, #campfire-menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 640px;
            background: linear-gradient(135deg, rgba(60, 30, 10, 0.98), rgba(80, 40, 20, 0.98));
            border: 3px solid rgba(255, 140, 0, 0.5);
            border-radius: 12px;
            padding: 0;
            backdrop-filter: blur(15px);
            box-shadow: 0 12px 48px rgba(255, 100, 0, 0.6);
            z-index: 1500;
            pointer-events: auto;
        }
        
        #furnace-header, #campfire-header {
            background: linear-gradient(135deg, rgba(255, 100, 0, 0.4), rgba(255, 140, 0, 0.4));
            padding: 15px 20px;
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            border-bottom: 2px solid rgba(255, 140, 0, 0.7);
        }
        
        #furnace-content, #campfire-content {
            padding: 25px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            align-items: start;
        }
        
        .smelting-slot-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        
        .smelting-label {
            font-size: 13px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
        }
        
        .smelting-slot {
            width: 80px;
            height: 80px;
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid rgba(255, 140, 0, 0.4);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .smelting-slot:hover {
            border-color: rgba(255, 140, 0, 0.8);
            background: rgba(255, 140, 0, 0.1);
            transform: scale(1.05);
        }
        
        .smelting-slot.output-slot {
            border-color: rgba(0, 255, 100, 0.4);
            cursor: pointer;
        }
        .smelting-slot.output-slot > * { pointer-events: none; }
        .smelting-slot > svg { pointer-events: none; }
        .smelting-slot > span { pointer-events: none; }
        
        .smelting-slot.output-slot:hover {
            border-color: rgba(0, 255, 100, 0.6);
        }
        
        .smelting-slot-count {
            position: absolute;
            bottom: 4px;
            right: 6px;
            font-size: 14px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 4px black, 0 0 2px black;
        }
        
        .smelting-progress-container {
            grid-column: 1 / -1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }
        
        .smelting-progress-bar {
            width: 100%;
            height: 30px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 140, 0, 0.5);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }
        
        .smelting-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6600, #ffaa00);
            width: 0%;
            transition: width 0.1s linear;
            box-shadow: 0 0 20px rgba(255, 140, 0, 0.8);
            position: relative;
        }
        
        .smelting-progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: progressShine 1.5s infinite;
        }
        
        @keyframes progressShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .smelting-progress-text {
            font-size: 16px;
            font-weight: bold;
            color: #ffaa00;
            text-shadow: 0 0 10px rgba(255, 140, 0, 0.8);
        }
        
        #close-furnace, #close-campfire {
            transition: all 0.2s ease;
        }
        
        #close-furnace:hover, #close-campfire:hover {
            background: rgba(255, 0, 0, 1) !important;
            transform: scale(1.1);
        }
        
        #cooking-station-menu {
            position: fixed;
            top: 50%;
            left: 28%;
            transform: translate(-50%, -50%);
            width: 560px;
            max-height: 88vh;
            overflow-y: auto;
            background: linear-gradient(135deg, rgba(40, 20, 5, 0.98), rgba(70, 35, 10, 0.98));
            border: 3px solid rgba(255, 160, 50, 0.5);
            border-radius: 12px;
            padding: 0;
            backdrop-filter: blur(15px);
            box-shadow: 0 12px 48px rgba(255, 120, 0, 0.6);
            z-index: 1500;
            pointer-events: auto;
        }
        #cooking-station-menu::-webkit-scrollbar { width: 6px; }
        #cooking-station-menu::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); }
        #cooking-station-menu::-webkit-scrollbar-thumb { background: rgba(255,140,0,0.5); border-radius: 3px; }
        #cooking-station-header {
            background: linear-gradient(135deg, rgba(200, 80, 0, 0.4), rgba(255, 140, 0, 0.4));
            padding: 10px 16px;
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            border-bottom: 2px solid rgba(255, 140, 0, 0.7);
            position: sticky; top: 0; z-index: 2;
        }
        #cooking-station-content {
            padding: 10px 16px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        /* Recipe book panel */
        #cs-recipe-book {
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,140,0,0.25);
            border-radius: 10px;
            padding: 8px;
            max-height: 260px;
            overflow-y: auto;
        }
        #cs-recipe-book::-webkit-scrollbar { width: 5px; }
        #cs-recipe-book::-webkit-scrollbar-thumb { background: rgba(255,140,0,0.4); border-radius:3px; }
        .cs-recipe-book-title {
            font-size: 11px; font-weight: bold; color: rgba(255,200,100,0.9);
            text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px;
        }
        /* Card grid — 2 columns */
        #cs-recipe-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }
        .cs-recipe-entry {
            display: flex; flex-direction: column; gap: 4px;
            padding: 7px; border-radius: 8px;
            background: rgba(255,140,0,0.06);
            border: 1px solid rgba(255,140,0,0.18);
            cursor: pointer;
            transition: background 0.15s, border-color 0.15s;
            position: relative;
        }
        .cs-recipe-entry:hover { background: rgba(255,140,0,0.16); border-color: rgba(255,140,0,0.45); }
        .cs-recipe-entry:hover .cs-recipe-tip { display: block; }
        .cs-recipe-entry > * { pointer-events: none; }
        .cs-recipe-entry .cs-recipe-tip { pointer-events: none; }
        /* Result row at top — big icon + name + desc */
        .cs-recipe-result-row {
            display: flex; align-items: center; gap: 8px;
        }
        .cs-recipe-result-row .cs-ricon {
            width: 36px; height: 36px; border-radius: 6px; flex-shrink: 0;
            background: rgba(0,0,0,0.5); border: 2px solid rgba(80,255,120,0.45);
            display: flex; align-items: center; justify-content: center; overflow: hidden;
        }
        .cs-recipe-result-row .cs-ricon svg { width: 28px !important; height: 28px !important; display: block; }
        .cs-recipe-result-info { display: flex; flex-direction: column; gap: 2px; min-width: 0; }
        .cs-recipe-result-name {
            font-size: 11px; font-weight: bold; color: rgba(100,255,130,0.95);
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .cs-recipe-result-desc {
            font-size: 10px; color: rgba(255,220,150,0.7); line-height: 1.3;
        }
        /* Divider between result and ingredients */
        .cs-recipe-divider {
            border: none; border-top: 1px solid rgba(255,140,0,0.15); margin: 0;
        }
        /* Ingredients row */
        .cs-recipe-ings-row {
            display: flex; align-items: flex-start; gap: 4px; flex-wrap: wrap;
        }
        .cs-recipe-ing-item {
            display: flex; flex-direction: column; align-items: center; gap: 3px;
        }
        .cs-recipe-ing-item .cs-ricon {
            width: 28px; height: 28px; border-radius: 5px;
            background: rgba(0,0,0,0.45); border: 1px solid rgba(255,140,0,0.3);
            display: flex; align-items: center; justify-content: center; overflow: hidden;
        }
        .cs-recipe-ing-item .cs-ricon svg { width: 20px !important; height: 20px !important; display: block; }
        .cs-recipe-ing-item .cs-rname {
            font-size: 8px; color: rgba(255,220,150,0.85); text-align: center;
            width: 28px; line-height: 1.2; word-break: break-word; font-weight: 600;
        }
        .cs-recipe-plus {
            font-size: 12px; color: rgba(255,140,0,0.5); font-weight: bold;
            align-self: center; padding-bottom: 14px;
        }
        /* Buff tag at bottom */
        .cs-recipe-buff-tag {
            font-size: 9px; background: rgba(0,255,100,0.12); border: 1px solid rgba(0,255,100,0.28);
            border-radius: 4px; padding: 2px 6px; color: rgba(100,255,130,0.9);
            white-space: nowrap; align-self: flex-start; font-weight: 600;
        }
        /* Keep legacy classes referenced elsewhere */
        .cs-recipe-icon-cell { display: flex; flex-direction: column; align-items: center; gap: 2px; }
        .cs-recipe-icon-cell .cs-ricon {
            width: 34px; height: 34px; border-radius: 6px;
            background: rgba(0,0,0,0.45); border: 1px solid rgba(255,140,0,0.3);
            display: flex; align-items: center; justify-content: center; overflow: hidden;
        }
        .cs-recipe-icon-cell .cs-ricon svg { width: 26px !important; height: 26px !important; display: block; }
        .cs-recipe-icon-cell .cs-rname {
            font-size: 9px; color: rgba(255,220,150,0.85); text-align: center;
            width: 34px; line-height: 1.2; word-break: break-word; font-weight: 600;
        }
        .cs-recipe-equals { display: none; }
        .cs-recipe-result-cell { display: none; }
        .cs-recipe-ings { color: rgba(255,200,100,0.85); font-size: 11px; }
        .cs-recipe-arrow { color: rgba(255,140,0,0.7); margin: 0 2px; }
        .cs-recipe-result { font-weight: bold; color: rgba(100,255,130,0.9); }
        .cs-recipe-tip {
            display: none;
            position: absolute;
            left: 50%; top: calc(100% + 6px);
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(10,30,10,0.98), rgba(20,50,20,0.98));
            border: 1px solid rgba(80,220,80,0.45);
            border-radius: 8px;
            padding: 10px 14px;
            min-width: 200px;
            max-width: 260px;
            z-index: 9999;
            pointer-events: none;
            box-shadow: 0 6px 24px rgba(0,0,0,0.7);
        }
        .cs-recipe-tip-title {
            font-size: 12px; font-weight: bold;
            color: #55ff88; margin-bottom: 6px;
            text-transform: uppercase; letter-spacing: 0.8px;
        }
        .cs-recipe-tip-buff { font-size: 12px; color: #aaffcc; line-height: 1.5; }
        .cs-recipe-tip-duration { font-size: 11px; color: rgba(180,255,180,0.6); margin-top: 4px; }
        .cs-buff-chevron {
            font-size: 10px; color: #44ff88; vertical-align: super; margin-left: 2px;
            text-shadow: 0 0 6px rgba(0,255,100,0.8); font-style: normal;
        }
        /* Active buff HUD indicator — flows naturally inside #ui panel */
        #buff-hud {
            display: flex; flex-direction: column; gap: 6px;
            margin-top: 10px;
            pointer-events: none;
        }
        .buff-indicator {
            background: linear-gradient(135deg, rgba(10,40,10,0.92), rgba(20,60,20,0.92));
            border: 1px solid rgba(80,220,80,0.5);
            border-radius: 8px; padding: 6px 12px;
            font-size: 12px; font-weight: bold; color: #66ff99;
            display: flex; align-items: center; gap: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.5);
            backdrop-filter: blur(6px);
        }
        .buff-indicator-timer { color: rgba(180,255,180,0.7); font-size: 11px; font-weight: normal; }
        /* Ingredient grid */
        .cs-row {
            display: flex; gap: 10px; align-items: flex-end; justify-content: center;
        }
        .cs-ingredient-grid { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; align-items: flex-start; padding: 4px 0; }
        .cs-slot-container { display: flex; flex-direction: column; align-items: center; gap: 3px; }
        .cs-label {
            font-size: 10px; font-weight: 600; color: rgba(255,255,255,0.65);
            text-transform: uppercase; letter-spacing: 0.5px; text-align: center;
        }
        /* All SVGs inside cooking station are icon-sized */
        #cooking-station-menu svg { width: 32px; height: 32px; flex-shrink: 0; display: inline-block; vertical-align: middle; }
        .cs-slot {
            width: 48px; height: 48px;
            background: rgba(0,0,0,0.55);
            border: 2px solid rgba(255,140,0,0.35);
            border-radius: 6px; display: flex; align-items: center; justify-content: center;
            font-size: 18px; cursor: pointer; transition: all 0.2s ease; position: relative;
            overflow: hidden; flex-shrink: 0;
        }
        .cs-slot svg { width: 36px !important; height: 36px !important; }
        .cs-slot:hover { border-color: rgba(255,140,0,0.75); background: rgba(255,140,0,0.1); transform: scale(1.05); }
        .cs-slot.cs-output { border-color: rgba(0,255,100,0.4); cursor: pointer; width: 56px; height: 56px; font-size: 22px; }
        .cs-slot.cs-output > * { pointer-events: none; }
        .cs-slot.cs-output svg { width: 44px !important; height: 44px !important; pointer-events: none; }
        .cs-slot.cs-output:hover { border-color: rgba(0,255,100,0.7); background: rgba(0,255,100,0.1); transform: scale(1.05); }
        .cs-slot.cs-waste { border-color: rgba(160,160,160,0.35); cursor: pointer; }
        .cs-slot.cs-waste:hover { border-color: rgba(160,160,160,0.6); background: rgba(160,160,160,0.08); }
        .cs-slot.drag-over { border-color: rgba(255,220,0,1) !important; background: rgba(255,220,0,0.2) !important; transform: scale(1.08); }
        .recycler-slot.drag-over { border-color: rgba(255,220,0,1) !important; background: rgba(255,220,0,0.2) !important; transform: scale(1.08); }
        .smelting-slot.dragging, .cs-slot.dragging, .recycler-slot.dragging, .wc-slot.dragging { opacity: 0.4; cursor: grabbing; }
        .recycler-slot[draggable="true"], .cs-slot[draggable="true"], .wc-slot[draggable="true"] { cursor: grab; }
        .cs-slot-count {
            position: absolute; bottom: 2px; right: 3px;
            font-size: 9px; font-weight: bold; color: white;
            text-shadow: 0 0 3px black, 0 0 2px black; pointer-events: none;
        }
        .cs-item-name {
            font-size: 9px; color: rgba(255,220,150,0.9); text-align: center;
            max-width: 56px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
            font-weight: 600; letter-spacing: 0.2px;
        }
        /* Recipe book inline icons — small fixed size */
        .cs-recipe-ings svg, .cs-recipe-result svg { width: 20px !important; height: 20px !important; vertical-align: middle; }
        #cs-recipe-hint {
            text-align: center; font-size: 11px;
            color: rgba(255,200,100,0.9); font-style: italic; min-height: 14px;
        }
        #cs-cook-btn {
            display: block; width: 100%;
            background: linear-gradient(135deg, #e67e22, #d35400);
            border: none; color: white; padding: 12px; border-radius: 8px;
            cursor: pointer; font-size: 15px; font-weight: bold;
            text-transform: uppercase; letter-spacing: 1px;
            transition: all 0.2s ease; box-shadow: 0 4px 15px rgba(230,126,34,0.4);
        }
        #cs-cook-btn:hover:not(:disabled) { background: linear-gradient(135deg, #f39c12, #e67e22); transform: scale(1.02); }
        #cs-cook-btn:disabled { opacity: 0.45; cursor: not-allowed; transform: none; }
        #close-cooking-station {
            background: rgba(255,0,0,0.8); border: none; color: white;
            padding: 5px 10px; border-radius: 4px; cursor: pointer; font-weight: bold;
            transition: all 0.2s ease;
        }
        #close-cooking-station:hover { background: rgba(255,0,0,1) !important; transform: scale(1.1); }
        
        .smelting-slot.drag-over {
            border-color: rgba(255, 220, 0, 1) !important;
            background: rgba(255, 220, 0, 0.2) !important;
            transform: scale(1.08);
        }
        
        .furnace-input-slot.active-smelt {
            border-color: rgba(255, 100, 0, 0.9) !important;
            box-shadow: 0 0 12px rgba(255, 100, 0, 0.7);
        }
        
        #close-inventory:hover {
            background: rgba(255, 0, 0, 1);
            transform: scale(1.1);
        }
        
        /* Recycler Menu */
        #recycler-menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 550px;
            background: linear-gradient(135deg, rgba(20, 40, 30, 0.98), rgba(30, 60, 40, 0.98));
            border: 3px solid rgba(76, 187, 23, 0.5);
            border-radius: 12px;
            padding: 0;
            backdrop-filter: blur(15px);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.8);
            z-index: 2001;
            pointer-events: auto;
        }
        
        #recycler-header {
            background: linear-gradient(135deg, rgba(76, 187, 23, 0.3), rgba(46, 125, 50, 0.3));
            padding: 15px 20px;
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            border-bottom: 2px solid rgba(76, 187, 23, 0.5);
        }
        
        #recycler-content {
            padding: 20px;
        }
        
        .recycler-section {
            margin-bottom: 15px;
        }
        
        .recycler-label {
            font-size: 14px;
            font-weight: bold;
            color: #4caf50;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .recycler-slots-container {
            display: flex;
            gap: 8px;
            justify-content: center;
        }
        
        .recycler-slot {
            width: 70px;
            height: 70px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(76, 187, 23, 0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
        }
        
        .recycler-slot:hover {
            border-color: rgba(76, 187, 23, 0.6);
            background: rgba(76, 187, 23, 0.1);
        }
        
        .recycler-slot.filled {
            background: rgba(76, 187, 23, 0.2);
            border-color: rgba(76, 187, 23, 0.5);
        }
        
        .recycler-slot-icon {
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 2px auto;
        }
        .recycler-slot-icon svg { display: block; width: 100%; height: 100%; border-radius: 4px; }
        
        .recycler-slot-count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 12px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 4px black;
        }
        
        .recycler-controls {
            text-align: center;
            margin: 20px 0;
        }
        
        #recycler-start-btn {
            background: linear-gradient(135deg, #4caf50, #2e7d32);
            border: none;
            color: white;
            padding: 12px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #recycler-start-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #66bb6a, #43a047);
            transform: scale(1.05);
        }
        
        #recycler-start-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .recycler-progress-container {
            margin: 15px 0;
        }
        
        .recycler-progress-bar {
            position: relative;
            height: 24px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(76, 187, 23, 0.3);
        }
        
        .recycler-progress-fill {
            position: absolute;
            top: 0; left: 0;
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            transition: width 0.05s linear;
            box-shadow: 0 0 15px rgba(76, 187, 23, 0.7);
            border-radius: 12px;
        }
        
        .recycler-progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 13px;
            font-weight: bold;
            color: white;
            text-shadow: 0 1px 3px rgba(0,0,0,0.9), 0 0 6px rgba(0,0,0,0.8);
            z-index: 2;
            pointer-events: none;
            white-space: nowrap;
        }
        
        #close-recycler {
            background: rgba(255, 0, 0, 0.8);
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
        }
        
        #close-recycler:hover {
            background: rgba(255, 0, 0, 1);
            transform: scale(1.1);
        }
        
        /* Well Menu */
        #water-catcher-menu {
            position: fixed;
            top: 50%;
            left: 28%;
            transform: translate(-50%, -50%);
            width: 420px;
            background: linear-gradient(135deg, rgba(10, 30, 50, 0.98), rgba(15, 45, 70, 0.98));
            border: 3px solid rgba(52, 152, 219, 0.5);
            border-radius: 12px;
            padding: 0;
            backdrop-filter: blur(15px);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.8), 0 0 30px rgba(52, 152, 219, 0.2);
            z-index: 2001;
            pointer-events: auto;
        }
        #water-catcher-header {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.3), rgba(41, 128, 185, 0.3));
            padding: 15px 20px;
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            border-bottom: 2px solid rgba(52, 152, 219, 0.5);
        }
        #water-catcher-content {
            padding: 20px;
        }
        .wc-label {
            font-size: 13px;
            font-weight: bold;
            color: #3498db;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .wc-slots-container {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        .wc-slot {
            width: 70px;
            height: 70px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(52, 152, 219, 0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
        }
        .wc-slot:hover {
            border-color: rgba(52, 152, 219, 0.7);
            background: rgba(52, 152, 219, 0.1);
        }
        .wc-slot.filled {
            background: rgba(52, 152, 219, 0.2);
            border-color: rgba(52, 152, 219, 0.6);
        }
        .wc-slot-icon { width: 44px; height: 44px; display: flex; align-items: center; justify-content: center; margin: 2px auto; }
        .wc-slot-icon svg { display: block; width: 100%; height: 100%; border-radius: 4px; }
        .wc-slot-count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 12px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 4px black;
        }
        .wc-progress-container { margin: 15px 0; }
        .wc-progress-bar {
            position: relative;
            height: 28px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 14px;
            overflow: hidden;
            border: 2px solid rgba(52, 152, 219, 0.3);
        }
        .wc-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #2980b9, #3498db, #74b9ff);
            transition: width 0.5s linear;
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.7);
        }
        .wc-progress-text {
            display: block;
            margin-top: 6px;
            text-align: center;
            font-size: 13px;
            font-weight: bold;
            color: #74b9ff;
            text-shadow: 0 0 8px rgba(0,0,0,0.8);
            white-space: nowrap;
        }
        .wc-rain-status {
            text-align: center;
            font-size: 13px;
            font-weight: bold;
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 12px;
        }
        .wc-rain-active {
            background: rgba(52, 152, 219, 0.2);
            color: #74b9ff;
            border: 1px solid rgba(52, 152, 219, 0.4);
        }
        .wc-rain-inactive {
            background: rgba(100, 100, 100, 0.2);
            color: #aaa;
            border: 1px solid rgba(100, 100, 100, 0.3);
        }
        #close-water-catcher {
            background: rgba(255, 0, 0, 0.8);
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
        }
        #close-water-catcher:hover {
            background: rgba(255, 0, 0, 1);
            transform: scale(1.1);
        }
        
        
        
        #storage-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 6px;
            padding: 16px;
            overflow: visible;
        }
        
        #inventory-grid::-webkit-scrollbar, #storage-grid::-webkit-scrollbar {
            width: 8px;
        }
        
        #inventory-grid::-webkit-scrollbar-track, #storage-grid::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        
        #inventory-grid::-webkit-scrollbar-thumb, #storage-grid::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }
        
        .inventory-slot {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.03));
            border: 2px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            position: relative;
            cursor: grab;
            transition: all 0.2s ease;
        }
        
        .inventory-slot:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.08));
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
        }
        
        .inventory-slot.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        
        .inventory-slot.drag-over {
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.3), rgba(39, 174, 96, 0.3));
            border-color: #2ecc71;
        }
        
        .inventory-slot-icon {
            position: absolute;
            inset: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .inventory-slot-icon svg { display: block; width: 100%; height: 100%; border-radius: 4px; }
        
        .inventory-slot-name {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            font-size: 9px;
            color: rgba(255, 255, 255, 0.9);
            text-align: center;
            font-weight: 600;
            background: rgba(0,0,0,0.65);
            padding: 2px 2px;
            border-radius: 0 0 6px 6px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            z-index: 2;
        }
        
        .inventory-slot-count {
            position: absolute;
            top: 3px;
            right: 4px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            z-index: 2;
            line-height: 1.4;
        }
        
        .inventory-slot-empty {
            color: rgba(255, 255, 255, 0.2);
            font-size: 24px;
        }
        
        /* Clothing/Armor Panel */
        #clothing-panel {
            width: 240px;
            padding: 20px;
            border-right: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        #clothing-panel h3 {
            text-align: center;
            color: #3498db;
            font-size: 14px;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }
        
        #armor-slots-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .armor-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .armor-label {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            min-width: 50px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .armor-slot {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.03));
            border: 2px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .armor-slot:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.08));
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
        }
        
        .armor-slot.equipped {
            border-color: #2ecc71;
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.2), rgba(39, 174, 96, 0.15));
        }
        
        .armor-slot.drag-over {
            border-color: rgba(52, 152, 219, 0.9);
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.25), rgba(41, 128, 185, 0.2));
            transform: scale(1.05);
        }
        .armor-slot.drag-invalid {
            border-color: rgba(231, 76, 60, 0.9);
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.2), rgba(192, 57, 43, 0.15));
        }

        
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto;
            opacity: 0.4;
        }
        .armor-slot-icon svg { display: block; width: 100%; height: 100%; border-radius: 4px; }
        
        .armor-slot.equipped .armor-slot-icon {
            opacity: 1;
        }
        
        #inventory-grid-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        #inventory-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            padding: 20px 20px 8px 20px;
        }

        #inventory-trash-slot {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 80px;
            height: 80px;
            border-radius: 8px;
            background: linear-gradient(135deg, rgba(180, 30, 30, 0.25), rgba(120, 10, 10, 0.3));
            border: 2px dashed rgba(220, 60, 60, 0.5);
            cursor: default;
            transition: background 0.15s, border-color 0.15s, transform 0.1s;
            font-size: 32px;
            margin: auto auto 16px auto;
            flex-shrink: 0;
        }
        #inventory-trash-slot:hover {
            background: linear-gradient(135deg, rgba(220, 50, 50, 0.35), rgba(160, 20, 20, 0.4));
            border-color: rgba(255, 80, 80, 0.8);
        }
        #inventory-trash-slot.drag-over {
            background: linear-gradient(135deg, rgba(255, 60, 60, 0.55), rgba(200, 20, 20, 0.55));
            border-color: rgba(255, 120, 120, 1);
            transform: scale(1.12);
        }
        
        /* ── Backpack extra slots panel ── */
        #backpack-slots-panel {
            display: none;
            border-top: 1px solid rgba(255,255,255,0.1);
            padding: 10px 20px 4px 20px;
        }
        #backpack-slots-panel .bp-header {
            font-size: 11px;
            color: rgba(255,255,255,0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        #backpack-slots-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
        }

        #admin-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(10, 10, 30, 0.98), rgba(20, 20, 40, 0.98));
            color: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 800px;
            max-height: 85vh;
            overflow-y: auto;
            pointer-events: auto;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.8);
            z-index: 3000;
        }
        
        #admin-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        #admin-content {
            padding: 10px 0;
        }
        
        .admin-section h3 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #3498db;
        }
        
        #admin-items-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }
        
        .admin-item {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .admin-item:hover {
            background: rgba(52, 152, 219, 0.2);
            border-color: rgba(52, 152, 219, 0.5);
            transform: scale(1.05);
        }
        
        .admin-item-icon {
            width: 44px;
            height: 44px;
            margin-bottom: 8px;
            margin-left: auto;
            margin-right: auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .admin-item-icon svg { display: block; width: 100%; height: 100%; border-radius: 4px; }
        
        .admin-item-name {
            font-size: 12px;
            font-weight: bold;
        }
        
        #pause-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 4000;
            pointer-events: auto;
        }
        
        #pause-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .pause-button {
            padding: 20px 60px;
            font-size: 20px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 8px 30px rgba(52, 152, 219, 0.3);
        }
        
        .pause-button:hover {
            background: linear-gradient(135deg, #2980b9, #21618c);
            transform: scale(1.05) translateY(-5px);
            box-shadow: 0 12px 40px rgba(52, 152, 219, 0.5);
        }
        
        #save-status {
            text-align: center;
            font-weight: bold;
        }

        /* ===== SAVE SLOT MODAL ===== */
        #save-slot-modal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.88);
            z-index: 9000;
            align-items: center;
            justify-content: center;
        }
        #save-slot-modal.open { display: flex; }
        #save-slot-box {
            background: linear-gradient(160deg, #0d1b2a, #1a2a3a);
            border: 2px solid rgba(52,152,219,0.5);
            border-radius: 18px;
            padding: 36px 40px 30px;
            min-width: 520px;
            max-width: 560px;
            box-shadow: 0 0 60px rgba(0,0,0,0.9), 0 0 30px rgba(52,152,219,0.15);
            color: white;
        }
        #save-slot-title {
            text-align: center;
            font-size: 26px;
            font-weight: bold;
            letter-spacing: 3px;
            text-transform: uppercase;
            margin-bottom: 6px;
            color: #3498db;
            text-shadow: 0 0 20px rgba(52,152,219,0.5);
        }
        #save-slot-subtitle {
            text-align: center;
            font-size: 12px;
            color: rgba(255,255,255,0.4);
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 24px;
        }
        .save-slot-row {
            display: flex;
            align-items: center;
            gap: 14px;
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 12px;
            padding: 13px 16px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
        .save-slot-row:hover { background: rgba(52,152,219,0.12); border-color: rgba(52,152,219,0.4); }
        .save-slot-row.autosave-row { border-color: rgba(255,165,0,0.25); }
        .save-slot-row.autosave-row:hover { background: rgba(255,165,0,0.1); border-color: rgba(255,165,0,0.5); }
        .save-slot-row.selected-slot { border-color: rgba(52,152,219,0.7); background: rgba(52,152,219,0.15); }
        .save-slot-icon {
            font-size: 26px;
            width: 36px;
            text-align: center;
            flex-shrink: 0;
        }
        .save-slot-info { flex: 1; min-width: 0; }
        .save-slot-label {
            font-size: 13px;
            font-weight: bold;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: rgba(255,255,255,0.9);
            margin-bottom: 3px;
        }
        .autosave-row .save-slot-label { color: #FFA040; }
        .save-slot-meta {
            font-size: 11px;
            color: rgba(255,255,255,0.45);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .save-slot-meta.has-data { color: rgba(255,255,255,0.65); }
        .save-slot-actions {
            display: flex;
            gap: 7px;
            flex-shrink: 0;
        }
        .slot-btn {
            padding: 7px 14px;
            font-size: 12px;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            letter-spacing: 0.5px;
        }
        .slot-btn-save {
            background: linear-gradient(135deg, #27ae60, #1e8449);
            color: white;
        }
        .slot-btn-save:hover { background: linear-gradient(135deg, #2ecc71, #27ae60); transform: scale(1.05); }
        .slot-btn-load {
            background: linear-gradient(135deg, #2980b9, #21618c);
            color: white;
        }
        .slot-btn-load:hover { background: linear-gradient(135deg, #3498db, #2980b9); transform: scale(1.05); }
        .slot-btn-load:disabled { background: #333; color: #666; cursor: not-allowed; transform: none; }
        .slot-btn-delete {
            background: rgba(192,57,43,0.7);
            color: rgba(255,255,255,0.7);
            padding: 7px 9px;
        }
        .slot-btn-delete:hover { background: rgba(231,76,60,0.9); color: white; transform: scale(1.05); }
        .slot-btn-delete:disabled { background: #1a1a1a; color: #333; cursor: not-allowed; transform: none; }
        .autosave-row .slot-btn-save { display: none; }
        #save-slot-close-row {
            display: flex;
            justify-content: center;
            margin-top: 18px;
        }
        #save-slot-close-btn {
            padding: 11px 40px;
            font-size: 14px;
            font-weight: bold;
            background: rgba(255,255,255,0.07);
            border: 1px solid rgba(255,255,255,0.15);
            color: rgba(255,255,255,0.7);
            border-radius: 10px;
            cursor: pointer;
            letter-spacing: 1px;
            transition: all 0.2s;
        }
        #save-slot-close-btn:hover { background: rgba(255,255,255,0.12); color: white; }
        #save-slot-status {
            text-align: center;
            font-size: 13px;
            font-weight: bold;
            min-height: 20px;
            margin-top: 14px;
            margin-bottom: -6px;
        }
        #autosave-timer-display {
            text-align: center;
            font-size: 11px;
            color: rgba(255,165,0,0.55);
            margin-bottom: 16px;
            letter-spacing: 1px;
        }

        /* ===== RESPONSIVE UI SCALING ===== */
        :root {
            --ui-scale: 1;
            --hotbar-slot: 70px;
            --inv-width: 850px;
        }
        @media (max-width: 1400px) {
            :root { --ui-scale: 0.88; --hotbar-slot: 62px; --inv-width: 748px; }
        }
        @media (max-width: 1100px) {
            :root { --ui-scale: 0.76; --hotbar-slot: 54px; --inv-width: 646px; }
        }
        @media (max-width: 800px) {
            :root { --ui-scale: 0.62; --hotbar-slot: 46px; --inv-width: 527px; }
        }
        @media (max-width: 550px) {
            :root { --ui-scale: 0.50; --hotbar-slot: 40px; --inv-width: 425px; }
        }
        #ui {
            transform-origin: top left;
            transform: scale(var(--ui-scale));
        }
        #hotbar {
            transform-origin: bottom center;
            transform: translateX(-50%) scale(var(--ui-scale));
        }
        .hotbar-slot {
            width: var(--hotbar-slot) !important;
            height: var(--hotbar-slot) !important;
        }
        /* inventory-panel sizing handled by clamp() in base rule above */
        #ammo-counter {
            transform-origin: bottom right;
            transform: scale(var(--ui-scale));
        }
        /* Edge-drag handles */
        #inventory-panel .drag-edge {
            position: absolute;
            z-index: 10;
            cursor: move;
        }
        #inventory-panel .drag-edge.top    { top: 0;    left: 8px;  right: 8px;  height: 8px; }
        #inventory-panel .drag-edge.bottom { bottom: 0; left: 8px;  right: 8px;  height: 8px; }
        #inventory-panel .drag-edge.left   { left: 0;   top: 8px;   bottom: 8px; width: 8px; }
        #inventory-panel .drag-edge.right  { right: 0;  top: 8px;   bottom: 8px; width: 8px; }
        #inventory-panel .drag-edge.corner { width: 12px; height: 12px; }
        #inventory-panel .drag-edge.tl { top: 0; left: 0; }
        #inventory-panel .drag-edge.tr { top: 0; right: 0; }
        #inventory-panel .drag-edge.bl { bottom: 0; left: 0; }
        #inventory-panel .drag-edge.br { bottom: 0; right: 0; }

        /* ── FISHING UI ─────────────────────────────────────────────────── */
        /* ── FISHING PROXIMITY HINT (small overlay near river) ── */
        #fishing-overlay {
            position: fixed;
            bottom: 160px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 2000;
            pointer-events: none;
        }
        #fishing-overlay.visible { display: flex; }
        #fishing-hint {
            background: rgba(0,0,0,0.75);
            color: #aaddff;
            font-size: 13px;
            font-weight: bold;
            padding: 6px 18px;
            border-radius: 20px;
            border: 1px solid rgba(100,180,255,0.4);
            white-space: nowrap;
        }
        /* ── FISHING MINIGAME FLOATING WINDOW ── */
        #fishing-minigame {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 3500;
            width: 440px;
            background: linear-gradient(135deg, rgba(5,18,45,0.98), rgba(8,28,65,0.98));
            border: 2px solid rgba(80,160,255,0.5);
            border-radius: 14px;
            box-shadow: 0 12px 48px rgba(0,80,200,0.6), 0 0 0 1px rgba(80,160,255,0.15);
            backdrop-filter: blur(15px);
            pointer-events: auto;
            flex-direction: column;
            overflow: hidden;
        }
        #fishing-minigame.fmg-open { display: flex; }
        #fmg-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px 8px;
            background: linear-gradient(135deg, rgba(0,60,140,0.5), rgba(0,100,200,0.35));
            border-bottom: 1px solid rgba(80,160,255,0.3);
        }
        #fmg-title {
            font-size: 14px;
            font-weight: bold;
            color: rgba(150,210,255,0.95);
            font-family: 'Segoe UI', sans-serif;
            letter-spacing: 0.5px;
        }
        #fmg-score-badge {
            font-size: 14px;
            font-weight: bold;
            color: rgba(120,255,180,0.95);
            font-family: 'Segoe UI', sans-serif;
        }
        #fmg-close-btn {
            background: rgba(255,60,60,0.7);
            border: none;
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.15s;
        }
        #fmg-close-btn:hover { background: rgba(255,60,60,1); }
        #fmg-canvas-wrap {
            position: relative;
            line-height: 0;
        }
        #fishing-canvas {
            cursor: none;
            display: block;
            width: 100%;
        }
        #fmg-flash-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 22px;
            font-weight: 900;
            font-family: 'Segoe UI', sans-serif;
            text-shadow: 0 0 20px currentColor;
            pointer-events: none;
            display: none;
            transition: opacity 0.15s;
            white-space: nowrap;
        }
        #fmg-bottom-hint {
            text-align: center;
            color: rgba(180,220,255,0.8);
            font-size: 11px;
            font-family: 'Segoe UI', sans-serif;
            padding: 7px 14px;
            background: rgba(0,0,0,0.4);
            border-top: 1px solid rgba(80,160,255,0.2);
            pointer-events: none;
            white-space: nowrap;
        }


        #fishing-panel {
            position: fixed; top: calc(50% - 65px); left: 50%; transform: translate(-50%, -50%);
            width: 420px; background: linear-gradient(135deg, rgba(10,10,30,0.98), rgba(20,20,40,0.98));
            border: 2px solid rgba(255,255,255,0.2); border-radius: 12px; backdrop-filter: blur(15px);
            box-shadow: 0 12px 48px rgba(0,0,0,0.8); z-index: 1500; pointer-events: auto;
            color: white; font-family: "Segoe UI", sans-serif; user-select: none;
        }
        #fishing-panel-header {
            background: linear-gradient(135deg, rgba(20,100,60,0.4), rgba(15,80,50,0.4));
            padding: 15px 20px; border-radius: 10px 10px 0 0;
            display: flex; justify-content: space-between; align-items: center;
            color: white; border-bottom: 2px solid rgba(40,180,100,0.4);
        }
        /* ── Fishing scene animations ── */
        @keyframes fp-bubble-rise {
            0%   { transform: translateY(0)    scale(1);   opacity: 0.35; }
            70%  { opacity: 0.5; }
            100% { transform: translateY(-80px) scale(1.3); opacity: 0; }
        }
        @keyframes fp-bob-wait {
            0%,100% { transform: translateY(0px)  rotate(-5deg); }
            50%     { transform: translateY(8px)   rotate(5deg); }
        }
        @keyframes fp-bob-bite {
            0%,100% { transform: translateY(0px)  rotate(-8deg); }
            30%     { transform: translateY(12px)  rotate(8deg); }
            60%     { transform: translateY(-3px)  rotate(-4deg); }
        }
        @keyframes fp-fish-swim {
            0%,100% { transform: translateY(0px); }
            50%     { transform: translateY(-8px); }
        }
        @keyframes fp-tail-wag {
            0%,100% { transform: rotate(-20deg) scaleX(1);    }
            50%     { transform: rotate(20deg)  scaleX(0.85); }
        }
        @keyframes fp-fish-pop {
            0%   { transform: scale(1); }
            40%  { transform: scale(1.5) rotate(10deg); }
            100% { transform: scale(1)   rotate(0deg); }
        }
        #fp-fish-body    { animation: fp-fish-swim 1.4s ease-in-out infinite; }
        #fp-fish-tail    { animation: fp-tail-wag  0.35s ease-in-out infinite; }
        #fp-bobber-float { animation: fp-bob-wait  1.8s ease-in-out infinite; }
    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-title" id="loading-title-text">CRUST</div>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
        <div id="loading-status" style="color:rgba(255,255,255,0.6);font-size:13px;margin-top:16px;letter-spacing:1px;">Loading 3D engine...</div>
    </div>

    <div id="ui">
        <div class="stat-container">
            <div class="stat-label">Health</div>
            <div class="stat-bar">
                <div class="stat-fill health-bar" id="health-bar"></div>
                <div class="stat-text" id="health-text">100 / 100</div>
            </div>
        </div>
        <div class="stat-container">
            <div class="stat-label">Hunger</div>
            <div class="stat-bar">
                <div class="stat-fill hunger-bar" id="hunger-bar"></div>
                <div class="stat-text" id="hunger-text">100 / 100</div>
            </div>
        </div>
        <div class="stat-container">
            <div class="stat-label">Thirst</div>
            <div class="stat-bar">
                <div class="stat-fill thirst-bar" id="thirst-bar"></div>
                <div class="stat-text" id="thirst-text">100 / 100</div>
            </div>
        </div>
        <div class="stat-container">
            <div class="stat-label">Stamina</div>
            <div class="stat-bar">
                <div class="stat-fill stamina-bar" id="stamina-bar"></div>
                <div class="stat-text" id="stamina-text">100 / 100</div>
            </div>
        </div>
        <div class="stat-container">
            <div class="stat-label">Temperature</div>
            <div id="temp-bar-track" style="
                position: relative;
                height: 24px;
                border-radius: 12px;
                overflow: visible;
                border: 2px solid rgba(255,255,255,0.1);
                box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
                background: linear-gradient(to right, #3498db, #2ecc71 50%, #e74c3c);
            ">
                <div id="temp-indicator" style="
                    position: absolute;
                    top: 50%;
                    transform: translate(-50%, -50%);
                    width: 14px;
                    height: 20px;
                    background: white;
                    border-radius: 4px;
                    border: 2px solid rgba(0,0,0,0.5);
                    box-shadow: 0 0 6px rgba(0,0,0,0.6);
                    transition: left 0.5s ease;
                    left: 50%;
                    z-index: 2;
                "></div>
            </div>
            <div id="temp-label" style="font-size:11px; text-align:center; margin-top:3px; opacity:0.8;">Normal</div>
        </div>
        <div style="margin-top: 20px; font-size: 14px; opacity: 0.9;">
            <div>Day: <span id="day">1</span></div>
        </div>
        <div id="buff-hud"></div>
    </div>

    <div class="time-display">
        <span id="time">🕐 06:00</span>
    </div>

    <canvas id="minimap"></canvas>
    
    <div id="crosshair"></div>
    
    <div id="pistol-crosshair" style="display: none;"></div>
    
    <div id="ammo-counter" style="display: none;"></div>
    
    <div id="instructions" style="display: none;">
        <strong>🎮 REMASTERED CONTROLS</strong><br>
        WASD: Move | Shift: Sprint | Space: Jump | Mouse: Look | Wheel: Switch Items | Left Click: Gather/Attack/Place | Right Click: Remove Building (with 🔨) | E: Use/Open | R: Reload/Rotate | TAB: Inventory | C: Craft | F: Flashlight | P: Pause<br>
        <strong>📷 Camera:</strong> P: Toggle Third-Person<br>
            <strong>🏗️ Building:</strong> G: Toggle Snapping (ON by default) | Snapping auto-aligns walls/floors like Rust! Walls snap to walls & floor edges, floors snap to floors, stairs snap to floor edges<br>
        <strong>🔫 Pistol:</strong> Craft at Workbench (20 ingots) | R to reload | 8 shots per clip<br>
        <strong>🛏️ Sleeping Bag:</strong> Press E to set spawn point!<br>
        <strong>🪜 Ladder:</strong> Climb with E, descend with S | Stacks vertically for multi-story access<br>
        <button id="close-controls" style="margin-top: 10px; background: rgba(231, 76, 60, 0.9); border: none; color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: bold;">Close</button>
    </div>
    
    <div id="message"></div>
    <div id="build-info"></div>
    
    <div id="hotbar-tooltip"></div>
    <div id="hotbar"></div>
    
    <div id="inventory-panel" style="display: none;">
        <div class="drag-edge top"></div>
        <div class="drag-edge bottom"></div>
        <div class="drag-edge left"></div>
        <div class="drag-edge right"></div>
        <div class="drag-edge corner tl"></div>
        <div class="drag-edge corner tr"></div>
        <div class="drag-edge corner bl"></div>
        <div class="drag-edge corner br"></div>
        <div id="inventory-header">
            <span style="font-weight: bold; font-size: 18px;">🎒 INVENTORY</span>
            <button id="close-inventory" style="background: rgba(255,0,0,0.8); border: none; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-weight: bold;">✕</button>
        </div>
        <div id="inventory-content">
            <div id="clothing-panel">
                <h3>🛡️ ARMOR</h3>
                <div id="armor-slots-container">
                    <div class="armor-row">
                        <div class="armor-label">Head</div>
                        <div class="armor-slot" id="armor-head" data-slot="head" title="Helmet">
                            <div class="armor-slot-icon" id="armor-placeholder-head"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e1e2e"/><path d="M6,20 Q6,6 16,5 Q26,6 26,20 Z" fill="#9988aa"/><rect x="5" y="19" width="22" height="4" rx="1" fill="#9988aa"/><rect x="5" y="21" width="5" height="6" rx="1" fill="#9988aa"/><rect x="22" y="21" width="5" height="6" rx="1" fill="#9988aa"/><rect x="9" y="13" width="14" height="5" rx="2" fill="#1e1e2e"/></svg></div>
                        </div>
                    </div>
                    <div class="armor-row">
                        <div class="armor-label">Chest</div>
                        <div class="armor-slot" id="armor-chest" data-slot="chest" title="Chest Armor">
                            <div class="armor-slot-icon" id="armor-placeholder-chest"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e1e2e"/><rect x="3" y="6" width="8" height="8" rx="2" fill="#9988aa"/><rect x="21" y="6" width="8" height="8" rx="2" fill="#9988aa"/><rect x="5" y="8" width="22" height="20" rx="2" fill="#9988aa"/><path d="M12,8 L16,12 L20,8 Z" fill="#1e1e2e"/></svg></div>
                        </div>
                    </div>
                    <div class="armor-row">
                        <div class="armor-label">Hands</div>
                        <div class="armor-slot" id="armor-hands" data-slot="hands" title="Gloves">
                            <div class="armor-slot-icon" id="armor-placeholder-hands"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e1e2e"/><rect x="5" y="4" width="2" height="8" rx="1" fill="#9988aa"/><rect x="8" y="3" width="2" height="9" rx="1" fill="#9988aa"/><rect x="11" y="4" width="2" height="8" rx="1" fill="#9988aa"/><rect x="4" y="10" width="10" height="16" rx="2" fill="#9988aa"/><rect x="19" y="4" width="2" height="8" rx="1" fill="#9988aa"/><rect x="22" y="3" width="2" height="9" rx="1" fill="#9988aa"/><rect x="25" y="4" width="2" height="8" rx="1" fill="#9988aa"/><rect x="18" y="10" width="10" height="16" rx="2" fill="#9988aa"/></svg></div>
                        </div>
                    </div>
                    <div class="armor-row">
                        <div class="armor-label">Legs</div>
                        <div class="armor-slot" id="armor-legs" data-slot="legs" title="Leg Armor">
                            <div class="armor-slot-icon" id="armor-placeholder-legs"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e1e2e"/><rect x="5" y="4" width="22" height="6" rx="2" fill="#9988aa"/><rect x="5" y="10" width="10" height="18" rx="2" fill="#9988aa"/><rect x="17" y="10" width="10" height="18" rx="2" fill="#9988aa"/></svg></div>
                        </div>
                    </div>
                    <div class="armor-row">
                        <div class="armor-label">Feet</div>
                        <div class="armor-slot" id="armor-feet" data-slot="feet" title="Boots">
                            <div class="armor-slot-icon" id="armor-placeholder-feet"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e1e2e"/><rect x="4" y="4" width="10" height="16" rx="2" fill="#9988aa"/><rect x="3" y="18" width="12" height="10" rx="2" fill="#9988aa"/><rect x="18" y="4" width="10" height="16" rx="2" fill="#9988aa"/><rect x="17" y="18" width="12" height="10" rx="2" fill="#9988aa"/></svg></div>
                        </div>
                    </div>
                    <div class="armor-row">
                        <div class="armor-label">Back</div>
                        <div class="armor-slot" id="armor-back" data-slot="back" title="Backpack">
                            <div class="armor-slot-icon" id="armor-placeholder-back"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e1e2e"/><rect x="11" y="3" width="10" height="5" rx="2.5" fill="#9988aa"/><rect x="8" y="6" width="16" height="20" rx="3" fill="#9988aa"/><rect x="11" y="6" width="10" height="3" rx="1" fill="#1e1e2e"/><rect x="10" y="14" width="12" height="8" rx="2" fill="#1e1e2e" opacity="0.4"/><rect x="13" y="17" width="6" height="1.5" rx="0.75" fill="#9988aa"/><rect x="8" y="9" width="2.5" height="14" rx="1.25" fill="#7a6a8a"/><rect x="21.5" y="9" width="2.5" height="14" rx="1.25" fill="#7a6a8a"/></svg></div>
                        </div>
                    </div>
                </div>
                <div id="damage-reduction-display" style="margin-top: 15px; padding: 10px; background: linear-gradient(135deg, rgba(46, 204, 113, 0.15), rgba(39, 174, 96, 0.1)); border: 2px solid rgba(46, 204, 113, 0.3); border-radius: 8px; text-align: center;">
                    <div style="font-size: 11px; color: rgba(255,255,255,0.7); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 5px;">Damage Reduction</div>
                    <div id="damage-reduction-value" style="font-size: 24px; font-weight: bold; color: #2ecc71;">0%</div>
                </div>
                <div id="insulation-display" style="margin-top: 8px; padding: 10px; background: linear-gradient(135deg, rgba(52, 152, 219, 0.15), rgba(41, 128, 185, 0.1)); border: 2px solid rgba(52, 152, 219, 0.3); border-radius: 8px; text-align: center;">
                    <div style="font-size: 11px; color: rgba(255,255,255,0.7); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 5px;">🧥 Insulation</div>
                    <div id="insulation-value" style="font-size: 24px; font-weight: bold; color: #95a5a6;">0%</div>
                    <div style="font-size: 10px; color: rgba(255,255,255,0.45); margin-top: 3px;">Reduces temperature effect</div>
                </div>
                <div style="text-align: center; font-size: 10px; color: rgba(255,255,255,0.5); margin-top: 15px; line-height: 1.4;">
                    Double-click to equip<br>Click to remove
                </div>
            </div>
            <div id="inventory-grid-container">
                <div id="inventory-grid"></div>
                <div id="backpack-slots-panel">
                    <div class="bp-header">🎒 <span id="backpack-slots-label">Backpack</span></div>
                    <div id="backpack-slots-grid"></div>
                </div>
                <div id="inventory-trash-slot" title="Drop items here to delete them">🗑️</div>
            </div>
        </div>
    </div>
    
    <div id="storage-panel" style="display: none;">
        <div id="storage-header">
            <span style="font-weight: bold; font-size: 18px;">📦 STORAGE BOX</span>
            <button id="close-storage" style="background: rgba(255,0,0,0.8); border: none; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-weight: bold;">✕</button>
        </div>
        <div id="storage-grid"></div>
    </div>

    <!-- PLANTER BOX UI -->
    <div id="planter-panel" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:linear-gradient(135deg,rgba(20,40,20,0.97),rgba(10,30,10,0.95)); border:2px solid rgba(80,180,80,0.35); border-radius:14px; padding:22px 28px; z-index:5000; min-width:380px; max-width:520px; box-shadow:0 8px 32px rgba(0,0,0,0.6); font-family:'Segoe UI',sans-serif; color:white; backdrop-filter:blur(10px);">
        <div id="planter-header" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px; cursor:move; user-select:none;">
            <span id="planter-title" style="font-weight:bold; font-size:18px;">🌱 Planter Box</span>
            <button id="close-planter" style="background:rgba(255,0,0,0.8); border:none; color:white; padding:5px 10px; border-radius:4px; cursor:pointer; font-weight:bold;">✕</button>
        </div>
        <div style="font-size:12px; color:rgba(255,255,255,0.55); margin-bottom:14px; letter-spacing:0.5px;">Place seeds in slots. Rain waters them and starts growth. Press E or click grown slot to harvest.</div>
        <div id="planter-slots" style="display:grid; grid-template-columns:repeat(4,1fr); gap:8px; margin-bottom:16px;"></div>
        <div id="planter-status" style="font-size:13px; color:rgba(180,255,140,0.85); min-height:18px; text-align:center;"></div>
    </div>

    <!-- BEE HIVE MENU -->
    <div id="bee-hive-menu" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
        width:380px; background:linear-gradient(135deg,rgba(40,25,5,0.98),rgba(60,38,8,0.98));
        border:3px solid rgba(218,165,32,0.6); border-radius:14px; z-index:3000; pointer-events:auto;
        box-shadow:0 12px 48px rgba(0,0,0,0.85), 0 0 24px rgba(218,165,32,0.2); color:white; font-family:'Segoe UI',sans-serif;">
        <div style="background:linear-gradient(135deg,rgba(218,165,32,0.3),rgba(180,120,10,0.3)); padding:14px 18px;
            border-radius:11px 11px 0 0; display:flex; justify-content:space-between; align-items:center;
            border-bottom:2px solid rgba(218,165,32,0.4);">
            <span style="font-size:20px; font-weight:bold; letter-spacing:1px;">🐝 Bee Hive</span>
            <button onclick="closeBeeHiveMenu()" style="background:rgba(255,60,60,0.8); border:none; color:white;
                padding:5px 11px; border-radius:5px; cursor:pointer; font-weight:bold; font-size:14px;">✕</button>
        </div>
        <div style="padding:22px 20px;">
            <div id="bh-status" style="text-align:center; font-size:15px; margin-bottom:18px; color:#FFD700; letter-spacing:0.5px;">🐝 Bees are working...</div>
            <div style="display:flex; justify-content:center; align-items:center; gap:16px; margin-bottom:20px;
                background:rgba(0,0,0,0.35); border-radius:10px; padding:16px; border:1px solid rgba(218,165,32,0.3);">
                <div style="font-size:48px;">🍯</div>
                <div style="text-align:left;">
                    <div style="font-size:13px; color:rgba(255,255,200,0.75); text-transform:uppercase; letter-spacing:1px; margin-bottom:4px;">Honey Stored</div>
                    <div style="font-size:32px; font-weight:bold; color:#FFD700;"><span id="bh-honey-count">0</span> jars</div>
                </div>
            </div>
            <div style="margin-bottom:16px;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                    <span style="font-size:12px; color:rgba(255,240,180,0.8); text-transform:uppercase; letter-spacing:1px;">Next Honey Jar</span>
                    <span id="bh-progress-text" style="font-size:12px; font-weight:bold; color:#FFD700;">--:--</span>
                </div>
                <div style="position:relative; height:22px; background:rgba(0,0,0,0.5); border-radius:11px; overflow:hidden; border:1px solid rgba(218,165,32,0.35);">
                    <div id="bh-progress-fill" style="height:100%; width:0%; background:linear-gradient(90deg,#B8860B,#DAA520,#FFD700); border-radius:11px; transition:width 1s linear; box-shadow:0 0 12px rgba(218,165,32,0.6);"></div>
                </div>
            </div>
            <button id="bh-collect-btn" disabled onclick="collectHoney()"
                style="width:100%; padding:13px; background:linear-gradient(135deg,#B8860B,#DAA520); border:none; border-radius:9px;
                color:white; font-size:15px; font-weight:bold; cursor:pointer; letter-spacing:0.5px;
                transition:all 0.2s ease; opacity:0.5;">
                🍯 Collect Honey
            </button>
        </div>
    </div>

    <!-- CHICKEN COOP MENU -->
    <div id="chicken-coop-menu" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
        width:400px; background:linear-gradient(135deg,rgba(30,18,5,0.98),rgba(50,30,8,0.98));
        border:3px solid rgba(180,90,20,0.6); border-radius:14px; z-index:3000; pointer-events:auto;
        box-shadow:0 12px 48px rgba(0,0,0,0.85), 0 0 24px rgba(180,90,20,0.2); color:white; font-family:'Segoe UI',sans-serif;">
        <div style="background:linear-gradient(135deg,rgba(180,90,20,0.3),rgba(140,60,10,0.3)); padding:14px 18px;
            border-radius:11px 11px 0 0; display:flex; justify-content:space-between; align-items:center;
            border-bottom:2px solid rgba(180,90,20,0.4);">
            <span style="font-size:20px; font-weight:bold; letter-spacing:1px;">🐔 Chicken Coop</span>
            <button onclick="closeChickenCoopMenu()" style="background:rgba(255,60,60,0.8); border:none; color:white;
                padding:5px 11px; border-radius:5px; cursor:pointer; font-weight:bold; font-size:14px;">✕</button>
        </div>
        <div style="padding:22px 20px;">
            <div id="cc-status" style="text-align:center; font-size:15px; margin-bottom:18px; color:#FFCC88; letter-spacing:0.5px;">🐔 Chickens are laying...</div>
            <div style="display:flex; justify-content:center; align-items:center; gap:16px; margin-bottom:20px;
                background:rgba(0,0,0,0.35); border-radius:10px; padding:16px; border:1px solid rgba(180,90,20,0.3);">
                <div style="font-size:48px;">🥚</div>
                <div style="text-align:left;">
                    <div style="font-size:13px; color:rgba(255,220,180,0.75); text-transform:uppercase; letter-spacing:1px; margin-bottom:4px;">Eggs Stored</div>
                    <div style="font-size:32px; font-weight:bold; color:#FFCC88;"><span id="cc-egg-count">0</span> eggs</div>
                </div>
            </div>
            <div style="margin-bottom:16px;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                    <span style="font-size:12px; color:rgba(255,230,190,0.8); text-transform:uppercase; letter-spacing:1px;">Next Egg</span>
                    <span id="cc-progress-text" style="font-size:12px; font-weight:bold; color:#FFCC88;">--:--</span>
                </div>
                <div style="position:relative; height:22px; background:rgba(0,0,0,0.5); border-radius:11px; overflow:hidden; border:1px solid rgba(180,90,20,0.35);">
                    <div id="cc-progress-fill" style="height:100%; width:0%; background:linear-gradient(90deg,#7B3A10,#B46020,#E07030); border-radius:11px; transition:width 1s linear; box-shadow:0 0 12px rgba(180,90,20,0.6);"></div>
                </div>
            </div>
            <button id="cc-collect-btn" disabled onclick="collectEggs()"
                style="width:100%; padding:13px; background:linear-gradient(135deg,#8B4513,#B46020); border:none; border-radius:9px;
                color:white; font-size:15px; font-weight:bold; cursor:pointer; letter-spacing:0.5px;
                transition:all 0.2s ease; opacity:0.5;">
                🥚 Collect Eggs
            </button>
        </div>
    </div>

    <div id="backpack-panel">
        <div id="backpack-header">
            <span style="font-weight: bold; font-size: 18px;">🎒 DEATH BACKPACK</span>
            <button id="close-backpack" style="background: rgba(255,0,0,0.8); border: none; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-weight: bold;">✕</button>
        </div>
        <div id="backpack-grid"></div>
    </div>

    <!-- FULL MAP -->
    <div id="fullmap-overlay" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.82);
        z-index:6000; font-family:'Segoe UI',sans-serif;">

        <!-- Panel -->
        <div style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
            width:760px; max-width:96vw; background:linear-gradient(160deg,#0d1a0d,#0a130a);
            border:2px solid rgba(80,180,80,0.35); border-radius:16px;
            box-shadow:0 16px 64px rgba(0,0,0,0.85), 0 0 40px rgba(40,160,40,0.08);
            overflow:hidden;">

            <!-- Header -->
            <div style="display:flex; align-items:center; justify-content:space-between;
                padding:14px 20px; border-bottom:1px solid rgba(255,255,255,0.08);
                background:rgba(0,0,0,0.3);">
                <div style="display:flex; align-items:center; gap:10px;">
                    <span style="font-size:20px;">🗺️</span>
                    <span style="font-weight:700; font-size:17px; color:#e8f5e8; letter-spacing:1px;">WORLD MAP</span>
                </div>
                <div style="display:flex; align-items:center; gap:10px;">
                    <span id="fullmap-mode-label" style="font-size:12px; color:rgba(255,255,255,0.45);
                        background:rgba(255,255,255,0.06); padding:4px 10px; border-radius:20px;">
                        Click to place marker
                    </span>
                    <button id="fullmap-close" style="background:rgba(255,50,50,0.75); border:none;
                        color:white; width:28px; height:28px; border-radius:6px; cursor:pointer;
                        font-size:14px; font-weight:bold; line-height:28px; text-align:center;">✕</button>
                </div>
            </div>

            <!-- Map canvas + legend row -->
            <div style="display:flex; gap:0;">
                <!-- Canvas -->
                <div style="position:relative; flex:1;">
                    <canvas id="fullmap-canvas" width="680" height="520"
                        style="display:block; cursor:crosshair; width:100%; height:auto;"></canvas>
                    <!-- Marker name input popup -->
                    <div id="fullmap-marker-popup" style="display:none; position:absolute;
                        background:rgba(10,20,10,0.97); border:1px solid rgba(80,200,80,0.5);
                        border-radius:8px; padding:10px 12px; z-index:10; min-width:180px;
                        box-shadow:0 4px 20px rgba(0,0,0,0.6);">
                        <div style="font-size:11px; color:rgba(255,255,255,0.5); margin-bottom:6px;">Marker label (optional)</div>
                        <input id="fullmap-marker-input" type="text" maxlength="24" placeholder="e.g. Base, Ore spot..."
                            style="width:100%; background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.2);
                            color:white; border-radius:4px; padding:5px 8px; font-size:13px; outline:none;
                            box-sizing:border-box;" />
                        <div style="display:flex; gap:6px; margin-top:8px;">
                            <button id="fullmap-marker-confirm" style="flex:1; background:rgba(60,180,60,0.8);
                                border:none; color:white; border-radius:4px; padding:5px; cursor:pointer;
                                font-size:12px; font-weight:bold;">Add</button>
                            <button id="fullmap-marker-cancel" style="flex:1; background:rgba(80,80,80,0.7);
                                border:none; color:white; border-radius:4px; padding:5px; cursor:pointer;
                                font-size:12px;">Cancel</button>
                        </div>
                    </div>
                </div>

                <!-- Legend + markers sidebar -->
                <div style="width:148px; background:rgba(0,0,0,0.25); border-left:1px solid rgba(255,255,255,0.07);
                    padding:14px 12px; display:flex; flex-direction:column; gap:12px; overflow-y:auto; max-height:520px;">

                    <div style="font-size:11px; font-weight:700; color:rgba(255,255,255,0.5); letter-spacing:1px; text-transform:uppercase;">Legend</div>
                    <div style="display:flex; flex-direction:column; gap:7px; font-size:12px; color:rgba(255,255,255,0.75);">
                        <div style="display:flex;align-items:center;gap:7px;"><span style="display:inline-block;width:10px;height:10px;border-radius:2px;background:rgba(200,168,90,0.9);flex-shrink:0;"></span>Beach</div>
                        <div style="display:flex;align-items:center;gap:7px;"><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:#3498db;flex-shrink:0;"></span>You</div>
                        <div style="display:flex;align-items:center;gap:7px;"><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:rgba(255,50,50,0.9);flex-shrink:0;"></span>Enemy</div>
                        <div style="display:flex;align-items:center;gap:7px;"><span style="display:inline-block;width:10px;height:10px;border-radius:2px;background:rgba(140,100,60,0.9);flex-shrink:0;"></span>Building</div>
                        <div style="display:flex;align-items:center;gap:7px;"><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:rgba(0,120,0,0.8);flex-shrink:0;"></span>Tree</div>
                        <div style="display:flex;align-items:center;gap:7px;"><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:rgba(180,220,255,0.8);flex-shrink:0;"></span>Snow tree</div>
                        <div style="display:flex;align-items:center;gap:7px;"><span style="display:inline-block;width:8px;height:8px;border-radius:2px;background:rgba(140,130,120,0.8);flex-shrink:0;margin:1px;"></span>Rock</div>
                        <div style="display:flex;align-items:center;gap:7px;"><span style="display:inline-block;width:8px;height:8px;border-radius:2px;background:rgba(160,200,220,0.8);flex-shrink:0;margin:1px;"></span>Snow rock</div>
                        <div style="display:flex;align-items:center;gap:7px;"><span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:rgba(120,200,255,0.9);flex-shrink:0;margin:1px;"></span>Crystal</div>
                        <div style="display:flex;align-items:center;gap:7px;"><span style="font-size:12px;line-height:1;">💀</span>Death bag</div>
                        <div style="display:flex;align-items:center;gap:7px;"><span style="font-size:12px;line-height:1;">📍</span>Marker</div>
                    </div>

                    <div style="border-top:1px solid rgba(255,255,255,0.08); padding-top:10px;">
                        <div style="font-size:11px; font-weight:700; color:rgba(255,255,255,0.5); letter-spacing:1px; text-transform:uppercase; margin-bottom:8px;">My Markers</div>
                        <div id="fullmap-marker-list" style="display:flex; flex-direction:column; gap:5px; font-size:11px; color:rgba(255,255,255,0.7);">
                            <div style="color:rgba(255,255,255,0.25); font-style:italic;">None yet</div>
                        </div>
                    </div>
                    <div style="font-size:10px; color:rgba(255,255,255,0.25); margin-top:auto; line-height:1.5;">
                        [M] toggle map<br>Click map to add<br>Click 📍 to remove
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- JUNK PILE UI -->
    <div id="junkpile-panel" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
        background:linear-gradient(135deg, rgba(30,22,10,0.97), rgba(20,15,5,0.95));
        border:2px solid rgba(160,120,60,0.4); border-radius:14px; padding:22px 28px;
        z-index:5000; min-width:360px; box-shadow:0 8px 32px rgba(0,0,0,0.7);
        font-family:'Segoe UI',sans-serif; color:white; backdrop-filter:blur(10px);">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
            <span style="font-weight:bold; font-size:18px;">🗑️ JUNK PILE</span>
            <button id="close-junkpile" style="background:rgba(255,0,0,0.8); border:none; color:white; padding:5px 10px; border-radius:4px; cursor:pointer; font-weight:bold;">✕</button>
        </div>
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:14px;">
            <div style="font-size:11px; color:rgba(255,255,255,0.45); letter-spacing:0.5px;">Click an item to take it</div>
            <button id="junkpile-take-all" style="background:linear-gradient(135deg,rgba(160,120,60,0.85),rgba(200,160,80,0.9));
                border:1px solid rgba(200,160,80,0.6); color:white; padding:5px 14px; border-radius:6px;
                cursor:pointer; font-size:12px; font-weight:bold; letter-spacing:0.5px;
                box-shadow:0 2px 8px rgba(0,0,0,0.4); transition:background 0.15s;">
                ✋ Take All
            </button>
        </div>
        <div id="junkpile-grid" style="display:grid; grid-template-columns:repeat(3,1fr); gap:8px;"></div>
        <div id="junkpile-respawn-label" style="display:none; margin-top:12px; font-size:11px;
            color:rgba(255,180,60,0.7); text-align:center; letter-spacing:0.5px;"></div>
    </div>
    
    <div id="crafting-menu">
        <div class="menu-title">🔧 Crafting</div>
        <div id="crafting-list"></div>
        <button class="menu-button" onclick="toggleCraftingMenu()">Close (C)</button>
    </div>
    
    <div id="workbench-menu">
        <div class="menu-title">🔧 Workbench</div>
        <div id="workbench-list"></div>
        <button class="menu-button" onclick="closeAllUI()">Close (ESC)</button>
    </div>
    
    <div id="furnace-menu" style="display: none;">
        <div id="furnace-header">
            <span style="font-weight: bold; font-size: 18px;">🔥 FURNACE</span>
            <button id="close-furnace" style="background: rgba(255,0,0,0.8); border: none; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-weight: bold;">✕</button>
        </div>
        <div id="furnace-content">
            <div class="smelting-slot-container" style="grid-column: 1 / -1;">
                <div class="smelting-label">Ore Input Slots (drag ores here)</div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <div class="smelting-slot furnace-input-slot" id="furnace-input-slot-0" data-slot-type="furnace-input" data-slot-index="0"></div>
                    <div class="smelting-slot furnace-input-slot" id="furnace-input-slot-1" data-slot-type="furnace-input" data-slot-index="1"></div>
                    <div class="smelting-slot furnace-input-slot" id="furnace-input-slot-2" data-slot-type="furnace-input" data-slot-index="2"></div>
                </div>
            </div>
            <div class="smelting-slot-container">
                <div class="smelting-label">Fuel (Wood/Sticks)</div>
                <div class="smelting-slot" id="furnace-fuel-slot"></div>
            </div>
            <div class="smelting-progress-container" style="grid-column: unset;">
                <div class="smelting-label" id="furnace-active-label" style="font-size:11px; color:#ffaa00; margin-bottom:4px;"></div>
                <div class="smelting-progress-bar">
                    <div class="smelting-progress-fill" id="furnace-progress"></div>
                </div>
                <div class="smelting-progress-text" id="furnace-progress-text">0%</div>
            </div>
            <div class="smelting-slot-container">
                <div class="smelting-label">Output 1 (Iron Ingot)</div>
                <div class="smelting-slot output-slot" id="furnace-output-slot-0"></div>
            </div>
            <div class="smelting-slot-container">
                <div class="smelting-label">Output 2 (Smelted Sulfur)</div>
                <div class="smelting-slot output-slot" id="furnace-output-slot-1"></div>
            </div>
            <div class="smelting-slot-container" style="grid-column: 1 / -1; align-items: center;">
                <div class="smelting-label">Waste (Coal)</div>
                <div class="smelting-slot output-slot" id="furnace-waste-slot" style="width:60px;height:60px;font-size:28px;"></div>
            </div>
        </div>
    </div>
    
    <div id="campfire-menu" style="display: none;">
        <div id="campfire-header">
            <span style="font-weight: bold; font-size: 18px;">🔥 CAMPFIRE</span>
            <button id="close-campfire" style="background: rgba(255,0,0,0.8); border: none; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-weight: bold;">✕</button>
        </div>
        <div id="campfire-content">
            <div class="smelting-slot-container">
                <div class="smelting-label">Food (drag food here)</div>
                <div class="smelting-slot" id="campfire-input-slot" data-slot-type="campfire-input" data-slot-index="0"></div>
            </div>
            <div class="smelting-slot-container">
                <div class="smelting-label">Fuel (Wood/Sticks)</div>
                <div class="smelting-slot" id="campfire-fuel-slot"></div>
            </div>
            <div class="smelting-progress-container">
                <div class="smelting-progress-bar">
                    <div class="smelting-progress-fill" id="campfire-progress"></div>
                </div>
                <div class="smelting-progress-text" id="campfire-progress-text">0%</div>
            </div>
            <!-- Queue display -->
            <div style="grid-column:1/-1; background:rgba(0,0,0,0.3); border-radius:8px; padding:10px; margin-top:4px;">
                <div class="smelting-label" style="margin-bottom:8px; font-size:11px; color:rgba(255,200,100,0.9);">🍽️ COOKING QUEUE (left cooks first)</div>
                <div id="campfire-queue-display" style="display:flex; gap:8px; justify-content:center;"></div>
            </div>
            <!-- 4 Output slots -->
            <div style="grid-column:1/-1;">
                <div class="smelting-label" style="margin-bottom:8px; text-align:center; font-size:11px; color:rgba(80,255,120,0.9);">✅ COOKED OUTPUT (click to collect)</div>
                <div style="display:flex; gap:8px; justify-content:center;">
                    <div class="smelting-slot output-slot" id="campfire-output-slot-0" style="cursor:pointer;"></div>
                    <div class="smelting-slot output-slot" id="campfire-output-slot-1" style="cursor:pointer;"></div>
                    <div class="smelting-slot output-slot" id="campfire-output-slot-2" style="cursor:pointer;"></div>
                    <div class="smelting-slot output-slot" id="campfire-output-slot-3" style="cursor:pointer;"></div>
                </div>
            </div>
            <div class="smelting-slot-container" style="grid-column:1/-1; align-items:center;">
                <div class="smelting-label">Waste (Ash)</div>
                <div class="smelting-slot output-slot" id="campfire-waste-slot"></div>
            </div>
        </div>
    </div>
    
    <div id="cooking-station-menu" style="display: none;">
        <div id="cooking-station-header">
            <span style="font-weight: bold; font-size: 18px;">🍳 COOKING STATION</span>
            <button id="close-cooking-station">✕</button>
        </div>
        <div id="cooking-station-content">
            <!-- Recipe book -->
            <div id="cs-recipe-book">
                <div class="cs-recipe-book-title">📖 Recipes — click a green card to cook!</div>
                <div id="cs-recipe-list"></div>
            </div>
            <!-- 5 ingredient slots (hidden — recipe cards auto-fill these) -->
            <div style="display:none;">
                <div class="cs-label" style="margin-bottom:8px; text-align:center;">Ingredients (click recipe to auto-fill)</div>
                <div class="cs-ingredient-grid">
                    <div class="cs-slot-container">
                        <div class="cs-slot" id="cs-input-0" data-cs-slot="input" data-cs-index="0">+</div>
                    </div>
                    <div class="cs-slot-container">
                        <div class="cs-slot" id="cs-input-1" data-cs-slot="input" data-cs-index="1">+</div>
                    </div>
                    <div class="cs-slot-container">
                        <div class="cs-slot" id="cs-input-2" data-cs-slot="input" data-cs-index="2">+</div>
                    </div>
                    <div class="cs-slot-container">
                        <div class="cs-slot" id="cs-input-3" data-cs-slot="input" data-cs-index="3">+</div>
                    </div>
                    <div class="cs-slot-container">
                        <div class="cs-slot" id="cs-input-4" data-cs-slot="input" data-cs-index="4">+</div>
                    </div>
                </div>
            </div>
            <!-- Recipe hint -->
            <div id="cs-recipe-hint">Place ingredients to see recipe...</div>
            <!-- Cook button removed: click a green recipe card to cook directly -->
            <!-- Progress bar -->
            <div class="smelting-progress-container" style="margin:0;">
                <div class="smelting-progress-bar">
                    <div class="smelting-progress-fill" id="cs-progress" style="width:0%"></div>
                </div>
                <div class="smelting-progress-text" id="cs-progress-text">0%</div>
            </div>
            <!-- Queue display -->
            <div style="background:rgba(0,0,0,0.3); border-radius:8px; padding:7px 10px;">
                <div class="cs-label" style="margin-bottom:5px; color:rgba(255,200,100,0.9); font-size:10px;">🍽️ COOKING QUEUE (left cooks first)</div>
                <div id="cs-queue-display" style="display:flex; gap:6px; justify-content:center;"></div>
            </div>
            <!-- 4 Output slots -->
            <div>
                <div class="cs-label" style="margin-bottom:5px; text-align:center; color:rgba(80,255,120,0.9); font-size:10px;">✅ OUTPUT (click to collect)</div>
                <div style="display:flex; gap:8px; justify-content:center;">
                    <div class="cs-slot cs-output" id="cs-output-slot-0" style="cursor:pointer;"></div>
                    <div class="cs-slot cs-output" id="cs-output-slot-1" style="cursor:pointer;"></div>
                    <div class="cs-slot cs-output" id="cs-output-slot-2" style="cursor:pointer;"></div>
                    <div class="cs-slot cs-output" id="cs-output-slot-3" style="cursor:pointer;"></div>
                </div>
            </div>
            <!-- Legacy hidden output slot for backwards compat -->
            <div style="display:none;"><div class="cs-slot cs-output" id="cs-output-slot"></div></div>
            <!-- Ash -->
            <div class="cs-row" style="justify-content:center;">
                <div class="cs-slot-container">
                    <div class="cs-label" style="font-size:10px;">Ash (click to collect)</div>
                    <div class="cs-slot cs-waste" id="cs-waste-slot"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- FISHING UI OVERLAY -->
    <!-- FISHING: proximity hint overlay -->
    <div id="fishing-overlay">
        <div id="fishing-hint">🎣 Press E to fish</div>
    </div>

    <!-- FISHING MINIGAME FLOATING WINDOW -->
    <div id="fishing-minigame">
        <div id="fmg-header">
            <span id="fmg-title">🎣 Fishing</span>
            <span id="fmg-score-badge">🐟 ×0</span>
            <button id="fmg-close-btn" title="Stop fishing (E)">✕</button>
        </div>
        <div id="fmg-canvas-wrap">
            <canvas id="fishing-canvas"></canvas>
            <div id="fmg-flash-msg"></div>
        </div>
        <div id="fmg-bottom-hint">Move mouse to aim • Click to drop hook • E to cancel</div>
    </div>

    <div id="recycler-menu" style="display: none;">
        <div id="recycler-header">
            <span style="font-weight: bold; font-size: 18px;">♻️ RECYCLER</span>
            <button id="close-recycler">✕</button>
        </div>
        <div id="recycler-content">
            <div class="recycler-section">
                <div class="recycler-label">Input Slots</div>
                <div style="font-size: 11px; color: rgba(255,255,255,0.6); margin-bottom: 5px; text-align: center;">Double-click items in your inventory to add them</div>
                <div class="recycler-slots-container">
                    <div class="recycler-slot" data-slot="input" data-index="0"></div>
                    <div class="recycler-slot" data-slot="input" data-index="1"></div>
                    <div class="recycler-slot" data-slot="input" data-index="2"></div>
                    <div class="recycler-slot" data-slot="input" data-index="3"></div>
                    <div class="recycler-slot" data-slot="input" data-index="4"></div>
                </div>
            </div>
            
            <div class="recycler-controls">
                <button id="recycler-start-btn">♻️ START RECYCLING</button>
            </div>
            
            <div class="recycler-progress-container">
                <div class="recycler-progress-bar">
                    <div class="recycler-progress-fill" id="recycler-progress"></div>
                    <div class="recycler-progress-text" id="recycler-progress-text">0%</div>
                </div>
            </div>
            
            <div class="recycler-section">
                <div class="recycler-label">Output Slots</div>
                <div style="font-size: 11px; color: rgba(255,255,255,0.6); margin-bottom: 5px; text-align: center;">Click to collect recycled materials</div>
                <div class="recycler-slots-container">
                    <div class="recycler-slot" data-slot="output" data-index="0"></div>
                    <div class="recycler-slot" data-slot="output" data-index="1"></div>
                    <div class="recycler-slot" data-slot="output" data-index="2"></div>
                    <div class="recycler-slot" data-slot="output" data-index="3"></div>
                    <div class="recycler-slot" data-slot="output" data-index="4"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Well Menu -->
    <div id="water-catcher-menu" style="display: none;">
        <div id="water-catcher-header">
            <span style="font-weight: bold; font-size: 18px;">🪣 WELL</span>
            <button id="close-water-catcher">✕</button>
        </div>
        <div id="water-catcher-content">
            <div id="wc-rain-status" class="wc-rain-status wc-rain-inactive">☁️ Not raining — waiting for rain...</div>
            <div class="wc-label">Filling Progress</div>
            <div class="wc-progress-container">
                <div class="wc-progress-bar">
                    <div class="wc-progress-fill" id="wc-progress-fill" style="width:0%"></div>
                </div>
            </div>
            <div class="wc-progress-text" id="wc-progress-text">Waiting for rain...</div>
            <div class="wc-label" style="margin-top:15px;">Water Bottles (drag to inventory)</div>
            <div class="wc-slots-container" id="wc-output-slots">
                <div class="wc-slot" data-wc-slot="0" draggable="true"></div>
                <div class="wc-slot" data-wc-slot="1" draggable="true"></div>
                <div class="wc-slot" data-wc-slot="2" draggable="true"></div>
                <div class="wc-slot" data-wc-slot="3" draggable="true"></div>
                <div class="wc-slot" data-wc-slot="4" draggable="true"></div>
            </div>
        </div>
    </div>
    
    <div id="death-screen">
        <h1>💀 YOU DIED 💀</h1>
        <p>You survived <span id="survival-time">0</span> days</p>
        <button id="respawn-button" onclick="respawn()">Respawn</button>
    </div>
    
    <div id="admin-menu" style="display: none;">
        <div id="admin-header">
            <span style="font-weight: bold; font-size: 20px;">🛡️ ADMIN MENU</span>
            <button id="close-admin" style="background: rgba(255,0,0,0.8); border: none; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-weight: bold;">✕</button>
        </div>
        <div id="admin-content">
            <div class="admin-section">
                <h3>Add Items</h3>
                <div id="admin-items-grid"></div>
            </div>
            <div class="admin-section" style="margin-top: 20px;">
                <h3>\ud83d\udee0\ufe0f Developer Tools</h3>
                <button id="sync-icon-fallbacks" style="width: 100%; padding: 12px; margin-bottom: 10px; background: linear-gradient(135deg, #27ae60, #2ecc71); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 15px; font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.3);">\ud83d\udee1\ufe0f Sync Icon Fallbacks</button>
                <div id="icon-sync-output" style="display:none; margin-top: 8px; background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.15); border-radius: 6px; padding: 10px;">
                    <div style="font-size: 12px; color: #aaa; margin-bottom: 6px;">Copy the lines below into <code>_iconFallbacks</code>:</div>
                    <textarea id="icon-sync-text" readonly style="width:100%; height: 120px; background: transparent; border: none; color: #2ecc71; font-family: monospace; font-size: 11px; resize: vertical; outline: none;"></textarea>
                    <button id="icon-sync-copy" style="margin-top: 6px; padding: 6px 14px; background: rgba(52,152,219,0.8); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">\ud83d\udccb Copy to Clipboard</button>
                </div>
            </div>
            <div class="admin-section" style="margin-top: 20px;">
                <h3>Environment Controls</h3>
                <button id="set-day" style="width: 100%; padding: 12px; margin-bottom: 10px; background: linear-gradient(135deg, #f39c12, #e67e22); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.3);">☀️ Set Day (Noon)</button>
                <button id="set-night" style="width: 100%; padding: 12px; margin-bottom: 10px; background: linear-gradient(135deg, #34495e, #2c3e50); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.3);">🌙 Set Night (Midnight)</button>
                <button id="freeze-time" style="width: 100%; padding: 12px; margin-bottom: 10px; background: linear-gradient(135deg, #9b59b6, #8e44ad); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.3);">❄️ Freeze Time</button>
                <button id="toggle-rain" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #3498db, #2980b9); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.3);">🌧️ Toggle Rain</button>
            </div>
        </div>
    </div>
    
    <div id="pause-menu" style="display: none;">
        <div id="pause-header">
            <h1 style="font-size: 48px; margin-bottom: 30px; text-shadow: 0 0 20px rgba(52, 152, 219, 0.5);">⏸️ PAUSED</h1>
        </div>
        <div id="pause-content">
            <button class="pause-button" id="resume-button">▶️ Resume</button>
            <button class="pause-button" id="save-button">💾 Save Game</button>
            <button class="pause-button" id="load-button">📂 Load Game</button>
            <button class="pause-button" id="controls-button">🎮 Controls</button>
            <button class="pause-button" id="settings-button">⚙️ Settings</button>
            <button class="pause-button" id="unstuck-button" style="background: linear-gradient(135deg, #e67e22, #d35400); box-shadow: 0 8px 30px rgba(230,126,34,0.3);">🆘 Unstuck</button>
        </div>
        <div id="save-status" style="margin-top: 20px; color: #2ecc71; font-size: 14px;"></div>
    </div>

    <!-- ===== SAVE SLOT MODAL ===== -->
    <div id="save-slot-modal">
        <div id="save-slot-box">
            <div id="save-slot-title">💾 Save Slots</div>
            <div id="save-slot-subtitle" id="save-slot-subtitle">Select a slot</div>
            <div id="autosave-timer-display">⏱ Autosave in <span id="autosave-countdown">5:00</span></div>

            <!-- Autosave slot -->
            <div class="save-slot-row autosave-row" id="slot-row-auto">
                <div class="save-slot-icon">🔄</div>
                <div class="save-slot-info">
                    <div class="save-slot-label">Autosave</div>
                    <div class="save-slot-meta" id="slot-meta-auto">No autosave yet</div>
                </div>
                <div class="save-slot-actions">
                    <button class="slot-btn slot-btn-load" id="slot-load-auto">Load</button>
                    <button class="slot-btn slot-btn-delete" id="slot-delete-auto" title="Delete">🗑</button>
                </div>
            </div>

            <div style="border-top:1px solid rgba(255,255,255,0.07);margin:12px 0 10px;"></div>

            <!-- Manual slots 1-5 -->
            <div class="save-slot-row" id="slot-row-0">
                <div class="save-slot-icon">📁</div>
                <div class="save-slot-info">
                    <div class="save-slot-label">Slot 1</div>
                    <div class="save-slot-meta" id="slot-meta-0">Empty</div>
                </div>
                <div class="save-slot-actions">
                    <button class="slot-btn slot-btn-save" id="slot-save-0">Save</button>
                    <button class="slot-btn slot-btn-load" id="slot-load-0" disabled>Load</button>
                    <button class="slot-btn slot-btn-delete" id="slot-delete-0" title="Delete" disabled>🗑</button>
                </div>
            </div>
            <div class="save-slot-row" id="slot-row-1">
                <div class="save-slot-icon">📁</div>
                <div class="save-slot-info">
                    <div class="save-slot-label">Slot 2</div>
                    <div class="save-slot-meta" id="slot-meta-1">Empty</div>
                </div>
                <div class="save-slot-actions">
                    <button class="slot-btn slot-btn-save" id="slot-save-1">Save</button>
                    <button class="slot-btn slot-btn-load" id="slot-load-1" disabled>Load</button>
                    <button class="slot-btn slot-btn-delete" id="slot-delete-1" title="Delete" disabled>🗑</button>
                </div>
            </div>
            <div class="save-slot-row" id="slot-row-2">
                <div class="save-slot-icon">📁</div>
                <div class="save-slot-info">
                    <div class="save-slot-label">Slot 3</div>
                    <div class="save-slot-meta" id="slot-meta-2">Empty</div>
                </div>
                <div class="save-slot-actions">
                    <button class="slot-btn slot-btn-save" id="slot-save-2">Save</button>
                    <button class="slot-btn slot-btn-load" id="slot-load-2" disabled>Load</button>
                    <button class="slot-btn slot-btn-delete" id="slot-delete-2" title="Delete" disabled>🗑</button>
                </div>
            </div>
            <div class="save-slot-row" id="slot-row-3">
                <div class="save-slot-icon">📁</div>
                <div class="save-slot-info">
                    <div class="save-slot-label">Slot 4</div>
                    <div class="save-slot-meta" id="slot-meta-3">Empty</div>
                </div>
                <div class="save-slot-actions">
                    <button class="slot-btn slot-btn-save" id="slot-save-3">Save</button>
                    <button class="slot-btn slot-btn-load" id="slot-load-3" disabled>Load</button>
                    <button class="slot-btn slot-btn-delete" id="slot-delete-3" title="Delete" disabled>🗑</button>
                </div>
            </div>
            <div class="save-slot-row" id="slot-row-4">
                <div class="save-slot-icon">📁</div>
                <div class="save-slot-info">
                    <div class="save-slot-label">Slot 5</div>
                    <div class="save-slot-meta" id="slot-meta-4">Empty</div>
                </div>
                <div class="save-slot-actions">
                    <button class="slot-btn slot-btn-save" id="slot-save-4">Save</button>
                    <button class="slot-btn slot-btn-load" id="slot-load-4" disabled>Load</button>
                    <button class="slot-btn slot-btn-delete" id="slot-delete-4" title="Delete" disabled>🗑</button>
                </div>
            </div>

            <div id="save-slot-status"></div>
            <div id="save-slot-close-row">
                <button id="save-slot-close-btn">✕ Close</button>
            </div>
        </div>
    </div>
    
    <div id="settings-menu" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 40, 0.95)); padding: 40px; border-radius: 20px; border: 2px solid rgba(52, 152, 219, 0.5); box-shadow: 0 0 50px rgba(0, 0, 0, 0.8); z-index: 10000; min-width: 500px; max-height: 90vh; overflow-y: auto;">
        <h2 style="color: white; margin-bottom: 30px; text-align: center; font-size: 32px;">⚙️ Settings</h2>

        <!-- Graphics -->
        <div style="color: #3498db; font-size: 13px; font-weight: bold; letter-spacing: 2px; text-transform: uppercase; margin-bottom: 15px; border-bottom: 1px solid rgba(52,152,219,0.3); padding-bottom: 6px;">🎮 Graphics</div>

        <div style="margin-bottom: 25px;">
            <label style="color: white; display: block; margin-bottom: 10px; font-size: 18px;">🔭 Render Distance</label>
            <input type="range" id="render-distance" min="80" max="500" value="100" step="10" style="width: 100%; height: 8px; border-radius: 5px; background: #444; outline: none; cursor: pointer;">
            <div style="color: #3498db; font-size: 14px; margin-top: 5px;" id="render-distance-value">100 units</div>
        </div>

        <!-- Audio -->
        <div style="color: #3498db; font-size: 13px; font-weight: bold; letter-spacing: 2px; text-transform: uppercase; margin-bottom: 15px; border-bottom: 1px solid rgba(52,152,219,0.3); padding-bottom: 6px; margin-top: 10px;">🔊 Audio</div>
        
        <div style="margin-bottom: 25px;">
            <label style="color: white; display: block; margin-bottom: 10px; font-size: 18px;">🌲 Forest Ambience</label>
            <input type="range" id="forest-volume" min="0" max="100" value="21" style="width: 100%; height: 8px; border-radius: 5px; background: #444; outline: none; cursor: pointer;">
            <div style="color: #3498db; font-size: 14px; margin-top: 5px;" id="forest-value">30%</div>
        </div>
        
        <div style="margin-bottom: 25px;">
            <label style="color: white; display: block; margin-bottom: 10px; font-size: 18px;">💨 Wind</label>
            <input type="range" id="wind-volume" min="0" max="100" value="10" style="width: 100%; height: 8px; border-radius: 5px; background: #444; outline: none; cursor: pointer;">
            <div style="color: #3498db; font-size: 14px; margin-top: 5px;" id="wind-value">10%</div>
        </div>
        
        <div style="margin-bottom: 25px;">
            <label style="color: white; display: block; margin-bottom: 10px; font-size: 18px;">🐾 Animal Sounds</label>
            <input type="range" id="animal-volume" min="0" max="100" value="50" style="width: 100%; height: 8px; border-radius: 5px; background: #444; outline: none; cursor: pointer;">
            <div style="color: #3498db; font-size: 14px; margin-top: 5px;" id="animal-value">50%</div>
        </div>
        
        <div style="margin-bottom: 25px;">
            <label style="color: white; display: block; margin-bottom: 10px; font-size: 18px;">⚔️ Enemy Sounds</label>
            <input type="range" id="enemy-volume" min="0" max="100" value="50" style="width: 100%; height: 8px; border-radius: 5px; background: #444; outline: none; cursor: pointer;">
            <div style="color: #3498db; font-size: 14px; margin-top: 5px;" id="enemy-value">50%</div>
        </div>
        
        <div style="margin-bottom: 25px;">
            <label style="color: white; display: block; margin-bottom: 10px; font-size: 18px;">👣 Footstep Sounds</label>
            <input type="range" id="footstep-volume" min="0" max="100" value="50" style="width: 100%; height: 8px; border-radius: 5px; background: #444; outline: none; cursor: pointer;">
            <div style="color: #3498db; font-size: 14px; margin-top: 5px;" id="footstep-value">50%</div>
        </div>
        
        <div style="margin-bottom: 25px;">
            <label style="color: white; display: block; margin-bottom: 10px; font-size: 18px;">🌧️ Rain</label>
            <input type="range" id="rain-volume" min="0" max="100" value="50" style="width: 100%; height: 8px; border-radius: 5px; background: #444; outline: none; cursor: pointer;">
            <div style="color: #3498db; font-size: 14px; margin-top: 5px;" id="rain-value">50%</div>
        </div>
        
        <div style="margin-bottom: 25px;">
            <label style="color: white; display: block; margin-bottom: 10px; font-size: 18px;">📱 Mobile Touch Controls</label>
            <button id="mobile-controls-toggle-btn" style="width:100%; padding:12px; font-size:16px; background:rgba(52,152,219,0.2); color:white; border:2px solid rgba(52,152,219,0.5); border-radius:10px; cursor:pointer; font-weight:bold;">📱 Mobile Controls: OFF</button>
        </div>

        <button id="close-settings" style="width: 100%; padding: 15px; font-size: 18px; background: linear-gradient(135deg, #3498db, #2980b9); color: white; border: none; border-radius: 10px; cursor: pointer; margin-top: 20px; font-weight: bold; box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);">✅ Done</button>
    </div>
    
    <!-- Mobile Touch Controls Overlay -->
    <div id="mobile-controls" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:5000;">

        <!-- Always-visible toggle button -->
        <button id="mobile-toggle-fab" style="
            position:fixed; top:12px; right:12px;
            width:44px; height:44px; border-radius:50%;
            background:rgba(0,0,0,0.6); border:2px solid rgba(255,255,255,0.4);
            color:white; font-size:20px; cursor:pointer;
            pointer-events:all; z-index:5100; display:none;
        " title="Toggle Mobile Controls">📱</button>

        <!-- Left joystick zone -->
        <div id="joy-zone" style="
            position:absolute; left:20px; bottom:120px;
            width:160px; height:160px; pointer-events:all;
        ">
            <div id="joy-base" style="
                width:160px; height:160px; border-radius:50%;
                background:rgba(255,255,255,0.08);
                border:2px solid rgba(255,255,255,0.25);
                position:relative;
            ">
                <div id="joy-thumb" style="
                    width:60px; height:60px; border-radius:50%;
                    background:rgba(255,255,255,0.35);
                    border:2px solid rgba(255,255,255,0.6);
                    position:absolute; top:50px; left:50px;
                    transition: background 0.1s;
                "></div>
            </div>
        </div>

        <!-- Sprint toggle button -->
        <div id="btn-sprint" style="
            position:absolute; left:20px; bottom:80px;
            width:70px; height:36px; border-radius:18px;
            background:rgba(255,165,0,0.25); border:2px solid rgba(255,165,0,0.5);
            color:white; font-size:13px; font-weight:bold;
            display:flex; align-items:center; justify-content:center;
            pointer-events:all; cursor:pointer; user-select:none;
        ">🏃 RUN</div>

        <!-- Right look zone -->
        <div id="look-zone" style="
            position:absolute; right:0; bottom:0;
            width:55%; height:75%;
            pointer-events:all;
            /* transparent — no visual */
        "></div>

        <!-- Action buttons (right side) -->
        <div style="position:absolute; right:20px; bottom:200px; display:flex; flex-direction:column; gap:14px; pointer-events:all;">
            <!-- Jump -->
            <div id="btn-jump" style="
                width:70px; height:70px; border-radius:50%;
                background:rgba(52,152,219,0.35); border:2px solid rgba(52,152,219,0.7);
                color:white; font-size:22px;
                display:flex; align-items:center; justify-content:center;
                cursor:pointer; user-select:none;
            ">⬆️</div>
        </div>

        <div style="position:absolute; right:110px; bottom:120px; display:flex; flex-direction:column; gap:14px; pointer-events:all;">
            <!-- Attack / Use -->
            <div id="btn-attack" style="
                width:80px; height:80px; border-radius:50%;
                background:rgba(231,76,60,0.35); border:2px solid rgba(231,76,60,0.7);
                color:white; font-size:26px;
                display:flex; align-items:center; justify-content:center;
                cursor:pointer; user-select:none;
            ">⚔️</div>
        </div>

        <!-- Inventory button -->
        <div id="btn-inventory" style="
            position:absolute; right:20px; bottom:120px;
            width:70px; height:70px; border-radius:50%;
            background:rgba(46,204,113,0.35); border:2px solid rgba(46,204,113,0.7);
            color:white; font-size:22px;
            display:flex; align-items:center; justify-content:center;
            pointer-events:all; cursor:pointer; user-select:none;
        ">🎒</div>

        <!-- Interact / E button -->
        <div id="btn-interact" style="
            position:absolute; right:110px; bottom:220px;
            width:60px; height:60px; border-radius:50%;
            background:rgba(155,89,182,0.35); border:2px solid rgba(155,89,182,0.7);
            color:white; font-size:18px;
            display:flex; align-items:center; justify-content:center;
            pointer-events:all; cursor:pointer; user-select:none;
        ">🔘 E</div>

    </div>
    <div id="code-lock-menu" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(20, 30, 40, 0.98), rgba(10, 20, 30, 0.98)); padding: 40px; border-radius: 20px; border: 3px solid rgba(52, 152, 219, 0.6); box-shadow: 0 0 60px rgba(0, 0, 0, 0.9); z-index: 10001; min-width: 400px;">
        <h2 id="code-lock-title" style="color: white; margin-bottom: 20px; text-align: center; font-size: 28px;">🔒 Set Door Code</h2>
        
        <!-- Status Light -->
        <div style="text-align: center; margin-bottom: 20px;">
            <div id="code-lock-light" style="width: 60px; height: 60px; border-radius: 50%; margin: 0 auto; background: #2ecc71; box-shadow: 0 0 30px rgba(46, 204, 113, 0.8); transition: all 0.3s ease;"></div>
        </div>
        
        <!-- Code Display -->
        <div style="background: rgba(0, 0, 0, 0.6); padding: 20px; border-radius: 10px; margin-bottom: 20px; text-align: center;">
            <div id="code-display" style="font-size: 36px; color: #3498db; letter-spacing: 10px; font-family: 'Courier New', monospace; min-height: 50px;">----</div>
        </div>
        
        <!-- Number Pad -->
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 20px;">
            <button class="code-btn" data-num="1" style="padding: 20px; font-size: 24px; background: linear-gradient(135deg, #34495e, #2c3e50); color: white; border: 2px solid rgba(52, 152, 219, 0.4); border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.2s;">1</button>
            <button class="code-btn" data-num="2" style="padding: 20px; font-size: 24px; background: linear-gradient(135deg, #34495e, #2c3e50); color: white; border: 2px solid rgba(52, 152, 219, 0.4); border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.2s;">2</button>
            <button class="code-btn" data-num="3" style="padding: 20px; font-size: 24px; background: linear-gradient(135deg, #34495e, #2c3e50); color: white; border: 2px solid rgba(52, 152, 219, 0.4); border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.2s;">3</button>
            <button class="code-btn" data-num="4" style="padding: 20px; font-size: 24px; background: linear-gradient(135deg, #34495e, #2c3e50); color: white; border: 2px solid rgba(52, 152, 219, 0.4); border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.2s;">4</button>
            <button class="code-btn" data-num="5" style="padding: 20px; font-size: 24px; background: linear-gradient(135deg, #34495e, #2c3e50); color: white; border: 2px solid rgba(52, 152, 219, 0.4); border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.2s;">5</button>
            <button class="code-btn" data-num="6" style="padding: 20px; font-size: 24px; background: linear-gradient(135deg, #34495e, #2c3e50); color: white; border: 2px solid rgba(52, 152, 219, 0.4); border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.2s;">6</button>
            <button class="code-btn" data-num="7" style="padding: 20px; font-size: 24px; background: linear-gradient(135deg, #34495e, #2c3e50); color: white; border: 2px solid rgba(52, 152, 219, 0.4); border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.2s;">7</button>
            <button class="code-btn" data-num="8" style="padding: 20px; font-size: 24px; background: linear-gradient(135deg, #34495e, #2c3e50); color: white; border: 2px solid rgba(52, 152, 219, 0.4); border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.2s;">8</button>
            <button class="code-btn" data-num="9" style="padding: 20px; font-size: 24px; background: linear-gradient(135deg, #34495e, #2c3e50); color: white; border: 2px solid rgba(52, 152, 219, 0.4); border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.2s;">9</button>
            <button id="code-clear" style="padding: 20px; font-size: 20px; background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; border: 2px solid rgba(231, 76, 60, 0.4); border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.2s;">CLR</button>
            <button class="code-btn" data-num="0" style="padding: 20px; font-size: 24px; background: linear-gradient(135deg, #34495e, #2c3e50); color: white; border: 2px solid rgba(52, 152, 219, 0.4); border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.2s;">0</button>
            <button id="code-enter" style="padding: 20px; font-size: 20px; background: linear-gradient(135deg, #2ecc71, #27ae60); color: white; border: 2px solid rgba(46, 204, 113, 0.4); border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.2s;">ENT</button>
        </div>
        
        <button id="code-cancel" style="width: 100%; padding: 15px; font-size: 18px; background: linear-gradient(135deg, #95a5a6, #7f8c8d); color: white; border: none; border-radius: 10px; cursor: pointer; font-weight: bold; box-shadow: 0 4px 15px rgba(127, 140, 141, 0.4);">Cancel</button>
    </div>

    <script>
        (function() {
            const cdns = [
                'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js',
                'https://unpkg.com/three@0.128.0/build/three.min.js',
                'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js'
            ];

            const statusEl = () => document.getElementById('loading-status');
            const progressEl = () => document.getElementById('loadingProgress');
            let gameStarted = false;

            // Animate progress bar 0-8% while waiting for THREE.js CDN
            let fakeProgress = 0;
            const progressInterval = setInterval(() => {
                fakeProgress = Math.min(fakeProgress + (7 - fakeProgress) * 0.05, 7);
                const p = progressEl();
                if (p) p.style.width = fakeProgress + '%';
            }, 100);

            function onThreeLoaded() {
                if (gameStarted) return;
                gameStarted = true;
                clearInterval(progressInterval);
                if (statusEl()) statusEl().textContent = 'Loading models...';

                // Load GLTFLoader AFTER Three.js is confirmed ready, then start game
                window._gltfLoaderReady = false;
                window._gltfLoaderPromise = new Promise(resolve => {
                    const gltfUrls = [
                        'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js',
                        'https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js'
                    ];
                    function tryGLTF(i) {
                        if (i >= gltfUrls.length) { console.warn('GLTFLoader failed all CDNs'); resolve(false); return; }
                        const gs = document.createElement('script');
                        gs.src = gltfUrls[i];
                        gs.onload = () => {
                            window._gltfLoaderReady = true; console.log('GLTFLoader ready');
                            // Also load SkeletonUtils for proper rigged model cloning
                            const su = document.createElement('script');
                            su.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/SkeletonUtils.js';
                            su.onerror = () => console.warn('SkeletonUtils failed to load');
                            document.head.appendChild(su);
                            resolve(true);
                        };
                        gs.onerror = () => tryGLTF(i + 1);
                        document.head.appendChild(gs);
                    }
                    tryGLTF(0);
                });

                // Also load DRACOLoader for Draco-compressed GLBs.
                // _dracoLoaderPromise resolves when the script is ready.
                // _glbLoadersReady() waits for both this AND GLTFLoader before any parse.
                const dracoScript = document.createElement('script');
                dracoScript.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js';
                window._dracoLoaderPromise = new Promise(res => {
                    dracoScript.onload  = () => {
                        // Invalidate shared loader so next _getGLTFLoader() attaches Draco
                        if (window._sharedGLTFLoader) { window._sharedGLTFLoader = null; }
                        console.log('DRACOLoader ready');
                        res(true);
                    };
                    dracoScript.onerror = () => { console.warn('DRACOLoader failed to load'); res(false); };
                });
                document.head.appendChild(dracoScript);

                window._gltfLoaderPromise.then(() => {
                    if (statusEl()) statusEl().textContent = 'Initializing...';
                    try {
                        if (typeof startGame === 'function') startGame();
                    } catch(e) {
                        const el = document.getElementById('loading-status');
                        if (el) el.textContent = '\u274c ' + e.message;
                        console.error('startGame crashed:', e);
                        setTimeout(() => {
                            const ls = document.getElementById('loadingScreen');
                            if (ls) ls.classList.add('hidden');
                        }, 2000);
                    }
                });
            }

            function showError() {
                clearInterval(progressInterval);
                const title = document.getElementById('loading-title-text');
                const bar = document.querySelector('.loading-bar');
                const s = statusEl();
                if (title) {
                    title.style.fontSize = '26px';
                    title.textContent = 'CRUST';
                }
                if (bar) bar.style.display = 'none';
                if (s) {
                    s.style.fontSize = '14px';
                    s.style.lineHeight = '1.8';
                    s.style.color = 'rgba(255,255,255,0.8)';
                    s.innerHTML = '\u26a0\ufe0f Network access required for the 3D engine.<br>Please <b>download</b> the file and open it in Chrome, Firefox, or Edge.';
                }
            }

            function tryLoad(idx) {
                if (idx >= cdns.length) { showError(); return; }
                if (statusEl()) statusEl().textContent = 'Loading 3D engine... (attempt ' + (idx+1) + '/' + cdns.length + ')';

                // Try script tag
                const s = document.createElement('script');
                s.src = cdns[idx];
                s.onload = onThreeLoaded;
                s.onerror = function() {
                    // Try fetch+blob as fallback
                    fetch(cdns[idx])
                        .then(r => { if (!r.ok) throw 0; return r.text(); })
                        .then(code => {
                            const url = URL.createObjectURL(new Blob([code], {type:'application/javascript'}));
                            const s2 = document.createElement('script');
                            s2.src = url;
                            s2.onload = () => { URL.revokeObjectURL(url); onThreeLoaded(); };
                            s2.onerror = () => { URL.revokeObjectURL(url); tryLoad(idx + 1); };
                            document.head.appendChild(s2);
                        })
                        .catch(() => tryLoad(idx + 1));
                };
                document.head.appendChild(s);
            }

            tryLoad(0);
        })();
    </script>
    <!-- GLTFLoader is now loaded inside onThreeLoaded, after THREE.js is ready -->
    <script>
        window.onerror = function(msg, src, line, col, err) {
            const el = document.getElementById('loading-status');
            if (el) el.textContent = '\u274c ' + msg + ' (line ' + line + ')';
            console.error('Game error:', msg, 'line:', line, err);
            // Dismiss loading screen after a moment so error is visible
            setTimeout(() => {
                const ls = document.getElementById('loadingScreen');
                if (ls) ls.classList.add('hidden');
            }, 3000);
        };
        function startGame() {
        // ===== TEXTURE CACHE SYSTEM (IndexedDB) =====
        const TEXTURE_CACHE_VERSION = 2;
        const TEXTURE_DB_NAME = 'CrustTextureCache';
        const TEXTURE_STORE_NAME = 'textures';

        class TextureCache {
            constructor() {
                this.db = null;
                this.ready = false;
                this.cacheStats = { hits: 0, misses: 0, generated: 0 };
            }
            
            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(TEXTURE_DB_NAME, TEXTURE_CACHE_VERSION);
                    
                    request.onerror = () => {
                        console.warn('\u26a0\ufe0f IndexedDB not available, caching disabled');
                        resolve();
                    };
                    
                    request.onsuccess = () => {
                        this.db = request.result;
                        this.ready = true;
                        console.log('\u2705 Texture cache initialized');
                        resolve();
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(TEXTURE_STORE_NAME)) {
                            db.createObjectStore(TEXTURE_STORE_NAME, { keyPath: 'id' });
                            console.log('\u2705 Texture cache database created');
                        }
                    };
                });
            }
            
            async saveTexture(id, canvas) {
                if (!this.ready || !canvas) return;
                
                try {
                    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                    const transaction = this.db.transaction([TEXTURE_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(TEXTURE_STORE_NAME);
                    
                    await new Promise((resolve, reject) => {
                        const request = store.put({ 
                            id, 
                            blob, 
                            timestamp: Date.now(),
                            version: TEXTURE_CACHE_VERSION
                        });
                        request.onsuccess = resolve;
                        request.onerror = () => reject(request.error);
                    });
                    
                    console.log(`\ud83d\udcbe Cached texture: ${id}`);
                } catch (error) {
                    console.warn(`Failed to cache texture ${id}:`, error);
                }
            }
            
            async loadTexture(id) {
                if (!this.ready) return null;
                
                try {
                    const transaction = this.db.transaction([TEXTURE_STORE_NAME], 'readonly');
                    const store = transaction.objectStore(TEXTURE_STORE_NAME);
                    
                    const result = await new Promise((resolve, reject) => {
                        const request = store.get(id);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    if (result && result.blob && result.version === TEXTURE_CACHE_VERSION) {
                        const canvas = await this.blobToCanvas(result.blob);
                        this.cacheStats.hits++;
                        console.log(`\u26a1 Loaded from cache: ${id}`);
                        return canvas;
                    } else {
                        this.cacheStats.misses++;
                        return null;
                    }
                } catch (error) {
                    this.cacheStats.misses++;
                    return null;
                }
            }
            
            async blobToCanvas(blob) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    const url = URL.createObjectURL(blob);
                    
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        URL.revokeObjectURL(url);
                        resolve(canvas);
                    };
                    
                    img.onerror = () => {
                        URL.revokeObjectURL(url);
                        reject(new Error('Failed to load image from blob'));
                    };
                    
                    img.src = url;
                });
            }
            
            async clearCache() {
                if (!this.ready) return;
                
                try {
                    const transaction = this.db.transaction([TEXTURE_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(TEXTURE_STORE_NAME);
                    await new Promise((resolve, reject) => {
                        const request = store.clear();
                        request.onsuccess = resolve;
                        request.onerror = () => reject(request.error);
                    });
                    console.log('\u2705 Texture cache cleared');
                    if (typeof showMessage !== 'undefined') {
                        showMessage('\u2705 Texture cache cleared! Reload to regenerate.');
                    }
                } catch (error) {
                    console.warn('Failed to clear cache:', error);
                }
            }
            
            getStats() {
                const total = this.cacheStats.hits + this.cacheStats.misses;
                const hitRate = total > 0 ? ((this.cacheStats.hits / total) * 100).toFixed(1) : 0;
                return {
                    ...this.cacheStats,
                    total,
                    hitRate: hitRate + '%'
                };
            }
        }

        // Initialize global texture cache
        const textureCache = new TextureCache();
        
        // ===== PROCEDURAL SOUND SYSTEM =====
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // ===== THEME MUSIC (Web Audio API — plays on click-to-play overlay only) =====
        let _themeBuffer = null;
        let _themeSource = null;
        let _themeGain = null;

        // Pre-fetch the theme during loading so it's ready to play instantly when the overlay appears
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/theme.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => {
                _themeBuffer = buf;
                console.log('Theme loaded OK');
            })
            .catch(e => { console.error('Theme fetch error:', e); });

        function startTheme() {
            if (!_themeBuffer || _themeSource) return;
            audioContext.resume().then(() => {
                if (_themeSource) return;
                _themeGain = audioContext.createGain();
                _themeGain.gain.value = 0.7;
                _themeGain.connect(audioContext.destination);
                _themeSource = audioContext.createBufferSource();
                _themeSource.buffer = _themeBuffer;
                _themeSource.loop = true;
                _themeSource.connect(_themeGain);
                _themeSource.start();
                console.log('🎵 Theme music started');
            }).catch(() => {});
        }

        function stopTheme() {
            if (!_themeGain || !_themeSource) return;
            const gain = _themeGain;
            const src = _themeSource;
            _themeSource = null;
            _themeGain = null;
            const now = audioContext.currentTime;
            gain.gain.setValueAtTime(gain.gain.value, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.6);
            src.stop(now + 0.65);
        }
        
        // ===== AMBIENT SOUNDS \u2014 BIOME-AWARE WITH SMOOTH CROSSFADE =====
        let ambientWindOscillator = null;
        let ambientWindGain       = null;
        let ambientWindFilter     = null;

        // biomeBlend: 0 = fully forest, 1 = fully desert
        // Crossfade zone: 40 units wide centred on biome boundary z = -100
        // NOTE: groundSize is defined later, so these are computed lazily in getBiomeBlend()
        let _biomeBlend = 0;

        function getBiomeBlend() {
            // edgeZ is offset by +fadeHalf/2 so that _biomeBlend hits 0.5
            // (the isInDesert threshold) exactly at z = -(groundSize/2) = -100,
            // matching the UI world-map biome boundary.
            const fadeHalf = 40;                  // wider fade zone — smoother biome transition
            const edgeZ    = -(groundSize / 2) + (fadeHalf / 2);  // -80 once groundSize=200
            const raw = (edgeZ - camera.position.z) / fadeHalf;
            return Math.max(0, Math.min(1, raw));
        }
        function isInDesert() { return _biomeBlend > 0.5; }
        // so desert visuals/sounds/effects don't bleed into snow territory.
        function getEffectiveDesertBlend() {
            const desert = getBiomeBlend();
            if (desert < 0.01) return 0;
            const sbFade = 40;
            const sbHalf = SB_SIZE / 2;
            const sbRawX = (sbHalf + sbFade / 2 - Math.abs(camera.position.x - SB_CX)) / sbFade;
            const sbRawZ = (sbHalf + sbFade / 2 - Math.abs(camera.position.z - SB_CZ)) / sbFade;
            const snowBlend = Math.max(0, Math.min(1, Math.min(sbRawX, sbRawZ)));
            return Math.max(0, desert - snowBlend);
        }

        // Per-layer master gain nodes (created inside startAmbientSounds)
        let _forestGain = null;
        let _desertGain = null;
        let _forestAmbienceGain = null;
        let _windLPF    = null;   // shared wind low-pass — tuned per biome
        let _snowWalkBuffer = null; // decoded AudioBuffer for Snowwalk.mp3
        let _snowFeetBuffer = null; // decoded AudioBuffer for SnowFeet.mp3
        let _snowWindGain   = null; // gain node for looping SnowWind.mp3 ambient

        function startAmbientSounds() {
            // \u2500\u2500 Shared looping wind noise \u2500\u2500
            const wBuf  = audioContext.createBuffer(1, audioContext.sampleRate * 10, audioContext.sampleRate);
            const wData = wBuf.getChannelData(0);
            for (let i = 0; i < wData.length; i++) wData[i] = Math.random() * 2 - 1;

            const wSrc = audioContext.createBufferSource();
            wSrc.buffer = wBuf; wSrc.loop = true;
            _windLPF = audioContext.createBiquadFilter(); _windLPF.type = 'lowpass';  _windLPF.frequency.value = 900;
            const wHP = audioContext.createBiquadFilter(); wHP.type = 'highpass'; wHP.frequency.value = 180;
            const wN  = audioContext.createBiquadFilter(); wN.type  = 'notch';    wN.frequency.value  = 400; wN.Q.value = 1.2;
            ambientWindGain = audioContext.createGain();
            ambientWindGain.gain.value = volumeSettings.ambient * 0.03;
            wSrc.connect(_windLPF); _windLPF.connect(wHP); wHP.connect(wN); wN.connect(ambientWindGain);
            ambientWindGain.connect(audioContext.destination);
            wSrc.start();
            ambientWindOscillator = wSrc;

            // Gust variance
            (function gustLoop() {
                setTimeout(() => {
                    if (ambientWindGain && !isPaused)
                        ambientWindGain.gain.linearRampToValueAtTime(
                            volumeSettings.wind * (0.01 + Math.random() * 0.02),
                            audioContext.currentTime + 2 + Math.random() * 5);
                    gustLoop();
                }, (4 + Math.random() * 8) * 1000);
            })();

            // Real forest ambience track via Web Audio API
            let forestAmbienceSource = null;
            _forestAmbienceGain = audioContext.createGain();
            _forestAmbienceGain.gain.value = volumeSettings.forest;
            _forestAmbienceGain.connect(audioContext.destination);
            fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/forestambience.mp3')
                .then(r => r.arrayBuffer())
                .then(ab => audioContext.decodeAudioData(ab))
                .then(buffer => {
                    console.log('Forest ambience loaded OK');
                    forestAmbienceSource = audioContext.createBufferSource();
                    forestAmbienceSource.buffer = buffer;
                    forestAmbienceSource.loop = true;
                    forestAmbienceSource.connect(_forestAmbienceGain);
                    forestAmbienceSource.start();
                })
                .catch(e => { console.error('Forest ambience fetch error:', e); });

            // Load enemy attack sound after user interaction
            _enemyAttackAudio = new Audio('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/Bite.mp3');
            _enemyAttackAudio.preload = 'auto';

            // ── Snow Walk footstep buffer ──────────────────────────────────
            // Decoded once; playSnowFootstep() slices a random chunk each step.
            fetch('https://jam110uk.github.io/Crust-Sounds/Snowwalk.mp3')
                .then(r => { if (!r.ok) throw new Error('HTTP ' + r.status); return r.arrayBuffer(); })
                .then(ab => audioContext.decodeAudioData(ab))
                .then(buffer => {
                    console.log('❄️ Snow walk buffer loaded OK — duration:', buffer.duration.toFixed(2), 's');
                    _snowWalkBuffer = buffer;
                })
                .catch(e => console.error('Snow walk fetch error:', e));

            // ── SnowFeet footstep buffer ───────────────────────────────────
            fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/SnowFeet.mp3')
                .then(r => { if (!r.ok) throw new Error('HTTP ' + r.status); return r.arrayBuffer(); })
                .then(ab => audioContext.decodeAudioData(ab))
                .then(buffer => {
                    console.log('👣 SnowFeet buffer loaded OK — duration:', buffer.duration.toFixed(2), 's');
                    _snowFeetBuffer = buffer;
                })
                .catch(e => console.error('SnowFeet fetch error:', e));

            // ── SnowWind ambient loop ──────────────────────────────────────
            _snowWindGain = audioContext.createGain();
            _snowWindGain.gain.value = 0; // starts silent; crossfade interval drives it
            _snowWindGain.connect(audioContext.destination);
            fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/SnowWind.mp3')
                .then(r => { if (!r.ok) throw new Error('HTTP ' + r.status); return r.arrayBuffer(); })
                .then(ab => audioContext.decodeAudioData(ab))
                .then(buffer => {
                    console.log('🌨️ SnowWind ambient loaded OK');
                    const src = audioContext.createBufferSource();
                    src.buffer = buffer;
                    src.loop = true;
                    src.connect(_snowWindGain);
                    src.start();
                })
                .catch(e => console.error('SnowWind fetch error:', e));

            // \u2500\u2500 Forest layer gain \u2500\u2500
            _forestGain = audioContext.createGain();
            _forestGain.gain.value = 1.0;
            _forestGain.connect(audioContext.destination);

            // \u2500\u2500 Desert layer gain \u2500\u2500
            _desertGain = audioContext.createGain();
            _desertGain.gain.value = 0.0;
            _desertGain.connect(audioContext.destination);

            // ── River ambient gain (River.mp3 fades in within 100 units of river) ──
            window._riverAmbGain = audioContext.createGain();
            window._riverAmbGain.gain.value = 0;
            window._riverAmbGain.connect(audioContext.destination);
            fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/River.mp3')
                .then(r => { if (!r.ok) throw new Error('HTTP ' + r.status); return r.arrayBuffer(); })
                .then(ab => audioContext.decodeAudioData(ab))
                .then(buffer => {
                    console.log('🌊 River ambient loaded OK');
                    const src = audioContext.createBufferSource();
                    src.buffer = buffer;
                    src.loop = true;
                    src.connect(window._riverAmbGain);
                    src.start();
                })
                .catch(e => console.error('River ambient fetch error:', e));

            // ── River walk sound buffer (RiverWalk.mp3 — played as footstep) ──
            window._riverWalkBuffer = null;
            fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/RiverWalk.mp3')
                .then(r => { if (!r.ok) throw new Error('HTTP ' + r.status); return r.arrayBuffer(); })
                .then(ab => audioContext.decodeAudioData(ab))
                .then(buffer => {
                    console.log('🌊 RiverWalk sound loaded OK');
                    window._riverWalkBuffer = buffer;
                })
                .catch(e => console.error('RiverWalk fetch error:', e));

            // Crossfade poll: 200 ms resolution gives silky smooth fade
            setInterval(() => {
                if (isPaused) return;
                _biomeBlend = getEffectiveDesertBlend();
                // Snow blend — mutes both forest and desert when in snow biome
                const _snowAmbBlend = (typeof _getSnowBiomeBlend === 'function') ? _getSnowBiomeBlend() : 0;
                const forestVol = Math.max(0, (1 - _biomeBlend) * (1 - _snowAmbBlend));
                const desertVol = Math.max(0, _biomeBlend * (1 - _snowAmbBlend));
                const now = audioContext.currentTime;
                const fadeT = 0.4;
                _forestGain.gain.linearRampToValueAtTime(forestVol * volumeSettings.ambient, now + fadeT);
                _desertGain.gain.linearRampToValueAtTime(desertVol * volumeSettings.ambient, now + fadeT);
                if (_forestAmbienceGain) _forestAmbienceGain.gain.linearRampToValueAtTime(forestVol * volumeSettings.forest, now + fadeT);
                if (_snowWindGain) _snowWindGain.gain.linearRampToValueAtTime(_snowAmbBlend * volumeSettings.ambient, now + fadeT);
                // River ambient — fade in within 100 units of river centre (RB_CX=200, RB_CZ=0)
                if (window._riverAmbGain) {
                    const _rpx = camera.position.x - 200, _rpz = camera.position.z - 0;
                    const _riverDist = Math.sqrt(_rpx*_rpx + _rpz*_rpz);
                    const _riverVol = Math.max(0, 1 - _riverDist / 100) * volumeSettings.ambient * 1.6;
                    window._riverAmbGain.gain.linearRampToValueAtTime(_riverVol, now + fadeT);
                }
                _windLPF.frequency.linearRampToValueAtTime(600 + _biomeBlend * 1600, now + fadeT);
                // Stop rain if player crosses into desert or snow
                if ((_biomeBlend > 0.5 || _snowAmbBlend > 0.5) && isRaining) stopRain();
            }, 200);

            // \u2500\u2500 Start all ambient loops \u2500\u2500
            scheduleDesertCicada();
            scheduleDesertHawk();
        }

        // \u2500\u2500 Desert sounds \u2500\u2500
        function scheduleDesertCicada() {
            setTimeout(() => {
                if (!isPaused && _biomeBlend > 0.15) playDesertCicadaTo(_desertGain);
                scheduleDesertCicada();
            }, 2500 + Math.random() * 6000);
        }
        function scheduleDesertHawk() {
            setTimeout(() => {
                if (!isPaused && _biomeBlend > 0.15 && Math.random() < 0.4) playDesertHawkTo(_desertGain);
                scheduleDesertHawk();
            }, 10000 + Math.random() * 18000);
        }

        // \u2500\u2500 Sound emitters routed to a destination node \u2500\u2500
        function playBirdChirpTo(dest) {
            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator(), g = audioContext.createGain();
            osc.type = 'sine';
            const bf = 1400 + Math.random() * 1200;
            osc.frequency.setValueAtTime(bf, now);
            osc.frequency.setValueAtTime(bf * 1.25, now + 0.05);
            osc.frequency.setValueAtTime(bf * 0.85, now + 0.12);
            g.gain.setValueAtTime(0.08, now);
            g.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
            osc.connect(g); g.connect(dest || audioContext.destination);
            osc.start(now); osc.stop(now + 0.18);
        }
        function playRustleTo(dest) {
            const now = audioContext.currentTime;
            const buf = audioContext.createBuffer(1, ~~(audioContext.sampleRate * 0.3), audioContext.sampleRate);
            const d = buf.getChannelData(0);
            for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * 0.3;
            const src = audioContext.createBufferSource(); src.buffer = buf;
            const f = audioContext.createBiquadFilter(); f.type = 'highpass'; f.frequency.value = 800;
            const g = audioContext.createGain();
            g.gain.setValueAtTime(0.06, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
            src.connect(f); f.connect(g); g.connect(dest || audioContext.destination);
            src.start(now);
        }
        function playDesertCicadaTo(dest) {
            const now = audioContext.currentTime;
            const buf = audioContext.createBuffer(1, ~~(audioContext.sampleRate * 1.6), audioContext.sampleRate);
            const d = buf.getChannelData(0);
            for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * 0.4;
            const src = audioContext.createBufferSource(); src.buffer = buf;
            const bp = audioContext.createBiquadFilter(); bp.type = 'bandpass';
            bp.frequency.value = 4000 + Math.random() * 1000; bp.Q.value = 9;
            const g = audioContext.createGain();
            g.gain.setValueAtTime(0, now);
            g.gain.linearRampToValueAtTime(0.07, now + 0.25);
            g.gain.linearRampToValueAtTime(0.04, now + 0.9);
            g.gain.linearRampToValueAtTime(0, now + 1.6);
            src.connect(bp); bp.connect(g); g.connect(dest || audioContext.destination);
            src.start(now);
        }
        function playDesertHawkTo(dest) {
            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const f = audioContext.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = 1400; f.Q.value = 2;
            const g = audioContext.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(950, now);
            osc.frequency.exponentialRampToValueAtTime(460, now + 0.6);
            osc.frequency.exponentialRampToValueAtTime(300, now + 1.2);
            g.gain.setValueAtTime(0, now);
            g.gain.linearRampToValueAtTime(0.07, now + 0.09);
            g.gain.exponentialRampToValueAtTime(0.001, now + 1.25);
            osc.connect(f); f.connect(g); g.connect(dest || audioContext.destination);
            osc.start(now); osc.stop(now + 1.3);
        }

        // \u2500\u2500 Sand-gust whoosh (called by particle system) \u2500\u2500
        function playSandGustSound(intensity) {
            if (!_desertGain || _biomeBlend < 0.25 || isPaused) return;
            const now = audioContext.currentTime;
            const dur = 1.6 + Math.random() * 1.4;
            const buf = audioContext.createBuffer(1, ~~(audioContext.sampleRate * dur), audioContext.sampleRate);
            const d = buf.getChannelData(0);
            for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
            const src = audioContext.createBufferSource(); src.buffer = buf;
            const bp1 = audioContext.createBiquadFilter(); bp1.type = 'bandpass'; bp1.frequency.value = 1100; bp1.Q.value = 1.4;
            const bp2 = audioContext.createBiquadFilter(); bp2.type = 'bandpass'; bp2.frequency.value = 3600; bp2.Q.value = 2.2;
            const mix = audioContext.createGain(); mix.gain.value = 0.5;
            const g   = audioContext.createGain();
            const vol = intensity * _biomeBlend * 0.20;
            g.gain.setValueAtTime(0, now);
            g.gain.linearRampToValueAtTime(vol,       now + 0.35);
            g.gain.linearRampToValueAtTime(vol * 0.5, now + dur * 0.65);
            g.gain.linearRampToValueAtTime(0,         now + dur);
            src.connect(bp1); src.connect(bp2);
            bp1.connect(mix); bp2.connect(mix);
            mix.connect(g); g.connect(_desertGain);
            src.start(now);
        }

        // Legacy aliases so existing call-sites still work
        function playBirdChirp()   { playBirdChirpTo(_forestGain); }
        function playRustleSound() { playRustleTo(_forestGain); }

        function updateAmbientVolume() {
            const _snowAmbBlend = (typeof _getSnowBiomeBlend === 'function') ? _getSnowBiomeBlend() : 0;
            const forestVol = Math.max(0, (1 - _biomeBlend) * (1 - _snowAmbBlend));
            const desertVol = Math.max(0, _biomeBlend * (1 - _snowAmbBlend));
            if (ambientWindGain) ambientWindGain.gain.value = volumeSettings.wind * 0.03;
            if (_forestAmbienceGain) _forestAmbienceGain.gain.value = forestVol * volumeSettings.forest;
            if (_forestGain) _forestGain.gain.value = forestVol * volumeSettings.ambient;
            if (_desertGain) _desertGain.gain.value = desertVol * volumeSettings.ambient;
            if (_snowWindGain) _snowWindGain.gain.value = _snowAmbBlend * volumeSettings.ambient;
        }

        // ===== SAND GUST PARTICLE SYSTEM =====
        const SAND_MAX = 800;
        const _sandPx = new Float32Array(SAND_MAX), _sandPy = new Float32Array(SAND_MAX), _sandPz = new Float32Array(SAND_MAX);
        const _sandVx = new Float32Array(SAND_MAX), _sandVy = new Float32Array(SAND_MAX), _sandVz = new Float32Array(SAND_MAX);
        const _sandLife = new Float32Array(SAND_MAX), _sandMaxLife = new Float32Array(SAND_MAX);
        // Turbulence per-particle: angular spin rate and phase offset for swirling
        const _sandSpin  = new Float32Array(SAND_MAX); // radians/sec angular drift
        const _sandPhase = new Float32Array(SAND_MAX); // random phase offset

        const _sandGeo     = new THREE.BufferGeometry();
        const _sandPosAttr = new THREE.BufferAttribute(new Float32Array(SAND_MAX * 3), 3);
        _sandGeo.setAttribute('position', _sandPosAttr);
        for (let i = 0; i < SAND_MAX; i++) _sandPosAttr.setXYZ(i, 0, -9999, 0);
        _sandPosAttr.needsUpdate = true;

        // Shared soft round-disc textures — radial gradient, same technique as snow.
        const _sandCircleTex = (() => {
            const sz = 64, c = document.createElement('canvas');
            c.width = c.height = sz;
            const ctx = c.getContext('2d'), r = sz / 2;
            const g = ctx.createRadialGradient(r, r, 0, r, r, r);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(0.45, 'rgba(255,255,255,0.8)');
            g.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = g; ctx.fillRect(0, 0, sz, sz);
            return new THREE.CanvasTexture(c);
        })();
        const _fireCircleTex = (() => {
            const sz = 64, c = document.createElement('canvas');
            c.width = c.height = sz;
            const ctx = c.getContext('2d'), r = sz / 2;
            const g = ctx.createRadialGradient(r, r, 0, r, r, r);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(0.4, 'rgba(255,255,255,0.85)');
            g.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = g; ctx.fillRect(0, 0, sz, sz);
            return new THREE.CanvasTexture(c);
        })();
        const _smokeCircleTex = (() => {
            const sz = 64, c = document.createElement('canvas');
            c.width = c.height = sz;
            const ctx = c.getContext('2d'), r = sz / 2;
            const g = ctx.createRadialGradient(r, r, 0, r, r, r);
            g.addColorStop(0, 'rgba(255,255,255,0.9)');
            g.addColorStop(0.5, 'rgba(255,255,255,0.5)');
            g.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = g; ctx.fillRect(0, 0, sz, sz);
            return new THREE.CanvasTexture(c);
        })();

        const _sandMat = new THREE.PointsMaterial({
            color: 0xc8a060,
            size: 0.5,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.55,
            depthWrite: false,
            map: _sandCircleTex,
            alphaTest: 0.01,
        });
        const _sandPoints = new THREE.Points(_sandGeo, _sandMat);
        _sandPoints.renderOrder = 2;
        _sandPoints.frustumCulled = false;  // bounding sphere is stale (parked verts) \u2014 skip culling
        // scene.add deferred \u2014 called after scene is ready

        let _sandGustTimer    = 0;
        let _sandGustInterval = 4 + Math.random() * 6;  // first gust within 4-10s
        let _sandGustActive   = false;
        let _sandGustDur      = 0;
        let _sandGustAge      = 0;
        let _sandGustWind     = new THREE.Vector3(1, 0, 0);
        let _sandPrevTime     = -1;   // -1 signals first frame

        function _spawnSandParticle(cx, cz, wind, speed) {
            for (let i = 0; i < SAND_MAX; i++) {
                if (_sandLife[i] <= 0) {
                    const spread = 20;
                    _sandPx[i] = cx + (Math.random() - 0.5) * spread;
                    _sandPy[i] = 0.04 + Math.random() * 1.8;
                    _sandPz[i] = cz + (Math.random() - 0.5) * spread;
                    const s = speed * (0.5 + Math.random() * 0.9);
                    // Give each particle a random sideways deviation so they don't travel in straight lines
                    const lateralAngle = (Math.random() - 0.5) * 1.8; // \u00b1~103\u00b0
                    const perpX =  wind.z, perpZ = -wind.x; // perpendicular to wind
                    const lateral = Math.sin(lateralAngle) * s * 0.7;
                    _sandVx[i] = wind.x * s * Math.cos(lateralAngle) + perpX * lateral + (Math.random() - 0.5) * 0.05;
                    _sandVy[i] = 0.006 + Math.random() * 0.025;
                    _sandVz[i] = wind.z * s * Math.cos(lateralAngle) + perpZ * lateral + (Math.random() - 0.5) * 0.05;
                    // Spin rate: some particles curl tightly, others drift wide
                    _sandSpin[i]  = (Math.random() - 0.5) * 4.0; // radians/sec
                    _sandPhase[i] = Math.random() * Math.PI * 2;
                    _sandMaxLife[i] = 1.8 + Math.random() * 2.5;
                    _sandLife[i]    = _sandMaxLife[i];
                    return;
                }
            }
        }

        function updateSandParticles() {
            const now = _frameTime;
            if (_sandPrevTime < 0) { _sandPrevTime = now; return; }  // skip first frame
            const dt = Math.min(now - _sandPrevTime, 0.05);
            _sandPrevTime = now;
            if (dt <= 0) return;

            _biomeBlend = getEffectiveDesertBlend();

            if (_biomeBlend < 0.01) {
                // hide everything when fully in forest
                _sandMat.opacity = 0;
                for (let i = 0; i < SAND_MAX; i++) {
                    _sandLife[i] = 0;
                    _sandPosAttr.setXYZ(i, 0, -9999, 0);
                }
                _sandPosAttr.needsUpdate = true;
                return;
            }

            // \u2500\u2500 Gust scheduling \u2500\u2500
            _sandGustTimer += dt;
            if (!_sandGustActive && _sandGustTimer >= _sandGustInterval) {
                _sandGustActive   = true;
                _sandGustAge      = 0;
                _sandGustDur      = 3.0 + Math.random() * 4.0;
                const ga          = Math.random() * Math.PI * 2;
                _sandGustWind.set(Math.cos(ga), 0, Math.sin(ga));
                _sandGustTimer    = 0;
                _sandGustInterval = 4 + Math.random() * 10;
                playSandGustSound(0.7 + Math.random() * 0.5);
            }

            // \u2500\u2500 Spawn particles during active gust \u2500\u2500
            if (_sandGustActive) {
                _sandGustAge += dt;

                // envelope: 0.6s attack, sustain, 1.0s release
                let env;
                if      (_sandGustAge < 0.6)                          env = _sandGustAge / 0.6;
                else if (_sandGustAge < _sandGustDur - 1.0)           env = 1.0;
                else                                                   env = Math.max(0, (_sandGustDur - _sandGustAge) / 1.0);

                // Spawn ~120 particles/sec at peak — integer count via accumulator
                const toSpawn = Math.round(env * _biomeBlend * 55 * dt);
                const cx = camera.position.x, cz = camera.position.z;
                for (let s = 0; s < toSpawn; s++) {
                    _spawnSandParticle(cx, cz, _sandGustWind, 0.18 + env * 0.22);
                }

                if (_sandGustAge >= _sandGustDur) _sandGustActive = false;
            }

            // \u2500\u2500 Simulate live particles with turbulent whispy curl \u2500\u2500
            for (let i = 0; i < SAND_MAX; i++) {
                if (_sandLife[i] <= 0) {
                    _sandPosAttr.setXYZ(i, 0, -9999, 0);
                    continue;
                }
                _sandLife[i] -= dt;
                const age = _sandMaxLife[i] - _sandLife[i];

                // Angular turbulence: each particle curls in a sinusoidal swirl
                const curl = Math.sin(age * _sandSpin[i] + _sandPhase[i]) * 0.04;
                _sandVx[i] += curl * _sandGustWind.z;   // perpendicular push
                _sandVz[i] -= curl * _sandGustWind.x;

                _sandVy[i] -= 0.010 * dt;               // gravity
                _sandVx[i] *= 1 - 0.35 * dt;            // drag
                _sandVz[i] *= 1 - 0.35 * dt;
                _sandPx[i] += _sandVx[i];
                _sandPy[i] += _sandVy[i];
                _sandPz[i] += _sandVz[i];
                if (_sandPy[i] < 0.02) { _sandPy[i] = 0.02; _sandVy[i] = Math.abs(_sandVy[i]) * 0.12; }
                _sandPosAttr.setXYZ(i, _sandPx[i], _sandPy[i], _sandPz[i]);
            }
            _sandPosAttr.needsUpdate = true;

            // fade opacity with biome blend — zero in snow biome
            _sandMat.opacity = 0.52 * _biomeBlend;
        }

        // ===== SNOW FLOURISH PARTICLE SYSTEM =====
        // Mirrors the sand gust system but white, lighter, and driven by snow biome blend.
        const SNOW_MAX = 800;
        const _snowFx = new Float32Array(SNOW_MAX), _snowFy = new Float32Array(SNOW_MAX), _snowFz = new Float32Array(SNOW_MAX);
        const _snowFvx = new Float32Array(SNOW_MAX), _snowFvy = new Float32Array(SNOW_MAX), _snowFvz = new Float32Array(SNOW_MAX);
        const _snowFLife = new Float32Array(SNOW_MAX), _snowFMaxLife = new Float32Array(SNOW_MAX);
        const _snowFSpin  = new Float32Array(SNOW_MAX);
        const _snowFPhase = new Float32Array(SNOW_MAX);

        const _snowFGeo     = new THREE.BufferGeometry();
        const _snowFPosAttr = new THREE.BufferAttribute(new Float32Array(SNOW_MAX * 3), 3);
        _snowFGeo.setAttribute('position', _snowFPosAttr);
        for (let i = 0; i < SNOW_MAX; i++) _snowFPosAttr.setXYZ(i, 0, -9999, 0);
        _snowFPosAttr.needsUpdate = true;

        // Shared circular soft-disc texture for all snow particles
        // Generates a radial gradient canvas: fully opaque centre, transparent edges
        const _snowCircleTex = (() => {
            const sz = 64;
            const c  = document.createElement('canvas');
            c.width  = sz; c.height = sz;
            const ctx = c.getContext('2d');
            const r   = sz / 2;
            const grad = ctx.createRadialGradient(r, r, 0, r, r, r);
            grad.addColorStop(0,    'rgba(255,255,255,1)');
            grad.addColorStop(0.45, 'rgba(255,255,255,0.9)');
            grad.addColorStop(1,    'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, sz, sz);
            const tex = new THREE.CanvasTexture(c);
            return tex;
        })();

        const _snowFMat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.35,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.7,
            depthWrite: false,
            map: _snowCircleTex,
            alphaTest: 0.01,
        });
        const _snowFPoints = new THREE.Points(_snowFGeo, _snowFMat);
        _snowFPoints.renderOrder = 2;
        _snowFPoints.frustumCulled = false;

        let _snowFGustTimer    = 0;
        let _snowFGustInterval = 3 + Math.random() * 5;
        let _snowFGustActive   = false;
        let _snowFGustDur      = 0;
        let _snowFGustAge      = 0;
        let _snowFGustWind     = new THREE.Vector3(1, 0, 0);
        let _snowFPrevTime     = -1;

        function _getSnowBiomeBlend() {
            const sbFade = 40, sbHalf = SB_SIZE / 2;
            const rawX = (sbHalf + sbFade / 2 - Math.abs(camera.position.x - SB_CX)) / sbFade;
            const rawZ = (sbHalf + sbFade / 2 - Math.abs(camera.position.z - SB_CZ)) / sbFade;
            return Math.max(0, Math.min(1, Math.min(rawX, rawZ)));
        }

        function _spawnSnowFlourish(cx, cz, wind, speed) {
            for (let i = 0; i < SNOW_MAX; i++) {
                if (_snowFLife[i] <= 0) {
                    const spread = 22;
                    _snowFx[i] = cx + (Math.random() - 0.5) * spread;
                    _snowFy[i] = 0.05 + Math.random() * 2.2;  // slightly higher float
                    _snowFz[i] = cz + (Math.random() - 0.5) * spread;
                    const s = speed * (0.4 + Math.random() * 0.8);
                    const lateralAngle = (Math.random() - 0.5) * 2.0;
                    const perpX =  wind.z, perpZ = -wind.x;
                    const lateral = Math.sin(lateralAngle) * s * 0.8;
                    _snowFvx[i] = wind.x * s * Math.cos(lateralAngle) + perpX * lateral + (Math.random() - 0.5) * 0.04;
                    _snowFvy[i] = 0.003 + Math.random() * 0.015;  // lighter — floats up more gently
                    _snowFvz[i] = wind.z * s * Math.cos(lateralAngle) + perpZ * lateral + (Math.random() - 0.5) * 0.04;
                    _snowFSpin[i]  = (Math.random() - 0.5) * 3.0;
                    _snowFPhase[i] = Math.random() * Math.PI * 2;
                    _snowFMaxLife[i] = 2.5 + Math.random() * 3.0;  // lingers longer
                    _snowFLife[i]    = _snowFMaxLife[i];
                    return;
                }
            }
        }

        function updateSnowFlourish() {
            const now = _frameTime;
            if (_snowFPrevTime < 0) { _snowFPrevTime = now; return; }
            const dt = Math.min(now - _snowFPrevTime, 0.05);
            _snowFPrevTime = now;
            if (dt <= 0) return;

            const snowBlend = _getSnowBiomeBlend();

            if (snowBlend < 0.01) {
                _snowFMat.opacity = 0;
                for (let i = 0; i < SNOW_MAX; i++) {
                    _snowFLife[i] = 0;
                    _snowFPosAttr.setXYZ(i, 0, -9999, 0);
                }
                _snowFPosAttr.needsUpdate = true;
                return;
            }

            // Gust scheduling
            _snowFGustTimer += dt;
            if (!_snowFGustActive && _snowFGustTimer >= _snowFGustInterval) {
                _snowFGustActive   = true;
                _snowFGustAge      = 0;
                _snowFGustDur      = 3.5 + Math.random() * 4.5;
                const ga           = Math.random() * Math.PI * 2;
                _snowFGustWind.set(Math.cos(ga), 0, Math.sin(ga));
                _snowFGustTimer    = 0;
                _snowFGustInterval = 3 + Math.random() * 8;
            }

            // Spawn particles during active gust
            if (_snowFGustActive) {
                _snowFGustAge += dt;
                let env;
                if      (_snowFGustAge < 0.8)                             env = _snowFGustAge / 0.8;
                else if (_snowFGustAge < _snowFGustDur - 1.2)             env = 1.0;
                else                                                       env = Math.max(0, (_snowFGustDur - _snowFGustAge) / 1.2);

                const toSpawn = Math.round(env * snowBlend * 50 * dt);
                const cx = camera.position.x, cz = camera.position.z;
                for (let s = 0; s < toSpawn; s++) {
                    _spawnSnowFlourish(cx, cz, _snowFGustWind, 0.14 + env * 0.18);
                }
                if (_snowFGustAge >= _snowFGustDur) _snowFGustActive = false;
            }

            // Simulate — snow is lighter so gravity is weaker and drag higher
            for (let i = 0; i < SNOW_MAX; i++) {
                if (_snowFLife[i] <= 0) {
                    _snowFPosAttr.setXYZ(i, 0, -9999, 0);
                    continue;
                }
                _snowFLife[i] -= dt;
                const age = _snowFMaxLife[i] - _snowFLife[i];

                const curl = Math.sin(age * _snowFSpin[i] + _snowFPhase[i]) * 0.035;
                _snowFvx[i] += curl * _snowFGustWind.z;
                _snowFvz[i] -= curl * _snowFGustWind.x;

                _snowFvy[i] -= 0.005 * dt;              // weaker gravity — flakes drift
                _snowFvx[i] *= 1 - 0.40 * dt;           // higher drag — floaty feel
                _snowFvz[i] *= 1 - 0.40 * dt;
                _snowFx[i] += _snowFvx[i];
                _snowFy[i] += _snowFvy[i];
                _snowFz[i] += _snowFvz[i];
                if (_snowFy[i] < 0.02) { _snowFy[i] = 0.02; _snowFvy[i] = Math.abs(_snowFvy[i]) * 0.08; }
                _snowFPosAttr.setXYZ(i, _snowFx[i], _snowFy[i], _snowFz[i]);
            }
            _snowFPosAttr.needsUpdate = true;

            _snowFMat.opacity = 0.65 * snowBlend;
        }

        // ===== LOCAL SNOW LAYER — player-centred, motion-reactive =====
        // Dense close-range particles that fall straight when still,
        // then blow opposite to travel direction when moving.
        const LSNOW_MAX = 350;
        const _lsnowPx = new Float32Array(LSNOW_MAX);
        const _lsnowPy = new Float32Array(LSNOW_MAX);
        const _lsnowPz = new Float32Array(LSNOW_MAX);
        const _lsnowVx = new Float32Array(LSNOW_MAX);
        const _lsnowVy = new Float32Array(LSNOW_MAX);
        const _lsnowVz = new Float32Array(LSNOW_MAX);
        const _lsnowLife    = new Float32Array(LSNOW_MAX);
        const _lsnowMaxLife = new Float32Array(LSNOW_MAX);

        const _lsnowGeo     = new THREE.BufferGeometry();
        const _lsnowPosAttr = new THREE.BufferAttribute(new Float32Array(LSNOW_MAX * 3), 3);
        _lsnowGeo.setAttribute('position', _lsnowPosAttr);
        for (let i = 0; i < LSNOW_MAX; i++) _lsnowPosAttr.setXYZ(i, 0, -9999, 0);
        _lsnowPosAttr.needsUpdate = true;

        const _lsnowMat = new THREE.PointsMaterial({
            color: 0xeef4ff,          // very slightly blue-white
            size: 0.22,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.0,
            depthWrite: false,
            map: _snowCircleTex,
            alphaTest: 0.01,
        });
        const _lsnowPoints = new THREE.Points(_lsnowGeo, _lsnowMat);
        _lsnowPoints.renderOrder = 3;
        _lsnowPoints.frustumCulled = false;

        let _lsnowPrevTime = -1;
        // Smoothed wind vector — lerps toward target each frame for gradual onset
        const _lsnowWindSmooth = new THREE.Vector3(0, 0, 0);

        function _spawnLocalSnow(cx, cy, cz, windX, windZ) {
            for (let i = 0; i < LSNOW_MAX; i++) {
                if (_lsnowLife[i] <= 0) {
                    const r = 5 + Math.random() * 9;   // 5–14 unit radius around player
                    const angle = Math.random() * Math.PI * 2;
                    _lsnowPx[i] = cx + Math.cos(angle) * r;
                    _lsnowPy[i] = cy + 0.5 + Math.random() * 7; // up to 7 units above eye
                    _lsnowPz[i] = cz + Math.sin(angle) * r;
                    // Base fall + player-wind offset
                    _lsnowVx[i] = windX * (1.2 + Math.random() * 1.0) + (Math.random() - 0.5) * 0.015;
                    _lsnowVy[i] = -(0.03 + Math.random() * 0.025);  // fall speed
                    _lsnowVz[i] = windZ * (1.2 + Math.random() * 1.0) + (Math.random() - 0.5) * 0.015;
                    _lsnowMaxLife[i] = 1.5 + Math.random() * 2.0;
                    _lsnowLife[i]    = _lsnowMaxLife[i];
                    return;
                }
            }
        }

        function updateLocalSnow() {
            const now = _frameTime;
            if (_lsnowPrevTime < 0) { _lsnowPrevTime = now; return; }
            const dt = Math.min(now - _lsnowPrevTime, 0.05);
            _lsnowPrevTime = now;
            if (dt <= 0) return;

            // Only active inside snow biome
            const snowBlend = _getSnowBiomeBlend();
            if (snowBlend < 0.1) {
                _lsnowMat.opacity = 0;
                for (let i = 0; i < LSNOW_MAX; i++) {
                    _lsnowLife[i] = 0;
                    _lsnowPosAttr.setXYZ(i, 0, -9999, 0);
                }
                _lsnowPosAttr.needsUpdate = true;
                return;
            }

            const cx = camera.position.x;
            const cy = camera.position.y;
            const cz = camera.position.z;

            // Target wind: opposite to player movement when moving, zero when still
            let targetWX = 0, targetWZ = 0;
            if (_playerIsMoving && _playerVelDir.lengthSq() > 0) {
                const strength = 0.18; // how hard particles blow back
                targetWX = -_playerVelDir.x * strength;
                targetWZ = -_playerVelDir.z * strength;
            }

            // Smooth wind onset/offset so it feels gradual, not snappy
            const lerpRate = _playerIsMoving ? 0.18 : 0.04;
            _lsnowWindSmooth.x += (targetWX - _lsnowWindSmooth.x) * lerpRate;
            _lsnowWindSmooth.z += (targetWZ - _lsnowWindSmooth.z) * lerpRate;

            // Spawn ~60 particles/sec continuously (no gust — always present)
            const toSpawn = Math.round(60 * dt);
            for (let s = 0; s < toSpawn; s++) {
                _spawnLocalSnow(cx, cy, cz, _lsnowWindSmooth.x, _lsnowWindSmooth.z);
            }

            // Simulate
            for (let i = 0; i < LSNOW_MAX; i++) {
                if (_lsnowLife[i] <= 0) {
                    _lsnowPosAttr.setXYZ(i, 0, -9999, 0);
                    continue;
                }
                _lsnowLife[i] -= dt;

                // Apply wind each frame (allows mid-flight direction change)
                _lsnowVx[i] += (_lsnowWindSmooth.x - _lsnowVx[i]) * 0.05;
                _lsnowVz[i] += (_lsnowWindSmooth.z - _lsnowVz[i]) * 0.05;

                _lsnowPx[i] += _lsnowVx[i];
                _lsnowPy[i] += _lsnowVy[i];
                _lsnowPz[i] += _lsnowVz[i];

                // Fade out as particle ages
                const lifeFrac = _lsnowLife[i] / _lsnowMaxLife[i];
                // Kill if too far below player or drifted too far away
                const dx = _lsnowPx[i] - cx, dz = _lsnowPz[i] - cz;
                if (_lsnowPy[i] < cy - 2.5 || dx*dx + dz*dz > 20*20) {
                    _lsnowLife[i] = 0;
                }
                _lsnowPosAttr.setXYZ(i, _lsnowPx[i], _lsnowPy[i], _lsnowPz[i]);
            }
            _lsnowPosAttr.needsUpdate = true;

            // Fade opacity in with snow blend, gentle pulse for atmosphere
            _lsnowMat.opacity = snowBlend * (0.55 + Math.sin(_frameTime * 0.7) * 0.05);
        }
        let _woodChopAudioBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/wood chop.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _woodChopAudioBuffer = buf; console.log('Wood chop sound loaded OK'); })
            .catch(e => { console.error('Wood chop sound fetch error:', e); });

        function playTreeChopSound() {
            if (!_woodChopAudioBuffer) { console.log('Wood chop buffer not ready yet'); return; }
            const src = audioContext.createBufferSource();
            src.buffer = _woodChopAudioBuffer;
            const gain = audioContext.createGain();
            gain.gain.value = volumeSettings.sfx !== undefined ? volumeSettings.sfx : 1.0;
            src.connect(gain);
            gain.connect(audioContext.destination);
            src.start();
        }
        
        // Tree fall sound
        let _treeFallAudioBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/treefall.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _treeFallAudioBuffer = buf; console.log('Tree fall sound loaded OK'); })
            .catch(e => { console.error('Tree fall sound fetch error:', e); });

        function playTreeFallSound() {
            if (!_treeFallAudioBuffer) { console.log('Tree fall buffer not ready yet'); return; }
            const src = audioContext.createBufferSource();
            src.buffer = _treeFallAudioBuffer;
            const gain = audioContext.createGain();
            gain.gain.value = volumeSettings.sfx !== undefined ? volumeSettings.sfx : 1.0;
            src.connect(gain);
            gain.connect(audioContext.destination);
            src.start(0, 0.6); // skip first 0.6 seconds
        }

        // Inventory move sound
        let _inventoryMoveAudioBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/inventorymove.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _inventoryMoveAudioBuffer = buf; console.log('Inventory move sound loaded OK'); })
            .catch(e => { console.error('Inventory move sound fetch error:', e); });

        function playInventoryMoveSound() {
            if (!_inventoryMoveAudioBuffer) return;
            const src = audioContext.createBufferSource();
            src.buffer = _inventoryMoveAudioBuffer;
            const gain = audioContext.createGain();
            gain.gain.value = volumeSettings.sfx !== undefined ? volumeSettings.sfx : 1.0;
            src.connect(gain);
            gain.connect(audioContext.destination);
            src.start();
        }

        // Bench/workbench interaction sound
        let _benchAudioBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/bench.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _benchAudioBuffer = buf; console.log('Bench sound loaded OK'); })
            .catch(e => { console.error('Bench sound fetch error:', e); });

        function playBenchSound() {
            if (!_benchAudioBuffer) return;
            const src = audioContext.createBufferSource();
            src.buffer = _benchAudioBuffer;
            const gain = audioContext.createGain();
            gain.gain.value = volumeSettings.sfx !== undefined ? volumeSettings.sfx : 1.0;
            src.connect(gain);
            gain.connect(audioContext.destination);
            src.start();
        }

        // Furnace/fire interaction sound
        let _furnaceInteractAudioBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/furnaceinteract.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _furnaceInteractAudioBuffer = buf; console.log('Furnace interact sound loaded OK'); })
            .catch(e => { console.error('Furnace interact sound fetch error:', e); });

        // Junk pile loot sound
        let _lootAudioBuffer = null;
        fetch('https://jam110uk.github.io/Crust-Sounds/Loot.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _lootAudioBuffer = buf; console.log('Loot sound loaded OK'); })
            .catch(e => { console.error('Loot sound fetch error:', e); });

        function playLootSound() {
            if (!_lootAudioBuffer) return;
            const src = audioContext.createBufferSource();
            src.buffer = _lootAudioBuffer;
            const gain = audioContext.createGain();
            gain.gain.value = volumeSettings.sfx !== undefined ? volumeSettings.sfx : 1.0;
            src.connect(gain);
            gain.connect(audioContext.destination);
            src.start();
        }

        function playFurnaceInteractSound() {
            if (!_furnaceInteractAudioBuffer) return;
            const src = audioContext.createBufferSource();
            src.buffer = _furnaceInteractAudioBuffer;
            const gain = audioContext.createGain();
            gain.gain.value = volumeSettings.sfx !== undefined ? volumeSettings.sfx : 1.0;
            src.connect(gain);
            gain.connect(audioContext.destination);
            src.start();
        }
        
        // Stone/ore mining sound
        let _stoneMineAudioBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/stonemine.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _stoneMineAudioBuffer = buf; console.log('Stone mine sound loaded OK'); })
            .catch(e => { console.error('Stone mine sound fetch error:', e); });

        function playStoneMineSound() {
            if (!_stoneMineAudioBuffer) { console.log('Stone mine buffer not ready yet'); return; }
            const src = audioContext.createBufferSource();
            src.buffer = _stoneMineAudioBuffer;
            const gain = audioContext.createGain();
            gain.gain.value = volumeSettings.sfx !== undefined ? volumeSettings.sfx : 1.0;
            src.connect(gain);
            gain.connect(audioContext.destination);
            src.start();
        }

        function playRockMineSound() { playStoneMineSound(); }
        
        function playOreMineSound() { playStoneMineSound(); }
        
        function playBerryPickSound() { /* replaced by plant MP3 */ }
        
        // Door opening sound
        let _doorOpenAudioBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/opendoor.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _doorOpenAudioBuffer = buf; console.log('Door open sound loaded OK'); })
            .catch(e => { console.error('Door open sound fetch error:', e); });

        function playDoorOpenSound() {
            if (!_doorOpenAudioBuffer) { console.log('Door open buffer not ready yet'); return; }
            const src = audioContext.createBufferSource();
            src.buffer = _doorOpenAudioBuffer;
            const gain = audioContext.createGain();
            gain.gain.value = volumeSettings.sfx !== undefined ? volumeSettings.sfx : 1.0;
            src.connect(gain);
            gain.connect(audioContext.destination);
            src.start();
        }
        
        // Door closing sound
        let _doorCloseAudioBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/DoorClose.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _doorCloseAudioBuffer = buf; console.log('Door close sound loaded OK'); })
            .catch(e => { console.error('Door close sound fetch error:', e); });

        function playDoorCloseSound() {
            if (!_doorCloseAudioBuffer) { console.log('Door close buffer not ready yet'); return; }
            const src = audioContext.createBufferSource();
            src.buffer = _doorCloseAudioBuffer;
            const gain = audioContext.createGain();
            gain.gain.value = volumeSettings.sfx !== undefined ? volumeSettings.sfx : 1.0;
            src.connect(gain);
            gain.connect(audioContext.destination);
            src.start();
        }
        
        // Code lock beep sound
        function playCodeLockBeep() {
            const now = audioContext.currentTime;
            
            const beep = audioContext.createOscillator();
            const beepGain = audioContext.createGain();
            beep.connect(beepGain);
            beepGain.connect(audioContext.destination);
            beep.type = 'square';
            beep.frequency.setValueAtTime(800, now);
            beepGain.gain.setValueAtTime(0.105, now);
            beepGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            beep.start(now);
            beep.stop(now + 0.12);
        }
        
        // Open code lock UI to set code
        function openCodeLockSetUI(door) {
            uiOpen();
            currentCodeLockDoor = door;
            codeLockMode = 'set';
            currentCode = '';
            
            document.getElementById('code-lock-menu').style.display = 'block';
            document.getElementById('code-lock-title').textContent = '\ud83d\udd12 Set Door Code';
            document.getElementById('code-display').textContent = '----';
            document.getElementById('code-lock-light').style.background = '#2ecc71';
            document.getElementById('code-lock-light').style.boxShadow = '0 0 30px rgba(46, 204, 113, 0.8)';
        }
        
        // Open code lock UI to enter code
        function openCodeLockEnterUI(door) {
            uiOpen();
            currentCodeLockDoor = door;
            codeLockMode = 'enter';
            currentCode = '';
            
            document.getElementById('code-lock-menu').style.display = 'block';
            document.getElementById('code-lock-title').textContent = '\ud83d\udd12 Enter Door Code';
            document.getElementById('code-display').textContent = '----';
            document.getElementById('code-lock-light').style.background = '#e74c3c';
            document.getElementById('code-lock-light').style.boxShadow = '0 0 30px rgba(231, 76, 60, 0.8)';
            
            // pointer lock handled by uiOpen()
        }
        
        // Close code lock UI
        function closeCodeLockUI() {
            currentCodeLockDoor = null;
            codeLockMode = null;
            currentCode = '';
            closeAllUI();
        }
        
        // Handle code entry
        function handleCodeEntry(digit) {
            if (currentCode.length < 4) {
                currentCode += digit;
                playCodeLockBeep();
                updateCodeDisplay();
            }
        }
        
        // Update code display
        function updateCodeDisplay() {
            let display = '';
            for (let i = 0; i < 4; i++) {
                display += i < currentCode.length ? currentCode[i] : '-';
            }
            document.getElementById('code-display').textContent = display;
        }
        
        // Clear code
        function clearCode() {
            currentCode = '';
            updateCodeDisplay();
        }
        
        // Submit code
        function submitCode() {
            if (currentCode.length !== 4) {
                showMessage('\u26a0\ufe0f Code must be 4 digits!');
                return;
            }
            
            if (codeLockMode === 'set') {
                // Set the code on the door
                currentCodeLockDoor.userData.codeLock = currentCode;
                currentCodeLockDoor.userData.hasCodeLock = true;
                
                // Create and attach visual code lock model to the door
                createCodeLockModel(currentCodeLockDoor);
                
                // Turn light red (locked)
                document.getElementById('code-lock-light').style.background = '#e74c3c';
                document.getElementById('code-lock-light').style.boxShadow = '0 0 30px rgba(231, 76, 60, 0.8)';
                
                playCodeLockBeep();
                showMessage('\ud83d\udd12 Code set! Door is now locked.');
                
                setTimeout(() => {
                    closeCodeLockUI();
                }, 1000);
            } else if (codeLockMode === 'enter') {
                // Check if code is correct
                if (currentCode === currentCodeLockDoor.userData.codeLock) {
                    // Correct code! Open the door
                    playCodeLockBeep();
                    
                    // Turn light green
                    document.getElementById('code-lock-light').style.background = '#2ecc71';
                    document.getElementById('code-lock-light').style.boxShadow = '0 0 30px rgba(46, 204, 113, 0.8)';
                    
                    showMessage('\u2705 Code correct! Door unlocked.');
                    
                    // Update code lock light on door to green
                    if (currentCodeLockDoor.userData.codeLockModel) {
                        currentCodeLockDoor.userData.codeLockModel.children.forEach(child => {
                            if (child.userData.isStatusLight) {
                                child.material.color.setHex(0x2ecc71);
                                child.material.emissive.setHex(0x2ecc71);
                            }
                        });
                    }
                    
                    // Open the door
                    currentCodeLockDoor.userData.isOpen = true;
                    
                    if (currentCodeLockDoor.userData.doorType === 'single') {
                        currentCodeLockDoor.userData.doorGroup.rotation.y = -Math.PI / 2;
                    } else if (currentCodeLockDoor.userData.doorType === 'double') {
                        currentCodeLockDoor.userData.leftDoorGroup.rotation.y = -Math.PI / 2;
                        currentCodeLockDoor.userData.rightDoorGroup.rotation.y = -Math.PI / 2;
                    } else {
                        const initialRotation = currentCodeLockDoor.userData.initialRotation || 0;
                        currentCodeLockDoor.rotation.y = initialRotation + Math.PI / 2;
                    }
                    
                    playDoorOpenSound();
                    
                    setTimeout(() => {
                        closeCodeLockUI();
                        
                        // Reset light back to red after 2 seconds
                        setTimeout(() => {
                            if (currentCodeLockDoor.userData.codeLockModel) {
                                currentCodeLockDoor.userData.codeLockModel.children.forEach(child => {
                                    if (child.userData.isStatusLight) {
                                        child.material.color.setHex(0xe74c3c);
                                        child.material.emissive.setHex(0xe74c3c);
                                    }
                                });
                            }
                        }, 2000);
                    }, 1000);
                } else {
                    // Wrong code! Deal damage
                    showMessage('\u274c Wrong code! Taking damage!');
                    
                    // Start damage over time
                    let damageCount = 0;
                    wrongCodeDamageTimer = setInterval(() => {
                        applyDamage(20);
                        damageCount++;
                        
                        if (damageCount >= 2 || health <= 0) {
                            clearInterval(wrongCodeDamageTimer);
                            wrongCodeDamageTimer = null;
                            
                            if (health <= 0) {
                                die();
                            }
                            
                            clearCode();
                            closeCodeLockUI();
                        }
                    }, 1000);
                }
            }
        }
        
        // Create code lock 3D model and attach to door frame
        // Code lock model removed - keeping UI-based system only
        function createCodeLockModel(door) {
            // Physical model disabled - code lock is now UI-only
            // All functionality remains through the code lock UI interface
        }
        
        // ===== ARMOR SYSTEM =====
        // Mapping of armor items to body slots
        const armorSlotMapping = {
            'cloth_helmet': 'head',
            'cloth_vest': 'chest',
            'cloth_gloves': 'hands',
            'cloth_pants': 'legs',
            'cloth_boots': 'feet',
            'iron_helmet': 'head',
            'iron_vest': 'chest',
            'iron_gloves': 'hands',
            'iron_pants': 'legs',
            'iron_boots': 'feet',
            'bronze_helmet': 'head',
            'bronze_vest': 'chest',
            'bronze_gloves': 'hands',
            'bronze_pants': 'legs',
            'bronze_boots': 'feet',
            // Thermal clothing — insulation-focused, sewing table only
            'thermal_hood': 'head',
            'thermal_jacket': 'chest',
            'thermal_gloves': 'hands',
            'thermal_pants': 'legs',
            'thermal_boots': 'feet',
            // Backpacks — back slot only
            'small_backpack': 'back',
            'large_backpack': 'back'
        };
        
        // Armor damage reduction values
        const armorReduction = {
            'cloth_helmet': 0.01,
            'cloth_vest': 0.01,
            'cloth_gloves': 0.01,
            'cloth_pants': 0.01,
            'cloth_boots': 0.01,
            'iron_helmet': 0.05,
            'iron_vest': 0.05,
            'iron_gloves': 0.05,
            'iron_pants': 0.05,
            'iron_boots': 0.05,
            'bronze_helmet': 0.02,
            'bronze_vest': 0.02,
            'bronze_gloves': 0.02,
            'bronze_pants': 0.02,
            'bronze_boots': 0.02,
            // Thermal set — low armour, high insulation
            'thermal_hood': 0.01,
            'thermal_jacket': 0.02,
            'thermal_gloves': 0.01,
            'thermal_pants': 0.01,
            'thermal_boots': 0.01
        };

        // Insulation values per clothing piece — reduces how fast temp changes affect the player
        // Cloth is best insulator (soft fabric), iron worst (conducts heat/cold), bronze middle
        const insulationValues = {
            'cloth_helmet':  0.06,
            'cloth_vest':    0.10,
            'cloth_gloves':  0.04,
            'cloth_pants':   0.08,
            'cloth_boots':   0.06,
            'bronze_helmet': 0.04,
            'bronze_vest':   0.07,
            'bronze_gloves': 0.03,
            'bronze_pants':  0.05,
            'bronze_boots':  0.04,
            'iron_helmet':   0.02,
            'iron_vest':     0.04,
            'iron_gloves':   0.02,
            'iron_pants':    0.03,
            'iron_boots':    0.02,
            // Thermal set — purpose-built for insulation
            'thermal_hood':    0.14,
            'thermal_jacket':  0.22,
            'thermal_gloves':  0.10,
            'thermal_pants':   0.18,
            'thermal_boots':   0.12
        };

        // Returns total insulation 0.0–1.0 (capped at 85%)
        function calculateInsulation() {
            let total = 0;
            Object.values(armorSlots).forEach(piece => {
                if (piece && insulationValues[piece]) total += insulationValues[piece];
            });
            return Math.min(total, 0.85);
        }
        
        // Calculate total damage reduction from equipped armor
        function calculateDamageReduction() {
            let reduction = 0;
            Object.values(armorSlots).forEach(armorPiece => {
                if (armorPiece && armorReduction[armorPiece]) {
                    reduction += armorReduction[armorPiece];
                }
            });
            return Math.min(reduction, 1.0); // Cap at 100% (though max is 25% with 5 pieces)
        }
        
        // Apply damage with armor reduction
        function applyDamage(damage) {
            const reduction = calculateDamageReduction();
            const actualDamage = damage * (1 - reduction);
            health -= actualDamage;
            if (health < 0) health = 0;
            updateUI();
            return actualDamage;
        }
        
        // Equip armor piece
        function equipArmor(itemName) {
            const slot = armorSlotMapping[itemName];
            if (!slot) return false;

            // Back slot only accepts backpacks
            if (slot === 'back' && itemName !== 'small_backpack' && itemName !== 'large_backpack') {
                showMessage('❌ Only backpacks can go in the back slot!');
                return false;
            }
            
            // If slot already has armor, unequip it first
            if (armorSlots[slot]) {
                unequipArmor(slot);
            }
            
            // Remove from inventory and equip
            if (inventory[itemName] > 0) {
                inventory[itemName]--;
                armorSlots[slot] = itemName;
                if (slot === 'back') syncBackpackSlots();
                updateUI();
                updateInventoryDisplay();
                updateArmorDisplay();
                showMessage(`✅ Equipped ${getItemDisplayName(itemName)}`);
                return true;
            }
            return false;
        }
        
        // Unequip armor piece from slot
        function unequipArmor(slot) {
            const itemName = armorSlots[slot];
            if (itemName) {
                // Block backpack removal if it still has items
                if (slot === 'back' && !isBackpackEmpty()) {
                    showMessage('❌ Empty your backpack before removing it!');
                    return false;
                }
                inventory[itemName] = (inventory[itemName] || 0) + 1;
                armorSlots[slot] = null;
                if (slot === 'back') syncBackpackSlots();
                updateUI();
                updateInventoryDisplay();
                updateArmorDisplay();
                showMessage(`🔄 Unequipped ${getItemDisplayName(itemName)}`);
                return true;
            }
            return false;
        }
        
        // Update armor display in clothing panel
        function updateArmorDisplay() {
            Object.keys(armorSlots).forEach(slot => {
                const slotElement = document.querySelector(`[data-slot="${slot}"]`);
                if (slotElement) {
                    const itemName = armorSlots[slot];
                    const iconElement = slotElement.querySelector('.armor-slot-icon');
                    
                    if (itemName) {
                        slotElement.classList.add('equipped');
                        const icon = itemIcons[itemName] || '\u2753';
                        iconElement.style.filter = '';
                        iconElement.innerHTML = icon;
                    } else {
                        slotElement.classList.remove('equipped');
                        iconElement.style.filter = '';
                        const defaultIcons = {
                            'head':  `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e1e2e"/><path d="M6,20 Q6,6 16,5 Q26,6 26,20 Z" fill="#9988aa"/><rect x="5" y="19" width="22" height="4" rx="1" fill="#9988aa"/><rect x="5" y="21" width="5" height="6" rx="1" fill="#9988aa"/><rect x="22" y="21" width="5" height="6" rx="1" fill="#9988aa"/><rect x="9" y="13" width="14" height="5" rx="2" fill="#1e1e2e"/></svg>`,
                            'chest': `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e1e2e"/><rect x="3" y="6" width="8" height="8" rx="2" fill="#9988aa"/><rect x="21" y="6" width="8" height="8" rx="2" fill="#9988aa"/><rect x="5" y="8" width="22" height="20" rx="2" fill="#9988aa"/><path d="M12,8 L16,12 L20,8 Z" fill="#1e1e2e"/></svg>`,
                            'hands': `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e1e2e"/><rect x="5" y="4" width="2" height="8" rx="1" fill="#9988aa"/><rect x="8" y="3" width="2" height="9" rx="1" fill="#9988aa"/><rect x="11" y="4" width="2" height="8" rx="1" fill="#9988aa"/><rect x="4" y="10" width="10" height="16" rx="2" fill="#9988aa"/><rect x="19" y="4" width="2" height="8" rx="1" fill="#9988aa"/><rect x="22" y="3" width="2" height="9" rx="1" fill="#9988aa"/><rect x="25" y="4" width="2" height="8" rx="1" fill="#9988aa"/><rect x="18" y="10" width="10" height="16" rx="2" fill="#9988aa"/></svg>`,
                            'legs':  `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e1e2e"/><rect x="5" y="4" width="22" height="6" rx="2" fill="#9988aa"/><rect x="5" y="10" width="10" height="18" rx="2" fill="#9988aa"/><rect x="17" y="10" width="10" height="18" rx="2" fill="#9988aa"/></svg>`,
                            'feet':  `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e1e2e"/><rect x="4" y="4" width="10" height="16" rx="2" fill="#9988aa"/><rect x="3" y="18" width="12" height="10" rx="2" fill="#9988aa"/><rect x="18" y="4" width="10" height="16" rx="2" fill="#9988aa"/><rect x="17" y="18" width="12" height="10" rx="2" fill="#9988aa"/></svg>`,
                            'back':  `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e1e2e"/><rect x="11" y="3" width="10" height="5" rx="2.5" fill="#9988aa"/><rect x="8" y="6" width="16" height="20" rx="3" fill="#9988aa"/><rect x="11" y="6" width="10" height="3" rx="1" fill="#1e1e2e"/><rect x="10" y="14" width="12" height="8" rx="2" fill="#1e1e2e" opacity="0.4"/><rect x="13" y="17" width="6" height="1.5" rx="0.75" fill="#9988aa"/><rect x="8" y="9" width="2.5" height="14" rx="1.25" fill="#7a6a8a"/><rect x="21.5" y="9" width="2.5" height="14" rx="1.25" fill="#7a6a8a"/></svg>`,
                        };
                        iconElement.innerHTML = defaultIcons[slot] || '';
                    }
                }
            });
            
            // Update damage reduction display
            const reduction = calculateDamageReduction();
            const reductionPercent = Math.round(reduction * 100);
            const reductionDisplay = document.getElementById('damage-reduction-value');
            if (reductionDisplay) {
                reductionDisplay.textContent = `${reductionPercent}%`;
                // Change color based on amount
                if (reductionPercent >= 20) {
                    reductionDisplay.style.color = '#2ecc71'; // Green for good protection
                } else if (reductionPercent >= 10) {
                    reductionDisplay.style.color = '#f39c12'; // Orange for medium
                } else if (reductionPercent > 0) {
                    reductionDisplay.style.color = '#e67e22'; // Light orange for low
                } else {
                    reductionDisplay.style.color = '#95a5a6'; // Gray for none
                }
            }

            // Update insulation display
            const insulation = calculateInsulation();
            const insulationPercent = Math.round(insulation * 100);
            const insulationDisplay = document.getElementById('insulation-value');
            if (insulationDisplay) {
                insulationDisplay.textContent = `${insulationPercent}%`;
                if (insulationPercent >= 50) {
                    insulationDisplay.style.color = '#3498db'; // Blue — well insulated
                } else if (insulationPercent >= 25) {
                    insulationDisplay.style.color = '#5dade2'; // Light blue — moderate
                } else if (insulationPercent > 0) {
                    insulationDisplay.style.color = '#85c1e9'; // Pale blue — low
                } else {
                    insulationDisplay.style.color = '#95a5a6'; // Gray — none
                }
            }
        }
        
        // Preload thunder sound
        let _thunderBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/Thunder.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _thunderBuffer = buf; console.log('Thunder sound loaded OK'); })
            .catch(e => { console.error('Thunder sound fetch error:', e); });

        function playThunderSound() {
            if (!_thunderBuffer) return;
            let volumeMultiplier = 0.6 + Math.random() * 0.4;
            const underRoof = isPlayerUnderRoof();
            if (underRoof) volumeMultiplier *= 0.2;
            const source = audioContext.createBufferSource();
            source.buffer = _thunderBuffer;
            source.playbackRate.value = 0.5 + Math.random() * 1.0; // pitch variation 0.5x to 1.5x
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(volumeMultiplier, audioContext.currentTime);
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);
            source.start();
        }
        
        // ===== CORE SETUP =====
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x87CEEB, 0.008);
        scene.add(_sandPoints); // deferred from sand particle setup above
        scene.add(_snowFPoints); // deferred from snow flourish particle setup above
        scene.add(_lsnowPoints); // deferred from local snow layer setup above
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.set(0, 1.7, 5);
        camera.rotation.order = 'YXZ';

        const heldItemGroup = new THREE.Group();
        heldItemGroup.position.set(0.28, -0.22, -0.42);
        heldItemGroup.scale.setScalar(1.0); // Slight scale up for better visibility
        camera.add(heldItemGroup);

        // ── FPS Arm viewmodel ────────────────────────────────────────────────────
        // Pattern from example: camera → fpsArmHolder (screen position) → fpsArmGroup (model)
        // fpsArmHolder anchors the viewmodel to a fixed point on screen.
        // fpsArmGroup is where the GLB model (or procedural fallback) lives.
        const fpsArmHolder = new THREE.Object3D();
        fpsArmHolder.position.set(0.45, -0.28, -0.5); // bottom-right FPS position
        camera.add(fpsArmHolder);

        const fpsArmGroup = new THREE.Object3D();
        fpsArmHolder.add(fpsArmGroup);

        // Arms disabled
        fpsArmHolder.visible = false;

        let _fpsArmMixer  = null;
        let _fpsArmClock  = new THREE.Clock();
        let _fpsArmLoaded = false;
        let _fpsArmAnims  = {}; // animName → AnimationAction

        // Make every mesh in the viewmodel render on top, no shadow
        function _fpsMakeViewmodel(obj) {
            obj.traverse(c => {
                c.frustumCulled = false;
                if (c.isMesh) {
                    c.castShadow    = false;
                    c.receiveShadow = false;
                    c.renderOrder   = 999;
                    const mats = Array.isArray(c.material) ? c.material : [c.material];
                    mats.forEach(m => { if (m) { m.depthTest = true; m.depthWrite = true; m.needsUpdate = true; } });
                }
            });
        }

        // Play a named arm animation (idle / swing / etc.)
        function playFpsArmAnim(name) {
            if (!_fpsArmMixer) return;
            let action = _fpsArmAnims[name];
            if (!action) {
                const key = Object.keys(_fpsArmAnims).find(k => k.toLowerCase().includes(name.toLowerCase()));
                if (key) action = _fpsArmAnims[key];
            }
            if (!action) return;
            Object.values(_fpsArmAnims).forEach(a => a.fadeOut(0.12));
            action.reset().fadeIn(0.12).play();
        }

        async function _loadFpsArm() {
            await _loadAssetGLB('Rigged Fps Arms.glb');
            const tmpl = _assetGLBCache['Rigged Fps Arms.glb'];

            if (!tmpl) {
                console.warn('💪 Rigged Fps Arms.glb not found — using procedural fallback');
                _buildProceduralArm(fpsArmGroup);
                _fpsArmLoaded = true;
                return;
            }

            // Use SkeletonUtils.clone for rigged/skinned models — regular .clone(true) shares
            // skeleton bones between instances, causing both arms to move as one broken mesh.
            const cloneFn = (THREE.SkeletonUtils && THREE.SkeletonUtils.clone)
                ? THREE.SkeletonUtils.clone
                : (obj) => obj.clone(true);
            const armScene = cloneFn(tmpl);
            _glbFixTextures(armScene);

            // Count only SkinnedMesh + Mesh
            let meshCount = 0;
            armScene.traverse(c => { if (c.isMesh || c.isSkinnedMesh) meshCount++; });

            if (meshCount === 0) {
                console.warn('💪 GLB had no meshes — using procedural fallback');
                _buildProceduralArm(fpsArmGroup);
                _fpsArmLoaded = true;
                return;
            }

            console.log('💪 Arm GLB cloned — meshes:', meshCount);

            // Scale down to viewmodel size. The arms GLB is typically exported at real-world
            // scale (~2m tall). At camera Z=-0.45 we want the forearm to fill ~30% of screen.
            // Start at 0.022 — tweak up/down if it looks wrong.
            armScene.scale.set(0.04, 0.04, 0.04);
            armScene.position.set(0, 0, 0);
            // Arm GLB is exported horizontal (along X axis), rotate so it points toward camera
            armScene.rotation.set(-Math.PI / 2, 0, Math.PI / 4); // fingers forward, thumb up

            _fpsMakeViewmodel(armScene);
            fpsArmGroup.add(armScene);

            // For a skinned mesh, hiding bones doesn't work — the meshes are skinned to the skeleton.
            // We need to hide the SkinnedMesh objects directly.
            // Log each ArmModel mesh so we can identify left vs right by position.
            armScene.updateMatrixWorld(true);
            armScene.traverse(c => {
                if (c.isSkinnedMesh || c.isMesh) {
                    const wp = new THREE.Vector3();
                    c.getWorldPosition(wp);
                    console.log('💪 Mesh:', c.name, 'worldX:', wp.x.toFixed(3));
                }
            });

            // Animations
            const rawClips = tmpl.userData._animClips || {};
            if (Object.keys(rawClips).length) {
                _fpsArmMixer = new THREE.AnimationMixer(armScene);
                Object.entries(rawClips).forEach(([name, clip]) => {
                    _fpsArmAnims[name] = _fpsArmMixer.clipAction(clip);
                });
                console.log('💪 Arm anims:', Object.keys(_fpsArmAnims).join(', '));
                const idleKey = Object.keys(_fpsArmAnims).find(k => /idle/i.test(k)) || Object.keys(_fpsArmAnims)[0];
                if (idleKey) _fpsArmAnims[idleKey].setLoop(THREE.LoopRepeat, Infinity).play();
            }

            _fpsArmLoaded = true;
            console.log('💪 FPS arm ready — meshes:', meshCount, '| anims:', Object.keys(_fpsArmAnims).join(', ') || 'none');
        }

        function _buildProceduralArm(group) {
            // The group sits at fpsArmGroup position: (0.18, -0.22, -0.35) in camera space.
            // At Z=-0.35 with FOV 75, 1 unit fills the full screen — keep geometry TINY.
            const skinMat  = new THREE.MeshStandardMaterial({ color: 0xc68642, roughness: 0.8, depthTest: false });
            const sleeveMat= new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.9, depthTest: false });
            const glovesMat= new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9, depthTest: false });

            const addPart = (geo, mat, px, py, pz, rz) => {
                const m = new THREE.Mesh(geo, mat);
                m.position.set(px, py, pz);
                if (rz) m.rotation.z = rz;
                m.renderOrder = 999;
                group.add(m);
            };

            // Forearm sleeve — short cylinder pointing down from group origin
            addPart(new THREE.CylinderGeometry(0.012, 0.014, 0.09, 8), sleeveMat,  0,      0.02,  0);
            // Wrist
            addPart(new THREE.CylinderGeometry(0.010, 0.012, 0.018, 8), skinMat,   0,     -0.035, 0);
            // Palm
            addPart(new THREE.BoxGeometry(0.024, 0.028, 0.014), glovesMat,          0,     -0.058, 0.003);
            // Fingers (4)
            for (let i = 0; i < 4; i++) {
                addPart(new THREE.BoxGeometry(0.005, 0.018, 0.005), glovesMat, -0.009 + i * 0.006, -0.075, 0.003);
            }
            // Thumb
            addPart(new THREE.BoxGeometry(0.005, 0.014, 0.005), skinMat, 0.015, -0.060, 0.003, -0.4);
            // Apply viewmodel rendering settings
            if (typeof _fpsMakeViewmodel === 'function') _fpsMakeViewmodel(group);
        }

        scene.add(camera);
        
        let currentHeldItem = null;
        let toolAnimation = {
            active: false,
            time: 0,
            duration: 0.3
        };
        
        // Create Sharp Stone model - Detailed handheld version
        async function createSharpStoneModel() {
            const stone = new THREE.Group();
            
            // Main stone body - more irregular/angular shape
            const stoneGeo = new THREE.DodecahedronGeometry(0.12, 0);
            const stoneMat = await createStoneMaterial(0x888888, 0.9);
            const stoneBody = new THREE.Mesh(stoneGeo, stoneMat);
            stoneBody.scale.set(1.5, 1.2, 0.8); // Flatter, wider
            stoneBody.castShadow = true;
            stone.add(stoneBody);
            
            // Sharp edge pieces (knapped edges)
            const edgePositions = [
                { x: 0.15, y: 0, z: 0, rot: 0 },
                { x: 0.12, y: 0.05, z: 0, rot: 0.3 },
                { x: 0.12, y: -0.05, z: 0, rot: -0.3 }
            ];
            
            edgePositions.forEach(pos => {
                const edgeGeo = new THREE.TetrahedronGeometry(0.04, 0);
                const edgeMat = new THREE.MeshStandardMaterial({ 
                    color: 0xaaaaaa,
                    roughness: 0.4,
                    metalness: 0.3,
                    flatShading: true
                });
                const edge = new THREE.Mesh(edgeGeo, edgeMat);
                edge.position.set(pos.x, pos.y, pos.z);
                edge.rotation.z = pos.rot;
                edge.scale.set(1.5, 0.8, 0.5);
                stone.add(edge);
            });
            
            // Knapping flakes (texture detail)
            for (let i = 0; i < 8; i++) {
                const flakeGeo = new THREE.BoxGeometry(0.04, 0.02, 0.01);
                const flakeMat = new THREE.MeshStandardMaterial({
                    color: 0x666666,
                    roughness: 0.7,
                    flatShading: true
                });
                const flake = new THREE.Mesh(flakeGeo, flakeMat);
                
                const angle = (i / 8) * Math.PI * 2;
                const radius = 0.08 + Math.random() * 0.04;
                flake.position.set(
                    Math.cos(angle) * radius,
                    (Math.random() - 0.5) * 0.12,
                    Math.sin(angle) * radius * 0.6
                );
                flake.rotation.set(
                    Math.random() - 0.5,
                    Math.random() - 0.5,
                    angle
                );
                stone.add(flake);
            }
            
            // Position for proper hand holding in FPS view
            stone.scale.setScalar(0.7); // Viewmodel scale
            stone.position.set(0.2, -0.25, -0.35);
            stone.rotation.set(0.5, 0.4, -0.4);
            
            return stone;
        }

        // ─── ASSET GLB LOADER ──────────────────────────────────────────────────────
        // Shared loader for weapon/tool held-item models AND world-object spawns.
        // ═══════════════════════════════════════════════════════════════════════
        // GLB ENGINE — unified, hardened loader & instantiator
        // All GLB loading in the game funnels through _glbLoad() and _glbSpawn().
        // Adding a new model never requires touching loading/safety code again —
        // just call _glbLoad(url) and _glbSpawn(filename, size) and it all works.
        //
        // Fixes baked in permanently:
        //   1. DRACOLoader race  — waits for both GLTFLoader AND DRACOLoader scripts
        //      before parsing any file, so Draco-compressed meshes never silently
        //      decode to empty geometry.
        //   2. NaN position guard — if bounding box is infinite/empty (Draco failure),
        //      position.y subtraction is skipped instead of writing -Infinity → NaN.
        //   3. Shared-material bug (Three.js r128) — every clone gets independent
        //      material instances so GPU upload state can't bleed between instances.
        //   4. Texture encoding fix — sRGB/Linear encoding set on all texture slots
        //      after parse, preventing black/invisible materials.
        //   5. Geometry always visible — frustumCulled=false, visible=true, shadows
        //      enabled on every mesh, bounding volumes computed.
        // ═══════════════════════════════════════════════════════════════════════

        const _ASSET_GLB_BASE   = 'https://jam110uk.github.io/Crust-Sounds/';
        const _assetGLBCache    = {};   // url-key AND bare-filename → THREE.Object3D template (or null)
        const _assetGLBPromises = {};   // url-key → Promise<template|null>

        // ── Shared Draco loader instance (created once after DRACOLoader script loads)
        let _sharedDracoLoader = null;

        // ── Loader-ready promise: resolves true only when BOTH scripts are loaded.
        //    _gltfLoaderPromise is set by the script-loading block above.
        //    _dracoLoaderPromise is set in the DRACOLoader script-tag onload below.
        //    Using Promise.all means every _glbLoad call automatically waits for both.
        function _glbLoadersReady() {
            return Promise.all([
                window._gltfLoaderPromise  || Promise.resolve(typeof THREE.GLTFLoader  !== 'undefined'),
                window._dracoLoaderPromise || Promise.resolve(typeof THREE.DRACOLoader !== 'undefined'),
            ]).then(([gltfOk]) => gltfOk);
        }

        // ── Single shared GLTFLoader with Draco attached (created lazily after ready)
        let _sharedGLTFLoader = null;
        function _getGLTFLoader() {
            if (_sharedGLTFLoader) return _sharedGLTFLoader;
            _sharedGLTFLoader = new THREE.GLTFLoader();
            if (typeof THREE.DRACOLoader !== 'undefined') {
                if (!_sharedDracoLoader) {
                    _sharedDracoLoader = new THREE.DRACOLoader();
                    _sharedDracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/draco/');
                    _sharedDracoLoader.setDecoderConfig({ type: 'js' });
                }
                _sharedGLTFLoader.setDRACOLoader(_sharedDracoLoader);
            }
            return _sharedGLTFLoader;
        }

        // ── _glbLoad(filename, baseUrl?)
        //    Fetches + parses a GLB file exactly once; returns a Promise<template|null>.
        //    Safe to call many times — deduplicates via _assetGLBCache/_assetGLBPromises.
        //    baseUrl defaults to _ASSET_GLB_BASE if omitted.
        function _glbLoad(filename, baseUrl) {
            const key = (baseUrl || _ASSET_GLB_BASE) + filename;
            if (key in _assetGLBCache)    return Promise.resolve(_assetGLBCache[key]);
            if (_assetGLBPromises[key])   return _assetGLBPromises[key];

            const url = (baseUrl || _ASSET_GLB_BASE) + encodeURIComponent(filename);
            console.log(`📦 [GLB] Loading: ${url}`);

            _assetGLBPromises[key] = _glbLoadersReady().then(ok => {
                if (!ok || typeof THREE.GLTFLoader === 'undefined') {
                    console.error(`📦 [GLB] GLTFLoader unavailable for ${filename}`);
                    return (_assetGLBCache[key] = null);
                }
                return fetch(url)
                    .then(r => {
                        if (!r.ok) throw new Error(`HTTP ${r.status}`);
                        console.log(`📦 [GLB] ${filename} — ${r.status}, reading buffer…`);
                        return r.arrayBuffer();
                    })
                    .then(buf => new Promise((resolve, reject) => {
                        console.log(`📦 [GLB] ${filename} — ${buf.byteLength} bytes, parsing…`);
                        _getGLTFLoader().parse(buf, '', gltf => {
                            const tmpl = gltf.scene;
                            // Store animation clips on the template for animated models
                            if (gltf.animations && gltf.animations.length) {
                                tmpl.userData._animClips = {};
                                gltf.animations.forEach(c => { tmpl.userData._animClips[c.name.toLowerCase()] = c; });
                            }
                            // Validate: Draco failure produces 0 meshes silently
                            let meshCount = 0;
                            tmpl.traverse(c => {
                                c.visible = true; c.frustumCulled = true; // bounding sphere computed below — safe to cull
                                if (c.isMesh) {
                                    meshCount++;
                                    c.castShadow = true; c.receiveShadow = true;
                                    if (c.geometry) { c.geometry.computeBoundingBox(); c.geometry.computeBoundingSphere(); }
                                }
                            });
                            const bbox = new THREE.Box3().setFromObject(tmpl);
                            const bs = new THREE.Vector3(); bbox.getSize(bs);
                            console.log(`📦 [GLB] ${filename} ✅ meshes=${meshCount} size=${bs.x.toFixed(2)}×${bs.y.toFixed(2)}×${bs.z.toFixed(2)}`);
                            if (meshCount === 0) console.warn(`📦 [GLB] ⚠️ ${filename} has 0 meshes — Draco decode failure or empty file!`);
                            _glbFixTextures(tmpl);
                            _assetGLBCache[key] = tmpl;
                            _assetGLBCache[filename] = tmpl;  // bare-filename alias for legacy lookups
                            resolve(tmpl);
                        }, err => {
                            console.error(`📦 [GLB] parse FAILED for ${filename}:`, err);
                            resolve(_assetGLBCache[key] = _assetGLBCache[filename] = null);
                        });
                    }))
                    .catch(err => {
                        console.error(`📦 [GLB] fetch FAILED for ${filename}:`, err);
                        return (_assetGLBCache[key] = _assetGLBCache[filename] = null);
                    });
            });
            return _assetGLBPromises[key];
        }

        // ── Backwards-compat alias used throughout the codebase
        function _loadAssetGLB(filename) { return _glbLoad(filename); }

        // ── _glbSpawn(filename, targetSize, positionOffset?, baseUrl?)
        //    Deep-clones the cached template, scales it to targetSize (largest axis, metres),
        //    grounds it (bottom of bbox sits at y=0), optionally offsets, and returns the
        //    instance ready to scene.add(). Returns null if template not loaded yet.
        //
        //    All the one-time fixes are here so no spawn site needs to repeat them:
        //      • Per-instance material clone  (shared-material r128 bug)
        //      • Texture encoding fix
        //      • NaN guard on bbox grounding
        //      • frustumCulled=false, shadows, bounding volumes
        function _glbSpawn(filename, targetSize, positionOffset, baseUrl) {
            const key  = (baseUrl || _ASSET_GLB_BASE) + filename;
            const tmpl = _assetGLBCache[key];
            if (!tmpl) { console.warn(`📦 [GLB] _glbSpawn: "${filename}" not loaded yet`); return null; }

            const inst = tmpl.clone(true);

            // Per-instance material clone — prevents GPU-upload state bleeding between instances
            inst.traverse(c => {
                if (!c.isMesh) return;
                if (Array.isArray(c.material)) {
                    c.material = c.material.map(m => { const mc = m ? m.clone() : m; if (mc) mc.needsUpdate = true; return mc; });
                } else if (c.material) {
                    c.material = c.material.clone();
                    c.material.needsUpdate = true;
                }
            });

            // Scale to target size
            const box = new THREE.Box3().setFromObject(inst);
            const sz  = new THREE.Vector3(); box.getSize(sz);
            const maxDim = Math.max(sz.x, sz.y, sz.z);
            if (maxDim === 0) {
                console.error(`📦 [GLB] ❌ ${filename} has zero bounding box — geometry empty, skipping spawn`);
                return null;   // Return null instead of adding an invisible ghost object
            }
            inst.scale.setScalar(targetSize / maxDim);

            // Ground: shift so bbox bottom sits at y=0.
            // NaN guard: if bbox is infinite (empty geometry slipped through), skip
            // rather than writing -Infinity into position.y which produces NaN matrix.
            inst.updateMatrixWorld(true);
            const b2 = new THREE.Box3().setFromObject(inst);
            if (isFinite(b2.min.y)) {
                inst.position.y -= b2.min.y;
            } else {
                console.error(`📦 [GLB] ⚠️ ${filename} grounding skipped — b2.min.y=${b2.min.y}`);
            }

            if (positionOffset) inst.position.add(positionOffset);

            // Ensure every mesh is renderable
            inst.traverse(c => {
                c.visible = true; c.frustumCulled = true; // bounding sphere computed below — safe to cull
                if (c.isMesh) {
                    c.castShadow = true; c.receiveShadow = true;
                    if (c.geometry) { c.geometry.computeBoundingBox(); c.geometry.computeBoundingSphere(); }
                }
            });

            _glbFixTextures(inst);
            return inst;
        }

        // ── Backwards-compat alias — old call sites use _instantiateGLB
        function _instantiateGLB(filename, targetSize, positionOffset) {
            return _glbSpawn(filename, targetSize, positionOffset);
        }

        // ── Viewmodel-safe GLB instantiator — NO grounding, NO world-space tricks ──
        // Use this for camera-child objects (held items, arms).
        // targetSize scales largest axis to that many units. positionOffset is applied directly.
        function _instantiateViewmodelGLB(filename, targetSize, positionOffset) {
            const key  = (_ASSET_GLB_BASE) + filename;
            const tmpl = _assetGLBCache[key] || _assetGLBCache[filename];
            if (!tmpl) return null;

            const inst = tmpl.clone(true);

            // Per-instance material clone
            inst.traverse(c => {
                if (!c.isMesh) return;
                if (Array.isArray(c.material)) {
                    c.material = c.material.map(m => { const mc = m ? m.clone() : m; if (mc) mc.needsUpdate = true; return mc; });
                } else if (c.material) {
                    c.material = c.material.clone();
                    c.material.needsUpdate = true;
                }
                // Viewmodel settings
                c.renderOrder = 999;
                c.castShadow = false;
                c.receiveShadow = false;
                c.frustumCulled = false;
                const mats = Array.isArray(c.material) ? c.material : [c.material];
                mats.forEach(m => { if (m) { m.depthTest = true; m.depthWrite = true; m.needsUpdate = true; } });
            });

            // Scale to target size
            const box = new THREE.Box3().setFromObject(inst);
            const sz  = new THREE.Vector3(); box.getSize(sz);
            const maxDim = Math.max(sz.x, sz.y, sz.z);
            if (maxDim === 0) return null;
            inst.scale.setScalar(targetSize / maxDim);

            // NO grounding — position directly in camera space
            inst.position.set(0, 0, 0);
            if (positionOffset) inst.position.copy(positionOffset);

            _glbFixTextures(inst);
            return inst;
        }

        // ── Texture-encoding fix: Three.js r128 bug — GLBs loaded via parse(ArrayBuffer)
        //    don't reliably have sRGB/Linear encoding set, causing black/invisible surfaces.
        //    Called on every template at load time AND on every instance at spawn time.
        function _glbFixTextures(root) {
            root.traverse(c => {
                if (!c.isMesh || !c.material) return;
                const mats = Array.isArray(c.material) ? c.material : [c.material];
                mats.forEach(mat => {
                    if (!mat) return;
                    ['map','emissiveMap'].forEach(k => {
                        if (mat[k]) { mat[k].encoding = THREE.sRGBEncoding; mat[k].needsUpdate = true; }
                    });
                    ['normalMap','roughnessMap','metalnessMap','aoMap','displacementMap','alphaMap','lightMap'].forEach(k => {
                        if (mat[k]) { mat[k].encoding = THREE.LinearEncoding; mat[k].needsUpdate = true; }
                    });
                    mat.needsUpdate = true;
                });
            });
        }
        // Backwards-compat alias
        const _fixGLBTextures = _glbFixTextures;

        // ── _makeGLTFLoader kept for any legacy call sites (Wolf loader etc.)
        //    Returns the shared loader so Draco is always attached.
        function _makeGLTFLoader() { return _getGLTFLoader(); }

        // Pre-load all new asset GLBs immediately
        const _ALL_ASSET_GLBS = [
            'Spear.glb', 'Pistol.glb', 'Sword.glb', 'Simple Pickaxe.glb', 'Axe.glb',
            'Prickly pear cactus.glb', 'Cactus.glb', 'Rock Medium.glb', 'Palm Tree.glb', 'Tree.glb', 'Tree 2.glb', 'DeadTree.glb', 'BushF.glb', 'Stump.glb', 'Rockpile.glb', 'Stick.glb',
            'Rubbish.glb',
            'Rigged Fps Arms.glb', 'Bedroll.glb', 'squirril.glb', 'Snowrock.glb', 'Snowtree1.glb', 'Snowtree2.glb', 'Snowbush.glb', 'Mineral.glb', 'Submachine Gun.glb',
            'Bookshelf.glb', 'Table.glb', 'Chair.glb', 'CubeShelf.glb', 'Candle.glb', 'Hive.glb', 'ChickenCoop.glb', 'Bee.glb'
        ];
        _ALL_ASSET_GLBS.forEach(f => _loadAssetGLB(f));

        // ── Weapon / tool held-item model builders ────────────────────────────────
        // Each returns a Promise<THREE.Group> — same API as the old async functions.
        // Falls back to the original procedural model if GLB hasn't loaded yet.

        async function createAxeModel() {
            await _loadAssetGLB('Axe.glb');
            const glb = _instantiateViewmodelGLB('Axe.glb', 1.0, new THREE.Vector3(0.30, 0.10, -0.50));
            if (glb) { glb.rotation.set(-Math.PI / 2, Math.PI, Math.PI / 2); return glb; }

            const axe = new THREE.Group();
            
            // Wooden handle with texture
            const handleGeo = new THREE.CylinderGeometry(0.035, 0.04, 1, 8);
            const handleMat = await createWoodMaterial(0x8B4513, 0.85);
            const handle = new THREE.Mesh(handleGeo, handleMat);
            handle.position.y = -0.4;
            handle.castShadow = true;
            axe.add(handle);
            
            // Handle grip wrapping
            const gripGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.25, 8);
            const gripMat = new THREE.MeshStandardMaterial({
                color: 0x3d2817,
                roughness: 0.9
            });
            const grip = new THREE.Mesh(gripGeo, gripMat);
            grip.position.y = -0.65;
            axe.add(grip);
            
            // Metal blade with realistic shape
            const bladeShape = new THREE.Shape();
            bladeShape.moveTo(0, 0);
            bladeShape.lineTo(0.35, 0.1);
            bladeShape.quadraticCurveTo(0.38, 0.05, 0.35, -0.1);
            bladeShape.lineTo(0, 0);
            
            const bladeGeo = new THREE.ExtrudeGeometry(bladeShape, {
                depth: 0.06,
                bevelEnabled: true,
                bevelThickness: 0.01,
                bevelSize: 0.01,
                bevelSegments: 2
            });
            
            const bladeMat = await createMetalMaterial(0x888888, 0.4);
            const blade = new THREE.Mesh(bladeGeo, bladeMat);
            blade.position.set(-0.03, 0.15, -0.03);
            blade.rotation.x = Math.PI / 2;
            blade.rotation.y = Math.PI / 2; // Rotate 90 degrees so edge faces forward
            blade.castShadow = true;
            axe.add(blade);
            
            // Blade edge highlight
            const edgeGeo = new THREE.BoxGeometry(0.02, 0.35, 0.04);
            const edgeMat = new THREE.MeshStandardMaterial({
                color: 0xcccccc,
                roughness: 0.2,
                metalness: 0.9
            });
            const edge = new THREE.Mesh(edgeGeo, edgeMat);
            edge.position.set(0, 0.15, 0.145); // Adjusted for rotated blade
            edge.rotation.y = Math.PI / 2;
            edge.castShadow = true;
            axe.add(edge);
            
            // Metal head socket
            const socketGeo = new THREE.CylinderGeometry(0.05, 0.045, 0.15, 8);
            const socket = new THREE.Mesh(socketGeo, bladeMat.clone());
            socket.position.y = 0.05;
            axe.add(socket);
            
            // Position for FPS view - handle vertical, blade at top pointing forward/up
            axe.scale.setScalar(0.7); // Viewmodel scale
            axe.rotation.set(-0.3, -0.1, 0);
            axe.position.set(0.25, -0.35, -0.45);
            
            return axe;
        }
        
        async function createPickaxeModel() {
            await _loadAssetGLB('Simple Pickaxe.glb');
            const glb = _instantiateViewmodelGLB('Simple Pickaxe.glb', 0.60, new THREE.Vector3(0.12, -0.18, -0.30));
            if (glb) { glb.rotation.set(-0.3, 0.2 + Math.PI / 2, 0.15); return glb; }

            const pickaxe = new THREE.Group();
            
            // Wooden handle with texture
            const handleGeo = new THREE.CylinderGeometry(0.035, 0.04, 1.1, 8);
            const handleMat = await createWoodMaterial(0x8B4513, 0.85);
            const handle = new THREE.Mesh(handleGeo, handleMat);
            handle.position.y = -0.45;
            handle.castShadow = true;
            pickaxe.add(handle);
            
            // Handle grip
            const gripGeo = new THREE.CylinderGeometry(0.042, 0.042, 0.3, 8);
            const gripMat = new THREE.MeshStandardMaterial({
                color: 0x654321,
                roughness: 0.95
            });
            const grip = new THREE.Mesh(gripGeo, gripMat);
            grip.position.y = -0.7;
            pickaxe.add(grip);
            
            // Metal pick head base
            const headBaseGeo = new THREE.BoxGeometry(0.5, 0.12, 0.1);
            const metalMat = await createMetalMaterial(0x666666, 0.4);
            const headBase = new THREE.Mesh(headBaseGeo, metalMat);
            headBase.position.y = 0.1;
            headBase.rotation.y = Math.PI / 2; // Rotate so pick points forward
            headBase.castShadow = true;
            pickaxe.add(headBase);
            
            // Pick point (main working end)
            const pickPointGeo = new THREE.ConeGeometry(0.05, 0.25, 6);
            const pickPoint = new THREE.Mesh(pickPointGeo, metalMat.clone());
            pickPoint.rotation.z = -Math.PI / 2;
            pickPoint.rotation.x = Math.PI / 2; // Point forward
            pickPoint.position.set(0, 0.1, 0.32);
            pickPoint.castShadow = true;
            pickaxe.add(pickPoint);
            
            // Sharp edge highlight on point
            const pointEdgeGeo = new THREE.ConeGeometry(0.03, 0.1, 4);
            const edgeMat = new THREE.MeshStandardMaterial({
                color: 0xaaaaaa,
                roughness: 0.2,
                metalness: 0.9
            });
            const pointEdge = new THREE.Mesh(pointEdgeGeo, edgeMat);
            pointEdge.rotation.z = -Math.PI / 2;
            pointEdge.rotation.x = Math.PI / 2; // Match pick rotation
            pointEdge.position.set(0, 0.1, 0.4);
            pickaxe.add(pointEdge);
            
            // Flat hammer end (opposite side)
            const hammerGeo = new THREE.BoxGeometry(0.12, 0.12, 0.1);
            const hammer = new THREE.Mesh(hammerGeo, metalMat.clone());
            hammer.position.set(0, 0.1, -0.25); // Behind handle
            hammer.castShadow = true;
            pickaxe.add(hammer);
            
            // Socket connecting head to handle
            const socketGeo = new THREE.CylinderGeometry(0.055, 0.05, 0.15, 8);
            const socket = new THREE.Mesh(socketGeo, metalMat.clone());
            socket.position.y = 0.02;
            pickaxe.add(socket);
            
            // Position for FPS view - handle diagonal, pick pointing down-forward
            pickaxe.scale.setScalar(0.7); // Viewmodel scale
            pickaxe.rotation.set(0.8, 0.3, 0.2);
            pickaxe.position.set(0.3, -0.4, -0.5);
            
            return pickaxe;
        }
        
        async function createSwordModel() {
            await _loadAssetGLB('Sword.glb');
            const glb = _instantiateViewmodelGLB('Sword.glb', 0.75, new THREE.Vector3(0.10, -0.18, -0.28));
            if (glb) { glb.rotation.set(-0.15, -0.05, 0); return glb; }

            const sword = new THREE.Group();
            
            // Blade - medieval longsword style
            const bladeLength = 0.75;
            const bladeShape = new THREE.Shape();
            bladeShape.moveTo(0, 0);
            bladeShape.lineTo(0.04, 0.05);
            bladeShape.lineTo(0.04, bladeLength - 0.08);
            bladeShape.lineTo(0, bladeLength);
            bladeShape.lineTo(-0.04, bladeLength - 0.08);
            bladeShape.lineTo(-0.04, 0.05);
            bladeShape.lineTo(0, 0);
            
            const bladeGeo = new THREE.ExtrudeGeometry(bladeShape, {
                depth: 0.008,
                bevelEnabled: true,
                bevelThickness: 0.003,
                bevelSize: 0.003,
                bevelSegments: 3
            });
            
            const bladeMat = await createMetalMaterial(0xcccccc, 0.3);
            const blade = new THREE.Mesh(bladeGeo, bladeMat);
            blade.position.set(0, bladeLength * 0.3, -0.004);
            blade.castShadow = true;
            sword.add(blade);
            
            // Fuller (blood groove) down center of blade
            const fullerGeo = new THREE.BoxGeometry(0.015, bladeLength * 0.7, 0.004);
            const fullerMat = new THREE.MeshStandardMaterial({
                color: 0x999999,
                roughness: 0.4,
                metalness: 0.8
            });
            const fuller = new THREE.Mesh(fullerGeo, fullerMat);
            fuller.position.y = bladeLength * 0.35;
            sword.add(fuller);
            
            // Sharp edge highlights
            const edge1Geo = new THREE.BoxGeometry(0.003, bladeLength * 0.8, 0.01);
            const edgeMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.1,
                metalness: 1,
                emissive: 0xaaaaaa,
                emissiveIntensity: 0.2
            });
            const edge1 = new THREE.Mesh(edge1Geo, edgeMat);
            edge1.position.set(0.04, bladeLength * 0.35, 0);
            sword.add(edge1);
            
            const edge2 = new THREE.Mesh(edge1Geo, edgeMat.clone());
            edge2.position.set(-0.04, bladeLength * 0.35, 0);
            sword.add(edge2);
            
            // Crossguard
            const guardGeo = new THREE.BoxGeometry(0.25, 0.04, 0.04);
            const guardMat = await createMetalMaterial(0x888888, 0.5);
            const guard = new THREE.Mesh(guardGeo, guardMat);
            guard.position.y = -0.02;
            guard.castShadow = true;
            sword.add(guard);
            
            // Guard decorations
            const guardTipGeo = new THREE.SphereGeometry(0.025, 8, 8);
            const guardTip1 = new THREE.Mesh(guardTipGeo, guardMat.clone());
            guardTip1.position.set(0.125, -0.02, 0);
            sword.add(guardTip1);
            
            const guardTip2 = new THREE.Mesh(guardTipGeo, guardMat.clone());
            guardTip2.position.set(-0.125, -0.02, 0);
            sword.add(guardTip2);
            
            // Grip/Handle wrapped in leather
            const gripGeo = new THREE.CylinderGeometry(0.022, 0.025, 0.22, 8);
            const gripMat = await createFabricMaterial(0x3d2817, 0.95);
            const grip = new THREE.Mesh(gripGeo, gripMat);
            grip.position.y = -0.13;
            grip.rotation.x = Math.PI / 2;
            grip.castShadow = true;
            sword.add(grip);
            
            // Grip wire wrapping detail
            for (let i = 0; i < 8; i++) {
                const wireGeo = new THREE.TorusGeometry(0.024, 0.004, 4, 8);
                const wireMat = new THREE.MeshStandardMaterial({
                    color: 0x4a4a4a,
                    roughness: 0.4,
                    metalness: 0.7
                });
                const wire = new THREE.Mesh(wireGeo, wireMat);
                wire.position.y = -0.05 - (i * 0.025);
                wire.rotation.x = Math.PI / 2;
                sword.add(wire);
            }
            
            // Pommel
            const pommelGeo = new THREE.SphereGeometry(0.04, 8, 8);
            const pommel = new THREE.Mesh(pommelGeo, guardMat.clone());
            pommel.scale.set(1, 0.7, 1);
            pommel.position.y = -0.26;
            pommel.castShadow = true;
            sword.add(pommel);
            
            // Position for proper hand holding in FPS view (diagonal grip)
            sword.rotation.set(-0.4, 0.2, -0.1);
            sword.scale.setScalar(0.7); // Viewmodel scale
            sword.position.set(0.18, -0.15, -0.3);
            
            return sword;
        }
        
        async function createSpearModel() {
            await _loadAssetGLB('Spear.glb');
            const glb = _instantiateViewmodelGLB('Spear.glb', 1.0, new THREE.Vector3(0.10, -0.18, -0.28));
            if (glb) { glb.rotation.set(-0.15, -0.05, 0); return glb; }

            const spear = new THREE.Group();
            
            // Long wooden shaft
            const shaftGeo = new THREE.CylinderGeometry(0.025, 0.03, 1.8, 8);
            const shaftMat = await createWoodMaterial(0x8B4513, 0.85);
            const shaft = new THREE.Mesh(shaftGeo, shaftMat);
            shaft.castShadow = true;
            spear.add(shaft);
            
            // Grip area (wrapped leather)
            const gripGeo = new THREE.CylinderGeometry(0.032, 0.032, 0.35, 8);
            const gripMat = new THREE.MeshStandardMaterial({
                color: 0x3d2817,
                roughness: 0.95
            });
            const grip = new THREE.Mesh(gripGeo, gripMat);
            grip.position.y = -0.5;
            spear.add(grip);
            
            // Metal spear head - diamond shaped blade
            const headLength = 0.35;
            const headWidth = 0.08;
            
            // Create blade shape
            const bladeShape = new THREE.Shape();
            bladeShape.moveTo(0, headLength / 2); // Tip
            bladeShape.lineTo(headWidth / 2, 0); // Right side
            bladeShape.lineTo(0, -headLength / 2); // Base
            bladeShape.lineTo(-headWidth / 2, 0); // Left side
            bladeShape.lineTo(0, headLength / 2); // Back to tip
            
            const bladeGeo = new THREE.ExtrudeGeometry(bladeShape, {
                depth: 0.015,
                bevelEnabled: true,
                bevelThickness: 0.005,
                bevelSize: 0.005,
                bevelSegments: 2
            });
            
            const bladeMat = await createMetalMaterial(0x888888, 0.3);
            const blade = new THREE.Mesh(bladeGeo, bladeMat);
            blade.rotation.x = Math.PI / 2;
            blade.position.y = 0.9 + headLength / 2;
            blade.castShadow = true;
            spear.add(blade);
            
            // Sharp edge highlights
            const edgeGeo = new THREE.PlaneGeometry(headWidth - 0.01, 0.005);
            const edgeMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.1,
                metalness: 1,
                emissive: 0xaaaaaa,
                emissiveIntensity: 0.3,
                side: THREE.DoubleSide
            });
            const edge1 = new THREE.Mesh(edgeGeo, edgeMat);
            edge1.rotation.x = Math.PI / 2;
            edge1.position.set(0, 0.9 + headLength / 2, 0.01);
            spear.add(edge1);
            
            const edge2 = new THREE.Mesh(edgeGeo, edgeMat.clone());
            edge2.rotation.x = Math.PI / 2;
            edge2.position.set(0, 0.9 + headLength / 2, -0.01);
            spear.add(edge2);
            
            // Socket/collar where blade meets shaft
            const socketGeo = new THREE.CylinderGeometry(0.04, 0.035, 0.12, 8);
            const socket = new THREE.Mesh(socketGeo, bladeMat.clone());
            socket.position.y = 0.85;
            socket.castShadow = true;
            spear.add(socket);
            
            // Decorative bands on shaft
            for (let i = 0; i < 3; i++) {
                const bandGeo = new THREE.CylinderGeometry(0.028, 0.028, 0.02, 8);
                const bandMat = new THREE.MeshStandardMaterial({
                    color: 0x2a2a2a,
                    roughness: 0.6,
                    metalness: 0.4
                });
                const band = new THREE.Mesh(bandGeo, bandMat);
                band.position.y = 0.6 - (i * 0.15);
                spear.add(band);
            }
            
            // Butt cap (metal end cap at bottom)
            const capGeo = new THREE.ConeGeometry(0.035, 0.08, 8);
            const cap = new THREE.Mesh(capGeo, bladeMat.clone());
            cap.position.y = -0.95;
            cap.castShadow = true;
            spear.add(cap);
            
            // Position for FPS view - spear held low and forward like image 3
            spear.rotation.set(1.3, 0, 0); // Angled forward and down
            spear.scale.setScalar(0.7); // Viewmodel scale
            spear.position.set(0.25, -0.5, -0.6);
            
            return spear;
        }
        
        async function createBowModel() {
            const bow = new THREE.Group();
            
            // Bow riser (central grip)
            const riserGeo = new THREE.BoxGeometry(0.06, 0.35, 0.04);
            const riserMat = await createWoodMaterial(0x654321, 0.8);
            const riser = new THREE.Mesh(riserGeo, riserMat);
            riser.castShadow = true;
            bow.add(riser);
            
            // Grip wrap in middle
            const gripGeo = new THREE.BoxGeometry(0.07, 0.12, 0.045);
            const gripMat = new THREE.MeshStandardMaterial({
                color: 0x3d2817,
                roughness: 0.95
            });
            const grip = new THREE.Mesh(gripGeo, gripMat);
            bow.add(grip);
            
            // Upper limb (curved)
            const upperLimbCurve = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(0, 0.18, 0),
                new THREE.Vector3(-0.08, 0.35, 0),
                new THREE.Vector3(-0.05, 0.5, 0)
            );
            const upperLimbGeo = new THREE.TubeGeometry(upperLimbCurve, 20, 0.018, 8, false);
            const limbMat = await createWoodMaterial(0x8B4513, 0.85);
            const upperLimb = new THREE.Mesh(upperLimbGeo, limbMat);
            upperLimb.castShadow = true;
            bow.add(upperLimb);
            
            // Lower limb (curved)
            const lowerLimbCurve = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(0, -0.18, 0),
                new THREE.Vector3(-0.08, -0.35, 0),
                new THREE.Vector3(-0.05, -0.5, 0)
            );
            const lowerLimbGeo = new THREE.TubeGeometry(lowerLimbCurve, 20, 0.018, 8, false);
            const lowerLimb = new THREE.Mesh(lowerLimbGeo, limbMat.clone());
            lowerLimb.castShadow = true;
            bow.add(lowerLimb);
            
            // Bowstring
            const stringPoints = [
                new THREE.Vector3(-0.05, 0.5, 0),
                new THREE.Vector3(0.12, 0, 0),
                new THREE.Vector3(-0.05, -0.5, 0)
            ];
            const stringCurve = new THREE.CatmullRomCurve3(stringPoints);
            const stringGeo = new THREE.TubeGeometry(stringCurve, 20, 0.003, 4, false);
            const stringMat = new THREE.MeshStandardMaterial({
                color: 0xdddddd,
                roughness: 0.6,
                metalness: 0.1
            });
            const bowstring = new THREE.Mesh(stringGeo, stringMat);
            bow.add(bowstring);
            
            // Nocking point (small marker on string)
            const nockGeo = new THREE.SphereGeometry(0.008, 6, 6);
            const nockMat = new THREE.MeshStandardMaterial({
                color: 0xff3300,
                roughness: 0.7
            });
            const nock = new THREE.Mesh(nockGeo, nockMat);
            nock.position.set(0.12, 0, 0);
            bow.add(nock);
            
            // Arrow rest (small shelf on riser)
            const restGeo = new THREE.BoxGeometry(0.04, 0.02, 0.015);
            const rest = new THREE.Mesh(restGeo, riserMat.clone());
            rest.position.set(0.03, 0, 0);
            bow.add(rest);
            
            // Create nocked arrow (visible when holding bow)
            const arrowGroup = new THREE.Group();
            
            // Arrow shaft
            const shaftGeo = new THREE.CylinderGeometry(0.005, 0.005, 0.6, 6);
            const shaftMat = await createWoodMaterial(0x8B6914, 0.7);
            const shaft = new THREE.Mesh(shaftGeo, shaftMat);
            shaft.rotation.z = Math.PI / 2;
            arrowGroup.add(shaft);
            
            // Arrow head (pointed)
            const headGeo = new THREE.ConeGeometry(0.012, 0.04, 6);
            const headMat = await createMetalMaterial(0x666666, 0.4);
            const head = new THREE.Mesh(headGeo, headMat);
            head.rotation.z = -Math.PI / 2;
            head.position.x = 0.32;
            arrowGroup.add(head);
            
            // Fletching (feathers)
            for (let i = 0; i < 3; i++) {
                const fletchGeo = new THREE.PlaneGeometry(0.03, 0.08);
                const fletchMat = new THREE.MeshStandardMaterial({
                    color: 0xff3300,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8
                });
                const fletch = new THREE.Mesh(fletchGeo, fletchMat);
                fletch.position.x = -0.28;
                fletch.rotation.y = (i * Math.PI * 2 / 3);
                arrowGroup.add(fletch);
            }
            
            // Nock (back of arrow)
            const nockEndGeo = new THREE.CylinderGeometry(0.006, 0.003, 0.015, 6);
            const nockEnd = new THREE.Mesh(nockEndGeo, shaftMat.clone());
            nockEnd.rotation.z = Math.PI / 2;
            nockEnd.position.x = -0.3;
            arrowGroup.add(nockEnd);
            
            // Position arrow on the bow (on the string)
            arrowGroup.position.set(0.12, 0, 0);
            arrowGroup.rotation.set(0, 0, 0);
            bow.add(arrowGroup);
            bow.userData.arrow = arrowGroup; // Store reference for shooting
            
            // Position for FPS view - bow vertical, string toward player
            bow.rotation.set(0, Math.PI / 2, 0);
            bow.scale.setScalar(0.7); // Viewmodel scale
            bow.position.set(0.15, -0.2, -0.4);
            
            return bow;
        }
        
        async function createPistolModel() {
            await _loadAssetGLB('Pistol.glb');
            const glb = _instantiateViewmodelGLB('Pistol.glb', 0.28, new THREE.Vector3(0.08, -0.12, -0.22));
            if (glb) { glb.rotation.set(-0.05, -0.05, 0); return glb; }

            const pistol = new THREE.Group();
            
            // Slide (top part) - detailed with texture
            const slideGeo = new THREE.BoxGeometry(0.09, 0.08, 0.38);
            const slideMat = await createMetalMaterial(0x1a1a1a, 0.3);
            const slide = new THREE.Mesh(slideGeo, slideMat);
            slide.position.set(0, 0.025, -0.4);
            slide.castShadow = true;
            pistol.add(slide);
            
            // Slide serrations (grip lines on top)
            for (let i = 0; i < 6; i++) {
                const serrationGeo = new THREE.BoxGeometry(0.092, 0.015, 0.02);
                const serrationMat = new THREE.MeshStandardMaterial({
                    color: 0x0a0a0a,
                    roughness: 0.9,
                    metalness: 0.3
                });
                const serration = new THREE.Mesh(serrationGeo, serrationMat);
                serration.position.set(0, 0.06, -0.3 - (i * 0.04));
                pistol.add(serration);
            }
            
            // Ejection port
            const portGeo = new THREE.BoxGeometry(0.03, 0.02, 0.08);
            const portMat = new THREE.MeshStandardMaterial({
                color: 0x000000,
                roughness: 0.8
            });
            const port = new THREE.Mesh(portGeo, portMat);
            port.position.set(0.048, 0.04, -0.35);
            pistol.add(port);
            
            // Barrel - detailed
            const barrelGeo = new THREE.CylinderGeometry(0.018, 0.018, 0.18, 12);
            const barrelMat = await createMetalMaterial(0x0a0a0a, 0.2);
            const barrel = new THREE.Mesh(barrelGeo, barrelMat);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.set(0, 0.02, -0.68);
            barrel.castShadow = true;
            pistol.add(barrel);
            
            // Barrel crown (muzzle)
            const crownGeo = new THREE.CylinderGeometry(0.022, 0.018, 0.02, 12);
            const crown = new THREE.Mesh(crownGeo, barrelMat.clone());
            crown.rotation.x = Math.PI / 2;
            crown.position.set(0, 0.02, -0.77);
            pistol.add(crown);
            
            // Frame/Receiver - textured
            const frameGeo = new THREE.BoxGeometry(0.085, 0.16, 0.14);
            const frameMat = await createMetalMaterial(0x2a2a2a, 0.4);
            const frame = new THREE.Mesh(frameGeo, frameMat);
            frame.position.set(0, -0.055, -0.26);
            frame.castShadow = true;
            pistol.add(frame);
            
            // Grip - textured with checkering
            const gripGeo = new THREE.BoxGeometry(0.078, 0.11, 0.105);
            const gripMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                roughness: 0.95,
                metalness: 0.1
            });
            const grip = new THREE.Mesh(gripGeo, gripMat);
            grip.position.set(0, -0.11, -0.26);
            grip.castShadow = true;
            pistol.add(grip);
            
            // Grip texture panels (checkering simulation)
            const panelGeo = new THREE.PlaneGeometry(0.06, 0.08);
            const panelMat = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,
                roughness: 1,
                side: THREE.DoubleSide
            });
            const leftPanel = new THREE.Mesh(panelGeo, panelMat);
            leftPanel.position.set(-0.04, -0.11, -0.26);
            leftPanel.rotation.y = Math.PI / 2;
            pistol.add(leftPanel);
            
            const rightPanel = new THREE.Mesh(panelGeo, panelMat.clone());
            rightPanel.position.set(0.04, -0.11, -0.26);
            rightPanel.rotation.y = -Math.PI / 2;
            pistol.add(rightPanel);
            
            // Trigger guard - curved
            const guardGeo = new THREE.TorusGeometry(0.035, 0.008, 8, 16, Math.PI);
            const guardMat = await createMetalMaterial(0x333333, 0.35);
            const triggerGuard = new THREE.Mesh(guardGeo, guardMat);
            triggerGuard.rotation.x = Math.PI / 2;
            triggerGuard.position.set(0, -0.025, -0.29);
            triggerGuard.castShadow = true;
            pistol.add(triggerGuard);
            
            // Trigger - detailed
            const triggerGeo = new THREE.BoxGeometry(0.018, 0.035, 0.012);
            const triggerMat = await createMetalMaterial(0x1a1a1a, 0.4);
            const trigger = new THREE.Mesh(triggerGeo, triggerMat);
            trigger.position.set(0, -0.015, -0.29);
            trigger.castShadow = true;
            pistol.add(trigger);
            
            // Trigger shoe (curved part)
            const shoeGeo = new THREE.SphereGeometry(0.012, 8, 8);
            const shoe = new THREE.Mesh(shoeGeo, triggerMat.clone());
            shoe.position.set(0, -0.03, -0.29);
            shoe.scale.set(1, 1.5, 0.8);
            pistol.add(shoe);
            
            // Sights - fiber optic style
            const rearSightGeo = new THREE.BoxGeometry(0.035, 0.025, 0.015);
            const sightMat = await createMetalMaterial(0x2a2a2a, 0.5);
            const rearSight = new THREE.Mesh(rearSightGeo, sightMat);
            rearSight.position.set(0, 0.07, -0.25);
            rearSight.castShadow = true;
            pistol.add(rearSight);
            
            // Rear sight dot (luminescent)
            const rearDotGeo = new THREE.SphereGeometry(0.006, 6, 6);
            const dotMat = new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 0.6,
                roughness: 0.3
            });
            const rearDotL = new THREE.Mesh(rearDotGeo, dotMat);
            rearDotL.position.set(-0.01, 0.08, -0.25);
            pistol.add(rearDotL);
            
            const rearDotR = new THREE.Mesh(rearDotGeo, dotMat.clone());
            rearDotR.position.set(0.01, 0.08, -0.25);
            pistol.add(rearDotR);
            
            // Front sight
            const frontSightGeo = new THREE.BoxGeometry(0.02, 0.03, 0.012);
            const frontSight = new THREE.Mesh(frontSightGeo, sightMat.clone());
            frontSight.position.set(0, 0.07, -0.62);
            frontSight.castShadow = true;
            pistol.add(frontSight);
            
            // Front sight fiber optic
            const frontDotGeo = new THREE.CylinderGeometry(0.004, 0.004, 0.015, 6);
            const frontDotMat = new THREE.MeshStandardMaterial({
                color: 0xff3300,
                emissive: 0xff3300,
                emissiveIntensity: 0.8,
                roughness: 0.2,
                transparent: true,
                opacity: 0.9
            });
            const frontDot = new THREE.Mesh(frontDotGeo, frontDotMat);
            frontDot.position.set(0, 0.08, -0.62);
            pistol.add(frontDot);
            
            // Magazine (clip) - detailed
            const magGeo = new THREE.BoxGeometry(0.065, 0.14, 0.09);
            const magMat = await createMetalMaterial(0x1a1a1a, 0.4);
            const magazine = new THREE.Mesh(magGeo, magMat);
            magazine.position.set(0, -0.15, -0.26);
            magazine.castShadow = true;
            pistol.add(magazine);
            
            // Magazine base plate
            const basePlateGeo = new THREE.BoxGeometry(0.07, 0.015, 0.095);
            const basePlate = new THREE.Mesh(basePlateGeo, magMat.clone());
            basePlate.position.set(0, -0.22, -0.26);
            pistol.add(basePlate);
            
            // Magazine release button
            const releaseGeo = new THREE.CylinderGeometry(0.008, 0.008, 0.015, 8);
            const releaseMat = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.6,
                metalness: 0.7
            });
            const release = new THREE.Mesh(releaseGeo, releaseMat);
            release.rotation.z = Math.PI / 2;
            release.position.set(-0.048, -0.02, -0.26);
            pistol.add(release);
            
            // Rail system (tactical rail)
            const railGeo = new THREE.BoxGeometry(0.025, 0.008, 0.15);
            const railMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                roughness: 0.7,
                metalness: 0.5
            });
            const rail = new THREE.Mesh(railGeo, railMat);
            rail.position.set(0, -0.01, -0.35);
            pistol.add(rail);
            
            pistol.userData.magazine = magazine; // Store reference for reload animation
            
            // Position and rotate for proper FPS view
            pistol.rotation.x = 0.1;
            pistol.rotation.y = -0.05;
            pistol.rotation.z = 0;
            pistol.scale.setScalar(0.7); // Viewmodel scale
            pistol.position.set(0.12, -0.15, -0.35);
            
            return pistol;
        }

        async function createMachineGunModel() {
            // Try to load Submachine Gun GLB — larger viewmodel than pistol
            await _loadAssetGLB('Submachine Gun.glb');
            // Pistol targetSize = 0.28; SMG is noticeably larger at 0.42
            const smgGlb = _instantiateViewmodelGLB('Submachine Gun.glb', 1.07, new THREE.Vector3(0.10, -0.14, -0.28));
            if (smgGlb) {
                // Barrel forward into scene, stock toward player
                smgGlb.rotation.set(-0.05, Math.PI / 2, 0);
                return smgGlb;
            }

            // ── Procedural fallback (used if GLB fails to load) ─────────────
            const mg = new THREE.Group();

            const metalDark  = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.55, metalness: 0.9 });
            const metalMid   = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.50, metalness: 0.85 });
            const metalLight = new THREE.MeshStandardMaterial({ color: 0x555566, roughness: 0.45, metalness: 0.80 });
            const gripMat    = new THREE.MeshStandardMaterial({ color: 0x1a1008, roughness: 0.95, metalness: 0.05 });
            const accentMat  = new THREE.MeshStandardMaterial({ color: 0x884400, roughness: 0.60, metalness: 0.40 });

            // Receiver (wider/longer than pistol slide)
            const receiver = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.13, 0.58), metalDark);
            receiver.position.set(0, 0.02, -0.02);
            mg.add(receiver);

            // Top rail / carry handle
            const rail = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.06, 0.55), metalMid);
            rail.position.set(0, 0.115, -0.02);
            mg.add(rail);

            // Barrel (longer than pistol)
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.028, 0.028, 0.72, 10), metalMid);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.set(0, 0.02, -0.52);
            mg.add(barrel);

            // Barrel shroud / heat shield
            const shroud = new THREE.Mesh(new THREE.CylinderGeometry(0.042, 0.042, 0.46, 12, 1, true), metalLight);
            shroud.rotation.x = Math.PI / 2;
            shroud.position.set(0, 0.02, -0.42);
            mg.add(shroud);

            // Muzzle
            const muzzle = new THREE.Mesh(new THREE.CylinderGeometry(0.033, 0.025, 0.06, 8), metalLight);
            muzzle.rotation.x = Math.PI / 2;
            muzzle.position.set(0, 0.02, -0.89);
            mg.add(muzzle);

            // Port (ejection port)
            const port = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.055, 0.11), metalDark);
            port.position.set(-0.13, 0.025, 0.07);
            mg.add(port);

            // Lower frame
            const frame = new THREE.Mesh(new THREE.BoxGeometry(0.24, 0.12, 0.48), metalMid);
            frame.position.set(0, -0.095, -0.01);
            mg.add(frame);

            // Magazine (larger — 20 round box mag)
            const magazine = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.26, 0.12), metalDark);
            magazine.position.set(0, -0.25, 0.09);
            mg.add(magazine);
            const magFloor = new THREE.Mesh(new THREE.BoxGeometry(0.105, 0.02, 0.125), accentMat);
            magFloor.position.set(0, -0.38, 0.09);
            mg.add(magFloor);

            // Pistol grip
            const grip = new THREE.Mesh(new THREE.BoxGeometry(0.09, 0.22, 0.12), gripMat);
            grip.rotation.x = -0.18;
            grip.position.set(0, -0.21, 0.27);
            mg.add(grip);
            const leftPanel  = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.17, 0.10), gripMat);
            leftPanel.position.set(-0.056, -0.21, 0.27);
            mg.add(leftPanel);
            const rightPanel = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.17, 0.10), gripMat);
            rightPanel.position.set( 0.056, -0.21, 0.27);
            mg.add(rightPanel);

            // Trigger guard
            const tg = new THREE.Mesh(new THREE.TorusGeometry(0.055, 0.012, 6, 16, Math.PI), metalMid);
            tg.rotation.x = -Math.PI / 2;
            tg.position.set(0, -0.13, 0.19);
            mg.add(tg);

            // Trigger
            const trigger = new THREE.Mesh(new THREE.BoxGeometry(0.018, 0.06, 0.022), metalLight);
            trigger.rotation.x = 0.3;
            trigger.position.set(0, -0.12, 0.17);
            mg.add(trigger);

            // Rear sights
            const rearSight = new THREE.Mesh(new THREE.BoxGeometry(0.085, 0.028, 0.022), metalDark);
            rearSight.position.set(0, 0.15, 0.23);
            mg.add(rearSight);
            const frontSight = new THREE.Mesh(new THREE.BoxGeometry(0.022, 0.032, 0.022), metalDark);
            frontSight.position.set(0, 0.15, -0.42);
            mg.add(frontSight);

            // Stock (folded stub — distinguishes it from pistol)
            const stock = new THREE.Mesh(new THREE.BoxGeometry(0.09, 0.10, 0.20), metalMid);
            stock.position.set(0, -0.04, 0.38);
            mg.add(stock);
            const stockEnd = new THREE.Mesh(new THREE.BoxGeometry(0.09, 0.045, 0.04), gripMat);
            stockEnd.position.set(0, -0.09, 0.47);
            mg.add(stockEnd);

            mg.userData.magazine = magazine;

            // Procedural fallback is also larger than pistol (scale 0.95 vs pistol 0.7)
            mg.rotation.x = 0.1;
            mg.rotation.y = -0.05;
            mg.scale.setScalar(0.95);
            mg.position.set(0.12, -0.15, -0.35);

            return mg;
        }
        
        async function updateHeldItem() {
            // Clear current held item
            while (heldItemGroup.children.length > 0) {
                heldItemGroup.remove(heldItemGroup.children[0]);
            }
            
            const selectedItem = hotbar[selectedHotbarSlot].item;
            
            if (!selectedItem || inventory[selectedItem] <= 0) {
                currentHeldItem = null;
                if (fpsArmHolder) fpsArmHolder.visible = false;
                // Hide pistol crosshair
                const pistolCrosshair = document.getElementById('pistol-crosshair');
                if (pistolCrosshair) pistolCrosshair.style.display = 'none';
                return;
            }
            
            currentHeldItem = selectedItem;
            
            let model = null;
            
            if (selectedItem === 'sharp_stone') {
                model = await createSharpStoneModel();
            } else if (selectedItem === 'axe') {
                model = await createAxeModel();
            } else if (selectedItem === 'pickaxe') {
                model = await createPickaxeModel();
            } else if (selectedItem === 'sword') {
                model = await createSwordModel();
            } else if (selectedItem === 'spear') {
                model = await createSpearModel();
            } else if (selectedItem === 'bow') {
                model = await createBowModel();
            } else if (selectedItem === 'pistol') {
                model = await createPistolModel();
            } else if (selectedItem === 'machine_gun') {
                model = await createMachineGunModel();
            }
            
            if (model) {
                // Ensure held item always renders on top (no clipping into world)
                model.traverse(c => {
                    if (c.isMesh) {
                        c.renderOrder = 999;
                        if (Array.isArray(c.material)) {
                            c.material.forEach(m => { m.depthTest = true; m.depthWrite = true; m.needsUpdate = true; });
                        } else {
                            c.material.depthTest = true;
                            c.material.depthWrite = true;
                            c.material.needsUpdate = true;
                        }
                    }
                });
                heldItemGroup.add(model);
            }

            // Show the FPS arm when any tool/weapon is equipped
            if (fpsArmGroup) {
                const toolItems = ['axe','stone_axe','pickaxe','stone_pickaxe','sword','spear','bow','pistol','machine_gun','hammer','sharp_stone'];
                fpsArmHolder.visible = false;
            }

            // Show/hide pistol crosshair and ammo counter
            const pistolCrosshair = document.getElementById('pistol-crosshair');
            const ammoCounter = document.getElementById('ammo-counter');
            if (selectedItem === 'pistol') {
                if (pistolCrosshair) pistolCrosshair.style.display = 'block';
                if (ammoCounter) {
                    ammoCounter.style.display = 'block';
                    ammoCounter.textContent = `${pistolState.currentClip} / ${inventory.pistol_ammo}`;
                }
            } else if (selectedItem === 'machine_gun') {
                if (pistolCrosshair) pistolCrosshair.style.display = 'block';
                if (ammoCounter) {
                    ammoCounter.style.display = 'block';
                    ammoCounter.textContent = `${machineGunState.currentClip} / ${inventory.mg_ammo}`;
                }
            } else {
                if (pistolCrosshair) pistolCrosshair.style.display = 'none';
                if (ammoCounter) ammoCounter.style.display = 'none';
            }
        }
        
        function animateTool(toolType) {
            toolAnimation.active = true;
            toolAnimation.time = 0;
            toolAnimation.toolType = toolType || 'default';
            
            // Play appropriate swing sound based on tool
            const heldItem = hotbar[selectedHotbarSlot].item;
            if (heldItem === 'axe' || heldItem === 'stone_axe') {
                playAxeSwingSound();
            } else if (heldItem === 'pickaxe' || heldItem === 'stone_pickaxe') {
                playPickaxeSwingSound();
            } else if (heldItem === 'sword') {
                playSwordSwingSound();
            } else if (heldItem === 'hammer') {
                playHammerSwingSound();
            }
        }
        
        function updateToolAnimation() {
            if (!toolAnimation.active) return;
            
            toolAnimation.time += 0.016; // ~60fps
            
            if (toolAnimation.time >= toolAnimation.duration) {
                toolAnimation.active = false;
                heldItemGroup.rotation.set(0, 0, 0);
                heldItemGroup.position.set(0.28, -0.22, -0.42);
                return;
            }
            
            const progress = toolAnimation.time / toolAnimation.duration;
            const heldItem = hotbar[selectedHotbarSlot].item;
            
            // Tool-specific animations with realistic arcs
            if (heldItem === 'sword') {
                // SWORD: Fast horizontal slash with weight
                if (progress < 0.3) {
                    // Wind up
                    const windUp = progress / 0.3;
                    heldItemGroup.rotation.x = -0.4 + windUp * 0.3;
                    heldItemGroup.rotation.y = -0.8 - windUp * 0.4;
                    heldItemGroup.rotation.z = 0.2;
                    heldItemGroup.position.x = 0.3 - windUp * 0.2;
                    heldItemGroup.position.y = -0.2;
                    heldItemGroup.position.z = -0.4;
                } else if (progress < 0.7) {
                    // Fast slash
                    const slash = (progress - 0.3) / 0.4;
                    const curve = Math.sin(slash * Math.PI);
                    heldItemGroup.rotation.x = -0.1 - curve * 0.3;
                    heldItemGroup.rotation.y = -1.2 + slash * 2.4;
                    heldItemGroup.rotation.z = 0.2 + curve * 0.4;
                    heldItemGroup.position.x = 0.1 + slash * 0.6;
                    heldItemGroup.position.y = -0.2 + curve * 0.15;
                    heldItemGroup.position.z = -0.4 - curve * 0.2;
                } else {
                    // Follow through
                    const follow = (progress - 0.7) / 0.3;
                    heldItemGroup.rotation.x = -0.4 + follow * 0.4;
                    heldItemGroup.rotation.y = 1.2 - follow * 0.4;
                    heldItemGroup.rotation.z = 0.6 - follow * 0.4;
                    heldItemGroup.position.x = 0.7 - follow * 0.4;
                    heldItemGroup.position.y = -0.2;
                    heldItemGroup.position.z = -0.5;
                }
            } else if (heldItem === 'spear') {
                // SPEAR: Forward thrust like image 3
                if (progress < 0.25) {
                    // Pull back
                    const pullBack = progress / 0.25;
                    heldItemGroup.rotation.x = 1.3 - pullBack * 0.2;
                    heldItemGroup.rotation.y = 0;
                    heldItemGroup.rotation.z = 0;
                    heldItemGroup.position.x = 0.25 - pullBack * 0.1;
                    heldItemGroup.position.y = -0.5 + pullBack * 0.1;
                    heldItemGroup.position.z = -0.6 + pullBack * 0.25;
                } else if (progress < 0.6) {
                    // Fast thrust forward
                    const thrust = (progress - 0.25) / 0.35;
                    heldItemGroup.rotation.x = 1.1 + thrust * 0.3;
                    heldItemGroup.rotation.y = 0;
                    heldItemGroup.rotation.z = 0;
                    heldItemGroup.position.x = 0.15 + thrust * 0.05;
                    heldItemGroup.position.y = -0.4 - thrust * 0.15;
                    heldItemGroup.position.z = -0.35 - thrust * 0.9;
                } else {
                    // Return
                    const ret = (progress - 0.6) / 0.4;
                    heldItemGroup.rotation.x = 1.4 - ret * 0.1;
                    heldItemGroup.rotation.y = 0;
                    heldItemGroup.rotation.z = 0;
                    heldItemGroup.position.x = 0.2 + ret * 0.05;
                    heldItemGroup.position.y = -0.55 + ret * 0.05;
                    heldItemGroup.position.z = -1.25 + ret * 0.65;
                }
            } else if (heldItem === 'axe' || heldItem === 'stone_axe') {
                // AXE: Overhead chop with power
                if (progress < 0.4) {
                    // Raise overhead
                    const raise = progress / 0.4;
                    const curve = Math.sin(raise * Math.PI * 0.5);
                    heldItemGroup.rotation.x = -curve * 2.0;
                    heldItemGroup.rotation.y = 0;
                    heldItemGroup.rotation.z = curve * 0.2;
                    heldItemGroup.position.x = 0.3;
                    heldItemGroup.position.y = -0.3 + curve * 0.8;
                    heldItemGroup.position.z = -0.5 + curve * 0.3;
                } else if (progress < 0.8) {
                    // Fast downward chop
                    const chop = (progress - 0.4) / 0.4;
                    const curve = Math.sin(chop * Math.PI);
                    heldItemGroup.rotation.x = -2.0 + chop * 1.6;
                    heldItemGroup.rotation.y = 0;
                    heldItemGroup.rotation.z = 0.2 - curve * 0.3;
                    heldItemGroup.position.x = 0.3;
                    heldItemGroup.position.y = 0.5 - chop * 0.9;
                    heldItemGroup.position.z = -0.2 - chop * 0.5;
                } else {
                    // Recovery
                    const recover = (progress - 0.8) / 0.2;
                    heldItemGroup.rotation.x = -0.4 + recover * 0.4;
                    heldItemGroup.rotation.y = 0;
                    heldItemGroup.rotation.z = -0.1 + recover * 0.1;
                    heldItemGroup.position.x = 0.3;
                    heldItemGroup.position.y = -0.4 + recover * 0.1;
                    heldItemGroup.position.z = -0.7 + recover * 0.2;
                }
            } else if (heldItem === 'pickaxe' || heldItem === 'stone_pickaxe') {
                // PICKAXE: Angled overhead strike
                if (progress < 0.35) {
                    // Wind up high and to the side
                    const windUp = progress / 0.35;
                    const curve = Math.sin(windUp * Math.PI * 0.5);
                    heldItemGroup.rotation.x = -curve * 1.8;
                    heldItemGroup.rotation.y = curve * 0.4;
                    heldItemGroup.rotation.z = curve * 0.3;
                    heldItemGroup.position.x = 0.3 + curve * 0.1;
                    heldItemGroup.position.y = -0.3 + curve * 0.7;
                    heldItemGroup.position.z = -0.5 + curve * 0.2;
                } else if (progress < 0.75) {
                    // Powerful downward strike
                    const strike = (progress - 0.35) / 0.4;
                    const curve = Math.sin(strike * Math.PI);
                    heldItemGroup.rotation.x = -1.8 + strike * 1.4;
                    heldItemGroup.rotation.y = 0.4 - curve * 0.3;
                    heldItemGroup.rotation.z = 0.3;
                    heldItemGroup.position.x = 0.4;
                    heldItemGroup.position.y = 0.4 - strike * 0.8;
                    heldItemGroup.position.z = -0.3 - strike * 0.6;
                } else {
                    // Return
                    const ret = (progress - 0.75) / 0.25;
                    heldItemGroup.rotation.x = -0.4 + ret * 0.4;
                    heldItemGroup.rotation.y = 0.1 - ret * 0.1;
                    heldItemGroup.rotation.z = 0.3 - ret * 0.3;
                    heldItemGroup.position.x = 0.4 - ret * 0.1;
                    heldItemGroup.position.y = -0.4 + ret * 0.1;
                    heldItemGroup.position.z = -0.9 + ret * 0.4;
                }
            } else if (heldItem === 'sharp_stone') {
                // SHARP STONE: Quick stabbing motion
                if (progress < 0.25) {
                    // Pull back
                    const pullBack = progress / 0.25;
                    heldItemGroup.rotation.x = -0.3 - pullBack * 0.3;
                    heldItemGroup.rotation.y = 0;
                    heldItemGroup.rotation.z = -0.2;
                    heldItemGroup.position.x = 0.3 - pullBack * 0.15;
                    heldItemGroup.position.y = -0.25;
                    heldItemGroup.position.z = -0.4 + pullBack * 0.2;
                } else if (progress < 0.6) {
                    // Fast stab forward
                    const stab = (progress - 0.25) / 0.35;
                    heldItemGroup.rotation.x = -0.6 + stab * 0.4;
                    heldItemGroup.rotation.y = 0;
                    heldItemGroup.rotation.z = -0.2;
                    heldItemGroup.position.x = 0.15 + stab * 0.1;
                    heldItemGroup.position.y = -0.25 - stab * 0.1;
                    heldItemGroup.position.z = -0.2 - stab * 0.7;
                } else {
                    // Return
                    const ret = (progress - 0.6) / 0.4;
                    heldItemGroup.rotation.x = -0.2 - ret * 0.1;
                    heldItemGroup.rotation.y = 0;
                    heldItemGroup.rotation.z = -0.2 + ret * 0.2;
                    heldItemGroup.position.x = 0.25 + ret * 0.05;
                    heldItemGroup.position.y = -0.35 + ret * 0.05;
                    heldItemGroup.position.z = -0.9 + ret * 0.4;
                }
            } else {
                // Default swing animation for other tools
                const swing = Math.sin(progress * Math.PI);
                heldItemGroup.rotation.x = -swing * 0.8;
                heldItemGroup.rotation.y = swing * 0.3;
                heldItemGroup.position.x = 0.3 + swing * 0.2;
                heldItemGroup.position.y = -0.3 - swing * 0.15;
                heldItemGroup.position.z = -0.5 - swing * 0.2;
            }
        }
        
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: false, 
            powerPreference: 'high-performance'
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Higher quality
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
        renderer.toneMapping = THREE.ACESFilmicToneMapping; // Cinematic look
        renderer.toneMappingExposure = 0.9; // Reduced brightness
        renderer.outputEncoding = THREE.sRGBEncoding; // Better colors
        renderer.sortObjects = true;
        document.body.appendChild(renderer.domElement);
        // Keep the 3D canvas below all fixed UI overlays
        renderer.domElement.style.position = 'fixed';
        renderer.domElement.style.top = '0';
        renderer.domElement.style.left = '0';
        renderer.domElement.style.zIndex = '0';

        // ── Crystal environment map ──────────────────────────────────────
        // Built lazily on first crystal spawn so the WebGL context is fully
        // warmed up before PMREMGenerator tries to compile its shaders.
        let _crystalEnvMap = null;
        function _buildCrystalEnvMap() {
            if (_crystalEnvMap) return;
            try {
                const pmrem = new THREE.PMREMGenerator(renderer);
                pmrem.compileEquirectangularShader();
                const envScene = new THREE.Scene();
                envScene.background = new THREE.Color(0xbbd5f0);
                const sun  = new THREE.DirectionalLight(0xfff8ee, 3.5);
                sun.position.set(1, 2, 0.5);
                envScene.add(sun);
                const fill = new THREE.DirectionalLight(0xaac4ff, 1.2);
                fill.position.set(-1, -0.3, -1);
                envScene.add(fill);
                _crystalEnvMap = pmrem.fromScene(envScene).texture;
                pmrem.dispose();
            } catch(e) {
                console.warn('Crystal env map build failed (non-fatal):', e);
            }
        }

        // ===== POST-PROCESSING PIPELINE =====
        // Renders the scene into a WebGLRenderTarget, then applies:
        //   1. Ore shimmer  \u2014 screen-space specular highlight boost on bright metallic pixels
        //   2. Wet ground   \u2014 darkens / blue-shifts the lower screen while raining, with
        //                     a gentle ripple distortion; fades out slowly after rain stops.

        let _ppTime    = 0;
        let _hazeAlpha = 0;   // drives pipeline bypass check

        // Render target for the main scene
        const _hazeRT = new THREE.WebGLRenderTarget(
            window.innerWidth, window.innerHeight,
            { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat }
        );

        // Composite shader
        const _hazeMaterial = new THREE.ShaderMaterial({
            uniforms: {
                tDiffuse:  { value: _hazeRT.texture },
                uTime:     { value: 0.0 },
                uWetness:  { value: 0.0 },   // 0=dry, 1=soaked
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = vec4(position.xy, 0.0, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float uTime;
                uniform float uWetness;
                varying vec2 vUv;

                // Luminance helper
                float luma(vec3 c) { return dot(c, vec3(0.299, 0.587, 0.114)); }

                void main() {
                    vec2 uv = vUv;

                    // ── WET GROUND: ripple distortion in lower 40% of screen ──
                    // groundZone: 1 at very bottom, 0 at the horizon line (uv.y=0.6)
                    float groundZone = clamp((0.6 - uv.y) / 0.6, 0.0, 1.0);
                    groundZone = groundZone * groundZone; // ease off toward horizon

                    if (uWetness > 0.001 && groundZone > 0.0) {
                        float w   = uWetness * groundZone;
                        float amp = w * 0.0018;
                        // Two overlapping ripple frequencies
                        float rx = sin(uTime * 1.8 + uv.y * 38.0 + uv.x * 12.0) * amp
                                 + sin(uTime * 3.1 + uv.y * 72.0 - uv.x * 20.0) * amp * 0.45;
                        float ry = cos(uTime * 2.2 + uv.x * 31.0 + uv.y * 15.0) * amp * 0.6;
                        uv += vec2(rx, ry);
                    }

                    vec4 col = texture2D(tDiffuse, uv);

                    // ── WET GROUND: colour grade the lower screen ──
                    if (uWetness > 0.001 && groundZone > 0.0) {
                        float w = uWetness * groundZone;
                        // Darken (wet surfaces absorb more light)
                        col.rgb *= 1.0 - w * 0.28;
                        // Slight blue/cool tint — standing water reflects the sky
                        col.rgb += vec3(-0.02, -0.01, 0.06) * w;
                        // Desaturate a little toward a reflective grey
                        float lum = luma(col.rgb);
                        col.rgb   = mix(col.rgb, vec3(lum), w * 0.18);
                    }

                    gl_FragColor = col;
                }
            `,
            depthTest: false,
            depthWrite: false
        });

        // Fullscreen triangle (covers NDC -1..1, no quad diagonal seam)
        const _hazeGeo = new THREE.BufferGeometry();
        _hazeGeo.setAttribute('position', new THREE.BufferAttribute(
            new Float32Array([-1,-1,0,  3,-1,0,  -1,3,0]), 3));
        _hazeGeo.setAttribute('uv', new THREE.BufferAttribute(
            new Float32Array([0,0,  2,0,  0,2]), 2));
        const _hazeMesh = new THREE.Mesh(_hazeGeo, _hazeMaterial);
        _hazeMesh.frustumCulled = false;

        // Minimal composite scene + orthographic camera
        const _hazeScene  = new THREE.Scene();
        _hazeScene.add(_hazeMesh);
        const _hazeCamera = new THREE.OrthographicCamera(-1,1,1,-1,0,1);

        // Resize render target with window
        window.addEventListener('resize', () => {
            _hazeRT.setSize(window.innerWidth, window.innerHeight);
        });

        function updateHeatHaze() {
            _ppTime += 0.016;

            // Wetness driven by the same _wetness scalar as groundMaterial
            _hazeMaterial.uniforms.uTime.value    = _ppTime;
            _hazeMaterial.uniforms.uWetness.value = _wetness;
        }
        
        // ===== ENHANCED LIGHTING =====
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3); // Back to white, reduced brightness
        scene.add(ambientLight);
        
        const sun = new THREE.DirectionalLight(0xffffff, 1.5); // Back to white, moderate brightness
        sun.position.set(50, 100, 50);
        sun.castShadow = true;
        sun.shadow.camera.left = -60;
        sun.shadow.camera.right = 60;
        sun.shadow.camera.top = 60;
        sun.shadow.camera.bottom = -60;
        sun.shadow.camera.near = 0.5;
        sun.shadow.camera.far = 200;
        sun.shadow.mapSize.width = 2048; // Keep higher quality shadows
        sun.shadow.mapSize.height = 2048;
        sun.shadow.bias = -0.0001;
        sun.shadow.radius = 2; // Keep softer shadow edges
        scene.add(sun);
        
        const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x8B7355, 0.4); // Original colors, reduced
        scene.add(hemiLight);
        
        // Add atmospheric fog for depth — values match default renderDistance of 100.
        // applyRenderDistance() is called after volumeSettings is declared below.
        scene.fog = new THREE.Fog(0x87CEEB, 80, 200);

        // Apply render distance: updates fog, camera clip plane, shadow frustum & map res.
        // Called after volumeSettings init and whenever the slider changes.
        function applyRenderDistance(dist) {
            volumeSettings.renderDistance = dist;

            // ── Fog ──────────────────────────────────────────────────────────
            scene.fog.near = dist * 0.4;
            scene.fog.far  = dist;

            // ── Camera clip plane ─────────────────────────────────────────────
            camera.far = dist * 1.15;
            camera.updateProjectionMatrix();

            // ── Shadow frustum ────────────────────────────────────────────────
            // Clamp shadow coverage to render distance so we never shadow geometry
            // the player can't see. Half-extent capped at 60 to preserve texel density.
            const shadowHalf = Math.min(dist * 0.5, 60);
            sun.shadow.camera.left   = -shadowHalf;
            sun.shadow.camera.right  =  shadowHalf;
            sun.shadow.camera.top    =  shadowHalf;
            sun.shadow.camera.bottom = -shadowHalf;
            sun.shadow.camera.far    = dist * 1.2;
            sun.shadow.camera.updateProjectionMatrix();

            // ── Shadow map resolution ─────────────────────────────────────────
            // Scale map size with render distance: smaller = fewer GPU pixels to fill.
            // ≤100 units → 512px, ≤160 → 1024px, >160 → 2048px (original quality).
            const newMapSize = dist <= 100 ? 512 : dist <= 160 ? 1024 : 2048;
            if (sun.shadow.mapSize.width !== newMapSize) {
                sun.shadow.mapSize.width  = newMapSize;
                sun.shadow.mapSize.height = newMapSize;
                // Dispose old shadow map so Three.js regenerates at the new size next frame
                if (sun.shadow.map) { sun.shadow.map.dispose(); sun.shadow.map = null; }
            }
        }
        
        // Flashlight
        const flashlight = new THREE.SpotLight(0xffd700, 0, 30, Math.PI / 6, 0.5, 2);
        flashlight.position.copy(camera.position);
        flashlight.target.position.set(0, 0, -1);
        flashlight.castShadow = true;
        flashlight.shadow.mapSize.width = 1024;
        flashlight.shadow.mapSize.height = 1024;
        scene.add(flashlight);
        scene.add(flashlight.target);
        let flashlightOn = false;
        
        // Lightning flash light - very bright white floodlight
        const lightningLight = new THREE.PointLight(0xffffff, 0, 150);
        lightningLight.position.set(0, 50, 0);
        scene.add(lightningLight);
        let lightningActive = false;
        let lightningStartTime = 0;
        let lightningDuration = 0;
        
        // ===== ENHANCED TERRAIN (FLATTENED) =====
        const groundSize = 200;
        // Simple single-quad \ufffd all variation handled in the shader, no vertex seams
        const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize, 1, 1);
        groundGeometry.computeVertexNormals();
        
        // ===== GRASS TEXTURE FROM IMAGE =====
        const rng = (min, max) => Math.random() * (max - min) + min;

        const grassCanvas = document.createElement('canvas');
        grassCanvas.width = 256;
        grassCanvas.height = 256;
        const grassCtx = grassCanvas.getContext('2d');
        // Load real grass photo — drawn into canvas so Three.js CanvasTexture picks it up
        const _grassImg = new Image();
        _grassImg.onload = () => { grassCtx.drawImage(_grassImg, 0, 0, 256, 256); if (typeof groundTexture !== 'undefined') groundTexture.needsUpdate = true; };
        _grassImg.src = 'data:image/jpeg;base64,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';

        // vnoise still needed for secondary grass texture (grassCanvas2)
        function vnoise(x, y, freq, seed) {
            const period = freq;
            const ix = Math.floor(x * freq), iy = Math.floor(y * freq);
            const fx = x * freq - ix, fy = y * freq - iy;
            const ux = fx * fx * (3 - 2 * fx), uy = fy * fy * (3 - 2 * fy);
            const ih = (px, py) => {
                const wx = ((px % period) + period) % period;
                const wy = ((py % period) + period) % period;
                let n = ((wx * 1619 + wy * 31337 + seed * 351) | 0) * 1540483477;
                n = (n ^ (n >>> 13)) * 1540483477;
                return ((n >>> 0) & 0xffff) / 65535;
            };
            return ih(ix,iy)*(1-ux)*(1-uy) + ih(ix+1,iy)*ux*(1-uy) +
                   ih(ix,iy+1)*(1-ux)*uy   + ih(ix+1,iy+1)*ux*uy;
        }

        // 256\ufffd256 pixel-by-pixel FBM \ufffd ~65k iterations, fast
        // grassCanvas filled by _grassImg.onload

                const groundTexture = new THREE.CanvasTexture(grassCanvas);
        groundTexture.wrapS = THREE.RepeatWrapping;
        groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set(24, 24);
        groundTexture.anisotropy = 4;

        // Dirt / mud texture for decals under trees & nodes - MUCH MORE VISIBLE
        const dirtCanvas = document.createElement('canvas');
        dirtCanvas.width = 128;
        dirtCanvas.height = 128;
        const dirtCtx = dirtCanvas.getContext('2d');
        dirtCtx.fillStyle = '#3d2510'; // Much darker brown for high contrast
        dirtCtx.fillRect(0, 0, 128, 128);
        for (let i = 0; i < 60; i++) {
            const px = rng(0, 128), py = rng(0, 128), r = rng(4, 18);
            const g = dirtCtx.createRadialGradient(px, py, 0, px, py, r);
            g.addColorStop(0, 'rgba(50,30,10,0.9)'); // Very dark and opaque
            g.addColorStop(1, 'rgba(40,25,8,0)');
            dirtCtx.fillStyle = g;
            dirtCtx.beginPath();
            dirtCtx.ellipse(px, py, r * 1.5, r * 0.8, rng(0, Math.PI), 0, Math.PI * 2);
            dirtCtx.fill();
        }
        for (let i = 0; i < 200; i++) {
            const px = rng(0, 128), py = rng(0, 128);
            dirtCtx.fillStyle = `rgba(${60+Math.random()*30|0},${40+Math.random()*15|0},${10+Math.random()*10|0},0.6)`; // Dark specks
            dirtCtx.fillRect(px, py, 1, 1);
        }
        const dirtTexture = new THREE.CanvasTexture(dirtCanvas);
        dirtTexture.wrapS = THREE.ClampToEdgeWrapping;
        dirtTexture.wrapT = THREE.ClampToEdgeWrapping;

        // Helper: place a round dirt decal at (x, z) with given radius
        function spawnDirtPatch(x, z, radius, darkness = 1.0) {
            // Geometry built directly in the XZ plane ? no rotation needed.
            const spokeCount = 18 + Math.floor(Math.random() * 10);
            const angleOffset = Math.random() * Math.PI * 2;
            const positions = [];
            const uvs = [];
            const indices = [];

            positions.push(0, 0, 0);
            uvs.push(0.5, 0.5);

            for (let i = 0; i < spokeCount; i++) {
                const angle = angleOffset + (i / spokeCount) * Math.PI * 2;
                const coarse = 1.0 + Math.sin(angle * (2 + Math.random() * 2)) * 0.22;
                const fine   = 1.0 + (Math.random() - 0.5) * 0.28;
                const lump   = Math.random() < 0.3 ? 1.0 + Math.random() * 0.25 : 1.0;
                const r = radius * coarse * fine * lump;
                positions.push(Math.cos(angle) * r, 0, Math.sin(angle) * r);
                uvs.push(0.5 + Math.cos(angle) * 0.5 * lump,
                         0.5 + Math.sin(angle) * 0.5 * lump);
            }

            for (let i = 1; i <= spokeCount; i++) {
                indices.push(0, i, i < spokeCount ? i + 1 : 1);
            }

            const decalGeo = new THREE.BufferGeometry();
            decalGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            decalGeo.setAttribute('uv',       new THREE.Float32BufferAttribute(uvs, 2));
            decalGeo.setIndex(indices);
            decalGeo.computeVertexNormals();

            // Create a detailed dirt texture procedurally
            const texSize = 256;
            const canvas = document.createElement('canvas');
            canvas.width = texSize;
            canvas.height = texSize;
            const ctx = canvas.getContext('2d');
            
            // Base dirt color
            const baseR = Math.round(0x3a * darkness);
            const baseG = Math.round(0x23 * darkness);
            const baseB = Math.round(0x10 * darkness);
            ctx.fillStyle = `rgb(${baseR},${baseG},${baseB})`;
            ctx.fillRect(0, 0, texSize, texSize);
            
            // Add dirt clumps and variation
            for (let i = 0; i < 150; i++) {
                const px = Math.random() * texSize;
                const py = Math.random() * texSize;
                const size = 5 + Math.random() * 20;
                const brightness = (30 + Math.random() * 40) * darkness;
                
                const gradient = ctx.createRadialGradient(px, py, 0, px, py, size);
                gradient.addColorStop(0, `rgba(${brightness + 20}, ${brightness}, ${brightness * 0.4}, 0.8)`);
                gradient.addColorStop(1, `rgba(${brightness}, ${brightness * 0.7}, ${brightness * 0.3}, 0)`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(px, py, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Add small pebbles and texture detail
            for (let i = 0; i < 400; i++) {
                const px = Math.random() * texSize;
                const py = Math.random() * texSize;
                const r = Math.random() * 3;
                const shade = (20 + Math.random() * 50) * darkness;
                ctx.fillStyle = `rgba(${shade}, ${shade * 0.8}, ${shade * 0.5}, ${0.5 + Math.random() * 0.5})`;
                ctx.beginPath();
                ctx.arc(px, py, r, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Add fine grain noise
            const imageData = ctx.getImageData(0, 0, texSize, texSize);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const noise = (Math.random() - 0.5) * 30;
                data[i] += noise;     // R
                data[i + 1] += noise * 0.8; // G
                data[i + 2] += noise * 0.6; // B
            }
            ctx.putImageData(imageData, 0, 0);
            
            const dirtTexture = new THREE.CanvasTexture(canvas);
            dirtTexture.wrapS = THREE.RepeatWrapping;
            dirtTexture.wrapT = THREE.RepeatWrapping;

            // MeshStandardMaterial with new detailed texture
            const decalMat = new THREE.MeshStandardMaterial({
                map: dirtTexture,
                roughness: 0.95,
                metalness: 0,
                side: THREE.DoubleSide,
                polygonOffset: true,
                polygonOffsetFactor: -10,
                polygonOffsetUnits: -10,
            });

            const decal = new THREE.Mesh(decalGeo, decalMat);
            decal.position.set(x, -0.01, z);
            decal.renderOrder = 2;
            decal.receiveShadow = true;
            return decal;
        }

        // Second seamless grass texture with different seeds for variety \ufffd no rotation artifacts
        const grassCanvas2 = document.createElement('canvas');
        grassCanvas2.width = 256; grassCanvas2.height = 256;
        const gc2 = grassCanvas2.getContext('2d');
        const imgData2 = gc2.createImageData(256, 256);
        const pix2 = imgData2.data;
        for (let gy = 0; gy < 256; gy++) {
            for (let gx = 0; gx < 256; gx++) {
                const nx = gx / 256, ny = gy / 256;
                const n1 = vnoise(nx, ny, 3,  99);
                const n2 = vnoise(nx, ny, 8,  17);
                const n3 = vnoise(nx, ny, 20, 55);
                const n4 = vnoise(nx, ny, 50, 88);
                const fbm = n1*0.50 + n2*0.28 + n3*0.14 + n4*0.08;
                let pr, pg, pb;
                if (fbm < 0.30) {
                    const t = fbm / 0.30;
                    pr = 4 + t * 5 | 0;   pg = 9 + t * 9 | 0;   pb = 3 + t * 3 | 0;
                } else if (fbm < 0.55) {
                    const t = (fbm - 0.30) / 0.25;
                    pr = 9 + t * 10 | 0;  pg = 18 + t * 18 | 0;  pb = 6 + t * 4 | 0;
                } else if (fbm < 0.75) {
                    const t = (fbm - 0.55) / 0.20;
                    pr = 19 + t * 12 | 0; pg = 36 + t * 12 | 0;  pb = 10 - t * 3 | 0;
                } else {
                    const t = (fbm - 0.75) / 0.25;
                    pr = 31 + t * 12 | 0; pg = 48 + t * 10 | 0;  pb = 7 + t * 5 | 0;
                }
                if (n4 > 0.88) { pr = pr*0.50|0; pg = pg*0.50|0; pb = pb*0.50|0; }
                if (n3 > 0.91 && n4 > 0.6) { pr = Math.min(255,pr+16); pg = Math.min(255,pg+14); pb = Math.min(255,pb+4); }
                const idx2 = (gy * 256 + gx) * 4;
                pix2[idx2]   = pr < 0 ? 0 : pr > 255 ? 255 : pr;
                pix2[idx2+1] = pg < 0 ? 0 : pg > 255 ? 255 : pg;
                pix2[idx2+2] = pb < 0 ? 0 : pb > 255 ? 255 : pb;
                pix2[idx2+3] = 255;
            }
        }
        gc2.putImageData(imgData2, 0, 0);
        for (let i = 0; i < 600; i++) {
            const bx = Math.random() * 256, by = Math.random() * 256;
            const bh = 3 + Math.random() * 9;
            const hue = 85 + (Math.random() - 0.5) * 28;
            const sat = 25 + Math.random() * 38;
            const lit = 3 + Math.random() * 8;
            const cpx = bx + (Math.random()-0.5)*4, cpy = by - bh*0.6;
            const epx = bx + (Math.random()-0.5)*5, epy = by - bh;
            gc2.strokeStyle = `hsla(${hue|0},${sat|0}%,${lit|0}%,${0.28 + Math.random()*0.45})`;
            gc2.lineWidth = 0.4 + Math.random() * 0.8;
            for (let ox = -256; ox <= 256; ox += 256) {
                for (let oy = -256; oy <= 256; oy += 256) {
                    gc2.beginPath();
                    gc2.moveTo(bx + ox, by + oy);
                    gc2.quadraticCurveTo(cpx + ox, cpy + oy, epx + ox, epy + oy);
                    gc2.stroke();
                }
            }
        }
        const groundTexture2 = new THREE.CanvasTexture(grassCanvas2);
        groundTexture2.wrapS = groundTexture2.wrapT = THREE.RepeatWrapping;
        groundTexture2.repeat.set(16, 16);
        groundTexture2.anisotropy = 4;

        const groundMaterial = new THREE.MeshStandardMaterial({
            map: groundTexture,
            roughness: 0.92,
            metalness: 0.0,
            color: 0xffffff,
            side: THREE.DoubleSide,
        });
        // Use alphaMap trick: blend two textures via UV offset so seams never align
        groundTexture.repeat.set(18, 18);
        groundTexture.offset.set(0.13, 0.27); // offset breaks symmetry
        
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        ground.renderOrder = 0;
        scene.add(ground);

        // ===================================================================
        // ===== BEACH BIOME + OCEAN =====
        // Beach: 22-unit wide tapered ring around island edges
        // Island inner edges: x=-100..300, z=-300..100
        // Beach outer edges:  x=-122..322, z=-322..122
        // Ocean starts at beach outer edge (y=-0.58)
        // ===================================================================
        {
            const BEACH_W  = 22;       // beach width in world units
            const OCEAN_Y  = -0.58;    // ocean surface Y (beach tapers to this)
            const ISL_XMIN = -100, ISL_XMAX = 300;
            const ISL_ZMIN = -300, ISL_ZMAX = 100;
            const BCH_XMIN = ISL_XMIN - BEACH_W, BCH_XMAX = ISL_XMAX + BEACH_W;
            const BCH_ZMIN = ISL_ZMIN - BEACH_W, BCH_ZMAX = ISL_ZMAX + BEACH_W;

            // ── Beach sand texture (high-detail: grain + ripples + wet darkening) ─
            const _beachSz  = 512;
            const _beachCvs = document.createElement('canvas');
            _beachCvs.width = _beachCvs.height = _beachSz;
            const _bCtx = _beachCvs.getContext('2d');
            const _bImg = _bCtx.createImageData(_beachSz, _beachSz);
            for (let gy = 0; gy < _beachSz; gy++) {
                for (let gx = 0; gx < _beachSz; gx++) {
                    const nx = gx / _beachSz, ny = gy / _beachSz;

                    // Multi-scale FBM base for large dune undulations
                    const base = vnoise(nx, ny, 2,  712) * 0.45
                               + vnoise(nx, ny, 6,  531) * 0.30
                               + vnoise(nx, ny, 14, 188) * 0.15
                               + vnoise(nx, ny, 30, 991) * 0.10;

                    // Fine sand grain (high freq noise)
                    const grain = vnoise(nx, ny, 80,  44) * 0.50
                                + vnoise(nx, ny, 160, 99) * 0.30
                                + vnoise(nx, ny, 260, 17) * 0.20;

                    // Wind-blown ripple lines — angled to look natural
                    const rippleA = Math.sin((nx * 1.7 + ny * 0.6) * 22.0
                                  + vnoise(nx, ny, 5, 333) * 2.5) * 0.5 + 0.5;
                    const rippleB = Math.sin((nx * 0.5 - ny * 1.3) * 18.0
                                  + vnoise(nx, ny, 7, 211) * 2.0) * 0.5 + 0.5;
                    // Blend two ripple directions for crossing patterns
                    const ripple = rippleA * 0.65 + rippleB * 0.35;

                    // Shell / pebble specks — rare bright flecks
                    const speck = vnoise(nx, ny, 200, 555) > 0.88 ? 0.18 : 0.0;

                    // Combine layers
                    const c = base * 0.38 + grain * 0.22 + ripple * 0.30 + speck + 0.05;
                    const cc = Math.min(1.0, Math.max(0.0, c));

                    // Warm golden sand palette
                    // shadow: #b89060  mid: #d4aa72  bright: #eecf98  highlight: #f8e8b8
                    let r, g, b;
                    if (cc < 0.25) {
                        const t = cc / 0.25;
                        r = 168 + t * 26 | 0;  g = 128 + t * 34 | 0;  b = 82  + t * 18 | 0;
                    } else if (cc < 0.55) {
                        const t = (cc - 0.25) / 0.30;
                        r = 194 + t * 34 | 0;  g = 162 + t * 38 | 0;  b = 100 + t * 22 | 0;
                    } else if (cc < 0.80) {
                        const t = (cc - 0.55) / 0.25;
                        r = 228 + t * 22 | 0;  g = 200 + t * 24 | 0;  b = 122 + t * 20 | 0;
                    } else {
                        const t = (cc - 0.80) / 0.20;
                        r = 250 - t * 10 | 0;  g = 224 - t * 6  | 0;  b = 142 + t * 20 | 0;
                    }

                    // Subtle blue-grey wet-sand tint near the base of the texture (y>0.7)
                    const wetness = Math.max(0, (ny - 0.65) / 0.35);
                    r = (r * (1 - wetness * 0.18)) | 0;
                    g = (g * (1 - wetness * 0.14)) | 0;
                    b = (b * (1 - wetness * 0.05) + wetness * 8) | 0;

                    const idx = (gy * _beachSz + gx) * 4;
                    _bImg.data[idx]   = Math.min(255, r);
                    _bImg.data[idx+1] = Math.min(255, g);
                    _bImg.data[idx+2] = Math.min(255, b);
                    _bImg.data[idx+3] = 255;
                }
            }
            _bCtx.putImageData(_bImg, 0, 0);
            const beachTex = new THREE.CanvasTexture(_beachCvs);
            beachTex.wrapS = beachTex.wrapT = THREE.RepeatWrapping;
            beachTex.repeat.set(0.35, 0.35); // slightly larger tiles = more visible grain

            // Roughness map — ripple crests slightly shinier (wet)
            const _bRoughCvs = document.createElement('canvas');
            _bRoughCvs.width = _bRoughCvs.height = 256;
            const _bRCtx = _bRoughCvs.getContext('2d');
            const _bRImg = _bRCtx.createImageData(256, 256);
            for (let gy = 0; gy < 256; gy++) {
                for (let gx = 0; gx < 256; gx++) {
                    const nx = gx / 256, ny = gy / 256;
                    const r2 = Math.sin((nx * 1.7 + ny * 0.6) * 22.0
                             + vnoise(nx, ny, 5, 333) * 2.5) * 0.5 + 0.5;
                    // High roughness overall (dry sand), dip at ripple crests
                    const rough = 0.82 - r2 * 0.22;
                    const v = (rough * 255) | 0;
                    const idx2 = (gy * 256 + gx) * 4;
                    _bRImg.data[idx2] = _bRImg.data[idx2+1] = _bRImg.data[idx2+2] = v;
                    _bRImg.data[idx2+3] = 255;
                }
            }
            _bRCtx.putImageData(_bRImg, 0, 0);
            const beachRoughTex = new THREE.CanvasTexture(_bRoughCvs);
            beachRoughTex.wrapS = beachRoughTex.wrapT = THREE.RepeatWrapping;
            beachRoughTex.repeat.set(0.35, 0.35);

            const beachMat = new THREE.MeshStandardMaterial({
                map:          beachTex,
                roughnessMap: beachRoughTex,
                roughness:    0.90,
                metalness:    0.0,
                envMapIntensity: 0.15,
            });

            // ── Generic beach geometry builder ───────────────────────────────
            // Builds a tapered beach mesh over any rectangular region.
            // Vertex Y is computed from how far the point lies outside the island.
            function _buildBeachGeo(xMin, xMax, zMin, zMax, xSegs, zSegs) {
                const positions = [];
                const normals   = [];
                const uvsArr    = [];
                const indices   = [];

                for (let iz = 0; iz <= zSegs; iz++) {
                    const wz = zMin + (zMax - zMin) * (iz / zSegs);
                    for (let ix = 0; ix <= xSegs; ix++) {
                        const wx = xMin + (xMax - xMin) * (ix / xSegs);

                        // Distance fraction outside island (0 = island edge, 1 = beach outer edge)
                        const dE = Math.max(0, wx - ISL_XMAX) / BEACH_W;
                        const dW = Math.max(0, ISL_XMIN - wx) / BEACH_W;
                        const dN = Math.max(0, wz - ISL_ZMAX) / BEACH_W;
                        const dS = Math.max(0, ISL_ZMIN - wz) / BEACH_W;
                        const t  = Math.min(1, Math.max(dE, dW, dN, dS));

                        // Smooth power curve: shallow at top, steeper near waterline
                        const wy = OCEAN_Y * Math.pow(t, 0.65);

                        positions.push(wx, wy, wz);
                        normals.push(0, 1, 0);
                        uvsArr.push(wx / 16, wz / 16);
                    }
                }

                for (let iz = 0; iz < zSegs; iz++) {
                    for (let ix = 0; ix < xSegs; ix++) {
                        const a = iz * (xSegs + 1) + ix;
                        const b = a + 1;
                        const c = a + (xSegs + 1);
                        const d = c + 1;
                        indices.push(a, c, b,  b, c, d);
                    }
                }

                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geo.setAttribute('normal',   new THREE.Float32BufferAttribute(normals, 3));
                geo.setAttribute('uv',       new THREE.Float32BufferAttribute(uvsArr, 2));
                geo.setIndex(indices);
                return geo;
            }

            function _addBeach(xMin, xMax, zMin, zMax, xS, zS) {
                const mesh = new THREE.Mesh(_buildBeachGeo(xMin, xMax, zMin, zMax, xS, zS), beachMat);
                mesh.receiveShadow = true;
                mesh.renderOrder   = 0;
                scene.add(mesh);
            }

            // 4 side strips
            _addBeach(ISL_XMIN, ISL_XMAX, ISL_ZMAX, BCH_ZMAX, 40, 8);  // North
            _addBeach(ISL_XMIN, ISL_XMAX, BCH_ZMIN, ISL_ZMIN, 40, 8);  // South
            _addBeach(BCH_XMIN, ISL_XMIN, ISL_ZMIN, ISL_ZMAX, 8,  40); // West
            _addBeach(ISL_XMAX, BCH_XMAX, ISL_ZMIN, ISL_ZMAX, 8,  40); // East
            // 4 corners
            _addBeach(BCH_XMIN, ISL_XMIN, ISL_ZMAX, BCH_ZMAX, 8, 8);   // NW
            _addBeach(ISL_XMAX, BCH_XMAX, ISL_ZMAX, BCH_ZMAX, 8, 8);   // NE
            _addBeach(BCH_XMIN, ISL_XMIN, BCH_ZMIN, ISL_ZMIN, 8, 8);   // SW
            _addBeach(ISL_XMAX, BCH_XMAX, BCH_ZMIN, ISL_ZMIN, 8, 8);   // SE

            // ── Animated ocean ──────────────────────────────────────────────
            const OCEAN_SIZE     = 2400;
            const OCEAN_CENTER_X = (ISL_XMIN + ISL_XMAX) / 2;  // 100
            const OCEAN_CENTER_Z = (ISL_ZMIN + ISL_ZMAX) / 2;  // -100

            const oceanMat = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uNight: { value: 0.0 } },
                vertexShader: `
                    uniform float uTime;
                    varying vec2 vW;
                    varying float vH;
                    void main() {
                        vW = position.xz;
                        vec3 p = position;
                        // Several waves at different angles — large swell dominates
                        float h = sin(p.x*0.040 + p.z*0.020 + uTime*0.90)*0.30
                                + sin(p.x*0.020 - p.z*0.045 + uTime*0.70)*0.20
                                + sin(p.x*0.060 + p.z*0.055 + uTime*1.20)*0.10
                                + sin(p.x*0.008 + p.z*0.012 + uTime*0.50)*0.45;
                        p.y += h;
                        vH = h;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(p,1.0);
                    }
                `,
                fragmentShader: `
                    uniform float uTime;
                    uniform float uNight;
                    varying vec2 vW;
                    varying float vH;

                    // Tiling value noise — NO visible grid
                    // Uses a hash that avoids the integer-boundary artifacts
                    float h2(vec2 p) {
                        p = fract(p * vec2(0.1031, 0.1030));
                        p += dot(p, p.yx + 33.33);
                        return fract((p.x + p.y) * p.x);
                    }
                    float vn(vec2 p) {
                        vec2 i = floor(p), f = fract(p);
                        // Hermite interpolation
                        vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);
                        float a = h2(i),            b = h2(i+vec2(1,0));
                        float c = h2(i+vec2(0,1)),  d = h2(i+vec2(1,1));
                        return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
                    }
                    // Domain-warped FBM: warp the input coords by another fbm
                    // so patterns curl organically with zero straight lines
                    float fbm(vec2 p) {
                        float v=0.0, a=0.52;
                        mat2 R = mat2(0.8,-0.6,0.6,0.8); // rotation prevents axis-aligned artefacts
                        for(int i=0;i<6;i++){v+=a*vn(p);p=R*p*2.03+7.1;a*=0.48;}
                        return v;
                    }
                    float wfbm(vec2 p) {
                        // Two layers of warp
                        vec2 q = vec2(fbm(p+vec2(0.0,0.0)), fbm(p+vec2(5.2,1.3)));
                        vec2 r = vec2(fbm(p+2.2*q+vec2(1.7,9.2)), fbm(p+2.2*q+vec2(8.3,2.8)));
                        return fbm(p + 2.4*r);
                    }

                    void main() {
                        // Water colour — elevation driven
                        float t = smoothstep(-0.6, 0.6, vH);
                        vec3 deep  = vec3(0.03, 0.15, 0.30);
                        vec3 mid   = vec3(0.06, 0.32, 0.52);
                        vec3 surf  = vec3(0.14, 0.52, 0.70);
                        vec3 col   = mix(deep, mid, t);
                        col        = mix(col,  surf, t*t);

                        // Surface detail — TWO scrolling wfbm layers at different scales/speeds
                        // These give the water visible texture without straight lines
                        vec2 s1 = vW*0.008 + vec2(uTime*0.025, uTime*0.018);
                        vec2 s2 = vW*0.014 - vec2(uTime*0.019, uTime*0.031);
                        float detail = wfbm(s1)*0.55 + wfbm(s2)*0.45;
                        // Lighten surface where detail is high (refracted light)
                        col = mix(col, surf*1.3, smoothstep(0.45,0.72,detail)*0.28);

                        // Specular glints — small bright flecks on wave faces
                        float spec = pow(smoothstep(0.60,0.80,detail), 3.0)*0.5;
                        col += vec3(1.0,0.98,0.92)*spec;

                        // Night darkening — ocean goes nearly black
                        float daylight = 1.0 - uNight;
                        col = mix(vec3(0.01, 0.02, 0.04), col, max(daylight * 1.2, 0.0));
                        col = clamp(col, 0.0, 1.0);

                        gl_FragColor = vec4(col, 0.97);
                    }
                `,
                transparent: true,
                side: THREE.FrontSide,
            });

            const OCN_EXT = 1200;
            const oceanPanels = [
                { cx: BCH_XMIN - OCN_EXT/2, cz: OCEAN_CENTER_Z, w: OCN_EXT, d: OCEAN_SIZE },
                { cx: BCH_XMAX + OCN_EXT/2, cz: OCEAN_CENTER_Z, w: OCN_EXT, d: OCEAN_SIZE },
                { cx: OCEAN_CENTER_X, cz: BCH_ZMAX + OCN_EXT/2, w: BCH_XMAX - BCH_XMIN, d: OCN_EXT },
                { cx: OCEAN_CENTER_X, cz: BCH_ZMIN - OCN_EXT/2, w: BCH_XMAX - BCH_XMIN, d: OCN_EXT },
            ];
            oceanPanels.forEach(p => {
                const segX = Math.round(p.w / 10);
                const segZ = Math.round(p.d / 10);
                const geo = new THREE.PlaneGeometry(p.w, p.d, segX, segZ);
                const mesh = new THREE.Mesh(geo, oceanMat);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.set(p.cx, OCEAN_Y - 0.01, p.cz);
                mesh.renderOrder = -1;
                scene.add(mesh);
            });

            window._customAnimators = window._customAnimators || [];
            window._customAnimators.push(dt => {
                oceanMat.uniforms.uTime.value += dt;
                // Sync night darkening — read from sky shader which is always updated
                if (sky && sky.material && sky.material.uniforms.uNight) {
                    oceanMat.uniforms.uNight.value = sky.material.uniforms.uNight.value;
                }
            });
        }

        // ===== PLAYER ISLAND BOUNDARY =====
        // Player can walk the beach but not into the ocean
        const _ISLAND_XMIN = -120, _ISLAND_XMAX = 320;
        const _ISLAND_ZMIN = -320, _ISLAND_ZMAX = 120;

        // ===== DESERT BIOME TERRAIN =====
        // Placed adjacent to the grass biome, offset by groundSize along Z axis
        const desertOffset = groundSize; // sits directly north of the grass biome

        // ===== DESERT SAND TEXTURE \ufffd complete rebuild =====
        // 512px for crisp detail. Uses same seamless vnoise as grass.
        const SAND_SZ = 512;

        // Helper: clamp to [0,255]
        const clamp8 = v => v < 0 ? 0 : v > 255 ? 255 : v | 0;

        // ---- Base sand pixel layer ----
        // Three FBM octave sets at different frequencies build:
        //   large dune-scale colour swells, medium ripple bands, fine grain speckle
        const sandCanvas = document.createElement('canvas');
        sandCanvas.width = SAND_SZ; sandCanvas.height = SAND_SZ;
        const sandCtx = sandCanvas.getContext('2d');
        const sandImgData = sandCtx.createImageData(SAND_SZ, SAND_SZ);
        const sandPix = sandImgData.data;

        for (let gy = 0; gy < SAND_SZ; gy++) {
            for (let gx = 0; gx < SAND_SZ; gx++) {
                const nx = gx / SAND_SZ, ny = gy / SAND_SZ;

                // Large dune swells \ufffd very low frequency
                const dune  = vnoise(nx, ny, 2, 301) * 0.6 + vnoise(nx, ny, 4, 177) * 0.4;

                // Wind-ripple bands \ufffd directional, predominantly along X axis
                // Use anisotropic sampling: stretch Y coordinate to create horizontal banding
                const ripA  = vnoise(nx * 0.6, ny * 3.5, 6,  119);  // coarse ripples
                const ripB  = vnoise(nx * 0.5, ny * 6.0, 12, 83);   // fine ripples
                const rip   = ripA * 0.55 + ripB * 0.45;

                // Fine grain noise
                const grain1 = vnoise(nx, ny, 28, 251);
                const grain2 = vnoise(nx, ny, 60, 193);
                const grain  = grain1 * 0.6 + grain2 * 0.4;

                // Composite \ufffd dune shape dominates colour, ripple modulates mid, grain adds texture
                const composite = dune * 0.45 + rip * 0.35 + grain * 0.20;

                // Sand colour palette:
                //   shadow troughs  ? deep amber-brown  (r?140 g?108 b?58)
                //   mid tone        ? warm golden sand   (r?196 g?162 b?88)
                //   sun-bleached crest ? pale ivory      (r?232 g?210 b?152)
                let sr, sg, sb;
                if (composite < 0.28) {
                    const t = composite / 0.28;
                    sr = 118 + t * 36 | 0;  sg = 88  + t * 30 | 0;  sb = 44 + t * 20 | 0;
                } else if (composite < 0.52) {
                    const t = (composite - 0.28) / 0.24;
                    sr = 154 + t * 42 | 0;  sg = 118 + t * 38 | 0;  sb = 64 + t * 24 | 0;
                } else if (composite < 0.72) {
                    const t = (composite - 0.52) / 0.20;
                    sr = 196 + t * 28 | 0;  sg = 156 + t * 30 | 0;  sb = 88 + t * 22 | 0;
                } else {
                    const t = (composite - 0.72) / 0.28;
                    sr = 224 + t * 18 | 0;  sg = 186 + t * 24 | 0;  sb = 110 + t * 30 | 0;
                }

                // Ripple shadow: where ripple troughs are deep, darken sharply
                if (ripA < 0.22) {
                    const shadow = (0.22 - ripA) / 0.22;
                    sr = sr * (1 - shadow * 0.38) | 0;
                    sg = sg * (1 - shadow * 0.40) | 0;
                    sb = sb * (1 - shadow * 0.35) | 0;
                }

                // Ripple highlight: crest catches light
                if (ripA > 0.80 && ripB > 0.60) {
                    const highlight = (ripA - 0.80) / 0.20;
                    sr = Math.min(255, sr + (highlight * 28 | 0));
                    sg = Math.min(255, sg + (highlight * 22 | 0));
                    sb = Math.min(255, sb + (highlight * 14 | 0));
                }

                // Occasional dark mineral specks (iron oxide, tiny pebbles)
                if (grain2 > 0.91 && grain1 < 0.45) {
                    sr = sr * 0.58 | 0;  sg = sg * 0.52 | 0;  sb = sb * 0.44 | 0;
                }

                // Occasional pale quartz glints
                if (grain1 > 0.93 && grain2 > 0.70) {
                    sr = Math.min(255, sr + 34);  sg = Math.min(255, sg + 28);  sb = Math.min(255, sb + 18);
                }

                const sidx = (gy * SAND_SZ + gx) * 4;
                sandPix[sidx]   = clamp8(sr);
                sandPix[sidx+1] = clamp8(sg);
                sandPix[sidx+2] = clamp8(sb);
                sandPix[sidx+3] = 255;
            }
        }
        sandCtx.putImageData(sandImgData, 0, 0);

        // ---- Drawn ripple strokes \ufffd long, nearly-horizontal, low opacity ----
        // These mimic the fine parallel wind-scour lines visible on real desert sand
        for (let i = 0; i < 900; i++) {
            const bx = Math.random() * SAND_SZ;
            const by = Math.random() * SAND_SZ;
            // Mostly horizontal ripples with slight wave
            const len   = 18 + Math.random() * 40;
            const wave  = (Math.random() - 0.5) * 6;
            const cpx   = bx + len * 0.5 + wave;
            const cpy   = by + (Math.random() - 0.5) * 4;
            const epx   = bx + len;
            const epy   = by + (Math.random() - 0.5) * 5;
            const hue   = 34 + (Math.random() - 0.5) * 10;
            const sat   = 28 + Math.random() * 22;
            // Alternate between shadow lines (dark) and highlight lines (light)
            const isHighlight = Math.random() < 0.35;
            const lit   = isHighlight ? 72 + Math.random() * 18 : 24 + Math.random() * 16;
            const alpha = isHighlight ? 0.10 + Math.random() * 0.18 : 0.14 + Math.random() * 0.22;
            sandCtx.strokeStyle = `hsla(${hue|0},${sat|0}%,${lit|0}%,${alpha.toFixed(2)})`;
            sandCtx.lineWidth   = 0.4 + Math.random() * 1.0;
            for (let ox = -SAND_SZ; ox <= SAND_SZ; ox += SAND_SZ) {
                for (let oy = -SAND_SZ; oy <= SAND_SZ; oy += SAND_SZ) {
                    sandCtx.beginPath();
                    sandCtx.moveTo(bx + ox, by + oy);
                    sandCtx.quadraticCurveTo(cpx + ox, cpy + oy, epx + ox, epy + oy);
                    sandCtx.stroke();
                }
            }
        }

        // ---- Tiny grain speckles drawn on top ----
        for (let i = 0; i < 1200; i++) {
            const px  = Math.random() * SAND_SZ;
            const py  = Math.random() * SAND_SZ;
            const r   = 0.4 + Math.random() * 1.1;
            const dark = Math.random() < 0.5;
            const lit2 = dark ? 18 + Math.random() * 20 : 70 + Math.random() * 25;
            const a2   = 0.12 + Math.random() * 0.28;
            sandCtx.fillStyle = `hsla(34,${25 + Math.random()*20 | 0}%,${lit2 | 0}%,${a2.toFixed(2)})`;
            sandCtx.beginPath();
            sandCtx.arc(px, py, r, 0, Math.PI * 2);
            sandCtx.fill();
        }

        const sandTexture = new THREE.CanvasTexture(sandCanvas);
        sandTexture.wrapS = THREE.RepeatWrapping;
        sandTexture.wrapT = THREE.RepeatWrapping;
        sandTexture.repeat.set(14, 14);
        sandTexture.offset.set(0.07, 0.19);
        sandTexture.anisotropy = 16;

        // ---- Second sand texture \ufffd different dune phase + cross-ripple direction ----
        // Ripples run diagonally to break up any repeat pattern when both layers tile
        const sandCanvas2 = document.createElement('canvas');
        sandCanvas2.width = SAND_SZ; sandCanvas2.height = SAND_SZ;
        const sc2 = sandCanvas2.getContext('2d');
        const sandImgData2 = sc2.createImageData(SAND_SZ, SAND_SZ);
        const sandPix2 = sandImgData2.data;

        for (let gy = 0; gy < SAND_SZ; gy++) {
            for (let gx = 0; gx < SAND_SZ; gx++) {
                const nx = gx / SAND_SZ, ny = gy / SAND_SZ;

                const dune  = vnoise(nx, ny, 2, 409) * 0.6 + vnoise(nx, ny, 4, 317) * 0.4;
                // Cross-diagonal ripples
                const diag  = (nx + ny) * 0.5;
                const ripA  = vnoise(diag * 0.7, ny * 2.5, 7,  53);
                const ripB  = vnoise(diag * 0.5, ny * 5.0, 14, 167);
                const rip   = ripA * 0.55 + ripB * 0.45;
                const grain1 = vnoise(nx, ny, 30, 277);
                const grain2 = vnoise(nx, ny, 65, 331);
                const grain  = grain1 * 0.6 + grain2 * 0.4;

                const composite = dune * 0.45 + rip * 0.35 + grain * 0.20;

                let sr, sg, sb;
                if (composite < 0.28) {
                    const t = composite / 0.28;
                    sr = 122 + t * 34 | 0;  sg = 90  + t * 28 | 0;  sb = 46 + t * 18 | 0;
                } else if (composite < 0.52) {
                    const t = (composite - 0.28) / 0.24;
                    sr = 156 + t * 40 | 0;  sg = 118 + t * 38 | 0;  sb = 64 + t * 24 | 0;
                } else if (composite < 0.72) {
                    const t = (composite - 0.52) / 0.20;
                    sr = 196 + t * 26 | 0;  sg = 156 + t * 28 | 0;  sb = 88 + t * 20 | 0;
                } else {
                    const t = (composite - 0.72) / 0.28;
                    sr = 222 + t * 20 | 0;  sg = 184 + t * 26 | 0;  sb = 108 + t * 32 | 0;
                }

                if (ripA < 0.22) {
                    const shadow = (0.22 - ripA) / 0.22;
                    sr = sr * (1 - shadow * 0.36) | 0;
                    sg = sg * (1 - shadow * 0.38) | 0;
                    sb = sb * (1 - shadow * 0.33) | 0;
                }
                if (ripA > 0.80 && ripB > 0.60) {
                    const highlight = (ripA - 0.80) / 0.20;
                    sr = Math.min(255, sr + (highlight * 26 | 0));
                    sg = Math.min(255, sg + (highlight * 20 | 0));
                    sb = Math.min(255, sb + (highlight * 12 | 0));
                }
                if (grain2 > 0.91 && grain1 < 0.45) {
                    sr = sr * 0.58 | 0;  sg = sg * 0.52 | 0;  sb = sb * 0.44 | 0;
                }
                if (grain1 > 0.93 && grain2 > 0.70) {
                    sr = Math.min(255, sr + 32);  sg = Math.min(255, sg + 26);  sb = Math.min(255, sb + 16);
                }

                const sidx2 = (gy * SAND_SZ + gx) * 4;
                sandPix2[sidx2]   = clamp8(sr);
                sandPix2[sidx2+1] = clamp8(sg);
                sandPix2[sidx2+2] = clamp8(sb);
                sandPix2[sidx2+3] = 255;
            }
        }
        sc2.putImageData(sandImgData2, 0, 0);

        for (let i = 0; i < 900; i++) {
            const bx = Math.random() * SAND_SZ, by = Math.random() * SAND_SZ;
            const len = 18 + Math.random() * 40;
            const ang = 0.35 + Math.random() * 0.3; // slight diagonal
            const epx = bx + Math.cos(ang) * len, epy = by + Math.sin(ang) * len;
            const cpx = bx + Math.cos(ang) * len * 0.5 + (Math.random()-0.5)*5;
            const cpy = by + Math.sin(ang) * len * 0.5 + (Math.random()-0.5)*5;
            const isH = Math.random() < 0.35;
            const lit = isH ? 70 + Math.random() * 20 : 22 + Math.random() * 18;
            const alpha = isH ? 0.09 + Math.random() * 0.16 : 0.13 + Math.random() * 0.20;
            sc2.strokeStyle = `hsla(34,${22 + Math.random()*22 | 0}%,${lit | 0}%,${alpha.toFixed(2)})`;
            sc2.lineWidth = 0.4 + Math.random() * 1.0;
            for (let ox = -SAND_SZ; ox <= SAND_SZ; ox += SAND_SZ) {
                for (let oy = -SAND_SZ; oy <= SAND_SZ; oy += SAND_SZ) {
                    sc2.beginPath();
                    sc2.moveTo(bx + ox, by + oy);
                    sc2.quadraticCurveTo(cpx + ox, cpy + oy, epx + ox, epy + oy);
                    sc2.stroke();
                }
            }
        }
        for (let i = 0; i < 1200; i++) {
            const px = Math.random() * SAND_SZ, py = Math.random() * SAND_SZ;
            const r  = 0.4 + Math.random() * 1.1;
            const dk = Math.random() < 0.5;
            const l2 = dk ? 18 + Math.random() * 20 : 68 + Math.random() * 26;
            const a2 = 0.10 + Math.random() * 0.26;
            sc2.fillStyle = `hsla(34,${24 + Math.random()*20 | 0}%,${l2 | 0}%,${a2.toFixed(2)})`;
            sc2.beginPath();
            sc2.arc(px, py, r, 0, Math.PI * 2);
            sc2.fill();
        }

        const sandTexture2 = new THREE.CanvasTexture(sandCanvas2);
        sandTexture2.wrapS = sandTexture2.wrapT = THREE.RepeatWrapping;
        sandTexture2.repeat.set(11, 11);
        sandTexture2.anisotropy = 16;

        // Desert ground mesh
        const desertGeometry = new THREE.PlaneGeometry(groundSize, groundSize, 1, 1);
        desertGeometry.computeVertexNormals();
        const desertMaterial = new THREE.MeshStandardMaterial({
            map: sandTexture,
            roughness: 0.88,
            metalness: 0.0,
            color: 0xffffff,
            polygonOffset: true,
            polygonOffsetFactor: -1,
            polygonOffsetUnits: -1,
        });
        const desertGround = new THREE.Mesh(desertGeometry, desertMaterial);
        desertGround.rotation.x = -Math.PI / 2;
        desertGround.position.set(0, 0.002, -desertOffset + 0.5); // raised 2mm above grass to prevent Z-fighting
        desertGround.receiveShadow = true;
        desertGround.renderOrder = 0;
        scene.add(desertGround);

        // Large angular sandstone formations inspired by desert landscapes
        // Desert formation collision radii - populated as formations are created
        const desertFormationColliders = []; // { x, z, r }

        function createDesertFormation(x, z) {
            const group = new THREE.Group();
            const formationType = Math.floor(Math.random() * 4);

            function makeDesertRockTexture() {
                const tc = document.createElement('canvas');
                tc.width = 512; tc.height = 512;
                const tx = tc.getContext('2d');
                tx.fillStyle = '#b8905a';
                tx.fillRect(0, 0, 512, 512);
                for (let i = 0; i < 40; i++) {
                    const px = Math.random() * 512, py = Math.random() * 512;
                    const r = 40 + Math.random() * 100;
                    const grd = tx.createRadialGradient(px, py, 0, px, py, r);
                    if (Math.random() > 0.45) {
                        grd.addColorStop(0, `rgba(210,175,115,${0.30 + Math.random()*0.30})`);
                    } else {
                        grd.addColorStop(0, `rgba(110,75,38,${0.22 + (py/512)*0.28})`);
                    }
                    grd.addColorStop(1, 'rgba(0,0,0,0)');
                    tx.fillStyle = grd;
                    tx.fillRect(0, 0, 512, 512);
                }
                for (let i = 0; i < 18; i++) {
                    const y = Math.random() * 512;
                    tx.save();
                    tx.strokeStyle = `rgba(${Math.random()>0.5?'90,60,25':'195,162,108'},${0.18+Math.random()*0.25})`;
                    tx.lineWidth = 1 + Math.random() * 3;
                    tx.beginPath(); tx.moveTo(0, y);
                    for (let sx = 0; sx < 512; sx += 40) tx.lineTo(sx + 40, y + (Math.random()-0.5) * 8);
                    tx.stroke(); tx.restore();
                }
                for (let i = 0; i < 10; i++) {
                    tx.save();
                    tx.strokeStyle = `rgba(40,25,10,${0.45+Math.random()*0.35})`;
                    tx.lineWidth = 0.8 + Math.random() * 2;
                    let cx = Math.random()*512, cy = Math.random()*512;
                    tx.beginPath(); tx.moveTo(cx, cy);
                    for (let j = 0; j < 5; j++) { cx += (Math.random()-0.5)*70; cy += (Math.random()-0.5)*70; tx.lineTo(cx, cy); }
                    tx.stroke(); tx.restore();
                }
                for (let i = 0; i < 6000; i++) {
                    const px = Math.random()*512, py = Math.random()*512;
                    tx.fillStyle = Math.random() > 0.55
                        ? `rgba(210,178,120,${0.06+Math.random()*0.14})`
                        : `rgba(30,18,8,${0.06+Math.random()*0.14})`;
                    tx.fillRect(px, py, 1+Math.random(), 1+Math.random());
                }
                const t = new THREE.CanvasTexture(tc);
                t.wrapS = t.wrapT = THREE.RepeatWrapping;
                t.anisotropy = 8;
                return t;
            }

            // Sandstone rock: shared-vertex lattice so no corner gaps.
            // Deformation is purely RADIAL (outward from centre axis) so no
            // overhangs or spikes - just natural rounded-but-angular desert rock.
            function makeRockMesh(w, h, d, sinkDepth) {
                sinkDepth = sinkDepth !== undefined ? sinkDepth : h * 0.28;
                const totalH = h + sinkDepth;
                const nx = 6, ny = 8, nz = 6;

                // Per-rock random seeds for smooth variation
                const freq1 = 1.8 + Math.random() * 1.4;
                const freq2 = 3.2 + Math.random() * 1.6;
                const ph1   = Math.random() * 6.28;
                const ph2   = Math.random() * 6.28;
                const ph3   = Math.random() * 6.28;

                // Smooth angular perturbation around the circumference (no overhangs)
                function radialNoise(angle, t) {
                    return Math.sin(angle * freq1 + ph1) * 0.5
                         + Math.sin(angle * freq2 + ph2) * 0.25
                         + Math.sin(angle * 1.0  + ph3) * 0.25;
                }

                // Slight random lean per rock
                const leanX = (Math.random()-0.5) * 0.12;
                const leanZ = (Math.random()-0.5) * 0.12;

                const pts = [];
                for (let iy = 0; iy <= ny; iy++) {
                    for (let iz = 0; iz <= nz; iz++) {
                        for (let ix = 0; ix <= nx; ix++) {
                            const u = ix/nx - 0.5;   // -0.5..0.5
                            const v = iy/ny;          // 0..1 bottom to top
                            const s = iz/nz - 0.5;

                            let px = u * w;
                            let py = (v - 0.5) * totalH;
                            let pz = s * d;

                            const aboveGround = py > (-totalH*0.5 + sinkDepth);

                            if (aboveGround) {
                                // t: 0=ground level, 1=peak
                                const t = (py - (-totalH*0.5 + sinkDepth)) / h;

                                // Profile: wider at base, tapers cleanly to top
                                // sin curve gives a natural bulge in lower-middle
                                const taper = 1.0
                                    + 0.12 * Math.sin(t * Math.PI * 0.9)  // gentle belly
                                    - 0.40 * Math.pow(t, 1.6);             // clean top taper

                                // Angle around vertical axis - used for smooth radial noise
                                const angle = Math.atan2(s, u);
                                const radialDist = Math.sqrt(u*u + s*s); // 0 at centre, ~0.7 at corner

                                // Radial scale: noise only pushes/pulls along the radius,
                                // never inward past centre so no overhangs
                                const noiseMag = radialNoise(angle, t) * 0.18 * (0.4 + 0.6 * radialDist);
                                const scaledTaper = Math.max(0.25, taper + noiseMag);

                                px *= scaledTaper;
                                pz *= scaledTaper;

                                // Lean: shift top of rock sideways
                                px += leanX * t * h * 0.4;
                                pz += leanZ * t * h * 0.4;

                                // Small y jitter for height variation (sediment layers look)
                                // Only on the outer shell verts, keep centre clean
                                py += (Math.random()-0.5) * h * 0.045;

                                // Subtle XZ facet jitter - keeps angular character
                                // but capped so it never creates spikes
                                const jitter = 0.032 + t * 0.055;
                                px += (Math.random()-0.5) * w * jitter;
                                pz += (Math.random()-0.5) * d * jitter;
                            }

                            pts.push([px, py, pz]);
                        }
                    }
                }

                const idxF = (ix,iy,iz) => iy*(nx+1)*(nz+1) + iz*(nx+1) + ix;
                const positions = [], normals = [], uvs = [], indices = [];

                function addQuad(a,b,c,dd) {
                    const base = positions.length / 3;
                    [a,b,c,dd].forEach(i => positions.push(...pts[i]));
                    const ax=pts[b][0]-pts[a][0], ay=pts[b][1]-pts[a][1], az=pts[b][2]-pts[a][2];
                    const bx=pts[c][0]-pts[a][0], by=pts[c][1]-pts[a][1], bz=pts[c][2]-pts[a][2];
                    const nx2=ay*bz-az*by, ny2=az*bx-ax*bz, nz2=ax*by-ay*bx;
                    const nl=Math.sqrt(nx2*nx2+ny2*ny2+nz2*nz2)||1;
                    for(let k=0;k<4;k++) normals.push(nx2/nl,ny2/nl,nz2/nl);
                    uvs.push(0,0,1,0,1,1,0,1);
                    indices.push(base,base+1,base+2, base,base+2,base+3);
                }

                for (let iy=0; iy<ny; iy++) {
                    for (let iz=0; iz<nz; iz++) {
                        for (let ix=0; ix<nx; ix++) {
                            const a=idxF(ix,iy,iz),    b=idxF(ix+1,iy,iz);
                            const c=idxF(ix+1,iy,iz+1), dd=idxF(ix,iy,iz+1);
                            const e=idxF(ix,iy+1,iz),   f=idxF(ix+1,iy+1,iz);
                            const g=idxF(ix+1,iy+1,iz+1), hh=idxF(ix,iy+1,iz+1);
                            if (iy===ny-1) addQuad(e,f,g,hh);
                            if (iy===0)    addQuad(dd,c,b,a);
                            if (iz===0)    addQuad(b,a,e,f);
                            if (iz===nz-1) addQuad(dd,c,g,hh);
                            if (ix===0)    addQuad(a,dd,hh,e);
                            if (ix===nx-1) addQuad(c,b,f,g);
                        }
                    }
                }

                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geo.setAttribute('normal',   new THREE.Float32BufferAttribute(normals,   3));
                geo.setAttribute('uv',       new THREE.Float32BufferAttribute(uvs,       2));
                geo.setIndex(indices);

                const mat = new THREE.MeshStandardMaterial({
                    map: makeDesertRockTexture(),
                    roughness: 0.93,
                    metalness: 0.02,
                    flatShading: true,
                    color: new THREE.Color(
                        0.82 + Math.random()*0.12,
                        0.72 + Math.random()*0.10,
                        0.52 + Math.random()*0.08
                    )
                });
                return new THREE.Mesh(geo, mat);
            }

            let collisionRadius = 3;

            if (formationType === 0) {
                // Tall narrow monolith - single angular column sunk into the sand
                const h = 6 + Math.random() * 5;
                const w = 1.8 + Math.random() * 1.2;
                const sink = h * 0.28;
                const m = makeRockMesh(w, h, w * (0.7 + Math.random()*0.5), sink);
                m.position.y = h/2 - sink * 0.5; // centre accounting for sink
                m.rotation.y = Math.random() * Math.PI;
                m.castShadow = m.receiveShadow = true;
                group.add(m);
                if (Math.random() > 0.4) {
                    const h2 = 3 + Math.random() * 3;
                    const sink2 = h2 * 0.25;
                    const m2 = makeRockMesh(w*0.6, h2, w*0.5, sink2);
                    m2.position.set(w*0.85, h2/2 - sink2*0.5, (Math.random()-0.5)*w*0.8);
                    m2.rotation.y = Math.random() * Math.PI;
                    m2.rotation.z = (Math.random()-0.5) * 0.22;
                    m2.castShadow = m2.receiveShadow = true;
                    group.add(m2);
                }
                collisionRadius = w * 1.1 + 1.0;

            } else if (formationType === 1) {
                // Cluster of 3-4 angular boulders, tight spacing, all sunk into sand
                const heights = [
                    4 + Math.random()*4,
                    3 + Math.random()*3,
                    5 + Math.random()*4,
                    3 + Math.random()*3
                ];
                const count = 3 + (Math.random() > 0.5 ? 1 : 0);
                const offsets = [
                    {x: 0,    z: 0},
                    {x: 2.0,  z: 0.6},
                    {x:-1.6,  z: 1.2},
                    {x: 0.4,  z: -1.8}
                ];
                for (let i = 0; i < count; i++) {
                    const h = heights[i];
                    const w = 1.5 + Math.random() * 1.4;
                    const sink = h * 0.25;
                    const m = makeRockMesh(w, h, w*(0.8+Math.random()*0.4), sink);
                    m.position.set(offsets[i].x, h/2 - sink*0.5, offsets[i].z);
                    m.rotation.y = Math.random() * Math.PI;
                    m.rotation.z = (Math.random()-0.5)*0.15;
                    m.castShadow = m.receiveShadow = true;
                    group.add(m);
                }
                collisionRadius = 3.5;

            } else if (formationType === 2) {
                // Flat-topped mesa: wide heavy base with a narrower slab on top
                const w = 5 + Math.random() * 4;
                const h = 2.5 + Math.random() * 2;
                const d = 4 + Math.random() * 3;
                const sink = h * 0.3;
                const m = makeRockMesh(w, h, d, sink);
                m.position.y = h/2 - sink*0.5;
                m.rotation.y = Math.random() * Math.PI;
                m.castShadow = m.receiveShadow = true;
                group.add(m);
                const capH = h * 0.55;
                const capSink = capH * 0.15;
                const m2 = makeRockMesh(w*0.65, capH, d*0.6, capSink);
                m2.position.y = h - sink*0.5 + capH/2 - capSink*0.5 - 0.15;
                m2.rotation.y = m.rotation.y + (Math.random()-0.5)*0.4;
                m2.castShadow = m2.receiveShadow = true;
                group.add(m2);
                collisionRadius = (w * 0.5) + 1.2;

            } else {
                // Two tall pillars - gap sealed by buried base rock so nothing walks through
                const h1 = 5 + Math.random() * 4, h2 = 4 + Math.random() * 4;
                const w = 1.6 + Math.random() * 0.8;
                const gap = 2.2 + Math.random() * 1.2;
                const sink1 = h1 * 0.28, sink2 = h2 * 0.28;
                const m1 = makeRockMesh(w, h1, w*0.9, sink1);
                m1.position.set(-gap/2, h1/2 - sink1*0.5, 0);
                m1.rotation.y = Math.random()*Math.PI;
                m1.castShadow = m1.receiveShadow = true;
                group.add(m1);
                const m2 = makeRockMesh(w*0.9, h2, w*0.85, sink2);
                m2.position.set(gap/2, h2/2 - sink2*0.5, 0.3);
                m2.rotation.y = Math.random()*Math.PI;
                m2.castShadow = m2.receiveShadow = true;
                group.add(m2);
                // Wide rubble base that fills the gap between the pillars
                const baseW = gap + w * 2.0;
                const baseH = 1.4 + Math.random() * 0.8;
                const baseRock = makeRockMesh(baseW, baseH, w * 1.6, baseH * 0.6);
                baseRock.position.y = baseH * 0.3;
                baseRock.castShadow = baseRock.receiveShadow = true;
                group.add(baseRock);
                if (h1 > 6 && h2 > 6) {
                    const lintel = makeRockMesh(gap + w, 0.9, w*0.7, 0);
                    lintel.position.set(0, Math.min(h1,h2) - 0.6, 0.15);
                    lintel.castShadow = lintel.receiveShadow = true;
                    group.add(lintel);
                }
                collisionRadius = gap/2 + w + 0.8;
            }

            group.position.set(x, 0, z);
            group.rotation.y = Math.random() * Math.PI * 2;
            scene.add(group);

            // Register collision footprint
            desertFormationColliders.push({ x, z, r: collisionRadius });
        }

        // Spawn formations across the full desert biome
        // Desert ground center is at z = -desertOffset + 0.5, size = groundSize x groundSize
        // So desert spans: x = [-groundSize/2, groundSize/2], z = [-desertOffset - groundSize/2, -desertOffset + groundSize/2]
        const desertFormationPositions = [];
        const margin = 12; // keep rocks away from edges so they don't float in the void
        const desertCenterZ = -desertOffset + 0.5;
        const desertHalf = groundSize / 2 - margin;
        const desertXMin = -groundSize / 2 + margin;
        const desertXMax =  groundSize / 2 - margin;
        const desertZMin = desertCenterZ - desertHalf;
        const desertZMax = desertCenterZ + desertHalf - 18; // leave a small buffer at the grass-edge seam

        // Grid-based placement to guarantee even coverage across the entire desert
        const gridCols = 5;
        const gridRows = 6;
        const cellW = (desertXMax - desertXMin) / gridCols;
        const cellH = (desertZMax - desertZMin) / gridRows;

        for (let row = 0; row < gridRows; row++) {
            for (let col = 0; col < gridCols; col++) {
                // Skip ~20% of cells randomly so it doesn't look too uniform
                if (Math.random() < 0.20) continue;
                let fx, fz, valid;
                let attempts = 0;
                do {
                    valid = true;
                    fx = desertXMin + col * cellW + (cellW * 0.1) + Math.random() * (cellW * 0.8);
                    fz = desertZMin + row * cellH + (cellH * 0.1) + Math.random() * (cellH * 0.8);
                    for (const p of desertFormationPositions) {
                        if (Math.sqrt((fx - p.x) ** 2 + (fz - p.z) ** 2) < 12) { valid = false; break; }
                    }
                    attempts++;
                } while (!valid && attempts < 40);
                if (valid) {
                    createDesertFormation(fx, fz);
                    desertFormationPositions.push({x: fx, z: fz});
                }
            }
        }


        // ===== SMALL DESERT ROCK CLUSTERS =====
        // Each cluster is ONE merged mesh per material group \u2013 very cheap to render
        (function spawnSmallRockClusters() {
            // Shared sandstone-pebble canvas texture (generated once, reused)
            function makeSmallRockTex() {
                const tc = document.createElement('canvas');
                tc.width = 128; tc.height = 128;
                const tx = tc.getContext('2d');
                // warm sandstone base
                tx.fillStyle = '#c09660';
                tx.fillRect(0, 0, 128, 128);
                // subtle blotchy variation
                for (let i = 0; i < 18; i++) {
                    const px = Math.random()*128, py = Math.random()*128;
                    const r  = 18 + Math.random()*42;
                    const g  = tx.createRadialGradient(px, py, 0, px, py, r);
                    g.addColorStop(0, Math.random() > 0.5
                        ? `rgba(220,188,130,${0.28+Math.random()*0.22})`
                        : `rgba(100,68,32,${0.18+Math.random()*0.18})`);
                    g.addColorStop(1, 'rgba(0,0,0,0)');
                    tx.fillStyle = g;
                    tx.fillRect(0, 0, 128, 128);
                }
                // fine grit
                for (let i = 0; i < 2000; i++) {
                    tx.fillStyle = Math.random() > 0.5
                        ? `rgba(230,198,142,${0.05+Math.random()*0.12})`
                        : `rgba(28,16,6,${0.05+Math.random()*0.10})`;
                    tx.fillRect(Math.random()*128, Math.random()*128, 1, 1);
                }
                const t = new THREE.CanvasTexture(tc);
                t.wrapS = t.wrapT = THREE.RepeatWrapping;
                t.anisotropy = 4;
                return t;
            }

            const sharedTex = makeSmallRockTex();
            const sharedMat = new THREE.MeshStandardMaterial({
                map: sharedTex, roughness: 0.92, metalness: 0.01,
                flatShading: true,
                color: new THREE.Color(0.88, 0.76, 0.56)
            });

            // Build a single rounded, squashed rock geometry in local space
            // Uses icosphere-like deformation for organic feel
            function makeSmallRockGeo(w, h, d) {
                const geo = new THREE.SphereGeometry(1, 6, 5);
                // squash to desired dimensions and deform vertices
                const pos = geo.attributes.position;
                const seed = Math.random() * 100;
                for (let i = 0; i < pos.count; i++) {
                    let vx = pos.getX(i), vy = pos.getY(i), vz = pos.getZ(i);
                    // gentle random noise on each vertex for angularity
                    const n = 0.82 + Math.sin((vx + seed) * 4.1) * 0.10
                                   + Math.cos((vz + seed) * 5.3) * 0.08;
                    vx *= w * n;
                    vy *= h * (0.88 + Math.random() * 0.24);
                    vz *= d * n;
                    // flatten the underside so it sits flush on the ground
                    if (vy < -h * 0.25) vy = -h * 0.25;
                    pos.setXYZ(i, vx, vy, vz);
                }
                geo.computeVertexNormals();
                return geo;
            }

            // Cluster types
            const clusterDefs = [
                // [count, radiusSpread, wRange, hRange, dRange]
                { count: [3,5],  spread: 0.9,  w:[0.25,0.55], h:[0.18,0.38], d:[0.22,0.50] }, // small scatter
                { count: [2,4],  spread: 0.7,  w:[0.40,0.80], h:[0.28,0.55], d:[0.38,0.72] }, // medium cluster
                { count: [5,8],  spread: 1.2,  w:[0.15,0.38], h:[0.10,0.24], d:[0.14,0.36] }, // pebble scatter
                { count: [2,3],  spread: 0.5,  w:[0.60,1.00], h:[0.40,0.70], d:[0.55,0.90] }, // 2-3 bigger boulders
            ];

            const _d2 = new THREE.Object3D();

            function createSmallRockCluster(cx, cz) {
                const def = clusterDefs[Math.floor(Math.random() * clusterDefs.length)];
                const count = def.count[0] + Math.floor(Math.random() * (def.count[1] - def.count[0] + 1));
                const pieces = [];

                for (let i = 0; i < count; i++) {
                    const angle  = (i / count) * Math.PI * 2 + Math.random() * 0.8;
                    const dist   = Math.random() * def.spread;
                    const rx     = cx + Math.cos(angle) * dist;
                    const rz     = cz + Math.sin(angle) * dist;
                    const w      = def.w[0] + Math.random() * (def.w[1] - def.w[0]);
                    const h      = def.h[0] + Math.random() * (def.h[1] - def.h[0]);
                    const d      = def.d[0] + Math.random() * (def.d[1] - def.d[0]);
                    const geo    = makeSmallRockGeo(w, h, d);
                    _d2.position.set(rx - cx, h * 0.25 - h * 0.25, rz - cz); // sit on ground (y\u22480)
                    _d2.rotation.set(
                        (Math.random() - 0.5) * 0.30,
                        Math.random() * Math.PI * 2,
                        (Math.random() - 0.5) * 0.22
                    );
                    _d2.scale.set(1, 1, 1);
                    _d2.updateMatrix();
                    pieces.push({ geo, matrix: _d2.matrix.clone() });
                }

                const merged = mergeGeometries(pieces);
                merged.computeVertexNormals();
                const mesh = new THREE.Mesh(merged, sharedMat);
                mesh.position.set(cx, 0, cz);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
            }

            // Scatter ~60-80 clusters across the desert, avoiding large formation spots
            const clusterCount = 65 + Math.floor(Math.random() * 20);
            const placed = [];
            let attempts2 = 0;
            while (placed.length < clusterCount && attempts2 < clusterCount * 10) {
                attempts2++;
                const cx = desertXMin + Math.random() * (desertXMax - desertXMin);
                const cz = desertZMin + Math.random() * (desertZMax - desertZMin);
                // Keep away from large formations
                let tooClose = false;
                for (const p of desertFormationPositions) {
                    if (Math.sqrt((cx - p.x) ** 2 + (cz - p.z) ** 2) < 5) { tooClose = true; break; }
                }
                if (tooClose) continue;
                // Minimum spacing between clusters
                for (const p of placed) {
                    if (Math.sqrt((cx - p.x) ** 2 + (cz - p.z) ** 2) < 3.5) { tooClose = true; break; }
                }
                if (tooClose) continue;
                createSmallRockCluster(cx, cz);
                placed.push({ x: cx, z: cz });
            }
        })();

        // No transition strip \ufffd desert ground overlaps grass edge to avoid seam

        // ===== DESERT GRASS TUFTS =====
        const desertGrassTufts = [];

        const desertGrassMat = new THREE.MeshStandardMaterial({
            side: THREE.DoubleSide,
            roughness: 0.98,
            metalness: 0,
            vertexColors: true,
        });

        function createDesertGrassTuft(x, z) {
            const numBlades = 6 + Math.floor(Math.random() * 5);
            const allPos = [], allNorm = [], allUV = [], allCol = [], allIdx = [];
            let vertOffset = 0;

            // Dry desert palette: tans, ochres, russets, bleached straw
            const palettes = [
                { h: 0.10, sMin: 0.38, sMax: 0.55, lMin: 0.28, lMax: 0.40 },
                { h: 0.08, sMin: 0.42, sMax: 0.60, lMin: 0.20, lMax: 0.33 },
                { h: 0.12, sMin: 0.30, sMax: 0.50, lMin: 0.36, lMax: 0.50 },
                { h: 0.09, sMin: 0.25, sMax: 0.42, lMin: 0.32, lMax: 0.45 },
                { h: 0.06, sMin: 0.35, sMax: 0.52, lMin: 0.18, lMax: 0.30 },
            ];

            for (let b = 0; b < numBlades; b++) {
                const bladeHeight = 0.45 + Math.random() * 0.55;
                const bladeWidth  = 0.05 + Math.random() * 0.05;
                const bx = (Math.random() - 0.5) * 0.26;
                const bz = (Math.random() - 0.5) * 0.26;
                const ry = Math.random() * Math.PI * 2;
                const cosR = Math.cos(ry), sinR = Math.sin(ry);
                const segsY = 4;
                const cols = 2, rows = segsY + 1;

                const pal = palettes[Math.floor(Math.random() * palettes.length)];
                const hue = pal.h + (Math.random() - 0.5) * 0.03;
                const sat = pal.sMin + Math.random() * (pal.sMax - pal.sMin);
                const lit = pal.lMin + Math.random() * (pal.lMax - pal.lMin);
                const baseCol = new THREE.Color().setHSL(hue, sat, lit);
                const tipCol  = new THREE.Color().setHSL(hue + 0.02, sat * 0.65, Math.min(lit + 0.18, 0.68));

                for (let row = 0; row < rows; row++) {
                    for (let col2 = 0; col2 < cols; col2++) {
                        const u = col2 / (cols - 1);
                        const v = row  / (rows - 1);
                        const lx = (u - 0.5) * bladeWidth;
                        const ly = v * bladeHeight - bladeHeight * 0.5;
                        const bendFactor = (v + 0.5) ** 2;
                        const bendX = bendFactor * (0.14 + Math.random() * 0.10);
                        const wx = cosR * (lx + bendX) + bx;
                        const wz = sinR * (lx + bendX) + bz;
                        allPos.push(wx, ly + bladeHeight * 0.5, wz);
                        allNorm.push(0, 1, 0);
                        allUV.push(u, v);
                        const c = baseCol.clone().lerp(tipCol, v * v);
                        allCol.push(c.r, c.g, c.b);
                    }
                }
                for (let row = 0; row < segsY; row++) {
                    const a = vertOffset + row * cols;
                    const b2 = a + 1, c2 = a + cols, d = c2 + 1;
                    allIdx.push(a, c2, b2,  b2, c2, d);
                }
                vertOffset += rows * cols;
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(allPos,  3));
            geo.setAttribute('normal',   new THREE.Float32BufferAttribute(allNorm, 3));
            geo.setAttribute('uv',       new THREE.Float32BufferAttribute(allUV,   2));
            geo.setAttribute('color',    new THREE.Float32BufferAttribute(allCol,  3));
            geo.setIndex(allIdx);
            geo.computeVertexNormals();

            const tuft = new THREE.Mesh(geo, desertGrassMat);
            tuft.position.set(x, 0, z);
            tuft.userData.type      = 'desert_grass';
            tuft.userData.windSpeed = 0.5 + Math.random() * 0.35;
            tuft.userData.windPhase = Math.random() * Math.PI * 2;
            desertGrassTufts.push(tuft);
            scene.add(tuft);
        }

        // Spread ~150 tufts across the desert, avoiding rock formations
        {
            const dgMargin  = 6;
            const dgCenterZ = -desertOffset + 0.5;
            const dgHalf    = groundSize / 2 - dgMargin;
            const dgXMin    = -groundSize / 2 + dgMargin;
            const dgXMax    =  groundSize / 2 - dgMargin;
            const dgZMin    = dgCenterZ - dgHalf;
            const dgZMax    = dgCenterZ + dgHalf - 18;

            const dgCols = 12, dgRows = 15;
            const dgCellW = (dgXMax - dgXMin) / dgCols;
            const dgCellH = (dgZMax - dgZMin) / dgRows;

            for (let row = 0; row < dgRows; row++) {
                for (let col = 0; col < dgCols; col++) {
                    if (Math.random() < 0.15) continue; // ~85% fill for natural patchiness
                    const fx = dgXMin + col * dgCellW + dgCellW * 0.1 + Math.random() * dgCellW * 0.8;
                    const fz = dgZMin + row * dgCellH + dgCellH * 0.1 + Math.random() * dgCellH * 0.8;
                    // Skip if too close to a rock formation
                    let tooClose = false;
                    for (const p of desertFormationPositions) {
                        if (Math.sqrt((fx - p.x) ** 2 + (fz - p.z) ** 2) < 5) { tooClose = true; break; }
                    }
                    if (!tooClose) createDesertGrassTuft(fx, fz);
                }
            }
        }


        // ===== OPTIMIZED SKY (INVISIBLE BACKDROP) =====
        // Ultra-light sky with minimal geometry - should never be visible
        const skyGeometry = new THREE.SphereGeometry(5000, 64, 32);
        const skyMaterial = new THREE.ShaderMaterial({
            uniforms: {
                topColor:    { value: new THREE.Color(0x0077ff) },
                bottomColor: { value: new THREE.Color(0xffffff) },
                offset:      { value: 33 },
                exponent:    { value: 0.6 },
                uNight:      { value: 0.0 },
                uTime:       { value: 0.0 },
                uAuroraTime: { value: 0.0 },
                uStar1Dir:   { value: new THREE.Vector3(0,0,0) },
                uStar1T:     { value: -1.0 },
                uStar2Dir:   { value: new THREE.Vector3(0,0,0) },
                uStar2T:     { value: -1.0 },
                uSunDir:     { value: new THREE.Vector3(1,0,0) }, // normalised sun direction
                uMoonDir:    { value: new THREE.Vector3(-1,0,0) }, // normalised moon direction
                uDayBlend:   { value: 1.0 }, // 1=day, 0=night
            },
            vertexShader: `
                varying vec3 vWorldPosition;
                varying vec3 vDir;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    vDir = normalize(position); // unit direction on sphere
                    vec4 pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    gl_Position = pos.xyww;
                }
            `,
            fragmentShader: `
                uniform vec3  topColor;
                uniform vec3  bottomColor;
                uniform float offset;
                uniform float exponent;
                uniform float uNight;
                uniform float uTime;
                uniform float uAuroraTime;
                uniform vec3  uStar1Dir;
                uniform float uStar1T;
                uniform vec3  uStar2Dir;
                uniform float uStar2T;
                uniform vec3  uSunDir;
                uniform vec3  uMoonDir;
                uniform float uDayBlend;
                varying vec3  vWorldPosition;
                varying vec3  vDir;

                // --- hash / noise helpers ---
                float hash(vec2 p) {
                    p = fract(p * vec2(234.34, 435.345));
                    p += dot(p, p + 34.23);
                    return fract(p.x * p.y);
                }
                float hash3(vec3 p) {
                    p = fract(p * vec3(443.8975, 397.2973, 491.1871));
                    p += dot(p, p + 19.19);
                    return fract(p.x * p.y * p.z);
                }
                // smooth noise
                float noise(vec2 p) {
                    vec2 i = floor(p), f = fract(p);
                    f = f*f*(3.0-2.0*f);
                    return mix(mix(hash(i), hash(i+vec2(1,0)), f.x),
                               mix(hash(i+vec2(0,1)), hash(i+vec2(1,1)), f.x), f.y);
                }

                void main() {
                    // ── sky gradient (existing look) ──
                    float h = normalize(vWorldPosition + offset).y;
                    vec3 skyCol = mix(bottomColor, topColor, max(pow(max(h,0.0), exponent), 0.0));

                    // ── stars (only upper hemisphere) ──
                    float starLayer = 0.0;
                    if (uNight > 0.01 && vDir.y > -0.05) {
                        // Map direction to a 2D cell grid for star placement
                        // Use spherical coords as grid — lon/lat
                        float lon = atan(vDir.z, vDir.x) * (1.0/3.14159);  // -1..1
                        float lat = vDir.y;                                   // -1..1
                        vec2 grid = vec2(lon, lat) * 120.0; // density
                        vec2 cell = floor(grid);
                        vec2 cellF = fract(grid);

                        // Check 3x3 neighbourhood so stars near cell edges still show
                        for (int dy = -1; dy <= 1; dy++) {
                            for (int dx = -1; dx <= 1; dx++) {
                                vec2 nc = cell + vec2(float(dx), float(dy));
                                float rnd = hash(nc);
                                if (rnd > 0.06) continue; // ~6% of cells have a star

                                // Star centre within cell
                                vec2 starPos = vec2(hash(nc + 7.3), hash(nc + 13.1));
                                vec2 toStar  = cellF - vec2(float(dx), float(dy)) - starPos;
                                float dist   = length(toStar);

                                float size   = 0.04 + hash(nc + 91.0) * 0.12; // vary size
                                float bright = 1.0 - smoothstep(0.0, size, dist);
                                bright = pow(bright, 3.0); // sharp core

                                // Twinkle: per-star phase
                                float phase = hash(nc + 55.5) * 6.28;
                                float twinkle = 0.6 + 0.4 * sin(uTime * (1.5 + hash(nc)*2.0) + phase);
                                starLayer += bright * twinkle;
                            }
                        }
                        // Horizon fade — stars fade as they approach horizon
                        float horizonFade = smoothstep(-0.05, 0.15, vDir.y);
                        starLayer *= horizonFade;
                    }

                    // ── aurora (northern sky, low elevation, deep night only) ──
                    vec3 auroraCol = vec3(0.0);
                    float auroraNight = max(0.0, (uNight - 0.3) / 0.7); // starts appearing earlier at night
                    if (auroraNight > 0.0 && vDir.y > -0.02) {
                        // Aurora lives in northern sector (vDir.z < 0) at low elevation
                        float northFace = smoothstep(0.6, -0.6, vDir.z); // wide northern arc
                        float elevation = max(0.0, vDir.y);
                        float az = atan(vDir.x, -vDir.z); // azimuth, 0=north — declared here for breathe+curtain+waves
                        // Curtain band: tall ribbon from horizon up to ~0.4, breathing vertically
                        float breathe = 0.05 * sin(uAuroraTime * 0.6 + az * 0.5);
                        float curtain = smoothstep(0.0, 0.05, elevation) * smoothstep(0.5 + breathe, 0.15 + breathe, elevation);

                        if (curtain > 0.001) {
                            // Wavy noise along azimuth
                            float wave1 = noise(vec2(az * 3.0 + uAuroraTime * 0.8, uAuroraTime * 0.5)) * 0.5 + 0.5;
                            float wave2 = noise(vec2(az * 5.0 - uAuroraTime * 1.0, elevation * 8.0 + uAuroraTime * 0.4));
                            // Add a third slower wave for large-scale ripple
                            float wave3 = noise(vec2(az * 1.5 + uAuroraTime * 0.4, uAuroraTime * 0.25)) * 0.5 + 0.5;
                            float auroraShape = wave1 * wave3 * (0.7 + 0.3 * wave2);

                            // Colour: green base, cyan/purple fringes
                            vec3 greenCyan = mix(vec3(0.0,1.0,0.35), vec3(0.0,0.85,1.0), wave2);
                            vec3 purple    = vec3(0.55, 0.05, 1.0);
                            float purpleMix = smoothstep(-0.5, 0.5, az * 0.4 + wave2 * 0.6);
                            vec3 auroraBase = mix(greenCyan, purple, purpleMix * 0.45);

                            float azSpread = smoothstep(2.0, 0.5, abs(az)); // wider side spread
                            auroraCol = auroraBase * auroraShape * curtain * northFace * azSpread * 2.5;
                        }
                    }

                    // ── shooting stars ──
                    vec3 shootCol = vec3(0.0);
                    // Helper: render one shooting star trail
                    // dir = normalised direction from which the streak radiates; t = 0..1 progress
                    if (uStar1T >= 0.0) {
                        float along = dot(vDir, uStar1Dir); // -1..1, 1 = dead ahead
                        float trail = smoothstep(-0.002, 0.0, along - (1.0 - uStar1T * 0.04))
                                    * smoothstep(0.0, 0.008, (1.0 - uStar1T * 0.04) + 0.015 - along);
                        float perp  = length(vDir - along * uStar1Dir);
                        float width = smoothstep(0.004, 0.0, perp);
                        float fade  = sin(uStar1T * 3.14159); // fade in/out
                        shootCol += vec3(1.0, 0.97, 0.85) * trail * width * fade * 3.0;
                    }
                    if (uStar2T >= 0.0) {
                        float along = dot(vDir, uStar2Dir);
                        float trail = smoothstep(-0.002, 0.0, along - (1.0 - uStar2T * 0.04))
                                    * smoothstep(0.0, 0.008, (1.0 - uStar2T * 0.04) + 0.015 - along);
                        float perp  = length(vDir - along * uStar2Dir);
                        float width = smoothstep(0.004, 0.0, perp);
                        float fade  = sin(uStar2T * 3.14159);
                        shootCol += vec3(1.0, 0.97, 0.85) * trail * width * fade * 3.0;
                    }

                    // ── sun: removed from shader — rendered as sprite mesh (see _sunSprite) ──
                    vec3 sunCol = vec3(0.0);

                    // ── moon atmospheric glow only (disc is a separate sprite mesh) ──
                    vec3 moonCol = vec3(0.0);
                    {
                        float cosA = dot(vDir, uMoonDir);
                        float outerGlow = smoothstep(0.940, 0.999, cosA);
                        moonCol = vec3(0.30, 0.38, 0.70) * outerGlow * 0.10 * uNight;
                    }

                    // ── compose final colour ──
                    vec3 finalSky = skyCol;
                    vec3 starColor = vec3(1.0, 0.97, 0.9) * starLayer * uNight * 1.6;
                    finalSky += starColor + auroraCol * auroraNight + shootCol * uNight + sunCol + moonCol;

                    gl_FragColor = vec4(finalSky, 1.0);
                }
            `,
            side: THREE.BackSide,
            depthWrite: false,
            depthTest:  false,
            fog: false
        });
        
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        window._skyMat = skyMaterial; // expose for night sync
        sky.renderOrder = -1;
        sky.frustumCulled = false;
        sky.onBeforeRender = function(renderer, scene, camera) {
            sky.position.copy(camera.position);
        };
        scene.add(sky);

        // ── Moon sprite ── billboard, always a perfect circle, no shader clipping
        (function() {
            const SIZE = 1024; // large canvas so glow doesn't hit edges
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = SIZE;
            // Use alpha:true (default) and willReadFrequently for proper transparency
            const ctx = canvas.getContext('2d', { alpha: true });
            const cx = SIZE / 2, cy = SIZE / 2, r = SIZE * 0.28; // disc uses 28% so glow (r*1.55=43%) fits inside 50%

            // Canvas starts transparent by default — do NOT fill background

            // 1. Full glow ring — canvas is large enough to contain it
            const glow = ctx.createRadialGradient(cx, cy, r * 0.9, cx, cy, r * 1.55);
            glow.addColorStop(0,   'rgba(210,218,245,0.55)');
            glow.addColorStop(0.4, 'rgba(170,185,230,0.20)');
            glow.addColorStop(1,   'rgba(130,150,210,0.00)');
            ctx.beginPath();
            ctx.arc(cx, cy, r * 1.55, 0, Math.PI * 2);
            ctx.fillStyle = glow;
            ctx.fill();

            // 2. Disc: build entirely with compositing so ONLY the circle is drawn
            // Draw the disc base using a path — no fillRect anywhere
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fillStyle = '#c8cad2';
            ctx.fill();

            // 3. Limb highlight (off-centre bright spot) — clipped to disc via globalCompositeOperation
            ctx.save();
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.clip();

            const limb = ctx.createRadialGradient(cx - r*0.22, cy - r*0.22, 0, cx, cy, r);
            limb.addColorStop(0,   'rgba(255,255,255,0.50)');
            limb.addColorStop(0.5, 'rgba(220,222,228,0.10)');
            limb.addColorStop(1.0, 'rgba(50,52,62,0.55)');
            ctx.fillStyle = limb;
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fill();

            // 4. Mare patches (inside clip)
            ctx.fillStyle = 'rgba(75,79,92,0.52)';
            ctx.beginPath(); ctx.ellipse(cx - r*0.18, cy - r*0.10, r*0.28, r*0.21, -0.4, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(cx + r*0.14, cy - r*0.20, r*0.16, r*0.14, 0.3,  0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(cx + r*0.22, cy + r*0.08, r*0.20, r*0.15, 0.5,  0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(cx - r*0.05, cy + r*0.28, r*0.18, r*0.13, -0.2, 0, Math.PI*2); ctx.fill();

            ctx.restore();

            const moonTex = new THREE.CanvasTexture(canvas);
            // Use AdditiveBlending so the bright disc is unmistakably visible against dark sky
            const moonMat = new THREE.SpriteMaterial({
                map: moonTex,
                transparent: true,
                depthWrite: false,
                depthTest: false,
                fog: false,
            });
            const moonSprite = new THREE.Sprite(moonMat);
            moonSprite.renderOrder = 2;
            moonSprite.frustumCulled = false;
            const moonDist = 100;
            moonSprite.scale.setScalar(18);
            scene.add(moonSprite);
            window._moonSprite = moonSprite;
            window._moonDist   = moonDist;
        })();

        // ── Sun sprite ── billboard disc + glow, mirrors moon sprite pattern
        (function() {
            const SIZE = 1024;
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = SIZE;
            const ctx = canvas.getContext('2d', { alpha: true });
            const cx = SIZE / 2, cy = SIZE / 2, r = SIZE * 0.28;

            // 1. Outer corona glow
            const corona = ctx.createRadialGradient(cx, cy, r * 0.8, cx, cy, r * 1.8);
            corona.addColorStop(0,   'rgba(255,220,100,0.60)');
            corona.addColorStop(0.3, 'rgba(255,180,50,0.25)');
            corona.addColorStop(0.7, 'rgba(255,140,20,0.08)');
            corona.addColorStop(1,   'rgba(255,100,0,0.00)');
            ctx.beginPath();
            ctx.arc(cx, cy, r * 1.8, 0, Math.PI * 2);
            ctx.fillStyle = corona;
            ctx.fill();

            // 2. Solid disc
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fillStyle = '#fff7d0';
            ctx.fill();

            // 3. Limb darkening — edges slightly dimmer, centre bright
            ctx.save();
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.clip();
            const limb = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
            limb.addColorStop(0,   'rgba(255,255,240,0.00)'); // centre transparent (let disc show)
            limb.addColorStop(0.6, 'rgba(255,200,80,0.10)');
            limb.addColorStop(1.0, 'rgba(200,120,20,0.45)'); // darkened edge
            ctx.fillStyle = limb;
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            const sunTex = new THREE.CanvasTexture(canvas);
            const sunSpriteMat = new THREE.SpriteMaterial({
                map: sunTex,
                transparent: true,
                depthWrite: false,  // don't write depth (it's a billboard)
                depthTest: true,    // DO test depth so trees/clouds/terrain occlude it
                fog: false,
            });
            const sunSprite = new THREE.Sprite(sunSpriteMat);
            sunSprite.renderOrder = 0; // sort with normal world objects so occlusion works
            sunSprite.frustumCulled = false;
            sunSprite.scale.setScalar(18);
            scene.add(sunSprite);
            window._sunSprite    = sunSprite;
            window._sunSpriteMat = sunSpriteMat;
            window._sunDist      = 100;
        })();

        // Stars, aurora, sun and moon are all baked into the sky dome shader.
        const STAR_COUNT = 0;
        const starColors = new Float32Array(0);
        const starBaseOpacity = new Float32Array(0);
        const starTwinklePhase = new Float32Array(0);
        const starTwinkleSpeed = new Float32Array(0);
        const shootingStars = [];

        // Shooting star state — two slots driven into sky shader uniforms
        const _shootSlots = [
            { t: -1, dir: new THREE.Vector3(), timer: 0 },
            { t: -1, dir: new THREE.Vector3(), timer: 400 } // stagger second slot
        ];
        function _spawnShootingStar(slot) {
            // Random direction in upper hemisphere, biased away from zenith
            const theta = (Math.random() * 0.7 + 0.1) * Math.PI; // polar from top
            const phi   = Math.random() * Math.PI * 2;
            slot.dir.set(
                Math.sin(theta) * Math.cos(phi),
                Math.cos(theta) + 0.3,
                Math.sin(theta) * Math.sin(phi)
            ).normalize();
            slot.t = 0;
        }
        function _updateShootingStars(nightBlend) {
            _shootSlots.forEach((slot, i) => {
                const uDir = i === 0 ? sky.material.uniforms.uStar1Dir : sky.material.uniforms.uStar2Dir;
                const uT   = i === 0 ? sky.material.uniforms.uStar1T   : sky.material.uniforms.uStar2T;

                if (slot.t >= 0) {
                    // Active: advance progress
                    slot.t += 0.012;
                    uDir.value.copy(slot.dir);
                    uT.value = slot.t;
                    if (slot.t >= 1.0) {
                        slot.t = -1;
                        uT.value = -1;
                        // Schedule next one: 8-25 seconds
                        slot.timer = (8 + Math.random() * 17) * 60;
                    }
                } else {
                    // Idle: count down timer
                    if (nightBlend > 0.7) {
                        slot.timer--;
                        if (slot.timer <= 0) {
                            _spawnShootingStar(slot);
                        }
                    } else {
                        uT.value = -1;
                    }
                }
            });
        }

        // ===== FLUFFY CLOUDS — soft particle system matching campfire smoke =====
        // Each cloud is a THREE.Points with many overlapping soft-disc sprites,
        // using the same _smokeCircleTex radial gradient so they look identical
        // to campfire smoke puffs — round, soft, fluffy.
        const clouds = [];

        // Build a shared soft-disc cloud texture (same as smoke but brighter)
        const _cloudTex = (() => {
            const sz = 128, c = document.createElement('canvas');
            c.width = c.height = sz;
            const ctx = c.getContext('2d'), r = sz / 2;
            const g = ctx.createRadialGradient(r, r, 0, r, r, r);
            g.addColorStop(0,    'rgba(255,255,255,1.0)');
            g.addColorStop(0.35, 'rgba(255,255,255,0.85)');
            g.addColorStop(0.65, 'rgba(255,255,255,0.4)');
            g.addColorStop(1,    'rgba(255,255,255,0)');
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, sz, sz);
            return new THREE.CanvasTexture(c);
        })();

        function createCloud(x, y, z) {
            // Each cloud = 18-28 overlapping soft puff sprites
            const puffCount = 18 + Math.floor(Math.random() * 10);
            const positions = new Float32Array(puffCount * 3);
            const sizes     = new Float32Array(puffCount);

            for (let i = 0; i < puffCount; i++) {
                // Puffs spread in a flat oval: wide XZ, thin Y
                const angle = Math.random() * Math.PI * 2;
                const r     = Math.random() * 9;
                positions[i * 3 + 0] = Math.cos(angle) * r * (1.0 + Math.random() * 0.5);
                positions[i * 3 + 1] = (Math.random() - 0.5) * 3.5;
                positions[i * 3 + 2] = Math.sin(angle) * r * 0.65;
                sizes[i] = 5.5 + Math.random() * 6.0; // vary puff size
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('size',     new THREE.Float32BufferAttribute(sizes,     1));

            const mat = new THREE.PointsMaterial({
                color:          0xffffff,
                size:           8.0,
                sizeAttenuation: true,
                transparent:    true,
                opacity:        0.55 + Math.random() * 0.15,
                depthWrite:     false,
                map:            _cloudTex,
                alphaTest:      0.01,
            });

            const mesh = new THREE.Points(geo, mat);
            mesh.position.set(x, y, z);
            mesh.frustumCulled = true;

            mesh.userData.speed      = 0.005 + Math.random() * 0.01;
            mesh.userData.floatSpeed = 0.15  + Math.random() * 0.2;
            mesh.userData.floatPhase = Math.random() * Math.PI * 2;
            mesh.userData.baseY      = y;
            mesh.userData.baseOpacity = mat.opacity;

            clouds.push(mesh);
            scene.add(mesh);
        }
        
        // Spread clouds across entire sky - reduced count
        for (let i = 0; i < 10; i++) { // Reduced by 60% (was 25, now 10)
            createCloud(
                (Math.random() - 0.5) * 400, // Wider spread (was 160, now 400)
                35 + Math.random() * 40, // Higher range (35-75 instead of 40-70)
                (Math.random() - 0.5) * 400  // Wider spread (was 160, now 400)
            );
        }
        // Extra clouds seeded over the river biome (centred at x=200)
        for (let i = 0; i < 8; i++) {
            createCloud(
                100 + Math.random() * 200,       // x: 100–300 (river biome span)
                35  + Math.random() * 40,         // same height range
                (Math.random() - 0.5) * 200       // z: across biome width
            );
        }
        
        // ===== GAME STATE =====
        let health = 100;
        let hunger = 100;
        let thirst = 100;
        let playerTemp = 0; // -1 = freezing cold, 0 = normal, +1 = burning hot
        let day = 1;
        let time = 6; // 0-24 hour format
        let isDead = false;
        let gameTime = 0;
        let deathCamera = null;
        
        // Volume settings
        const volumeSettings = {
            ambient: 0.3,    // Legacy (used by desert/biome gain)
            forest: 0.21,     // Forest ambience track (reduced 30%)
            wind: 0.1,       // Wind sounds
            rain: 0.5,       // Rain sounds
            animals: 0.5,    // Animal sounds
            enemies: 0.5,    // Enemy sounds
            footsteps: 0.5,  // Footstep sounds
            renderDistance: 100  // Fog far plane / culling distance in world units
        };
        // Sync fog and camera clip plane with the default render distance now that
        // both volumeSettings and camera are available.
        applyRenderDistance(volumeSettings.renderDistance);
        
        const inventory = {
            sharp_stone: 1,  // START WITH SHARP STONE!
            wood: 0,
            stone: 0,
            berries: 0,
            worms: 0,
            mushroom: 0,
            roasted_mushroom: 0,
            meat: 0,
            sticks: 0,
            fiber: 0,
            crystal_shard: 0,
            iron_ore: 0,
            iron_ingot: 0,
            coal: 0,
            sulfur_ore: 0,
            smelted_sulfur: 0,
            gunpowder: 0,
            arrows: 0,
            pistol: 0,
            pistol_ammo: 0,
            machine_gun: 0,
            mg_ammo: 0,
            building_hammer: 0,
            sleeping_bag: 0,
            bandage: 0,
            medkit: 0,
            cloth: 0,
            floor_rug_red: 0,
            floor_rug_blue: 0,
            floor_rug_green: 0,
            small_storage_box: 0,
            storage_shelf: 0,
            wall_shelf: 0,
            planter_box: 0,
            large_planter: 0,
            // Seeds (found in world, not crafted)
            pumpkin_seed: 0,
            wheat_seed: 0,
            cabbage_seed: 0,
            cucumber_seed: 0,
            potato_seed: 0,
            carrot_seed: 0,
            hemp_seed: 0,
            corn_seed: 0,
            mushroom_seed: 0,
            red_berry_seed: 0,
            black_berry_seed: 0,
            strawberry_seed: 0,
            tomato_seed: 0,
            // Harvested produce
            pumpkin: 0,
            wheat: 0,
            cabbage: 0,
            cucumber: 0,
            potato: 0,
            carrot: 0,
            hemp_fiber: 0,
            corn: 0,
            mushroom_crop: 0,
            red_berries: 0,
            black_berries: 0,
            strawberry: 0,
            tomato: 0,
            building_bench: 0,
            sewing_table: 0,
            recycler: 0,
            curtain_red: 0,
            curtain_blue: 0,
            curtain_green: 0,
            curtain_white: 0,
            curtain_beige: 0,
            sofa: 0,
            bookcase: 0,
            table: 0,
            chair: 0,
            wall_shelf_b: 0,
            candle: 0,
            wall_light: 0,
            bee_hive: 0,
            chicken_coop: 0,
            oil_smelter: 0,
            code_lock: 0,
            iron_helmet: 0,
            iron_vest: 0,
            iron_gloves: 0,
            iron_pants: 0,
            iron_boots: 0,
            cloth_helmet: 0,
            cloth_vest: 0,
            cloth_gloves: 0,
            cloth_pants: 0,
            cloth_boots: 0,
            bronze_helmet: 0,
            bronze_vest: 0,
            bronze_gloves: 0,
            bronze_pants: 0,
            bronze_boots: 0,
            thermal_hood: 0,
            thermal_jacket: 0,
            thermal_gloves: 0,
            thermal_pants: 0,
            thermal_boots: 0,
            small_backpack: 0,
            large_backpack: 0,
            // Cooking station outputs
            meat_stew: 0,
            vegetable_stew: 0,
            berry_jam: 0,
            corn_bread: 0,
            hearty_meal: 0,
            cooking_station: 0,
            water_bottle: 0,
            water_catcher: 0,
            // Cooking station outputs
            flour: 0,
            bread: 0,
            blackcurrant_jam: 0,
            strawberry_jam: 0,
            toast_jam: 0,
            ham_sandwich: 0,
            honey: 0,
            egg: 0,
            omelette: 0,
            scrambled_eggs: 0,
            honey_cake: 0,
            honey_porridge: 0,
            // Fishing
            fishing_rod: 0,
            raw_fish: 0,
            cooked_fish: 0,
            grilled_fish_stew: 0
        };
        
        // Pistol state
        const pistolState = {
            clipSize: 8,
            currentClip: 8,
            isReloading: false,
            reloadStartTime: 0,
            reloadDuration: 1500 // 1.5 seconds
        };

        const machineGunState = {
            clipSize: 20,
            currentClip: 20,
            isReloading: false,
            reloadStartTime: 0,
            reloadDuration: 2500, // 2.5 seconds
            fireRate: 80,         // ms between shots (750 rpm)
            lastShotTime: 0,
            isFiring: false,      // mouse held down
            shotsFired: 0         // shots fired in current mouse-down burst
        };
        
        // Code lock state
        let currentCodeLockDoor = null;
        let codeLockMode = null; // 'set' or 'enter'
        let currentCode = '';
        let wrongCodeDamageTimer = null;
        
        // Healing over time state
        const healingState = {
            active: false,
            totalHealing: 0,
            healPerTick: 0,
            tickInterval: 1000, // 1 second
            lastTickTime: 0,
            healingsRemaining: 0
        };
        
        // Spawn point
        let spawnPoint = { x: 0, y: 1.7, z: 5 };
        
        const equipment = {
            weapon: null,
            tool: null
        };
        
        // Armor equipment slots
        const armorSlots = {
            head: null,
            chest: null,
            hands: null,
            legs: null,
            feet: null,
            back: null
        };
        
        const hotbar = [
            { type: 'tool', item: 'sharp_stone' },  // Sharp stone in first slot!
            { type: 'tool', item: null },
            { type: 'food', item: 'berries' },
            { type: 'building', item: null },
            { type: 'misc', item: null },
            { type: 'misc', item: null }
        ];
        let selectedHotbarSlot = 0;
        
        // Consumable items
        const _foodItems = new Set([
            'berries','mushroom','roasted_mushroom','meat','cooked_meat',
            'pumpkin','wheat','cabbage','cucumber','potato','carrot',
            'hemp_fiber','corn','mushroom_crop','red_berries','black_berries',
            'strawberry','tomato',
            'meat_stew','vegetable_stew','berry_jam','corn_bread','hearty_meal',
            'bread','toast_jam','ham_sandwich','blackcurrant_jam','strawberry_jam','flour',
            'water_bottle',
            'omelette','scrambled_eggs','honey_cake','honey_porridge',
            'raw_fish','cooked_fish','grilled_fish_stew',
            'pumpkin_soup','stuffed_pumpkin','pickled_cabbage','cabbage_stew',
            'red_berry_jam','summer_salad',
            'bandage','medkit',
        ]);
        function consumeItem(itemName) {
            if (itemName === 'bandage' || itemName === 'medkit') {
                playBandageSound();
            } else if (itemName !== 'water_bottle' && _foodItems.has(itemName) && inventory[itemName] > 0) {
                playEatSound();
            }
            if (itemName === 'berries' && inventory.berries > 0) {
                inventory.berries--;
                hunger = Math.min(100, hunger + 15);
                thirst = Math.min(100, thirst + 5);
                showMessage('\ud83e\uded0 Ate berries! +15 Hunger, +5 Thirst');
                updateUI();
                updateHotbar();
            } else if (itemName === 'mushroom' && inventory.mushroom > 0) {
                inventory.mushroom--;
                hunger = Math.min(100, hunger + 10);
                showMessage('\ud83c\udf44 Ate mushroom! +10 Hunger');
                updateUI();
                updateHotbar();
            } else if (itemName === 'roasted_mushroom' && inventory.roasted_mushroom > 0) {
                inventory.roasted_mushroom--;
                hunger = Math.min(100, hunger + 25);
                health = Math.min(activeBuffs.meat_stew ? 130 : 100, health + 5);
                showMessage('\ud83c\udf44 Ate roasted mushroom! +25 Hunger, +5 Health');
                updateUI();
                updateHotbar();
            } else if (itemName === 'meat' && inventory.meat > 0) {
                inventory.meat--;
                hunger = Math.min(100, hunger + 20);
                showMessage('\ud83e\udd69 Ate raw meat! +20 Hunger');
                updateUI();
                updateHotbar();
            } else if (itemName === 'cooked_meat' && inventory.cooked_meat > 0) {
                inventory.cooked_meat--;
                hunger = Math.min(100, hunger + 40);
                health = Math.min(activeBuffs.meat_stew ? 130 : 100, health + 10);
                showMessage('\ud83c\udf56 Ate cooked meat! +40 Hunger, +10 Health');
                updateUI();
                updateHotbar();
            } else if (itemName === 'bandage' && inventory.bandage > 0) {
                inventory.bandage--;
                // Heal 15 HP over 5 seconds (3 HP per second)
                startHealing(15, 3, 5);
                showMessage('\ud83e\ude79 Applied bandage! Healing over time...');
                updateUI();
                updateHotbar();
            } else if (itemName === 'medkit' && inventory.medkit > 0) {
                inventory.medkit--;
                startHealing(40, 10, 4);
                showMessage('\ud83c\udfe5 Used medkit! Rapid healing!');
                updateUI();
                updateHotbar();
            // ── Harvested produce ──────────────────────────────────────────────
            } else if (itemName === 'pumpkin' && inventory.pumpkin > 0) {
                inventory.pumpkin--;
                hunger = Math.min(100, hunger + 35); thirst = Math.min(100, thirst + 10);
                showMessage('\ud83c\udf83 Ate pumpkin! +35 Hunger, +10 Thirst');
                updateUI(); updateHotbar();
            } else if (itemName === 'wheat' && inventory.wheat > 0) {
                inventory.wheat--;
                hunger = Math.min(100, hunger + 20);
                showMessage('\ud83c\udf3e Ate wheat! +20 Hunger');
                updateUI(); updateHotbar();
            } else if (itemName === 'cabbage' && inventory.cabbage > 0) {
                inventory.cabbage--;
                hunger = Math.min(100, hunger + 18); thirst = Math.min(100, thirst + 8);
                showMessage('\ud83e\udd66 Ate cabbage! +18 Hunger, +8 Thirst');
                updateUI(); updateHotbar();
            } else if (itemName === 'cucumber' && inventory.cucumber > 0) {
                inventory.cucumber--;
                hunger = Math.min(100, hunger + 12); thirst = Math.min(100, thirst + 20);
                showMessage('\ud83e\udd52 Ate cucumber! +12 Hunger, +20 Thirst');
                updateUI(); updateHotbar();
            } else if (itemName === 'potato' && inventory.potato > 0) {
                inventory.potato--;
                hunger = Math.min(100, hunger + 30);
                showMessage('\ud83e\udd54 Ate potato! +30 Hunger');
                updateUI(); updateHotbar();
            } else if (itemName === 'carrot' && inventory.carrot > 0) {
                inventory.carrot--;
                hunger = Math.min(100, hunger + 22); health = Math.min(activeBuffs.meat_stew ? 130 : 100, health + 3);
                showMessage('\ud83e\udd55 Ate carrot! +22 Hunger, +3 Health');
                updateUI(); updateHotbar();
            } else if (itemName === 'hemp_fiber' && inventory.hemp_fiber > 0) {
                inventory.hemp_fiber--;
                health = Math.min(activeBuffs.meat_stew ? 130 : 100, health + 8);
                showMessage('\ud83c\udf3f Ate hemp! +8 Health');
                updateUI(); updateHotbar();
            } else if (itemName === 'corn' && inventory.corn > 0) {
                inventory.corn--;
                hunger = Math.min(100, hunger + 28); thirst = Math.min(100, thirst + 5);
                showMessage('\ud83c\udf3d Ate corn! +28 Hunger, +5 Thirst');
                updateUI(); updateHotbar();
            } else if (itemName === 'mushroom_crop' && inventory.mushroom_crop > 0) {
                inventory.mushroom_crop--;
                hunger = Math.min(100, hunger + 15); health = Math.min(activeBuffs.meat_stew ? 130 : 100, health + 5);
                showMessage('\ud83c\udf44 Ate mushroom! +15 Hunger, +5 Health');
                updateUI(); updateHotbar();
            } else if (itemName === 'red_berries' && inventory.red_berries > 0) {
                inventory.red_berries--;
                hunger = Math.min(100, hunger + 10); thirst = Math.min(100, thirst + 12);
                showMessage('\ud83c\udf53 Ate red berries! +10 Hunger, +12 Thirst');
                updateUI(); updateHotbar();
            } else if (itemName === 'black_berries' && inventory.black_berries > 0) {
                inventory.black_berries--;
                hunger = Math.min(100, hunger + 10); thirst = Math.min(100, thirst + 12); health = Math.min(activeBuffs.meat_stew ? 130 : 100, health + 4);
                showMessage('\ud83e\uded0 Ate black berries! +10 Hunger, +12 Thirst, +4 Health');
                updateUI(); updateHotbar();
            } else if (itemName === 'strawberry' && inventory.strawberry > 0) {
                inventory.strawberry--;
                hunger = Math.min(100, hunger + 12); thirst = Math.min(100, thirst + 15); health = Math.min(activeBuffs.meat_stew ? 130 : 100, health + 5);
                showMessage('\ud83c\udf53 Ate strawberry! +12 Hunger, +15 Thirst, +5 Health');
                updateUI(); updateHotbar();
            } else if (itemName === 'tomato' && inventory.tomato > 0) {
                inventory.tomato--;
                hunger = Math.min(100, hunger + 16); thirst = Math.min(100, thirst + 18);
                showMessage('\ud83c\udf45 Ate tomato! +16 Hunger, +18 Thirst');
                updateUI(); updateHotbar();
            } else if (itemName === 'meat_stew' && inventory.meat_stew > 0) {
                inventory.meat_stew--;
                hunger = Math.min(100, hunger + 60); health = Math.min(130, health + 15);
                applyBuff('meat_stew');
                showMessage('\ud83c\udf72 Ate meat stew! +60 Hunger, +15 Health | Buff: Fortified (+30% max health, 10 mins)');
                updateUI(); updateHotbar();
            } else if (itemName === 'vegetable_stew' && inventory.vegetable_stew > 0) {
                inventory.vegetable_stew--;
                hunger = Math.min(100, hunger + 50); thirst = Math.min(100, thirst + 20); health = Math.min(activeBuffs.meat_stew ? 130 : 100, health + 10);
                applyBuff('veggi_stew');
                showMessage('\ud83c\udf72 Ate vegetable stew! +50 Hunger, +20 Thirst, +10 Health | Buff: Stamina Saver (10 mins)');
                updateUI(); updateHotbar();
            } else if (itemName === 'berry_jam' && inventory.berry_jam > 0) {
                inventory.berry_jam--;
                hunger = Math.min(100, hunger + 35); thirst = Math.min(100, thirst + 25);
                showMessage('\ud83c\udf53 Ate berry jam! +35 Hunger, +25 Thirst');
                updateUI(); updateHotbar();
            } else if (itemName === 'corn_bread' && inventory.corn_bread > 0) {
                inventory.corn_bread--;
                hunger = Math.min(100, hunger + 45);
                showMessage('\ud83c\udf5e Ate corn bread! +45 Hunger');
                updateUI(); updateHotbar();
            } else if (itemName === 'hearty_meal' && inventory.hearty_meal > 0) {
                inventory.hearty_meal--;
                hunger = Math.min(100, hunger + 80); health = Math.min(activeBuffs.meat_stew ? 130 : 100, health + 25); thirst = Math.min(100, thirst + 15);
                applyBuff('hearty');
                showMessage('\ud83c\udf7d\ufe0f Ate hearty meal! +80 Hunger, +25 Health, +15 Thirst | Buff: Double Gathering (10 mins)');
                updateUI(); updateHotbar();
            } else if (itemName === 'water_bottle' && inventory.water_bottle > 0) {
                inventory.water_bottle--;
                thirst = Math.min(100, thirst + 50);
                showMessage('💧 Drank water bottle! +50 Thirst');
                updateUI(); updateHotbar();
                // Play BottleOpen then Drink sequentially
                const _bottleOpen = new Audio('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/BottleOpen.mp3');
                _bottleOpen.volume = 0.8;
                _bottleOpen.play().catch(() => {});
                _bottleOpen.addEventListener('ended', () => {
                    const _drink = new Audio('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/Drink.mp3');
                    _drink.volume = 0.8;
                    _drink.play().catch(() => {});
                });
            } else if (itemName === 'flour' && inventory.flour > 0) {
                inventory.flour--;
                hunger = Math.min(100, hunger + 5);
                showMessage('🌾 Ate flour... not great. +5 Hunger');
                updateUI(); updateHotbar();
            } else if (itemName === 'bread' && inventory.bread > 0) {
                inventory.bread--;
                hunger = Math.min(100, hunger + 35);
                showMessage('🍞 Ate bread! +35 Hunger');
                updateUI(); updateHotbar();
            } else if (itemName === 'blackcurrant_jam' && inventory.blackcurrant_jam > 0) {
                inventory.blackcurrant_jam--;
                hunger = Math.min(100, hunger + 20); thirst = Math.min(100, thirst + 10);
                showMessage('🫐 Ate blackcurrant jam! +20 Hunger, +10 Thirst');
                updateUI(); updateHotbar();
            } else if (itemName === 'strawberry_jam' && inventory.strawberry_jam > 0) {
                inventory.strawberry_jam--;
                hunger = Math.min(100, hunger + 20); thirst = Math.min(100, thirst + 10); health = Math.min(activeBuffs.meat_stew ? 130 : 100, health + 5);
                showMessage('🍓 Ate strawberry jam! +20 Hunger, +10 Thirst, +5 Health');
                updateUI(); updateHotbar();
            } else if (itemName === 'toast_jam' && inventory.toast_jam > 0) {
                inventory.toast_jam--;
                hunger = Math.min(100, hunger + 50); health = Math.min(activeBuffs.meat_stew ? 130 : 100, health + 5);
                showMessage('🍞 Ate toast with jam! +50 Hunger, +5 Health');
                updateUI(); updateHotbar();
            } else if (itemName === 'ham_sandwich' && inventory.ham_sandwich > 0) {
                inventory.ham_sandwich--;
                hunger = Math.min(100, hunger + 65); health = Math.min(activeBuffs.meat_stew ? 130 : 100, health + 10); thirst = Math.min(100, thirst + 10);
                showMessage('🥪 Ate ham sandwich! +65 Hunger, +10 Health, +10 Thirst');
                updateUI(); updateHotbar();
            } else if (itemName === 'omelette' && inventory.omelette > 0) {
                inventory.omelette--;
                hunger = Math.min(100, hunger + 50); health = Math.min(activeBuffs.meat_stew ? 130 : 100, health + 15);
                applyBuff('well_fed');
                showMessage('🍳 Ate omelette! +50 Hunger, +15 Health | Buff: Well Fed (3 min)');
                updateUI(); updateHotbar();
            } else if (itemName === 'scrambled_eggs' && inventory.scrambled_eggs > 0) {
                inventory.scrambled_eggs--;
                hunger = Math.min(100, hunger + 40); health = Math.min(activeBuffs.meat_stew ? 130 : 100, health + 10);
                applyBuff('fortified_gut');
                showMessage('🥚 Ate scrambled eggs! +40 Hunger, +10 Health | Buff: Fortified Gut (2 mins)');
                updateUI(); updateHotbar();
            } else if (itemName === 'honey_cake' && inventory.honey_cake > 0) {
                inventory.honey_cake--;
                hunger = Math.min(100, hunger + 70); health = Math.min(activeBuffs.meat_stew ? 130 : 100, health + 20);
                applyBuff('sugar_rush');
                showMessage('🍰 Ate honey cake! +70 Hunger, +20 Health | Buff: Sugar Rush (90s)');
                updateUI(); updateHotbar();
            } else if (itemName === 'honey_porridge' && inventory.honey_porridge > 0) {
                inventory.honey_porridge--;
                hunger = Math.min(100, hunger + 45); thirst = Math.min(100, thirst + 10);
                applyBuff('hydrated');
                applyBuff('warmth');
                showMessage('🍯 Ate honey porridge! +45 Hunger, +10 Thirst | Buffs: Hydrated (4 mins) & Warmth (5 mins)');
                updateUI(); updateHotbar();
            } else if (itemName === 'raw_fish' && inventory.raw_fish > 0) {
                inventory.raw_fish--;
                hunger = Math.min(100, hunger + 15); health = Math.min(activeBuffs.meat_stew ? 130 : 100, health - 5);
                showMessage('🐟 Ate raw fish! +15 Hunger, -5 Health (cook it first!)');
                updateUI(); updateHotbar();
            } else if (itemName === 'cooked_fish' && inventory.cooked_fish > 0) {
                inventory.cooked_fish--;
                hunger = Math.min(100, hunger + 40); health = Math.min(activeBuffs.meat_stew ? 130 : 100, health + 8);
                showMessage('🍗 Ate cooked fish! +40 Hunger, +8 Health');
                updateUI(); updateHotbar();
            } else if (itemName === 'grilled_fish_stew' && inventory.grilled_fish_stew > 0) {
                inventory.grilled_fish_stew--;
                hunger = Math.min(100, hunger + 65); thirst = Math.min(100, thirst + 20); health = Math.min(activeBuffs.meat_stew ? 130 : 100, health + 15);
                applyBuff('well_fed');
                showMessage('🍲 Ate grilled fish stew! +65 Hunger, +20 Thirst, +15 Health | Buff: Well Fed (3 mins)');
                updateUI(); updateHotbar();
            } else if (itemName === 'pumpkin_soup' && inventory.pumpkin_soup > 0) {
                inventory.pumpkin_soup--;
                hunger = Math.min(100, hunger + 45); thirst = Math.min(100, thirst + 25); health = Math.min(activeBuffs.meat_stew ? 130 : 100, health + 8);
                applyBuff('warmth');
                showMessage('🎃 Ate pumpkin soup! +45 Hunger, +25 Thirst, +8 Health | Buff: Warmth (5 mins)');
                updateUI(); updateHotbar();
            } else if (itemName === 'stuffed_pumpkin' && inventory.stuffed_pumpkin > 0) {
                inventory.stuffed_pumpkin--;
                hunger = Math.min(100, hunger + 75); thirst = Math.min(100, thirst + 15); health = Math.min(activeBuffs.meat_stew ? 130 : 100, health + 20);
                applyBuff('hearty');
                showMessage('🎃 Ate stuffed pumpkin! +75 Hunger, +15 Thirst, +20 Health | Buff: Double Gathering (10 mins)');
                updateUI(); updateHotbar();
            } else if (itemName === 'pickled_cabbage' && inventory.pickled_cabbage > 0) {
                inventory.pickled_cabbage--;
                hunger = Math.min(100, hunger + 25); thirst = Math.min(100, thirst + 20); health = Math.min(activeBuffs.meat_stew ? 130 : 100, health + 10);
                showMessage('🥬 Ate pickled cabbage! +25 Hunger, +20 Thirst, +10 Health');
                updateUI(); updateHotbar();
            } else if (itemName === 'cabbage_stew' && inventory.cabbage_stew > 0) {
                inventory.cabbage_stew--;
                hunger = Math.min(100, hunger + 55); thirst = Math.min(100, thirst + 25); health = Math.min(activeBuffs.meat_stew ? 130 : 100, health + 10);
                applyBuff('veggi_stew');
                showMessage('🥬 Ate cabbage stew! +55 Hunger, +25 Thirst, +10 Health | Buff: Stamina Saver (10 mins)');
                updateUI(); updateHotbar();
            } else if (itemName === 'red_berry_jam' && inventory.red_berry_jam > 0) {
                inventory.red_berry_jam--;
                hunger = Math.min(100, hunger + 20); thirst = Math.min(100, thirst + 15); health = Math.min(activeBuffs.meat_stew ? 130 : 100, health + 5);
                showMessage('🫐 Ate red berry jam! +20 Hunger, +15 Thirst, +5 Health');
                updateUI(); updateHotbar();
            } else if (itemName === 'summer_salad' && inventory.summer_salad > 0) {
                inventory.summer_salad--;
                hunger = Math.min(100, hunger + 30); thirst = Math.min(100, thirst + 35); health = Math.min(activeBuffs.meat_stew ? 130 : 100, health + 12);
                applyBuff('hydrated');
                showMessage('🥗 Ate summer salad! +30 Hunger, +35 Thirst, +12 Health | Buff: Hydrated (4 mins)');
                updateUI(); updateHotbar();
            }
        }
        
        // Start healing over time
        function startHealing(totalAmount, amountPerTick, ticks) {
            healingState.active = true;
            healingState.totalHealing = totalAmount;
            healingState.healPerTick = amountPerTick;
            healingState.healingsRemaining = ticks;
            healingState.lastTickTime = Date.now();
        }
        
        // Update healing over time
        function updateHealing() {
            if (!healingState.active) return;
            
            const now = Date.now();
            if (now - healingState.lastTickTime >= healingState.tickInterval) {
                health = Math.min(activeBuffs.meat_stew ? 130 : 100, health + healingState.healPerTick);
                healingState.healingsRemaining--;
                healingState.lastTickTime = now;
                updateUI();
                
                if (healingState.healingsRemaining <= 0) {
                    healingState.active = false;
                    showMessage('\ud83d\udc9a Healing complete!');
                }
            }
        }
        
        // ===== ENHANCED TREES =====
        const trees = [];
        const treePositions = [];
        const stumpRespawnQueue = []; // Track stumps waiting to respawn
        const rockRespawnQueue = []; // Track rocks waiting to respawn
        const oreRespawnQueue = []; // Track ores waiting to respawn
        
        function createTree(x, z) {
            // Try GLB first; fall back to procedural if not loaded yet
            if (_assetGLBCache['Tree.glb']) {
                const targetH = 5.5 + Math.random() * 3.0;
                const inst = _instantiateGLB('Tree.glb', targetH);
                inst.position.set(x, inst.position.y + yOffset, z);
                inst.rotation.y = Math.random() * Math.PI * 2;
                inst.userData.type = 'tree';
                inst.userData.health = 5;
                inst.userData.maxHealth = 5;
                inst.userData.trunkHeight = targetH * 0.65;
                inst.userData.swayPhase = Math.random() * Math.PI * 2;
                inst.userData.swaySpeed = 0.4 + Math.random() * 0.3;
                inst.userData.canopy = null;
                trees.push(inst);
                treePositions.push({ x, z, radius: 1.2 });
                scene.add(inst);
                return;
            }
            _loadAssetGLB('Tree.glb').then(() => { /* will be used on next spawn */ });
            const tree = new THREE.Group();
            
            // ?? Shape variation ??????????????????????????????????????????????
            // Pick a tree "archetype" so forests feel varied
            const archetype = Math.floor(Math.random() * 4);
            // 0 = tall/slender, 1 = short/wide, 2 = conical, 3 = lopsided
            
            const trunkHeight = archetype === 0 ? 7 + Math.random() * 3
                              : archetype === 1 ? 6 + Math.random() * 2
                              : archetype === 2 ? 6 + Math.random() * 2
                              :                   6 + Math.random() * 2.5;

            const trunkTopR    = archetype === 0 ? 0.28 + Math.random() * 0.08 : 0.35 + Math.random() * 0.12;
            const trunkBottomR = trunkTopR + 0.12 + Math.random() * 0.06;
            const trunkSegs    = 7 + Math.floor(Math.random() * 3); // 7?9 sides
            const trunkGeometry = new THREE.CylinderGeometry(trunkTopR, trunkBottomR, trunkHeight, trunkSegs);

            // Subtle random lean
            const leanX = (Math.random() - 0.5) * 0.12;
            const leanZ = (Math.random() - 0.5) * 0.12;

            // Better bark texture with more detail
            const barkData = new Uint8Array(16 * 16 * 4);
            for (let i = 0; i < 16 * 16; i++) {
                const bx = i % 16;
                const by = Math.floor(i / 16);
                const verticalPattern = Math.abs(Math.sin(bx * 0.8)) * 20;
                const horizontalRings = Math.abs(Math.sin(by * 0.5)) * 15;
                const noise = Math.random() * 10;
                const baseColor = 45 + verticalPattern + horizontalRings + noise;
                barkData[i * 4]     = baseColor;
                barkData[i * 4 + 1] = baseColor * 0.6;
                barkData[i * 4 + 2] = baseColor * 0.4;
                barkData[i * 4 + 3] = 255;
            }
            const trunkTexture = new THREE.DataTexture(barkData, 16, 16, THREE.RGBAFormat);
            trunkTexture.needsUpdate = true;
            trunkTexture.wrapS = THREE.RepeatWrapping;
            trunkTexture.wrapT = THREE.RepeatWrapping;
            trunkTexture.repeat.set(2, 4);
            trunkTexture.magFilter = THREE.NearestFilter;
            
            const trunkMaterial = new THREE.MeshStandardMaterial({
                map: trunkTexture,
                roughness: 0.95,
                metalness: 0
            });
            
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = trunkHeight / 2;
            trunk.rotation.x = leanX;
            trunk.rotation.z = leanZ;
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            tree.add(trunk);

            // ?? Optional side branch (50% chance) ???????????????????????????
            if (Math.random() < 0.5) {
                const branchAngle   = Math.random() * Math.PI * 2;          // random azimuth
                const branchHeightFrac = 0.55 + Math.random() * 0.3;        // 55?85% up trunk
                const branchY       = trunkHeight * branchHeightFrac;
                const branchLen     = 1.2 + Math.random() * 1.4;
                const branchR       = trunkTopR * (0.25 + Math.random() * 0.15);
                const branchGeo     = new THREE.CylinderGeometry(branchR * 0.4, branchR, branchLen, 6);
                const branch        = new THREE.Mesh(branchGeo, trunkMaterial);

                // Rotate so the cylinder points outward-and-upward from the trunk
                branch.rotation.z  =  Math.PI / 2;                          // lay it flat first
                branch.rotation.y  =  branchAngle;                          // azimuth
                // Tilt upward ~25?45?
                const tiltUp       = -(0.44 + Math.random() * 0.35);        // negative = tip goes up
                branch.rotation.x  = tiltUp;

                // Offset so the branch root sits at the trunk surface
                const offsetX = Math.cos(branchAngle) * trunkTopR;
                const offsetZ = Math.sin(branchAngle) * trunkTopR;
                branch.position.set(offsetX, branchY, offsetZ);
                branch.castShadow = true;
                tree.add(branch);

                // No separate tuft \ufffd branch blends into main crown
            }
            
            // ?? Foliage crown ????????????????????????????????????????????????
            // Archetype-specific crown shapes
            let foliageLayers, baseSize, sizeStep, spreadY, spreadXZ;
            if (archetype === 0) {          // tall / slender
                foliageLayers = 4; baseSize = 2.8; sizeStep = 0.5; spreadY = 1.8; spreadXZ = 0;
            } else if (archetype === 1) {   // short / wide
                foliageLayers = 2; baseSize = 4.2; sizeStep = 0.9; spreadY = 1.2; spreadXZ = 0.5;
            } else if (archetype === 2) {   // conical (pine-like stacked)
                foliageLayers = 5; baseSize = 3.2; sizeStep = 0.55; spreadY = 1.5; spreadXZ = -0.1;
            } else {                        // lopsided ? offset cluster
                foliageLayers = 3; baseSize = 3.0; sizeStep = 0.65; spreadY = 1.6; spreadXZ = 0.3;
            }

            for (let i = 0; i < foliageLayers; i++) {
                const size = baseSize - i * sizeStep;
                const foliageGeometry = new THREE.SphereGeometry(Math.max(size, 0.8), 8, 7);
                
                // Distort sphere vertices for a fluffy, non-uniform crown
                const fPos = foliageGeometry.attributes.position;
                for (let vi = 0; vi < fPos.count; vi++) {
                    const vx = fPos.getX(vi), vy = fPos.getY(vi), vz = fPos.getZ(vi);
                    const bumpScale = 0.12 + Math.random() * 0.1;
                    fPos.setXYZ(vi,
                        vx * (1 + (Math.random() - 0.5) * bumpScale),
                        vy * (1 + (Math.random() - 0.5) * bumpScale * 0.7),
                        vz * (1 + (Math.random() - 0.5) * bumpScale)
                    );
                }
                foliageGeometry.computeVertexNormals();

                const leafData = new Uint8Array(16 * 16 * 4);
                for (let j = 0; j < 16 * 16; j++) {
                    const lx = (j % 16) / 16;
                    const ly = Math.floor(j / 16) / 16;
                    const pattern = (Math.sin(lx * 8) * Math.cos(ly * 8) + 1) * 0.5;
                    const brightness = pattern + Math.random() * 0.2;
                    const greenBase = 50 + brightness * 80;
                    leafData[j * 4]     = greenBase * 0.4;
                    leafData[j * 4 + 1] = greenBase;
                    leafData[j * 4 + 2] = greenBase * 0.3;
                    leafData[j * 4 + 3] = 255;
                }
                const leafTexture = new THREE.DataTexture(leafData, 16, 16, THREE.RGBAFormat);
                leafTexture.needsUpdate = true;
                leafTexture.wrapS = THREE.RepeatWrapping;
                leafTexture.wrapT = THREE.RepeatWrapping;
                leafTexture.magFilter = THREE.NearestFilter;
                
                const foliageMaterial = new THREE.MeshStandardMaterial({
                    map: leafTexture,
                    color: new THREE.Color().setHSL(0.28 + Math.random() * 0.05 - i * 0.015, 0.78, 0.38 + i * 0.04),
                    roughness: 0.9,
                    metalness: 0,
                    flatShading: false
                });
                
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                // Lopsided archetype offsets the whole crown sideways
                const xOff = archetype === 3 ? (Math.random() - 0.5) * spreadXZ * 2 : 0;
                const zOff = archetype === 3 ? (Math.random() - 0.5) * spreadXZ * 2 : 0;
                // Push foliage down into the trunk top so no gap/flat-bottom is visible
                const overlapY = size * 0.18;  // small overlap to avoid gap, but trunk stays visible
                foliage.position.set(xOff, trunkHeight - overlapY + i * spreadY, zOff);
                // Squash bottom half slightly so the underside blends into the trunk
                foliage.scale.set(1, 0.82, 1);
                foliage.castShadow = true;
                foliage.receiveShadow = true;
                tree.add(foliage);
            }
            
            tree.position.set(x, 0, z);
            tree.userData.health = 3;
            tree.userData.type = 'tree';
            tree.userData.swayPhase = Math.random() * Math.PI * 2;
            tree.userData.swaySpeed = 0.5 + Math.random() * 0.3;
            
            // Dirt patch under trunk base
            const treeDirtRadius = trunkBottomR * 2.8 + Math.random() * 0.6;
            const treeDirtPatch = spawnDirtPatch(x, z, treeDirtRadius, 0.45);
            scene.add(treeDirtPatch);

            trees.push(tree);
            const _treePosEntry = { x, z, radius: 2 };
            tree.userData._posEntry = _treePosEntry;
            tree.userData._posArray = treePositions;
            treePositions.push(_treePosEntry);
            scene.add(tree);
        }
        
        // ── Tree 2 variant (uses Tree 2.glb, distinct grove spawn zone) ────────────
        function createTree2(x, z, noDirt = false) {
            // GLB-first: use Tree 2.glb if already loaded
            if (_assetGLBCache['Tree 2.glb']) {
                const targetH = 4.5 + Math.random() * 3.5;
                const inst = _instantiateGLB('Tree 2.glb', targetH);
                inst.position.set(x, inst.position.y, z);
                inst.rotation.y = Math.random() * Math.PI * 2;
                inst.userData.type        = 'tree';
                inst.userData.isTree2     = true;
                inst.userData.health      = 5;
                inst.userData.maxHealth   = 5;
                inst.userData.trunkHeight = targetH * 0.65;
                inst.userData.swayPhase   = Math.random() * Math.PI * 2;
                inst.userData.swaySpeed   = 0.45 + Math.random() * 0.3;
                inst.userData.canopy      = null;
                trees.push(inst);
                treePositions.push({ x, z, radius: 1.2 });
                scene.add(inst);
                return;
            }
            _loadAssetGLB('Tree 2.glb').then(() => { /* used on next spawn */ });

            // ── Procedural fallback ──────────────────────────────────────────────
            const tree = new THREE.Group();

            // Tree 2 archetypes: slightly different proportions to the standard tree
            const archetype = Math.floor(Math.random() * 4);
            // 0 = tall/slender,  1 = short/wide,  2 = conical,  3 = spreading

            const trunkHeight = archetype === 0 ? 8 + Math.random() * 4
                              : archetype === 1 ? 5 + Math.random() * 2
                              : archetype === 2 ? 7 + Math.random() * 2.5
                              :                   6 + Math.random() * 3;

            const trunkTopR    = archetype === 0 ? 0.22 + Math.random() * 0.07 : 0.30 + Math.random() * 0.10;
            const trunkBottomR = trunkTopR + 0.14 + Math.random() * 0.08;
            const trunkSegs    = 8 + Math.floor(Math.random() * 3);
            const trunkGeometry = new THREE.CylinderGeometry(trunkTopR, trunkBottomR, trunkHeight, trunkSegs);

            // Subtle lean
            const leanX = (Math.random() - 0.5) * 0.10;
            const leanZ = (Math.random() - 0.5) * 0.10;

            // Bark texture — slightly redder/darker tone than standard tree
            const barkData = new Uint8Array(16 * 16 * 4);
            for (let i = 0; i < 16 * 16; i++) {
                const bx = i % 16;
                const by = Math.floor(i / 16);
                const vertStripe  = Math.abs(Math.sin(bx * 1.1)) * 18;
                const horizRings  = Math.abs(Math.sin(by * 0.7)) * 12;
                const noise       = Math.random() * 12;
                const base        = 38 + vertStripe + horizRings + noise;
                barkData[i * 4]     = base;
                barkData[i * 4 + 1] = base * 0.55;
                barkData[i * 4 + 2] = base * 0.35;
                barkData[i * 4 + 3] = 255;
            }
            const trunkTexture = new THREE.DataTexture(barkData, 16, 16, THREE.RGBAFormat);
            trunkTexture.needsUpdate = true;
            trunkTexture.wrapS = THREE.RepeatWrapping;
            trunkTexture.wrapT = THREE.RepeatWrapping;
            trunkTexture.repeat.set(2, 5);
            trunkTexture.magFilter = THREE.NearestFilter;

            const trunkMaterial = new THREE.MeshStandardMaterial({
                map: trunkTexture, roughness: 0.96, metalness: 0
            });

            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = trunkHeight / 2;
            trunk.rotation.x = leanX;
            trunk.rotation.z = leanZ;
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            tree.add(trunk);

            // Optional side branch (60% chance)
            if (Math.random() < 0.6) {
                const branchAngle      = Math.random() * Math.PI * 2;
                const branchHeightFrac = 0.50 + Math.random() * 0.35;
                const branchY          = trunkHeight * branchHeightFrac;
                const branchLen        = 1.4 + Math.random() * 1.6;
                const branchR          = trunkTopR * (0.22 + Math.random() * 0.15);
                const branchGeo        = new THREE.CylinderGeometry(branchR * 0.35, branchR, branchLen, 6);
                const branch           = new THREE.Mesh(branchGeo, trunkMaterial);
                branch.rotation.z      = Math.PI / 2;
                branch.rotation.y      = branchAngle;
                branch.rotation.x      = -(0.38 + Math.random() * 0.40);
                const offsetX = Math.cos(branchAngle) * trunkTopR;
                const offsetZ = Math.sin(branchAngle) * trunkTopR;
                branch.position.set(offsetX, branchY, offsetZ);
                branch.castShadow = true;
                tree.add(branch);

                // Second branch for spreading archetype (50% chance)
                if (archetype === 3 && Math.random() < 0.5) {
                    const b2Angle  = branchAngle + Math.PI + (Math.random() - 0.5) * 0.4;
                    const b2Y      = trunkHeight * (branchHeightFrac + 0.12);
                    const b2Geo    = new THREE.CylinderGeometry(branchR * 0.3, branchR * 0.75, branchLen * 0.85, 6);
                    const branch2  = new THREE.Mesh(b2Geo, trunkMaterial);
                    branch2.rotation.z = Math.PI / 2;
                    branch2.rotation.y = b2Angle;
                    branch2.rotation.x = -(0.30 + Math.random() * 0.35);
                    branch2.position.set(Math.cos(b2Angle) * trunkTopR, b2Y, Math.sin(b2Angle) * trunkTopR);
                    branch2.castShadow = true;
                    tree.add(branch2);
                }
            }

            // Foliage crown — slightly deeper greens than standard tree
            let foliageLayers, baseSize, sizeStep, spreadY, spreadXZ;
            if (archetype === 0) {          // tall / slender
                foliageLayers = 5; baseSize = 2.5; sizeStep = 0.42; spreadY = 1.7; spreadXZ = 0;
            } else if (archetype === 1) {   // short / wide
                foliageLayers = 2; baseSize = 4.5; sizeStep = 1.0;  spreadY = 1.1; spreadXZ = 0.6;
            } else if (archetype === 2) {   // conical
                foliageLayers = 6; baseSize = 3.4; sizeStep = 0.50; spreadY = 1.4; spreadXZ = -0.1;
            } else {                        // spreading
                foliageLayers = 3; baseSize = 3.6; sizeStep = 0.75; spreadY = 1.7; spreadXZ = 0.55;
            }

            for (let i = 0; i < foliageLayers; i++) {
                const size = baseSize - i * sizeStep;
                const foliageGeometry = new THREE.SphereGeometry(Math.max(size, 0.75), 8, 7);

                const fPos = foliageGeometry.attributes.position;
                for (let vi = 0; vi < fPos.count; vi++) {
                    const vx = fPos.getX(vi), vy = fPos.getY(vi), vz = fPos.getZ(vi);
                    const bumpScale = 0.14 + Math.random() * 0.10;
                    fPos.setXYZ(vi,
                        vx * (1 + (Math.random() - 0.5) * bumpScale),
                        vy * (1 + (Math.random() - 0.5) * bumpScale * 0.7),
                        vz * (1 + (Math.random() - 0.5) * bumpScale)
                    );
                }
                foliageGeometry.computeVertexNormals();

                // Leaf texture — deeper greens with slightly more yellow variation
                const leafData = new Uint8Array(16 * 16 * 4);
                for (let j = 0; j < 16 * 16; j++) {
                    const lx = (j % 16) / 16;
                    const ly = Math.floor(j / 16) / 16;
                    const pattern    = (Math.sin(lx * 9) * Math.cos(ly * 7) + 1) * 0.5;
                    const brightness = pattern + Math.random() * 0.18;
                    const greenBase  = 44 + brightness * 74;
                    leafData[j * 4]     = greenBase * 0.35;
                    leafData[j * 4 + 1] = greenBase;
                    leafData[j * 4 + 2] = greenBase * 0.25;
                    leafData[j * 4 + 3] = 255;
                }
                const leafTexture = new THREE.DataTexture(leafData, 16, 16, THREE.RGBAFormat);
                leafTexture.needsUpdate = true;
                leafTexture.wrapS = THREE.RepeatWrapping;
                leafTexture.wrapT = THREE.RepeatWrapping;
                leafTexture.magFilter = THREE.NearestFilter;

                const foliageMaterial = new THREE.MeshStandardMaterial({
                    map: leafTexture,
                    color: new THREE.Color().setHSL(0.30 + Math.random() * 0.04 - i * 0.012, 0.72, 0.34 + i * 0.045),
                    roughness: 0.92, metalness: 0, flatShading: false
                });

                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                const xOff = archetype === 3 ? (Math.random() - 0.5) * spreadXZ * 2 : 0;
                const zOff = archetype === 3 ? (Math.random() - 0.5) * spreadXZ * 2 : 0;
                const overlapY = size * 0.18;
                foliage.position.set(xOff, trunkHeight - overlapY + i * spreadY, zOff);
                foliage.scale.set(1, 0.80, 1);
                foliage.castShadow = true;
                foliage.receiveShadow = true;
                tree.add(foliage);
            }

            tree.position.set(x, 0, z);
            tree.userData.health    = 5;
            tree.userData.maxHealth = 5;
            tree.userData.type      = 'tree';
            tree.userData.isTree2   = true;
            tree.userData.swayPhase = Math.random() * Math.PI * 2;
            tree.userData.swaySpeed = 0.45 + Math.random() * 0.3;

            const treeDirtRadius = trunkBottomR * 2.8 + Math.random() * 0.6;
            if (!noDirt) {
                const treeDirtPatch = spawnDirtPatch(x, z, treeDirtRadius, 0.45);
                scene.add(treeDirtPatch);
            }

            trees.push(tree);
            const _t2PosEntry = { x, z, radius: 2 };
            tree.userData._posEntry = _t2PosEntry;
            tree.userData._posArray = treePositions;
            treePositions.push(_t2PosEntry);
            scene.add(tree);
        }

        // Create tree stump after tree is cut
        async function createTreeStump(x, z, trunkHeight) {
            // GLB-first
            if (_assetGLBCache['Stump.glb']) {
                const inst = _instantiateGLB('Stump.glb', 1.0);
                if (inst) {
                    inst.position.set(x, inst.position.y, z);
                    inst.rotation.y = Math.random() * Math.PI * 2;
                    inst.userData.type = 'stump';
                    scene.add(inst);
                    return inst;
                }
            }
            _loadAssetGLB('Stump.glb'); // kick off load for next time

            // Procedural fallback
            const stump = new THREE.Group();
            
            // Stump trunk (short)
            const stumpHeight = 0.8;
            const stumpGeometry = new THREE.CylinderGeometry(0.45, 0.52, stumpHeight, 8);
            
            const trunkTexture = new THREE.DataTexture(
                new Uint8Array([
                    60, 40, 20, 255,  55, 38, 18, 255,
                    58, 39, 19, 255,  62, 41, 21, 255
                ]),
                2, 2, THREE.RGBAFormat
            );
            trunkTexture.needsUpdate = true;
            trunkTexture.wrapS = THREE.RepeatWrapping;
            trunkTexture.wrapT = THREE.RepeatWrapping;
            trunkTexture.repeat.set(1, 1);
            trunkTexture.magFilter = THREE.NearestFilter;
            
            const trunkMaterial = new THREE.MeshStandardMaterial({
                map: trunkTexture,
                roughness: 0.95,
                metalness: 0
            });
            
            const stumpMesh = new THREE.Mesh(stumpGeometry, trunkMaterial);
            stumpMesh.position.y = stumpHeight / 2;
            stumpMesh.castShadow = true;
            stumpMesh.receiveShadow = true;
            stump.add(stumpMesh);
            
            // Top of stump (flat cut surface)
            const topGeo = new THREE.CylinderGeometry(0.45, 0.45, 0.05, 16);
            const topMat = await createWoodMaterial(0xD2691E, 0.9);
            const top = new THREE.Mesh(topGeo, topMat);
            top.position.y = stumpHeight + 0.025;
            top.castShadow = true;
            top.receiveShadow = true;
            stump.add(top);
            
            // Tree rings on top
            for (let i = 0; i < 4; i++) {
                const ringGeo = new THREE.TorusGeometry(0.1 + (i * 0.08), 0.01, 8, 16);
                const ringMat = new THREE.MeshStandardMaterial({
                    color: 0x8B4513,
                    roughness: 0.95
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.position.y = stumpHeight + 0.03;
                ring.rotation.x = Math.PI / 2;
                stump.add(ring);
            }
            
            stump.position.set(x, 0, z);
            stump.userData.type = 'stump';
            stump.castShadow = true;
            stump.receiveShadow = true;
            
            scene.add(stump);
            return stump;
        }
        
        // Generate forest — spawn immediately (GLB used if loaded, else procedural fallback)
        for (let i = 0; i < 80; i++) {
            let x, z, valid;
            let attempts = 0;
            do {
                valid = true;
                x = (Math.random() - 0.5) * 180;
                z = (Math.random() - 0.5) * 180;
                
                if (Math.sqrt(x * x + z * z) < 15) {
                    valid = false;
                    continue;
                }
                
                for (let pos of treePositions) {
                    const dist = Math.sqrt((x - pos.x) ** 2 + (z - pos.z) ** 2);
                    if (dist < 8) {
                        valid = false;
                        break;
                    }
                }
                attempts++;
            } while (!valid && attempts < 50);
            
            if (valid) createTree(x, z);
        }

        // Spawn Tree 2 groves — occupies a different part of the forest biome.
        // Spawned in the outer ring (radius 35–88) to avoid clustering with the
        // core forest trees near the centre, giving a natural grove feel.
        {
            const numTree2 = 40;
            const minR = 35, maxR = 88;
            for (let i = 0; i < numTree2; i++) {
                let x, z, valid;
                let attempts = 0;
                do {
                    valid = true;
                    const angle = Math.random() * Math.PI * 2;
                    const radius = minR + Math.random() * (maxR - minR);
                    x = Math.cos(angle) * radius;
                    z = Math.sin(angle) * radius;

                    for (let pos of treePositions) {
                        const dist = Math.sqrt((x - pos.x) ** 2 + (z - pos.z) ** 2);
                        if (dist < 7) { valid = false; break; }
                    }
                    attempts++;
                } while (!valid && attempts < 60);

                if (valid) createTree2(x, z);
            }
        }

        // Once Tree.glb loads, swap all procedural FOREST trees for GLB versions
        _loadAssetGLB('Tree.glb').then(tmpl => {
            if (!tmpl) { console.warn('🌲 Tree.glb failed — keeping procedural forest trees'); return; }
            console.log(`🌲 Tree.glb loaded — scanning ${trees.length} entries for procedural forest trees...`);
            let swapped = 0;
            for (let i = trees.length - 1; i >= 0; i--) {
                const old = trees[i];
                // Skip: wrong type, already a GLB (no swayPhase), a palm tree, or a Tree 2
                if (old.userData.type !== 'tree') continue;
                if (!old.userData.swayPhase) continue;       // already a GLB instance — skip
                if (old.userData.isPalmTree) continue;        // palm trees get their own swap below
                if (old.userData.isTree2)    continue;        // Tree 2 trees get their own swap below
                if (old.userData.isDeadTree) continue;        // dead trees get their own swap below
                const x = old.position.x, z = old.position.z;
                const targetH = 5.5 + Math.random() * 3.0;
                const inst = _instantiateGLB('Tree.glb', targetH);
                if (!inst) { console.warn('🌲 _instantiateGLB returned null for Tree.glb'); continue; }
                inst.position.set(x, inst.position.y, z);
                inst.rotation.y = Math.random() * Math.PI * 2;
                inst.userData.type = 'tree';
                inst.userData.health = old.userData.health ?? 5;
                inst.userData.maxHealth = 5;
                inst.userData.trunkHeight = targetH * 0.65;
                inst.userData.swayPhase = Math.random() * Math.PI * 2;
                inst.userData.swaySpeed = 0.4 + Math.random() * 0.3;
                inst.userData._posEntry = old.userData._posEntry;
                inst.userData._posArray = old.userData._posArray;
                scene.remove(old);
                scene.add(inst);
                trees[i] = inst;
                swapped++;
                if (swapped === 1) {
                    inst.updateMatrixWorld(true);
                    const wp = new THREE.Vector3();
                    inst.getWorldPosition(wp);
                    const bb = new THREE.Box3().setFromObject(inst);
                    console.log(`🌲 FIRST TREE world pos: (${wp.x.toFixed(1)}, ${wp.y.toFixed(1)}, ${wp.z.toFixed(1)}) | bbox Y: ${bb.min.y.toFixed(2)} → ${bb.max.y.toFixed(2)} | inst.position.y=${inst.position.y.toFixed(3)} | scale=${inst.scale.x.toFixed(3)}`);
                }
            }
            console.log(`🌲 Forest tree swap done: ${swapped} procedural → GLB`);
        });

        // Once Tree 2.glb loads, swap procedural Tree 2 instances for GLB versions
        _loadAssetGLB('Tree 2.glb').then(tmpl => {
            if (!tmpl) { console.warn('🌳 Tree 2.glb failed — keeping procedural Tree 2 trees'); return; }
            console.log(`🌳 Tree 2.glb loaded — scanning ${trees.length} entries for procedural Tree 2 trees...`);
            let swapped2 = 0;
            for (let i = trees.length - 1; i >= 0; i--) {
                const old = trees[i];
                if (old.userData.type !== 'tree') continue;
                if (!old.userData.isTree2)        continue;   // only replace Tree 2 procedural instances
                if (!old.userData.swayPhase)       continue;   // already a GLB instance — skip
                const x = old.position.x, z = old.position.z;
                const targetH = 4.5 + Math.random() * 3.5;
                const inst = _instantiateGLB('Tree 2.glb', targetH);
                if (!inst) { console.warn('🌳 _instantiateGLB returned null for Tree 2.glb'); continue; }
                inst.position.set(x, inst.position.y, z);
                inst.rotation.y = Math.random() * Math.PI * 2;
                inst.userData.type        = 'tree';
                inst.userData.isTree2     = true;
                inst.userData.health      = old.userData.health ?? 5;
                inst.userData.maxHealth   = 5;
                inst.userData.trunkHeight = targetH * 0.65;
                inst.userData.swayPhase   = Math.random() * Math.PI * 2;
                inst.userData.swaySpeed   = 0.45 + Math.random() * 0.3;
                inst.userData._posEntry   = old.userData._posEntry;
                inst.userData._posArray   = old.userData._posArray;
                scene.remove(old);
                scene.add(inst);
                trees[i] = inst;
                swapped2++;
                if (swapped2 === 1) {
                    inst.updateMatrixWorld(true);
                    const wp = new THREE.Vector3();
                    inst.getWorldPosition(wp);
                    const bb = new THREE.Box3().setFromObject(inst);
                    console.log(`🌳 FIRST TREE2 world pos: (${wp.x.toFixed(1)}, ${wp.y.toFixed(1)}, ${wp.z.toFixed(1)}) | bbox Y: ${bb.min.y.toFixed(2)} → ${bb.max.y.toFixed(2)}`);
                }
            }
            console.log(`🌳 Tree 2 swap done: ${swapped2} procedural → GLB`);
        });

        // ===== SNOW BIOME CONSTANTS — east of the desert ──────────────────────────
        // Desert is centred at (0, -groundSize). Snow sits east: X = +groundSize, Z = -groundSize
        const SB_CX   = groundSize;          // 200 — same column as river biome
        const SB_CZ   = -groundSize;         // -200 — same row as desert biome
        const SB_SIZE = groundSize;          // 200 × 200

        // Smooth-noise helper (layered sinusoids — no external libs needed)
        function _sbNoise(x, z) {
            return Math.sin(x * 0.031 + 0.7) * Math.cos(z * 0.027 - 0.4) * 1.0
                 + Math.sin(x * 0.057 - 1.1) * Math.cos(z * 0.061 + 0.8) * 0.55
                 + Math.sin(x * 0.112 + 0.3) * Math.cos(z * 0.097 - 1.3) * 0.25
                 + Math.sin(x * 0.193 - 0.9) * Math.cos(z * 0.178 + 0.6) * 0.12;
        }

        // Flat-plateau mask: values near 0 become very flat, peaks preserved
        function _sbFlatten(h) {
            // Squash the lower 40% of height into near-zero — creates wide flat valleys
            if (h < 0.4) return h * h * 0.6;
            return h;
        }

        // Returns world-Y terrain height at any (wx,wz) INSIDE the snow biome.
        // Outside returns 0 (flat ground level). Positive = raised terrain.
        // Borders are kept flat so the transition between biomes is smooth and level.
        function snowTerrainY(wx, wz) {
            const lx = wx - SB_CX;
            const lz = wz - SB_CZ;
            const half = SB_SIZE / 2 + 4;
            if (Math.abs(lx) > half || Math.abs(lz) > half) return 0;

            // Wider edge fade — large flat border zone where biomes meet (was 28, now 55)
            // This creates a wide flat transition band so the terrain is level at all borders
            const fadeX = Math.max(0, Math.min(1, (half - Math.abs(lx)) / 55));
            const fadeZ = Math.max(0, Math.min(1, (half - Math.abs(lz)) / 55));
            const fade  = fadeX * fadeZ;

            // Raw height field: base gentle rolls + sharper ridges
            const raw = (_sbNoise(wx, wz) + 1) * 0.5;  // 0..1
            const flat = _sbFlatten(raw);

            // Scale: max raised area ~9 units high, flat valleys near 0
            return flat * 9.0 * fade;
        }

        // ===== RIVER BIOME =====
        // ── River constants in OUTER scope so the movement system can access them ──
        const RB_CX       = groundSize;   // world-space centre X = 200
        const RB_CZ       = 0;
        const RB_SIZE     = groundSize;   // 200
        const RIVER_WIDTH = 26;   // wider = gentler slopes = less jagged
        const RIVER_DEPTH = 3.2;
        const RB_PATH_N   = 120; // more path samples = smoother centreline

        function rbRiverCX(t) {
            return Math.sin(t * Math.PI * 2.1 + 0.9) * 16
                 + Math.sin(t * Math.PI * 1.05 - 0.3) * 10;
        }
        function rbRiverCZ(t) { return (t - 0.5) * 200; }
        function rbRiverTX(t) {
            const h = 0.001;
            return (rbRiverCX(t + h) - rbRiverCX(t - h)) / (2 * h);
        }

        // Pre-sample centreline once for fast distance queries
        const _rbPathPts = [];
        for (let i = 0; i <= RB_PATH_N; i++) {
            const t = i / RB_PATH_N;
            _rbPathPts.push({ x: rbRiverCX(t), z: rbRiverCZ(t) });
        }

        // Returns the terrain Y at world-space (wx, wz) — 0 on flat ground, negative inside channel
        function rbTerrainY(wx, wz) {
            const lx = wx - RB_CX, lz = wz - RB_CZ;
            if (Math.abs(lx) > RB_SIZE / 2 + 4 || Math.abs(lz) > RB_SIZE / 2 + 4) return 0;
            let minD2 = Infinity, closestT = 0;
            for (let i = 0; i < _rbPathPts.length; i++) {
                const dx = lx - _rbPathPts[i].x, dz = lz - _rbPathPts[i].z;
                const d2 = dx*dx + dz*dz;
                if (d2 < minD2) { minD2 = d2; closestT = i / RB_PATH_N; }
            }
            const dist  = Math.sqrt(minD2);
            const hw    = RIVER_WIDTH / 2;
            if (dist >= hw) return 0;
            // Smooth hermite (smoothstep) curve: zero slope at both edges → no cliff
            const u  = dist / hw;                         // 0=centre, 1=edge
            const s  = u * u * (3 - 2 * u);               // smoothstep 0→1
            const depthFrac = 1.0 - s;                    // 1 at centre, 0 at edge
            const endFade   = Math.min(1, Math.min(closestT, 1 - closestT) / 0.05);
            return -(RIVER_DEPTH * depthFrac * endFade);
        }

        // carve depth helper used during terrain build
        function rbCarveDepth(lx, lz) { return -rbTerrainY(lx + RB_CX, lz + RB_CZ); }

        {   // ── River biome scene-build block ─────────────────────────────────────

            // ── Textures ──────────────────────────────────────────────────────────

            // Grass texture — reuse the forest biome's groundTexture (real grass photo)
            const rbGrassTex = groundTexture;
            rbGrassTex.repeat.set(20, 20);

            // Dirt/riverbed texture
            const rbDirtCanvas = document.createElement('canvas');
            rbDirtCanvas.width = 128; rbDirtCanvas.height = 128;
            const rbDCtx = rbDirtCanvas.getContext('2d');
            for (let py = 0; py < 128; py++) {
                for (let px = 0; px < 128; px++) {
                    const n = Math.random();
                    rbDCtx.fillStyle = `rgb(${Math.floor(50+n*24)},${Math.floor(36+n*18)},${Math.floor(18+n*12)})`;
                    rbDCtx.fillRect(px, py, 1, 1);
                }
            }
            for (let sp = 0; sp < 400; sp++) {
                const px = Math.random() * 128, py = Math.random() * 128;
                const v = Math.floor(55 + Math.random() * 50);
                rbDCtx.fillStyle = `rgb(${v},${Math.floor(v*0.82)},${Math.floor(v*0.6)})`;
                rbDCtx.fillRect(px, py, 1 + Math.random() * 2, 1 + Math.random() * 2);
            }
            const rbDirtTex = new THREE.CanvasTexture(rbDirtCanvas);
            rbDirtTex.wrapS = THREE.RepeatWrapping;
            rbDirtTex.wrapT = THREE.RepeatWrapping;
            rbDirtTex.repeat.set(8, 8);

            // ── Unified terrain + water mesh ──────────────────────────────────────
            // Instead of a separate water ribbon (which always tears at the edges),
            // every vertex in the carved channel that is AT OR ABOVE the water level
            // is snapped to the water Y and rendered as water in the shader.
            // This guarantees zero seams — the water IS part of the terrain mesh.
            //
            // Water level sits at RIVER_DEPTH * 0.60 below ground surface.
            // Any terrain vertex whose carved Y is below that level gets snapped up
            // to water level and flagged as water (vertex color blue channel = 1).

            const WATER_LEVEL  = -(RIVER_DEPTH * 0.46); // y of flat water surface — raised
            const RB_SUBDIV    = 200;  // 200x200 = ~1 unit grid spacing, smooth banks
            const RB_SIZE_MESH = groundSize; // 200

            const rbVCols = []; // r=grass, g=dirt, b=water
            const rbVPos  = [];
            const rbVUVg  = [];
            const rbVUVd  = [];
            // Store which vertices are water so animator can ripple them
            const rbWaterVerts = []; // true/false per vertex

            for (let zi = 0; zi <= RB_SUBDIV; zi++) {
                for (let xi = 0; xi <= RB_SUBDIV; xi++) {
                    const lx    = (xi / RB_SUBDIV - 0.5) * RB_SIZE_MESH;
                    const lz    = (zi / RB_SUBDIV - 0.5) * RB_SIZE_MESH;
                    const carve = rbCarveDepth(lx, lz);
                    let   y     = -carve;

                    // Is this vertex inside the channel and below or at water level?
                    const isWater = (carve > 0 && y <= WATER_LEVEL + 0.01);
                    if (isWater) y = WATER_LEVEL; // snap to flat water surface

                    // Dirt blend for bank/bed — smooth transition, zero on water
                    let dirtBlend = 0;
                    if (!isWater && carve > 0) {
                        const t = Math.min(1, carve / RIVER_DEPTH * 1.3);
                        dirtBlend = t * t * (3 - 2 * t); // smoothstep
                    }
                    const waterVal  = isWater ? 1.0 : 0.0;
                    const grassVal  = isWater ? 0.0 : (1 - dirtBlend);

                    rbVPos.push(lx, y, lz);
                    rbVUVg.push((lx / RB_SIZE_MESH + 0.5) * 20, (lz / RB_SIZE_MESH + 0.5) * 20);
                    rbVUVd.push((lx / RB_SIZE_MESH + 0.5) * 8,  (lz / RB_SIZE_MESH + 0.5) * 8);
                    rbVCols.push(grassVal, dirtBlend, waterVal, 1.0);
                    rbWaterVerts.push(isWater);
                }
            }

            const rbIdx = [];
            for (let zi = 0; zi < RB_SUBDIV; zi++) {
                for (let xi = 0; xi < RB_SUBDIV; xi++) {
                    const a = zi * (RB_SUBDIV+1) + xi, b = (zi+1)*(RB_SUBDIV+1)+xi;
                    rbIdx.push(a, b, a+1,  a+1, b, b+1);
                }
            }

            const rbGeo = new THREE.BufferGeometry();
            rbGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(rbVPos),  3));
            rbGeo.setAttribute('uv',       new THREE.BufferAttribute(new Float32Array(rbVUVg),  2));
            rbGeo.setAttribute('uv2',      new THREE.BufferAttribute(new Float32Array(rbVUVd),  2));
            rbGeo.setAttribute('color',    new THREE.BufferAttribute(new Float32Array(rbVCols), 4));
            rbGeo.setIndex(rbIdx);
            rbGeo.computeVertexNormals();

            // Single shader renders grass / dirt / water by vertex colour channels
            const rbMat = new THREE.ShaderMaterial({
                uniforms: {
                    uGrass:  { value: rbGrassTex },
                    uDirt:   { value: rbDirtTex  },
                    uSunDir: { value: new THREE.Vector3(0.6, 1.0, 0.4).normalize() },
                    uTime:   { value: 0.0 },
                    uNight:  { value: 0.0 },
                },
                vertexShader: `
                    attribute vec2 uv2;
                    varying vec2  vUVg;
                    varying vec2  vUVd;
                    varying float vDirt;
                    varying float vWater;
                    varying vec3  vNormal;
                    varying vec3  vWorldPos;
                    void main() {
                        vUVg     = uv;
                        vUVd     = uv2;
                        vDirt    = color.g;
                        vWater   = color.b;
                        vNormal  = normalize(normalMatrix * normal);
                        vec4 wp  = modelMatrix * vec4(position, 1.0);
                        vWorldPos = wp.xyz;
                        gl_Position = projectionMatrix * viewMatrix * wp;
                    }
                `,
                fragmentShader: `
                    uniform sampler2D uGrass;
                    uniform sampler2D uDirt;
                    uniform vec3  uSunDir;
                    uniform float uTime;
                    uniform float uNight;
                    varying vec2  vUVg;
                    varying vec2  vUVd;
                    varying float vDirt;
                    varying float vWater;
                    varying vec3  vNormal;
                    varying vec3  vWorldPos;

                    float hash(vec2 p) { return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453); }
                    float noise(vec2 p) {
                        vec2 i = floor(p); vec2 f = fract(p);
                        vec2 u = f*f*(3.0-2.0*f);
                        return mix(mix(hash(i),hash(i+vec2(1,0)),u.x),mix(hash(i+vec2(0,1)),hash(i+vec2(1,1)),u.x),u.y);
                    }

                    void main() {
                        // Terrain colour (grass/dirt blend)
                        vec4 cGrass   = texture2D(uGrass, vUVg);
                        vec4 cDirt    = texture2D(uDirt,  vUVd);
                        vec4 cTerrain = mix(cGrass, cDirt, vDirt);

                        // ── Water ──────────────────────────────────────────────
                        // Base river colour: dark murky blue-green, much deeper/darker
                        vec3 deepCol    = vec3(0.02, 0.10, 0.22);
                        vec3 shallowCol = vec3(0.06, 0.28, 0.45);

                        // Multi-octave noise-based ripple (no grid artifacts)
                        float n1 = noise(vec2(vWorldPos.x * 0.9 + uTime * 0.7,  vWorldPos.z * 0.7 + uTime * 0.5));
                        float n2 = noise(vec2(vWorldPos.x * 1.8 - uTime * 0.9,  vWorldPos.z * 2.1 + uTime * 0.6));
                        float n3 = noise(vec2(vWorldPos.x * 3.1 + vWorldPos.z * 1.3 + uTime * 1.1, vWorldPos.z * 0.8 - uTime * 0.4));
                        float ripple = n1 * 0.5 + n2 * 0.3 + n3 * 0.2;

                        // Organic caustics — layered noise, no sin*sin grid
                        vec2 ca = vec2(vWorldPos.x * 2.8 + uTime * 0.6, vWorldPos.z * 2.8 + uTime * 0.45);
                        vec2 cb = vec2(vWorldPos.x * 2.1 - uTime * 0.5 + vWorldPos.z * 0.9, vWorldPos.z * 1.9 + uTime * 0.3);
                        float caustic = noise(ca) * noise(cb);
                        // Warp the lookup for more organic blobs
                        float warpX = noise(ca * 0.7 + vec2(uTime * 0.2, 0.0));
                        float warpZ = noise(cb * 0.7 + vec2(0.0, uTime * 0.15));
                        caustic = mix(caustic, noise(vec2(ca.x + warpX, cb.y + warpZ)), 0.5);
                        caustic = pow(caustic, 2.2) * 1.6;

                        // Foam at the banks (where dirt transitions to water)
                        float bankFoam = smoothstep(0.45, 0.85, vDirt) * vWater;
                        float foamNoise = noise(vec2(vWorldPos.x * 3.2 + uTime * 0.4, vWorldPos.z * 3.7 - uTime * 0.3));
                        float foam = bankFoam * foamNoise * 0.8;

                        // Organic specular — noise-derived glints, not sine grid
                        float specNoise1 = noise(vec2(vWorldPos.x * 4.5 + uTime * 1.8, vWorldPos.z * 3.8 + uTime * 1.4));
                        float specNoise2 = noise(vec2(vWorldPos.x * 7.0 - uTime * 1.5, vWorldPos.z * 5.5 + uTime * 1.0));
                        float spec1 = pow(max(0.0, specNoise1 * 2.0 - 1.2), 3.0) * 0.35;
                        float spec2 = pow(max(0.0, specNoise2 * 2.0 - 1.5), 4.0) * 0.25;

                        vec3 waterCol = mix(deepCol, shallowCol, ripple * 0.6);
                        waterCol += caustic * vec3(0.07, 0.13, 0.20);  // teal caustic tint
                        waterCol += foam * vec3(0.9, 0.95, 1.0);
                        waterCol += spec1 * vec3(0.75, 0.88, 1.0);
                        waterCol += spec2 * vec3(0.85, 0.93, 1.0);

                        // Deeper alpha — darker, more opaque water
                        float waterAlpha = 0.72;
                        vec4 cWater = vec4(waterCol, waterAlpha);

                        // Blend between terrain and water
                        vec4 col = mix(cTerrain, cWater, vWater);

                        // Diffuse lighting — flip normal on backface so underwater is lit correctly
                        vec3 n = gl_FrontFacing ? vNormal : -vNormal;
                        float diff = max(dot(n, uSunDir), 0.0) * 0.65 + 0.35;
                        // Night darkening — same approach as ocean
                        vec3 nightened = mix(col.rgb * diff, vec3(0.01, 0.02, 0.01), uNight * 0.92);
                        gl_FragColor = vec4(nightened, col.a);
                    }
                `,
                vertexColors: true,
                transparent: true,
                depthWrite:  true,
                side: THREE.DoubleSide,
                polygonOffset: true,
                polygonOffsetFactor: -1,
                polygonOffsetUnits:  -1,
            });

            const rbGround = new THREE.Mesh(rbGeo, rbMat);
            rbGround.position.set(RB_CX, 0, RB_CZ);
            rbGround.receiveShadow = true;
            rbGround.renderOrder   = 1;   // render after riverbed so water blends over it
            scene.add(rbGround);

            // ── Riverbed mesh ─────────────────────────────────────────────────────
            // A separate subdivided mesh that follows the carved channel floor,
            // sitting just below the water surface so it's visible through the
            // translucent water above. Uses its own sandy-gravel texture.
            (function() {
                const BED_SUBDIV = 160;
                const BED_SIZE   = RB_SIZE_MESH;
                const BED_Y_BIAS = -0.12;  // sit this far below WATER_LEVEL

                const bedVPos = [];
                const bedVUV  = [];

                for (let zi = 0; zi <= BED_SUBDIV; zi++) {
                    for (let xi = 0; xi <= BED_SUBDIV; xi++) {
                        const lx    = (xi / BED_SUBDIV - 0.5) * BED_SIZE;
                        const lz    = (zi / BED_SUBDIV - 0.5) * BED_SIZE;
                        const carve = rbCarveDepth(lx, lz);
                        // Only place bed geometry inside the channel
                        let y;
                        if (carve > 0) {
                            // Follow the carved depth but clamp to water level - bias
                            y = Math.min(WATER_LEVEL + BED_Y_BIAS, -carve);
                        } else {
                            // Outside channel — park way underground (invisible)
                            y = -999;
                        }
                        bedVPos.push(lx, y, lz);
                        bedVUV.push(
                            (lx / BED_SIZE + 0.5) * 6,
                            (lz / BED_SIZE + 0.5) * 6
                        );
                    }
                }

                const bedIdx = [];
                for (let zi = 0; zi < BED_SUBDIV; zi++) {
                    for (let xi = 0; xi < BED_SUBDIV; xi++) {
                        const a = zi * (BED_SUBDIV+1) + xi;
                        const b = (zi+1) * (BED_SUBDIV+1) + xi;
                        bedIdx.push(a, b, a+1,  a+1, b, b+1);
                    }
                }

                const bedGeo = new THREE.BufferGeometry();
                bedGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(bedVPos), 3));
                bedGeo.setAttribute('uv',       new THREE.BufferAttribute(new Float32Array(bedVUV),  2));
                bedGeo.setIndex(bedIdx);
                bedGeo.computeVertexNormals();

                // Sandy gravel riverbed texture — warm brown earth tones only
                const bedCanvas = document.createElement('canvas');
                bedCanvas.width = bedCanvas.height = 512;
                const bctx = bedCanvas.getContext('2d');

                // Base sand colour — rich dark brown, mud/earth tone
                bctx.fillStyle = '#5c4325';
                bctx.fillRect(0, 0, 512, 512);

                // Coarse sand grain noise — very small, same brown family
                for (let i = 0; i < 6000; i++) {
                    const px = Math.random() * 512;
                    const py = Math.random() * 512;
                    const sz = 0.5 + Math.random() * 1.5;
                    // Vary lightness only — keep hue firmly dark brown
                    const lightness = Math.floor(35 + Math.random() * 35); // 35–70
                    const r = Math.floor(lightness * 1.35);  // red heavy
                    const g = Math.floor(lightness * 0.85);  // less green
                    const b = Math.floor(lightness * 0.42);  // much less blue
                    bctx.fillStyle = 'rgb('+Math.min(r,255)+','+Math.min(g,255)+','+Math.min(b,255)+')';
                    bctx.fillRect(px, py, sz, sz);
                }

                // Pebbles — tiny oval shapes, dark grey-brown and light tan only
                const pebbleColors = [
                    '#5a4a35', '#4a3d2a', '#6b5540', '#7a6a50',
                    '#8a7860', '#3a3028', '#5f5040', '#9a8870',
                    '#6a5c48', '#4e4035'
                ];
                for (let i = 0; i < 500; i++) {
                    const px  = Math.random() * 512;
                    const py  = Math.random() * 512;
                    const rx  = 1.0 + Math.random() * 2.5;  // much smaller: was 3+7, now 1+2.5
                    const ry  = rx * (0.5 + Math.random() * 0.6);
                    const ang = Math.random() * Math.PI;
                    bctx.fillStyle = pebbleColors[Math.floor(Math.random() * pebbleColors.length)];
                    bctx.beginPath();
                    bctx.ellipse(px, py, rx, ry, ang, 0, Math.PI * 2);
                    bctx.fill();
                    // Subtle highlight on upper edge
                    bctx.strokeStyle = 'rgba(180,155,110,0.25)';
                    bctx.lineWidth   = 0.5;
                    bctx.beginPath();
                    bctx.ellipse(px, py - ry * 0.3, rx * 0.7, ry * 0.4, ang, Math.PI, Math.PI * 2);
                    bctx.stroke();
                }

                // Slight wet darkening overall (water makes things darker)
                bctx.fillStyle = 'rgba(20,12,5,0.28)';
                bctx.fillRect(0, 0, 512, 512);

                const bedTex = new THREE.CanvasTexture(bedCanvas);
                bedTex.wrapS = bedTex.wrapT = THREE.RepeatWrapping;
                bedTex.repeat.set(6, 6);  // tile 6x so pebbles appear much smaller

                const bedMat = new THREE.MeshLambertMaterial({
                    map:        bedTex,
                    color:      new THREE.Color(1.0, 1.0, 1.0),  // neutral — let texture show true
                    side:       THREE.FrontSide,
                    depthWrite: true,
                });

                const bedMesh = new THREE.Mesh(bedGeo, bedMat);
                bedMesh.position.set(RB_CX, 0, RB_CZ);
                bedMesh.receiveShadow = true;
                bedMesh.renderOrder   = 0;
                scene.add(bedMesh);
            })();
            // ── End riverbed mesh ─────────────────────────────────────────────────

            // ── Underwater fish (GLB models — Fish.glb, Fish2.glb, Fish3.glb) ──────────────
            (function spawnRiverFish() {
                const FISH_COUNT = 18;
                const FISH_DEPTH = WATER_LEVEL - 0.55;
                const RIVER_HW   = RIVER_WIDTH / 2 - 1.5;

                // One GLB per colour variation — 5 models cycling across 18 fish
                const FISH_GLBS = ['Fish.glb', 'Fish2.glb', 'Fish3.glb'];

                const fishGroup = new THREE.Group();
                scene.add(fishGroup);
                const fishInstances = [];

                // ── helpers ────────────────────────────────────────────────────────
                function seededRnd(seed) {
                    let x = Math.sin(seed * 127.1 + 311.7) * 43758.5453;
                    return x - Math.floor(x);
                }
                function smoothNoise(t, seed) {
                    const i = Math.floor(t), f = t - i;
                    const u = f * f * (3 - 2 * f);
                    return seededRnd(i + seed * 1000) * (1 - u) + seededRnd(i + 1 + seed * 1000) * u;
                }

                // ── placeholder body (used while GLBs load or if they fail) ───────
                function buildPlaceholderMesh(glbIndex) {
                    const colors = [0x8B6914, 0x4A7C59, 0x5C5C8A, 0x7A3B1E, 0x3D6B8C];
                    const bellies = [0xD4A853, 0x9DC1A4, 0xAAAAAA, 0xC87941, 0x7FB8D8];
                    const col = colors[glbIndex % colors.length];
                    const bel = bellies[glbIndex % bellies.length];

                    const bodyGeo = new THREE.SphereGeometry(1, 8, 6);
                    bodyGeo.scale(0.22, 0.07, 0.07);
                    const body = new THREE.Mesh(bodyGeo,
                        new THREE.MeshLambertMaterial({ color: col, transparent: true, opacity: 0.85 }));

                    const bellyGeo = new THREE.SphereGeometry(1, 8, 4);
                    bellyGeo.scale(0.18, 0.04, 0.055);
                    const belly = new THREE.Mesh(bellyGeo,
                        new THREE.MeshLambertMaterial({ color: bel, transparent: true, opacity: 0.75 }));
                    belly.position.set(0, -0.025, 0);
                    body.add(belly);

                    const tailGeo = new THREE.ConeGeometry(0.065, 0.11, 4);
                    tailGeo.rotateZ(Math.PI / 2);
                    const tailPivot = new THREE.Group();
                    tailPivot.position.set(-0.22, 0, 0);
                    const tail = new THREE.Mesh(tailGeo,
                        new THREE.MeshLambertMaterial({ color: col, transparent: true, opacity: 0.7 }));
                    tail.position.set(-0.055, 0, 0);
                    tailPivot.add(tail);
                    body.add(tailPivot);

                    const dorsalGeo = new THREE.ConeGeometry(0.03, 0.07, 3);
                    dorsalGeo.rotateZ(-Math.PI / 6);
                    const dorsal = new THREE.Mesh(dorsalGeo,
                        new THREE.MeshLambertMaterial({ color: col, transparent: true, opacity: 0.6 }));
                    dorsal.position.set(0.02, 0.055, 0);
                    body.add(dorsal);

                    const fishObj = new THREE.Group();
                    fishObj.add(body);
                    return { fishObj, tailPivot };
                }

                // ── find the tail-pivot group inside a GLB clone ───────────────────
                // GLB fish are expected to have a bone/node whose name contains 'tail'
                // If not found, we attach a synthetic pivot at the rear of the bbox.
                function findOrCreateTailPivot(glbRoot, rotated90) {
                    // 1. Look for a node/bone explicitly named 'tail'
                    let tailPivot = null;
                    glbRoot.traverse(c => {
                        if (!tailPivot && c.name && c.name.toLowerCase().includes('tail')) {
                            tailPivot = c;
                        }
                    });
                    if (tailPivot) return tailPivot;

                    // 2. Search skeleton bones — pick the rearmost bone.
                    // Normal fish (forward = +X): rearmost = min world-X
                    // Fish2 rotated 90° (forward = +Z after rotation): rearmost = max world-Z
                    glbRoot.updateMatrixWorld(true);
                    glbRoot.traverse(c => {
                        if (!tailPivot && c.isSkinnedMesh && c.skeleton) {
                            let best = null, bestVal = Infinity;
                            c.skeleton.bones.forEach(bone => {
                                const wp = new THREE.Vector3();
                                bone.getWorldPosition(wp);
                                const val = rotated90 ? -wp.z : wp.x; // min-X or max-Z
                                if (val < bestVal) { bestVal = val; best = bone; }
                            });
                            if (best) tailPivot = best;
                        }
                    });
                    if (tailPivot) return tailPivot;

                    // 3. Final fallback: synthetic group at rear bbox edge
                    const bbox = new THREE.Box3().setFromObject(glbRoot);
                    tailPivot = new THREE.Group();
                    tailPivot.name = 'synth_tail_pivot';
                    tailPivot.position.set(bbox.min.x, (bbox.min.y + bbox.max.y) / 2, (bbox.min.z + bbox.max.z) / 2);
                    glbRoot.add(tailPivot);
                    return tailPivot;
                }

                // ── clone + fit a GLB template to target world size ────────────────
                function instantiateFishGLB(tmpl, targetLength) {
                    const inst = tmpl.clone(true);
                    inst.traverse(c => {
                        if (!c.isMesh) return;
                        c.frustumCulled = false;
                        c.castShadow    = false;
                        c.receiveShadow = false;
                        if (Array.isArray(c.material)) {
                            c.material = c.material.map(m => {
                                if (!m) return m;
                                const mc = m.clone();
                                mc.transparent = true;
                                mc.opacity     = 0.88;
                                mc.needsUpdate = true;
                                return mc;
                            });
                        } else if (c.material) {
                            c.material           = c.material.clone();
                            c.material.transparent = true;
                            c.material.opacity     = 0.88;
                            c.material.needsUpdate = true;
                        }
                    });

                    // Wrap first
                    const wrapper = new THREE.Group();
                    wrapper.visible = false; // hidden until positioned at correct world coords
                    wrapper.add(inst);

                    // Native GLB size ~80 units. Target world length: 0.55–0.85 world units.
                    // Measure geometry bbox directly (not setFromObject) to avoid SkinnedMesh
                    // skeleton/bone inflation in r128 before the model has been rendered.
                    inst.updateMatrixWorld(true);
                    const bboxF = new THREE.Box3();
                    inst.traverse(c => {
                        if (c.geometry) { // catches Mesh, SkinnedMesh, etc.
                            c.geometry.computeBoundingBox();
                            const gb = c.geometry.boundingBox.clone().applyMatrix4(c.matrixWorld);
                            if (isFinite(gb.min.x)) bboxF.union(gb);
                        }
                    });
                    const sizeF = new THREE.Vector3();
                    if (!bboxF.isEmpty()) bboxF.getSize(sizeF);
                    // Fallback: fish GLBs are ~80 units long — prevents 700x scale if bbox fails
                    const nativeLen = (!bboxF.isEmpty() && Math.max(sizeF.x, sizeF.y, sizeF.z) > 1)
                        ? Math.max(sizeF.x, sizeF.y, sizeF.z)
                        : 80;
                    const worldTarget = 0.55 + (Math.random() * 0.3); // 0.55–0.85 world units
                    inst.scale.setScalar(worldTarget / nativeLen);

                    console.log(`🐟 GLB native: ${nativeLen.toFixed(1)}, target: ${worldTarget.toFixed(2)}, scale: ${(worldTarget/nativeLen).toFixed(4)}`);

                    return { wrapper, inner: inst };
                }

                // ── shared state for sampleMode (used in animator) ─────────────────
                function sampleMode(f, mode, T) {
                    if (mode === 'circle') {
                        const ax = f.circleCX + Math.cos(f.circleAngSample) * f.circleR;
                        const az = f.circleCZ + Math.sin(f.circleAngSample) * f.circleR;
                        const ay = FISH_DEPTH + f.yBase + Math.sin(T * f.yFreq + f.yPhase) * f.yAmp;
                        return [ax, ay, az];
                    } else if (mode === 'idle') {
                        const ix = f.idleAnchorX + Math.sin(T * 0.22 + f.seed * 5) * 0.4;
                        const iz = f.idleAnchorZ + Math.cos(T * 0.19 + f.seed * 7) * 0.4;
                        const iy = FISH_DEPTH + f.yBase + Math.sin(T * f.yFreq * 0.4 + f.yPhase) * f.yAmp * 0.5;
                        return [ix, iy, iz];
                    } else {
                        const cx = rbRiverCX(f.t) + RB_CX;
                        const cz = rbRiverCZ(f.t) + RB_CZ;
                        const h  = 0.0008;
                        const tx2 = rbRiverCX(f.t + h) - rbRiverCX(f.t - h);
                        const tz2 = rbRiverCZ(f.t + h) - rbRiverCZ(f.t - h);
                        const tl  = Math.sqrt(tx2 * tx2 + tz2 * tz2) || 1;
                        const perpX = -tz2 / tl, perpZ = tx2 / tl;
                        const sideOff = f.waveSideAmp * Math.sin(T * f.waveFreq + f.wavePhase);
                        const ry = FISH_DEPTH + f.yBase + Math.sin(T * f.yFreq + f.yPhase) * f.yAmp;
                        return [cx + perpX * sideOff, ry, cz + perpZ * sideOff];
                    }
                }

                const BLEND_DURATION = 2.5;

                // ── spawn all fish using placeholders first, swap to GLB when ready ──
                for (let i = 0; i < FISH_COUNT; i++) {
                    const glbIndex = i % FISH_GLBS.length;
                    const seed     = i + 0.137;
                    // Evenly distribute along river length with jitter so no clustering
                    const t0       = (i / FISH_COUNT) + (Math.random() - 0.5) * (0.8 / FISH_COUNT);
                    const t0c      = Math.max(0.05, Math.min(0.95, t0)); // clamp away from river ends
                    const modes    = ['river', 'river', 'river', 'circle', 'idle'];
                    const mode     = modes[Math.floor(Math.random() * modes.length)];

                    // Lateral offset within river — keep away from banks
                    const sideOffset = (Math.random() - 0.5) * RIVER_HW * 0.8;
                    const h0 = 0.0008;
                    const tx0 = rbRiverCX(t0c + h0) - rbRiverCX(t0c - h0);
                    const tz0 = rbRiverCZ(t0c + h0) - rbRiverCZ(t0c - h0);
                    const tl0 = Math.sqrt(tx0 * tx0 + tz0 * tz0) || 1;
                    const startX = rbRiverCX(t0c) + RB_CX + (-tz0 / tl0) * sideOffset;
                    const startZ = rbRiverCZ(t0c) + RB_CZ + ( tx0 / tl0) * sideOffset;

                    // Start with placeholder
                    const { fishObj: placeholderObj, tailPivot: placeholderTail } = buildPlaceholderMesh(glbIndex);
                    fishGroup.add(placeholderObj);

                    const circleT     = t0c;
                    const circleR     = 0.8 + Math.random() * 1.7;
                    const circleAng   = Math.random() * Math.PI * 2;
                    const circleSpeed = (Math.random() < 0.5 ? 1 : -1) * (0.5 + Math.random() * 1.0);
                    const circleCX    = rbRiverCX(circleT) + RB_CX;
                    const circleCZ    = rbRiverCZ(circleT) + RB_CZ;
                    const bodyLen     = 50 + Math.random() * 30; // native GLB units — fish are exported at ~80 units long

                    const fData = {
                        obj:        placeholderObj,
                        tailPivot:  placeholderTail,
                        glbReady:   false,
                        seed, mode,
                        t: t0c,
                        dir:        Math.random() < 0.5 ? 1 : -1,
                        baseSpeed:  0.00035 + Math.random() * 0.0005,
                        waveSideAmp:(Math.random() < 0.55) ? RIVER_HW * (0.12 + Math.random() * 0.38) : 0,
                        waveFreq:   0.18 + Math.random() * 0.35,
                        wavePhase:  Math.random() * Math.PI * 2,
                        yBase:      -(Math.random() * 0.35),
                        yAmp:       0.06 + Math.random() * 0.08,
                        yFreq:      0.3 + Math.random() * 0.5,
                        yPhase:     Math.random() * Math.PI * 2,
                        burstPhase: Math.random() * Math.PI * 2,
                        burstFreq:  0.08 + Math.random() * 0.18,
                        burstAmp:   0.6 + Math.random() * 1.8,
                        modeTimer:  Math.random() * 15,
                        circleAngSample: circleAng,
                        circleSpeed, circleR, circleCX, circleCZ,
                        idleAnchorX: startX,
                        idleAnchorZ: startZ,
                        blendT:     1.0,
                        blendFromX: 0, blendFromY: 0, blendFromZ: 0,
                        facingAngle: 0,
                        glbIndex,
                        wx: startX,
                        wy: FISH_DEPTH,
                        wz: startZ,
                        prevWx: 0, prevWz: 0,
                        bodyLen,
                    };
                    placeholderObj.scale.setScalar(0.012); // placeholder visible while GLB loads
                    placeholderObj.position.set(startX, FISH_DEPTH, startZ);
                    fishInstances.push(fData);

                    // Async: load GLB then swap out placeholder
                    _glbLoad(FISH_GLBS[glbIndex]).then(tmpl => {
                        if (!tmpl) {
                            console.warn(`🐟 ${FISH_GLBS[glbIndex]} failed — keeping placeholder`);
                            return;
                        }
                        const { wrapper, inner } = instantiateFishGLB(tmpl, bodyLen);

                        // Fish2.glb is exported sideways — rotate inner mesh 90° to face forward
                        const isfish2 = FISH_GLBS[glbIndex] === 'Fish2.glb';
                        if (isfish2) {
                            inner.rotation.y = Math.PI / 2;
                        }

                        const tailPivot = findOrCreateTailPivot(inner, isfish2);

                        // Place at current tracked world position (not placeholder's stale .position)
                        wrapper.position.set(fData.wx, fData.wy, fData.wz);
                        wrapper.rotation.y = -fData.facingAngle;
                        wrapper.visible = true;

                        fishGroup.remove(fData.obj);
                        fishGroup.add(wrapper);

                        fData.obj       = wrapper;
                        fData.tailPivot = tailPivot;
                        fData.glbReady  = true;
                        // Record if tailPivot is a real bone so animator drives it correctly
                        if (tailPivot) tailPivot._isBoneDriver = tailPivot.isBone || false;
                        console.log(`🐟 ${FISH_GLBS[glbIndex]} swapped in for fish #${i} at (${fData.wx.toFixed(1)}, ${fData.wz.toFixed(1)})`);
                    });
                }

                // ── animate ────────────────────────────────────────────────────────
                if (typeof window._customAnimators === 'undefined') window._customAnimators = [];
                window._customAnimators.push(function(dt) {
                    const T = performance.now() * 0.001;

                    for (const f of fishInstances) {

                        // ── 15-second mode switch ───────────────────────────────
                        f.modeTimer -= dt;
                        if (f.modeTimer <= 0) {
                            f.blendFromX = f.wx;
                            f.blendFromY = f.wy;
                            f.blendFromZ = f.wz;
                            f.blendT     = 0;

                            const prevMode = f.mode;
                            let newMode;
                            const r = Math.random();
                            if      (r < 0.50) newMode = 'river';
                            else if (r < 0.75) newMode = 'circle';
                            else               newMode = 'idle';
                            if (newMode === prevMode)
                                newMode = newMode === 'river' ? (Math.random() < 0.5 ? 'circle' : 'idle') : 'river';
                            f.mode = newMode;

                            if (newMode === 'river') {
                                f.waveSideAmp = (Math.random() < 0.55) ? RIVER_HW * (0.12 + Math.random() * 0.38) : 0;
                                f.dir = Math.random() < 0.4 ? -f.dir : f.dir;
                            } else if (newMode === 'circle') {
                                f.circleR     = 0.8 + Math.random() * 1.7;
                                f.circleSpeed = (Math.random() < 0.5 ? 1 : -1) * (0.5 + Math.random() * 1.0);
                                const entryAng = Math.random() * Math.PI * 2;
                                f.circleCX    = f.blendFromX - Math.cos(entryAng) * f.circleR;
                                f.circleCZ    = f.blendFromZ - Math.sin(entryAng) * f.circleR;
                                f.circleAngSample = entryAng;
                            } else {
                                f.idleAnchorX = f.wx;
                                f.idleAnchorZ = f.wz;
                            }
                            f.modeTimer = 12 + Math.random() * 6;
                        }

                        // ── circle angle ────────────────────────────────────────
                        if (f.mode === 'circle') f.circleAngSample += f.circleSpeed * dt;

                        // ── speed modulation ────────────────────────────────────
                        const noiseSample = smoothNoise(T * f.burstFreq + f.burstPhase, f.seed);
                        const speedMult   = 0.15 + noiseSample * f.burstAmp;
                        const effSpeed    = f.baseSpeed * speedMult;

                        if (f.mode === 'river') {
                            f.t += effSpeed * f.dir;
                            if (f.t >= 1.0) { f.t = 1.0; f.dir = -1; }
                            if (f.t <= 0.0) { f.t = 0.0; f.dir =  1; }
                        }

                        // ── tail wag ────────────────────────────────────────────
                        // Frequency and amplitude scale with swim speed
                        const tailFreq = 1.8 + speedMult * 4.0;
                        const tailAmp  = 0.25 + Math.min(speedMult, 2.5) * 0.25;
                        const wagVal   = Math.sin(T * tailFreq + f.wavePhase) * tailAmp;
                        if (f.tailPivot) {
                            if (f.tailPivot.isBone) {
                                // Rigged fish: drive the tail bone directly.
                                // Try Y first (sideways wag), also drive Z for natural flex.
                                f.tailPivot.rotation.y = wagVal;
                                f.tailPivot.rotation.z = wagVal * 0.3;
                            } else {
                                // Placeholder or synthetic pivot group
                                f.tailPivot.rotation.y = wagVal;
                            }
                        }

                        // ── target position ─────────────────────────────────────
                        const [tx, ty, tz] = sampleMode(f, f.mode, T);

                        f.prevWx = f.wx;
                        f.prevWz = f.wz;

                        if (f.blendT < 1.0) {
                            f.blendT = Math.min(1.0, f.blendT + dt / BLEND_DURATION);
                            const u = f.blendT * f.blendT * (3 - 2 * f.blendT);
                            f.wx = f.blendFromX + (tx - f.blendFromX) * u;
                            f.wy = f.blendFromY + (ty - f.blendFromY) * u;
                            f.wz = f.blendFromZ + (tz - f.blendFromZ) * u;
                        } else {
                            f.wx = tx; f.wy = ty; f.wz = tz;
                        }

                        f.obj.position.set(f.wx, f.wy, f.wz);

                        // ── facing ──────────────────────────────────────────────
                        const movDx = f.wx - f.prevWx;
                        const movDz = f.wz - f.prevWz;
                        if (Math.abs(movDx) + Math.abs(movDz) > 0.00004) {
                            const targetAngle = Math.atan2(movDz, movDx);
                            let diff = targetAngle - f.facingAngle;
                            while (diff >  Math.PI) diff -= Math.PI * 2;
                            while (diff < -Math.PI) diff += Math.PI * 2;
                            const turnRate = f.mode === 'idle' ? 1.5 : 4.5 + speedMult * 2;
                            f.facingAngle += diff * Math.min(1, turnRate * dt);
                        }
                        f.obj.rotation.y = -f.facingAngle;
                    }
                });
            })();
            // ── End underwater fish ───────────────────────────────────────────────

            // Animate water: update uTime uniform for shimmer + gently ripple water verts
            const _rbTerrPosBase = new Float32Array(rbVPos); // snapshot of original positions
            const _rbWaterTime   = { t: 0 };
            if (typeof window._customAnimators === 'undefined') window._customAnimators = [];
            window._customAnimators.push((dt) => {
                _rbWaterTime.t += dt;
                rbMat.uniforms.uTime.value = _rbWaterTime.t;
                if (window._skyMat) {
                    rbMat.uniforms.uNight.value = window._skyMat.uniforms.uNight.value;
                    // Darken river grass blades by driving emissive dark at night
                    const _rn = window._skyMat.uniforms.uNight.value;
                    riverGrassMat.emissive.setRGB(0, 0, 0);
                    // Reduce colour brightness directly
                    const _rl = Math.max(0.04, 1.0 - _rn * 0.88);
                    riverGrassMat.color.setHSL(0.27, 0.42, 0.22 * _rl);
                }

                // Gentle Y ripple on water verts — multi-directional to avoid grid
                const T  = _rbWaterTime.t;
                const pa = rbGeo.attributes.position;
                for (let vi = 0; vi < rbWaterVerts.length; vi++) {
                    if (!rbWaterVerts[vi]) continue;
                    const bx = _rbTerrPosBase[vi*3];
                    const bz = _rbTerrPosBase[vi*3+2];
                    // Angled wave directions to break grid symmetry
                    const w1 = Math.sin(bx * 0.55 + bz * 0.25 + T * 1.4) * 0.09;
                    const w2 = Math.sin(bx * 0.30 - bz * 0.60 + T * 1.1) * 0.07;
                    const w3 = Math.sin(bx * 0.15 + bz * 0.45 - T * 0.8) * 0.05;
                    const w4 = Math.sin(bx * 0.70 - bz * 0.20 + T * 0.6) * 0.04;
                    pa.setY(vi, WATER_LEVEL + w1 + w2 + w3 + w4);
                }
                pa.needsUpdate = true;
                rbGeo.computeVertexNormals();
            });

            // ── Water surface glint particles ─────────────────────────────────────
            // Two tiers:
            //   • SOFT tier  (160 pts) — subtle pale-blue drift flecks
            //   • SUN tier   ( 20 pts) — occasional bright white/gold sun-catch flares
            (function() {
                const SOFT_COUNT = 160;
                const SUN_COUNT  = 20;
                const TOTAL      = SOFT_COUNT + SUN_COUNT;
                const GLINT_WL   = WATER_LEVEL;

                // Sample valid water-surface positions along the river path
                const _gPts = []; // [wx, wz, wx, wz, ...]
                for (let ti = 0; ti <= 100; ti++) {
                    const t  = ti / 100;
                    const cx = rbRiverCX(t) + RB_CX;
                    const cz = rbRiverCZ(t) + RB_CZ;
                    for (let s = 0; s < 8; s++) {
                        const ang    = Math.random() * Math.PI * 2;
                        const spread = (0.4 + Math.random() * 0.85) * (RIVER_WIDTH / 2 - 1.0);
                        _gPts.push(cx + Math.cos(ang) * spread, cz + Math.sin(ang) * spread);
                    }
                }

                // Geometry
                const _gGeo   = new THREE.BufferGeometry();
                const _gPos   = new Float32Array(TOTAL * 3);
                const _gAlpha = new Float32Array(TOTAL);   // opacity per particle
                const _gTier  = new Float32Array(TOTAL);   // 0=soft, 1=sun

                const _gPhas  = new Float32Array(TOTAL);
                const _gSpd   = new Float32Array(TOTAL);
                const _gLife  = new Float32Array(TOTAL);
                const _gMaxL  = new Float32Array(TOTAL);
                const _gDX    = new Float32Array(TOTAL);
                const _gDZ    = new Float32Array(TOTAL);

                function _randPos(i) {
                    const si = Math.floor(Math.random() * (_gPts.length / 2));
                    _gPos[i*3]   = _gPts[si*2]   + (Math.random()-0.5) * 1.2;
                    _gPos[i*3+1] = GLINT_WL + 0.08 + Math.random() * 0.05;
                    _gPos[i*3+2] = _gPts[si*2+1] + (Math.random()-0.5) * 1.2;
                }

                for (let i = 0; i < TOTAL; i++) {
                    _randPos(i);
                    _gTier[i]  = i < SOFT_COUNT ? 0.0 : 1.0;
                    _gPhas[i]  = Math.random() * Math.PI * 2;
                    _gSpd[i]   = i < SOFT_COUNT
                        ? (0.8 + Math.random() * 2.0)   // soft: 0.8–2.8 Hz
                        : (0.3 + Math.random() * 0.9);  // sun:  0.3–1.2 Hz (slower, lazier)
                    _gMaxL[i]  = i < SOFT_COUNT
                        ? (1.5 + Math.random() * 3.5)   // soft: 1.5–5s
                        : (2.5 + Math.random() * 5.0);  // sun:  2.5–7.5s (linger longer)
                    _gLife[i]  = Math.random() * _gMaxL[i];
                    _gDX[i]    = (Math.random()-0.5) * 0.25;
                    _gDZ[i]    = (Math.random()-0.5) * 0.25;
                }

                _gGeo.setAttribute('position', new THREE.BufferAttribute(_gPos,   3));
                _gGeo.setAttribute('alpha',    new THREE.BufferAttribute(_gAlpha, 1));
                _gGeo.setAttribute('tier',     new THREE.BufferAttribute(_gTier,  1));

                const _gMat = new THREE.ShaderMaterial({
                    vertexShader: `
                        attribute float alpha;
                        attribute float tier;
                        varying   float vAlpha;
                        varying   float vTier;
                        void main() {
                            vAlpha = alpha;
                            vTier  = tier;
                            vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
                            // Sun particles are larger, soft are smaller
                            float baseSize = tier > 0.5 ? 9.0 : 5.5;
                            gl_PointSize = clamp(baseSize * 60.0 / -mvPos.z, 1.0, tier > 0.5 ? 14.0 : 7.0);
                            gl_Position  = projectionMatrix * mvPos;
                        }`,
                    fragmentShader: `
                        varying float vAlpha;
                        varying float vTier;
                        void main() {
                            vec2  uv  = gl_PointCoord - 0.5;
                            float r   = length(uv) * 2.0;
                            if (vTier > 0.5) {
                                // ── Sun-catch: bright star with 4-ray cross ──────
                                float disc  = 1.0 - smoothstep(0.0, 1.0, r);
                                float glow  = exp(-r * r * 2.5);
                                // Cross-hatch rays
                                float ray1  = exp(-abs(uv.x) * 28.0) * exp(-r * 1.5);
                                float ray2  = exp(-abs(uv.y) * 28.0) * exp(-r * 1.5);
                                float ray3  = exp(-abs(uv.x + uv.y) * 22.0) * exp(-r * 2.0);
                                float ray4  = exp(-abs(uv.x - uv.y) * 22.0) * exp(-r * 2.0);
                                float star  = (ray1 + ray2) * 0.55 + (ray3 + ray4) * 0.28;
                                float a     = (glow * 0.7 + star * 0.5 + disc * 0.15) * vAlpha;
                                // Warm white-gold tint
                                gl_FragColor = vec4(1.0, 0.97, 0.88, a);
                            } else {
                                // ── Soft: gentle pale-blue disc ─────────────────
                                float disc = 1.0 - smoothstep(0.3, 1.0, r);
                                float glow = exp(-r * r * 4.0);
                                float a    = (disc * 0.4 + glow * 0.6) * vAlpha;
                                gl_FragColor = vec4(0.82, 0.96, 1.0, a);
                            }
                        }`,
                    transparent: true,
                    depthWrite:  false,
                    blending:    THREE.AdditiveBlending,
                });

                const _gPoints = new THREE.Points(_gGeo, _gMat);
                _gPoints.frustumCulled = false;
                _gPoints.renderOrder   = 4;
                scene.add(_gPoints);

                let _gT = 0;
                window._customAnimators.push((dt) => {
                    _gT += dt;
                    const posArr = _gGeo.attributes.position.array;
                    const alpArr = _gGeo.attributes.alpha.array;

                    for (let i = 0; i < TOTAL; i++) {
                        _gLife[i] += dt;
                        if (_gLife[i] > _gMaxL[i]) {
                            _randPos(i);
                            _gLife[i] = 0;
                            _gMaxL[i] = i < SOFT_COUNT
                                ? (1.5 + Math.random() * 3.5)
                                : (2.5 + Math.random() * 5.0);
                            _gPhas[i] = Math.random() * Math.PI * 2;
                            _gSpd[i]  = i < SOFT_COUNT
                                ? (0.8 + Math.random() * 2.0)
                                : (0.3 + Math.random() * 0.9);
                            _gDX[i]   = (Math.random()-0.5) * 0.25;
                            _gDZ[i]   = (Math.random()-0.5) * 0.25;
                        }

                        posArr[i*3]   += _gDX[i] * dt;
                        posArr[i*3+2] += _gDZ[i] * dt;
                        posArr[i*3+1]  = GLINT_WL + 0.08 + Math.sin(_gT * 1.3 + _gPhas[i]) * 0.03;

                        const lt  = _gLife[i] / _gMaxL[i];       // 0→1
                        const env = Math.sin(lt * Math.PI);       // bell fade

                        if (i < SOFT_COUNT) {
                            // Soft: subtle twinkle, max ~0.26 opacity
                            const twinkle = 0.55 + 0.45 * Math.pow(
                                Math.max(0, Math.sin(_gT * _gSpd[i] + _gPhas[i])), 2);
                            alpArr[i] = env * twinkle * 0.26;
                        } else {
                            // Sun-catch: sharper pulse, allowed up to ~0.82 opacity
                            // Peaks are narrow (pow 6) so they feel like sudden sun-flashes
                            const pulse = Math.pow(
                                Math.max(0, Math.sin(_gT * _gSpd[i] + _gPhas[i])), 6);
                            alpArr[i] = env * (0.18 + pulse * 0.64);
                        }
                    }

                    _gGeo.attributes.position.needsUpdate = true;
                    _gGeo.attributes.alpha.needsUpdate    = true;
                });
            })();
            // ── End water glint particles ─────────────────────────────────────────

            // ── Populate biome with Tree 2 ────────────────────────────────────────
            const RB_TREE_COUNT  = 50;
            const RB_RIVER_CLEAR = RIVER_WIDTH / 2 + 5;

            for (let ti = 0; ti < RB_TREE_COUNT; ti++) {
                let ptx, ptz, valid;
                let attempts = 0;
                do {
                    valid = true;
                    ptx = RB_CX + (Math.random() - 0.5) * (groundSize - 12);
                    ptz = RB_CZ + (Math.random() - 0.5) * (groundSize - 12);

                    // Reject if inside river channel
                    const lx = ptx - RB_CX;
                    const lz = ptz - RB_CZ;
                    const lt = (lz / 200) + 0.5;
                    if (lt >= 0 && lt <= 1) {
                        const rcx = rbRiverCX(lt);
                        const txv = rbRiverTX(lt);
                        const tl  = Math.sqrt(txv*txv+1);
                        const px  = 1/tl, pz = -txv/tl;
                        const dx  = lx - rcx;
                        // Perpendicular distance to river centreline
                        const perpDist = Math.abs(dx * pz - lz * px + rbRiverCZ(lt) * px) ;
                        const distToLine = Math.sqrt((lx - rcx)**2 + (lz - rbRiverCZ(lt))**2);
                        if (distToLine < RB_RIVER_CLEAR) { valid = false; }
                    }

                    if (valid) {
                        for (const pos of treePositions) {
                            if (Math.sqrt((ptx-pos.x)**2+(ptz-pos.z)**2) < 7) { valid = false; break; }
                        }
                    }
                    attempts++;
                } while (!valid && attempts < 80);

                if (valid) createTree2(ptx, ptz, true); // noDirt: river biome has grass ground
            }
        }
        // ===== ENHANCED ROCKS =====
        const rocks = [];
        const rockPositions = [];
        
        function createRock(x, z) {
            if (_assetGLBCache['Rock Medium.glb']) {
                const targetSize = 0.6 + Math.random() * 1.2;
                const inst = _instantiateGLB('Rock Medium.glb', targetSize);
                inst.position.set(x, inst.position.y, z);
                inst.rotation.y = Math.random() * Math.PI * 2;
                inst.userData.type = 'rock';
                inst.userData.health = 5;
                inst.userData.maxHealth = 5;
                inst.userData.resources = { stone: 3, flint: 1 };
                rocks.push(inst);
                rockPositions.push({ x, z, radius: targetSize * 0.7 });
                scene.add(inst);
                return;
            }
            _loadAssetGLB('Rock Medium.glb');
            const rock = new THREE.Group();
            
            const size = 0.8 + Math.random() * 0.6;
            
            // Main rock body - use sphere with higher subdivision for smoother look
            const rockGeometry = new THREE.SphereGeometry(size, 16, 12);
            
            // Apply noise-based distortion for natural irregular shape
            const positions = rockGeometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const vertex = new THREE.Vector3(
                    positions.getX(i),
                    positions.getY(i),
                    positions.getZ(i)
                );
                
                // Normalize to get direction
                const direction = vertex.clone().normalize();
                
                // Apply multiple octaves of noise for natural variation
                const noise1 = Math.sin(direction.x * 3.5 + direction.y * 2.1) * 
                              Math.cos(direction.z * 2.8);
                const noise2 = Math.sin(direction.x * 7.2) * 
                              Math.cos(direction.y * 6.4 + direction.z * 5.3);
                
                // Combine noises with different scales
                const distortion = 1.0 + noise1 * 0.15 + noise2 * 0.08;
                
                // Apply distortion
                vertex.multiplyScalar(distortion);
                
                // Slightly flatten the bottom
                if (vertex.y < 0) {
                    vertex.y *= 0.7;
                }
                
                positions.setXYZ(i, vertex.x, vertex.y, vertex.z);
            }
            rockGeometry.computeVertexNormals();
            
            // Rich procedural stone texture
            const stoneCanvas = document.createElement('canvas');
            stoneCanvas.width = 512;
            stoneCanvas.height = 512;
            const sCtx = stoneCanvas.getContext('2d');

            // Base stone colour \ufffd medium grey
            sCtx.fillStyle = '#8a8a8a';
            sCtx.fillRect(0, 0, 512, 512);

            // Large-scale colour variation patches
            for (let i = 0; i < 60; i++) {
                const px = Math.random() * 512, py = Math.random() * 512;
                const r  = 30 + Math.random() * 80;
                const grd = sCtx.createRadialGradient(px, py, 0, px, py, r);
                const light = Math.random() > 0.5;
                grd.addColorStop(0, light ? 'rgba(200,198,192,0.55)' : 'rgba(90,88,84,0.55)');
                grd.addColorStop(1, 'rgba(0,0,0,0)');
                sCtx.fillStyle = grd;
                sCtx.beginPath();
                sCtx.ellipse(px, py, r * 1.4, r * 0.8, Math.random() * Math.PI, 0, Math.PI * 2);
                sCtx.fill();
            }

            // Fine grain noise
            for (let i = 0; i < 8000; i++) {
                const px = Math.random() * 512, py = Math.random() * 512;
                const sz = 1 + Math.random() * 2.5;
                const br = Math.random();
                sCtx.fillStyle = br > 0.6
                    ? `rgba(180,175,165,${0.08 + Math.random() * 0.18})`
                    : `rgba(15,12,10,${0.08 + Math.random() * 0.18})`;
                sCtx.fillRect(px, py, sz, sz);
            }

            // Mineral/quartz streaks
            for (let i = 0; i < 12; i++) {
                sCtx.save();
                sCtx.strokeStyle = `rgba(200,195,185,${0.12 + Math.random() * 0.22})`;
                sCtx.lineWidth = 0.5 + Math.random() * 2;
                sCtx.beginPath();
                const sx = Math.random() * 512, sy = Math.random() * 512;
                sCtx.moveTo(sx, sy);
                sCtx.bezierCurveTo(
                    sx + (Math.random()-0.5)*120, sy + (Math.random()-0.5)*120,
                    sx + (Math.random()-0.5)*120, sy + (Math.random()-0.5)*120,
                    sx + (Math.random()-0.5)*200, sy + (Math.random()-0.5)*200
                );
                sCtx.stroke();
                sCtx.restore();
            }

            // Dark cracks
            for (let i = 0; i < 8; i++) {
                sCtx.save();
                sCtx.strokeStyle = `rgba(10,8,6,${0.4 + Math.random() * 0.35})`;
                sCtx.lineWidth = 0.8 + Math.random() * 1.5;
                sCtx.beginPath();
                let crx = Math.random() * 512, cry = Math.random() * 512;
                sCtx.moveTo(crx, cry);
                for (let j = 0; j < 4; j++) {
                    crx += (Math.random()-0.5)*80; cry += (Math.random()-0.5)*80;
                    sCtx.lineTo(crx, cry);
                }
                sCtx.stroke();
                sCtx.restore();
            }

            // Subtle moss/lichen patches near bottom
            for (let i = 0; i < 18; i++) {
                const px = Math.random() * 512, py = 300 + Math.random() * 212;
                const r  = 10 + Math.random() * 30;
                const grd2 = sCtx.createRadialGradient(px, py, 0, px, py, r);
                grd2.addColorStop(0, 'rgba(72,85,45,0.45)');
                grd2.addColorStop(1, 'rgba(0,0,0,0)');
                sCtx.fillStyle = grd2;
                sCtx.beginPath();
                sCtx.ellipse(px, py, r, r * 0.7, Math.random()*Math.PI, 0, Math.PI*2);
                sCtx.fill();
            }

            const stoneTexture = new THREE.CanvasTexture(stoneCanvas);
            stoneTexture.wrapS = THREE.RepeatWrapping;
            stoneTexture.wrapT = THREE.RepeatWrapping;
            stoneTexture.encoding = THREE.sRGBEncoding;

            const rockMaterial = new THREE.MeshStandardMaterial({
                map: stoneTexture,
                color: 0xbbbbbb,
                roughness: 0.97,
                metalness: 0.02,
                flatShading: false
            });
            
            const rockMesh = new THREE.Mesh(rockGeometry, rockMaterial);
            rockMesh.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            rockMesh.castShadow = true;
            rockMesh.receiveShadow = true;
            rock.add(rockMesh);
            
            // Add smaller rocks around base
            for (let i = 0; i < 2; i++) {
                const smallSize = size * (0.15 + Math.random() * 0.15);
                const smallGeo = new THREE.SphereGeometry(smallSize, 8, 6);
                
                // Distort small rocks too
                const smallPositions = smallGeo.attributes.position;
                for (let j = 0; j < smallPositions.count; j++) {
                    const v = new THREE.Vector3(
                        smallPositions.getX(j),
                        smallPositions.getY(j),
                        smallPositions.getZ(j)
                    );
                    const dir = v.clone().normalize();
                    const n = Math.sin(dir.x * 5) * Math.cos(dir.y * 4 + dir.z * 3);
                    v.multiplyScalar(1.0 + n * 0.2);
                    smallPositions.setXYZ(j, v.x, v.y, v.z);
                }
                smallGeo.computeVertexNormals();
                
                const smallRock = new THREE.Mesh(smallGeo, rockMaterial);
                const angle = Math.random() * Math.PI * 2;
                const dist = size * 0.7;
                smallRock.position.set(
                    Math.cos(angle) * dist,
                    smallSize * 0.3,
                    Math.sin(angle) * dist
                );
                smallRock.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                smallRock.castShadow = true;
                rock.add(smallRock);
            }
            
            // Compute actual lowest point of the distorted+rotated geometry
            rock.updateMatrixWorld(true);
            const rockBox = new THREE.Box3().setFromObject(rock);
            const rockHeight = rockBox.max.y - rockBox.min.y;
            rock.position.set(x, -rockBox.min.y - rockHeight * 0.3, z);
            rock.userData.health = 3;
            rock.userData.maxHealth = 3;
            rock.userData.type = 'rock';
            
            rocks.push(rock);
            const _rockPos = { x, z, radius: size * 1.5 };
            rock.userData._posEntry = _rockPos;
            rock.userData._posArray = rockPositions;
            rockPositions.push(_rockPos);
            scene.add(rock);

            // Dirt patch at original size
            const dirtPatch = spawnDirtPatch(x, z, size * 2.5 + Math.random() * 0.8);
            scene.add(dirtPatch);
        }
        
        // Generate rocks
        for (let i = 0; i < 20; i++) {
            let x, z, valid;
            let attempts = 0;
            do {
                valid = true;
                x = (Math.random() - 0.5) * 180;
                z = (Math.random() - 0.5) * 180;
                
                if (Math.sqrt(x * x + z * z) < 15) {
                    valid = false;
                    continue;
                }
                
                for (let pos of [...treePositions, ...rockPositions]) {
                    const dist = Math.sqrt((x - pos.x) ** 2 + (z - pos.z) ** 2);
                    if (dist < 5) {
                        valid = false;
                        break;
                    }
                }
                attempts++;
            } while (!valid && attempts < 50);
            
            if (valid) createRock(x, z);
        }

        // Once Rock Medium.glb loads, swap procedural rocks for GLB versions
        _loadAssetGLB('Rock Medium.glb').then(tmpl => {
            if (!tmpl) return;
            for (let i = rocks.length - 1; i >= 0; i--) {
                const old = rocks[i];
                if (old.userData.type !== 'rock') continue;
                const x = old.position.x, z = old.position.z;
                const targetSize = 0.6 + Math.random() * 1.2;
                const inst = _instantiateGLB('Rock Medium.glb', targetSize);
                inst.position.set(x, inst.position.y, z);
                inst.rotation.y = Math.random() * Math.PI * 2;
                inst.userData.type = 'rock';
                inst.userData.health = old.userData.health ?? 5;
                inst.userData.maxHealth = 5;
                inst.userData.resources = { stone: 3, flint: 1 };
                inst.userData._posEntry = old.userData._posEntry;
                inst.userData._posArray = old.userData._posArray;
                scene.remove(old);
                scene.add(inst);
                rocks[i] = inst;
            }
        });

        // ===== METAL ORE NODES =====
        const metalOres = [];
        const orePositions = [];
        
        function createMetalOre(x, z) {
            const ore = new THREE.Group();
            
            const size = 0.9 + Math.random() * 0.5;
            
            // Dark procedural ore texture \ufffd near-black with rusty/metallic tones
            const oreCanvas = document.createElement('canvas');
            oreCanvas.width = 512; oreCanvas.height = 512;
            const oCtx = oreCanvas.getContext('2d');

            // Very dark base \ufffd reddish brown
            oCtx.fillStyle = '#5c3020';
            oCtx.fillRect(0, 0, 512, 512);

            // Dark variation patches
            for (let i = 0; i < 50; i++) {
                const px = Math.random() * 512, py = Math.random() * 512;
                const r = 25 + Math.random() * 70;
                const grd = oCtx.createRadialGradient(px, py, 0, px, py, r);
                const light = Math.random() > 0.5;
                grd.addColorStop(0, light ? 'rgba(130,70,40,0.6)' : 'rgba(35,15,8,0.6)');
                grd.addColorStop(1, 'rgba(0,0,0,0)');
                oCtx.fillStyle = grd;
                oCtx.beginPath();
                oCtx.ellipse(px, py, r * 1.3, r * 0.8, Math.random() * Math.PI, 0, Math.PI * 2);
                oCtx.fill();
            }

            // Fine grain noise
            for (let i = 0; i < 8000; i++) {
                const px = Math.random() * 512, py = Math.random() * 512;
                const sz = 1 + Math.random() * 2;
                oCtx.fillStyle = Math.random() > 0.6
                    ? `rgba(160,80,40,${0.06 + Math.random() * 0.14})`
                    : `rgba(30,10,5,${0.1 + Math.random() * 0.2})`;
                oCtx.fillRect(px, py, sz, sz);
            }

            // Rusty orange-brown streaks \ufffd hints of iron ore
            for (let i = 0; i < 10; i++) {
                oCtx.save();
                oCtx.strokeStyle = `rgba(${180 + Math.random()*60},${80 + Math.random()*40},20,${0.3 + Math.random() * 0.35})`;
                oCtx.lineWidth = 1 + Math.random() * 3;
                oCtx.beginPath();
                const sx = Math.random() * 512, sy = Math.random() * 512;
                oCtx.moveTo(sx, sy);
                oCtx.bezierCurveTo(
                    sx + (Math.random()-0.5)*140, sy + (Math.random()-0.5)*140,
                    sx + (Math.random()-0.5)*140, sy + (Math.random()-0.5)*140,
                    sx + (Math.random()-0.5)*220, sy + (Math.random()-0.5)*220
                );
                oCtx.stroke();
                oCtx.restore();
            }

            // Sharp cracks
            for (let i = 0; i < 6; i++) {
                oCtx.save();
                oCtx.strokeStyle = `rgba(5,3,2,${0.6 + Math.random() * 0.3})`;
                oCtx.lineWidth = 0.8 + Math.random() * 1.5;
                oCtx.beginPath();
                let crx = Math.random() * 512, cry = Math.random() * 512;
                oCtx.moveTo(crx, cry);
                for (let j = 0; j < 4; j++) {
                    crx += (Math.random()-0.5)*90; cry += (Math.random()-0.5)*90;
                    oCtx.lineTo(crx, cry);
                }
                oCtx.stroke();
                oCtx.restore();
            }

            const oreBaseTexture = new THREE.CanvasTexture(oreCanvas);
            oreBaseTexture.wrapS = THREE.RepeatWrapping;
            oreBaseTexture.wrapT = THREE.RepeatWrapping;
            oreBaseTexture.encoding = THREE.sRGBEncoding;

            const baseMat = new THREE.MeshStandardMaterial({
                map: oreBaseTexture,
                color: 0xaaaaaa,
                roughness: 0.55,
                metalness: 0.35,
                flatShading: true
            });

            const baseGeo = new THREE.SphereGeometry(size * 1.1, 7, 6);

            // Slightly distort for a natural lumpy rock shape (no sharp angles)
            const bPos = baseGeo.attributes.position;
            for (let i = 0; i < bPos.count; i++) {
                const v = new THREE.Vector3(bPos.getX(i), bPos.getY(i), bPos.getZ(i));
                const dir = v.clone().normalize();
                const n = Math.sin(dir.x * 4 + dir.y * 2.5) * Math.cos(dir.z * 3.2);
                const n2 = Math.sin(dir.x * 8) * Math.cos(dir.y * 7 + dir.z * 5);
                v.multiplyScalar(1.0 + n * 0.12 + n2 * 0.06);
                if (v.y < 0) v.y *= 0.75;
                bPos.setXYZ(i, v.x, v.y, v.z);
            }
            baseGeo.computeVertexNormals();

            const baseMesh = new THREE.Mesh(baseGeo, baseMat);
            baseMesh.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            baseMesh.castShadow = true;
            baseMesh.receiveShadow = true;
            ore.add(baseMesh);

            // Compute actual lowest point so the ore sits flush on the ground
            ore.updateMatrixWorld(true);
            const oreBox = new THREE.Box3().setFromObject(ore);
            const oreHeight = oreBox.max.y - oreBox.min.y;
            ore.position.set(x, -oreBox.min.y - oreHeight * 0.3, z);
            ore.userData.health = 4;
            ore.userData.maxHealth = 4;
            ore.userData.type = 'metal_ore';
            
            metalOres.push(ore);
            const _orePos = { x, z, radius: 1.5 };
            ore.userData._posEntry = _orePos;
            ore.userData._posArray = orePositions;
            orePositions.push(_orePos);
            scene.add(ore);

            // Dirt patch at original size
            const dirtPatch = spawnDirtPatch(x, z, size * 2.5 + Math.random() * 0.8);
            scene.add(dirtPatch);
        }
        
        // Generate metal ore nodes
        for (let i = 0; i < 10; i++) {
            let x, z, valid;
            let attempts = 0;
            do {
                valid = true;
                x = (Math.random() - 0.5) * 180;
                z = (Math.random() - 0.5) * 180;
                
                if (Math.sqrt(x * x + z * z) < 15) {
                    valid = false;
                    continue;
                }
                
                for (let pos of [...treePositions, ...rockPositions, ...orePositions]) {
                    const dist = Math.sqrt((x - pos.x) ** 2 + (z - pos.z) ** 2);
                    if (dist < 6) {
                        valid = false;
                        break;
                    }
                }
                attempts++;
            } while (!valid && attempts < 50);
            
            if (valid) createMetalOre(x, z);
        }

        // ===== SULPHUR ORE NODES =====
        const sulfurOres = [];
        const sulfurPositions = [];

        function createSulfurOre(x, z) {
            const ore = new THREE.Group();
            const size = 0.9 + Math.random() * 0.5;

            // Stone-like base texture with green sulphur veins
            const sCanvas = document.createElement('canvas');
            sCanvas.width = 512; sCanvas.height = 512;
            const sCtx2 = sCanvas.getContext('2d');

            // Base \ufffd same medium grey as stone nodes
            sCtx2.fillStyle = '#8a8a8a';
            sCtx2.fillRect(0, 0, 512, 512);

            // Large-scale grey variation patches
            for (let i = 0; i < 60; i++) {
                const px = Math.random() * 512, py = Math.random() * 512;
                const r = 30 + Math.random() * 80;
                const grd = sCtx2.createRadialGradient(px, py, 0, px, py, r);
                const light = Math.random() > 0.5;
                grd.addColorStop(0, light ? 'rgba(200,198,192,0.55)' : 'rgba(90,88,84,0.55)');
                grd.addColorStop(1, 'rgba(0,0,0,0)');
                sCtx2.fillStyle = grd;
                sCtx2.beginPath();
                sCtx2.ellipse(px, py, r * 1.4, r * 0.8, Math.random() * Math.PI, 0, Math.PI * 2);
                sCtx2.fill();
            }

            // Fine grain noise
            for (let i = 0; i < 8000; i++) {
                const px = Math.random() * 512, py = Math.random() * 512;
                const sz = 1 + Math.random() * 2.5;
                sCtx2.fillStyle = Math.random() > 0.6
                    ? `rgba(180,175,165,${0.08 + Math.random() * 0.18})`
                    : `rgba(15,12,10,${0.08 + Math.random() * 0.18})`;
                sCtx2.fillRect(px, py, sz, sz);
            }

            // Bright green sulphur veins cutting through the rock
            for (let i = 0; i < 14; i++) {
                sCtx2.save();
                const greenAlpha = 0.5 + Math.random() * 0.4;
                sCtx2.strokeStyle = `rgba(${60 + Math.random()*40},${160 + Math.random()*60},${20 + Math.random()*30},${greenAlpha})`;
                sCtx2.lineWidth = 1.5 + Math.random() * 4;
                sCtx2.beginPath();
                const sx = Math.random() * 512, sy = Math.random() * 512;
                sCtx2.moveTo(sx, sy);
                sCtx2.bezierCurveTo(
                    sx + (Math.random()-0.5)*150, sy + (Math.random()-0.5)*150,
                    sx + (Math.random()-0.5)*150, sy + (Math.random()-0.5)*150,
                    sx + (Math.random()-0.5)*240, sy + (Math.random()-0.5)*240
                );
                sCtx2.stroke();
                // Thin bright highlight down centre of vein
                sCtx2.strokeStyle = `rgba(180,255,100,${greenAlpha * 0.5})`;
                sCtx2.lineWidth = 0.5;
                sCtx2.stroke();
                sCtx2.restore();
            }

            // Green sulphur deposit blobs
            for (let i = 0; i < 20; i++) {
                const px = Math.random() * 512, py = Math.random() * 512;
                const r = 5 + Math.random() * 18;
                const grd = sCtx2.createRadialGradient(px, py, 0, px, py, r);
                grd.addColorStop(0, `rgba(100,200,40,0.55)`);
                grd.addColorStop(1, 'rgba(0,0,0,0)');
                sCtx2.fillStyle = grd;
                sCtx2.beginPath();
                sCtx2.ellipse(px, py, r, r * 0.7, Math.random()*Math.PI, 0, Math.PI*2);
                sCtx2.fill();
            }

            // Dark cracks
            for (let i = 0; i < 8; i++) {
                sCtx2.save();
                sCtx2.strokeStyle = `rgba(10,8,6,${0.4 + Math.random() * 0.3})`;
                sCtx2.lineWidth = 0.8 + Math.random() * 1.5;
                sCtx2.beginPath();
                let crx = Math.random() * 512, cry = Math.random() * 512;
                sCtx2.moveTo(crx, cry);
                for (let j = 0; j < 4; j++) {
                    crx += (Math.random()-0.5)*80; cry += (Math.random()-0.5)*80;
                    sCtx2.lineTo(crx, cry);
                }
                sCtx2.stroke();
                sCtx2.restore();
            }

            const sulfurTexture = new THREE.CanvasTexture(sCanvas);
            sulfurTexture.wrapS = THREE.RepeatWrapping;
            sulfurTexture.wrapT = THREE.RepeatWrapping;
            sulfurTexture.encoding = THREE.sRGBEncoding;

            const baseMat = new THREE.MeshStandardMaterial({
                map: sulfurTexture,
                color: 0xcccccc,
                roughness: 0.58,
                metalness: 0.28,
                flatShading: false
            });

            // Rounded lumpy shape like the stone node
            const baseGeo = new THREE.SphereGeometry(size * 1.05, 16, 12);
            const bPos = baseGeo.attributes.position;
            for (let i = 0; i < bPos.count; i++) {
                const v = new THREE.Vector3(bPos.getX(i), bPos.getY(i), bPos.getZ(i));
                const dir = v.clone().normalize();
                const n1 = Math.sin(dir.x * 3.5 + dir.y * 2.1) * Math.cos(dir.z * 2.8);
                const n2 = Math.sin(dir.x * 7.2) * Math.cos(dir.y * 6.4 + dir.z * 5.3);
                v.multiplyScalar(1.0 + n1 * 0.15 + n2 * 0.08);
                if (v.y < 0) v.y *= 0.7;
                bPos.setXYZ(i, v.x, v.y, v.z);
            }
            baseGeo.computeVertexNormals();

            const baseMesh = new THREE.Mesh(baseGeo, baseMat);
            baseMesh.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            baseMesh.castShadow = true;
            baseMesh.receiveShadow = true;
            ore.add(baseMesh);

            // Green sulphur crystals protruding from surface
            const crystalMat = new THREE.MeshStandardMaterial({
                color: 0x4ac420,
                roughness: 0.3,
                metalness: 0.1,
                emissive: 0x2a7010,
                emissiveIntensity: 0.25,
                flatShading: true,
                transparent: true,
                opacity: 0.88
            });

            const numCrystals = 4 + Math.floor(Math.random() * 4);
            for (let i = 0; i < numCrystals; i++) {
                // Cluster 2-3 small crystals together per group
                const clusterAngle = (i / numCrystals) * Math.PI * 2 + (Math.random()-0.5) * 0.5;
                const clusterPhi = 0.3 + Math.random() * 1.0;
                const clusterBase = new THREE.Vector3(
                    Math.sin(clusterPhi) * Math.cos(clusterAngle),
                    Math.cos(clusterPhi),
                    Math.sin(clusterPhi) * Math.sin(clusterAngle)
                ).multiplyScalar(size * 0.85);

                const numInCluster = 2 + Math.floor(Math.random() * 2);
                for (let j = 0; j < numInCluster; j++) {
                    const cSize = size * (0.12 + Math.random() * 0.18);
                    // Use a tapered cone-like shape for crystals
                    const cGeo = new THREE.CylinderGeometry(0, cSize * 0.5, cSize * 2.5, 5, 1);
                    const crystal = new THREE.Mesh(cGeo, crystalMat);
                    crystal.position.copy(clusterBase).addScaledVector(
                        new THREE.Vector3((Math.random()-0.5)*0.3, (Math.random()-0.5)*0.3, (Math.random()-0.5)*0.3), size * 0.2
                    );
                    // Point outward from centre
                    crystal.lookAt(crystal.position.clone().multiplyScalar(2));
                    crystal.rotateX(-Math.PI / 2);
                    crystal.rotateZ(Math.random() * Math.PI);
                    crystal.castShadow = true;
                    ore.add(crystal);
                }
            }

            ore.updateMatrixWorld(true);
            const oreBox = new THREE.Box3().setFromObject(ore);
            const oreHeight = oreBox.max.y - oreBox.min.y;
            ore.position.set(x, -oreBox.min.y - oreHeight * 0.3, z);
            ore.userData.health = 4;
            ore.userData.maxHealth = 4;
            ore.userData.type = 'sulfur_ore';

            sulfurOres.push(ore);
            const _sulfurPos = { x, z, radius: size * 1.5 };
            ore.userData._posEntry = _sulfurPos;
            ore.userData._posArray = sulfurPositions;
            sulfurPositions.push(_sulfurPos);
            scene.add(ore);

            const dirtPatch = spawnDirtPatch(x, z, size * 2.5 + Math.random() * 0.8);
            scene.add(dirtPatch);
        }

        // Generate sulphur ore nodes
        for (let i = 0; i < 8; i++) {
            let x, z, valid;
            let attempts = 0;
            do {
                valid = true;
                x = (Math.random() - 0.5) * 180;
                z = (Math.random() - 0.5) * 180;
                if (Math.sqrt(x * x + z * z) < 15) { valid = false; continue; }
                for (let pos of [...treePositions, ...rockPositions, ...orePositions, ...sulfurPositions]) {
                    if (Math.sqrt((x - pos.x) ** 2 + (z - pos.z) ** 2) < 6) { valid = false; break; }
                }
                attempts++;
            } while (!valid && attempts < 50);
            if (valid) createSulfurOre(x, z);
        }

        // ===== DESERT ROCKS & ORE NODES =====
        // Spawned after all position arrays are initialised.
        {
            const drMargin   = 10;
            const drCenterZ  = -desertOffset + 0.5;
            const drHalf     = groundSize / 2 - drMargin;
            const drXMin     = -groundSize / 2 + drMargin;
            const drXMax     =  groundSize / 2 - drMargin;
            const drZMin     = drCenterZ - drHalf;
            const drZMax     = drCenterZ + drHalf - 18;

            function desertRandomPos() {
                return {
                    x: drXMin + Math.random() * (drXMax - drXMin),
                    z: drZMin + Math.random() * (drZMax - drZMin)
                };
            }

            function tryDesertSpawn(minDist, spawnFn, count) {
                for (let i = 0; i < count; i++) {
                    let attempts = 0, valid = false, x, z;
                    do {
                        const p = desertRandomPos();
                        x = p.x; z = p.z;
                        valid = true;
                        // Avoid rock formations
                        for (const ob of desertFormationColliders) {
                            if (Math.sqrt((x-ob.x)**2 + (z-ob.z)**2) < ob.r + 2) { valid = false; break; }
                        }
                        if (!valid) continue;
                        // Avoid other desert rocks/ores already placed
                        for (const pos of [...rockPositions, ...orePositions, ...sulfurPositions]) {
                            if (Math.sqrt((x-pos.x)**2 + (z-pos.z)**2) < minDist) { valid = false; break; }
                        }
                        attempts++;
                    } while (!valid && attempts < 80);
                    if (valid) spawnFn(x, z);
                }
            }

            tryDesertSpawn(5, createRock, 14);
            tryDesertSpawn(6, createMetalOre, 6);
            tryDesertSpawn(6, createSulfurOre, 4);
        }

        // ===== DESERT CACTI =====
        const cacti = [];
        const cactiPositions = [];

        function createCactus(x, z) {
            const cactusGlb = Math.random() > 0.35 ? 'Cactus.glb' : 'Prickly pear cactus.glb';
            if (_assetGLBCache[cactusGlb]) {
                const targetH = 1.2 + Math.random() * 1.5;
                const inst = _instantiateGLB(cactusGlb, targetH);
                inst.position.set(x, inst.position.y, z);
                inst.rotation.y = Math.random() * Math.PI * 2;
                inst.userData.type = 'cactus';
                inst.userData.hasCloth = true;
                cacti.push(inst);
                cactiPositions.push({ x, z, radius: 0.6 });
                scene.add(inst);
                return;
            }
            _loadAssetGLB(cactusGlb);
            const group = new THREE.Group();

            // Cactus green material - waxy, slightly shiny
            const cactusMat = new THREE.MeshStandardMaterial({
                color: new THREE.Color(0.18 + Math.random()*0.06, 0.42 + Math.random()*0.08, 0.18 + Math.random()*0.06),
                roughness: 0.72,
                metalness: 0.04,
            });
            const spineMat = new THREE.MeshStandardMaterial({ color: 0xf0e8c8, roughness: 0.8 });

            const cactusType = Math.floor(Math.random() * 3); // 0=saguaro, 1=barrel, 2=small branched

            function addSpines(mesh, radius, height, count) {
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2 + Math.random() * 0.3;
                    const y = (Math.random() - 0.1) * height * 0.5;
                    const spineLen = 0.06 + Math.random() * 0.07;
                    const spineGeo = new THREE.CylinderGeometry(0.004, 0.001, spineLen, 3);
                    const spine = new THREE.Mesh(spineGeo, spineMat);
                    spine.position.set(
                        Math.cos(angle) * (radius + spineLen * 0.4),
                        y,
                        Math.sin(angle) * (radius + spineLen * 0.4)
                    );
                    spine.rotation.z = Math.PI / 2;
                    spine.rotation.y = -angle;
                    spine.castShadow = false;
                    group.add(spine);
                }
            }

            if (cactusType === 0) {
                // Saguaro - tall central column with 1-2 arms
                const trunkH = 2.5 + Math.random() * 2.0;
                const trunkR = 0.18 + Math.random() * 0.08;
                const trunkGeo = new THREE.CylinderGeometry(trunkR * 0.85, trunkR, trunkH, 9);
                const trunk = new THREE.Mesh(trunkGeo, cactusMat);
                trunk.position.y = trunkH / 2;
                trunk.castShadow = trunk.receiveShadow = true;
                group.add(trunk);
                addSpines(trunk, trunkR, trunkH, 24);

                // Top rounded cap
                const capGeo = new THREE.SphereGeometry(trunkR * 0.88, 8, 6, 0, Math.PI*2, 0, Math.PI*0.55);
                const cap = new THREE.Mesh(capGeo, cactusMat);
                cap.position.y = trunkH;
                group.add(cap);

                // 1 or 2 arms
                const armCount = Math.random() > 0.4 ? (Math.random() > 0.5 ? 2 : 1) : 0;
                for (let a = 0; a < armCount; a++) {
                    const armAngle = (a === 0 ? 0.6 : -0.7) + (Math.random()-0.5)*0.4;
                    const armBaseY = trunkH * (0.45 + Math.random() * 0.25);
                    const armR = trunkR * 0.72;
                    // Horizontal segment
                    const hLen = 0.4 + Math.random() * 0.5;
                    const hGeo = new THREE.CylinderGeometry(armR, armR*1.05, hLen, 8);
                    const hArm = new THREE.Mesh(hGeo, cactusMat);
                    hArm.rotation.z = Math.PI / 2;
                    hArm.position.set(Math.cos(armAngle) * hLen * 0.5, armBaseY, Math.sin(armAngle) * hLen * 0.5);
                    group.add(hArm);
                    // Vertical segment going up
                    const vLen = 0.6 + Math.random() * 0.7;
                    const vGeo = new THREE.CylinderGeometry(armR * 0.82, armR, vLen, 8);
                    const vArm = new THREE.Mesh(vGeo, cactusMat);
                    vArm.position.set(Math.cos(armAngle) * hLen, armBaseY + vLen/2, Math.sin(armAngle) * hLen);
                    group.add(vArm);
                    addSpines(vArm, armR, vLen, 14);
                }

            } else if (cactusType === 1) {
                // Barrel cactus - short fat ribbed cylinder
                const h = 0.7 + Math.random() * 0.6;
                const r = 0.22 + Math.random() * 0.14;
                // Ribbed look via multiple overlapping slightly offset cylinders
                const ribCount = 10;
                for (let i = 0; i < ribCount; i++) {
                    const ribAngle = (i / ribCount) * Math.PI * 2;
                    const ribGeo = new THREE.CylinderGeometry(r * 0.28, r * 0.30, h, 5);
                    const rib = new THREE.Mesh(ribGeo, cactusMat);
                    rib.position.set(Math.cos(ribAngle) * r * 0.72, h/2, Math.sin(ribAngle) * r * 0.72);
                    rib.castShadow = true;
                    group.add(rib);
                    // Spines on each rib
                    for (let s = 0; s < 4; s++) {
                        const sy = (s / 3 - 0.5) * h * 0.7;
                        const spineLen = 0.07 + Math.random() * 0.05;
                        const sGeo = new THREE.CylinderGeometry(0.004, 0.001, spineLen, 3);
                        const spine = new THREE.Mesh(sGeo, spineMat);
                        spine.position.set(Math.cos(ribAngle) * (r + spineLen*0.5), h/2 + sy, Math.sin(ribAngle) * (r + spineLen*0.5));
                        spine.rotation.z = Math.PI/2;
                        spine.rotation.y = -ribAngle;
                        group.add(spine);
                    }
                }
                // Domed top with a small flower
                const topGeo = new THREE.SphereGeometry(r * 0.9, 8, 5, 0, Math.PI*2, 0, Math.PI*0.5);
                const top = new THREE.Mesh(topGeo, cactusMat);
                top.position.y = h;
                group.add(top);

            } else {
                // Small branched cluster - 3-5 short columns at ground level
                const count = 2 + Math.floor(Math.random() * 3);
                const offsets = [{x:0,z:0},{x:0.28,z:0.1},{x:-0.22,z:0.18},{x:0.05,z:-0.28},{x:-0.15,z:-0.2}];
                for (let i = 0; i < count; i++) {
                    const h = 0.5 + Math.random() * 0.8;
                    const r = 0.10 + Math.random() * 0.06;
                    const seg = new THREE.CylinderGeometry(r*0.88, r, h, 8);
                    const m = new THREE.Mesh(seg, cactusMat);
                    m.position.set(offsets[i].x, h/2, offsets[i].z);
                    m.rotation.y = Math.random() * Math.PI;
                    m.castShadow = m.receiveShadow = true;
                    group.add(m);
                    addSpines(m, r, h, 16);
                    const capG = new THREE.SphereGeometry(r*0.9, 7, 5, 0, Math.PI*2, 0, Math.PI*0.5);
                    const capM = new THREE.Mesh(capG, cactusMat);
                    capM.position.set(offsets[i].x, h, offsets[i].z);
                    group.add(capM);
                }
            }

            group.position.set(x, 0, z);
            group.rotation.y = Math.random() * Math.PI * 2;
            group.userData.type = 'cactus';
            group.userData.hasCloth = true; // freshly harvestable
            cacti.push(group);
            cactiPositions.push({ x, z, radius: 0.6 });
            scene.add(group);
        }

        // Spawn 20-26 cacti across the desert, avoiding formations and other obstacles
        {
            const dcMargin  = 8;
            const dcCenterZ = -desertOffset + 0.5;
            const dcHalf    = groundSize / 2 - dcMargin;
            const dcXMin    = -groundSize / 2 + dcMargin;
            const dcXMax    =  groundSize / 2 - dcMargin;
            const dcZMin    = dcCenterZ - dcHalf;
            const dcZMax    = dcCenterZ + dcHalf - 18;
            const numCacti  = 20 + Math.floor(Math.random() * 7);

            for (let i = 0; i < numCacti; i++) {
                let attempts = 0, valid = false, fx, fz;
                do {
                    fx = dcXMin + Math.random() * (dcXMax - dcXMin);
                    fz = dcZMin + Math.random() * (dcZMax - dcZMin);
                    valid = true;
                    for (const ob of desertFormationColliders) {
                        if (Math.sqrt((fx-ob.x)**2+(fz-ob.z)**2) < ob.r + 1.5) { valid=false; break; }
                    }
                    if (!valid) { attempts++; continue; }
                    for (const p of [...rockPositions, ...orePositions, ...sulfurPositions, ...cactiPositions]) {
                        if (Math.sqrt((fx-p.x)**2+(fz-p.z)**2) < 4) { valid=false; break; }
                    }
                    attempts++;
                } while (!valid && attempts < 80);
                if (valid) createCactus(fx, fz);
            }
        }

        // Once cactus GLBs load, swap procedural cacti for GLB versions
        Promise.all([_loadAssetGLB('Cactus.glb'), _loadAssetGLB('Prickly pear cactus.glb')]).then(() => {
            console.log(`🌵 Cactus GLBs loaded — scanning ${cacti.length} cacti for swap...`);
            let swapped = 0;
            for (let i = cacti.length - 1; i >= 0; i--) {
                const old = cacti[i];
                if (old.userData.type !== 'cactus') continue;
                const x = old.position.x, z = old.position.z;
                const glbName = Math.random() > 0.35 ? 'Cactus.glb' : 'Prickly pear cactus.glb';
                if (!_assetGLBCache[glbName]) continue;
                const targetH = 1.2 + Math.random() * 1.5;
                const inst = _instantiateGLB(glbName, targetH);
                if (!inst) { console.warn(`🌵 _instantiateGLB null for ${glbName}`); continue; }
                inst.position.set(x, inst.position.y, z);
                inst.rotation.y = Math.random() * Math.PI * 2;
                inst.userData.type = 'cactus';
                inst.userData.hasCloth = old.userData.hasCloth ?? true;
                scene.remove(old);
                scene.add(inst);
                cacti[i] = inst;
                swapped++;
            }
            console.log(`🌵 Cactus swap done: ${swapped} procedural → GLB`);
        });


        // ===== DESERT PALM TREES =====
        function createPalmTree(x, z, yOffset = 0) {
            if (_assetGLBCache['Palm Tree.glb']) {
                const targetH = 5.0 + Math.random() * 3.5;
                const inst = _instantiateGLB('Palm Tree.glb', targetH);
                inst.position.set(x, inst.position.y + yOffset, z);
                inst.rotation.y = Math.random() * Math.PI * 2;
                inst.userData.type = 'tree';
                inst.userData.isPalmTree = true;
                inst.userData.health = 3;
                inst.userData.maxHealth = 3;
                inst.userData.trunkHeight = targetH * 0.75;
                inst.userData.swayPhase = Math.random() * Math.PI * 2;
                inst.userData.swaySpeed = 0.3 + Math.random() * 0.2;
                trees.push(inst);
                treePositions.push({ x, z, radius: 1.0 });
                scene.add(inst);
                return;
            }
            _loadAssetGLB('Palm Tree.glb');

            const tree = new THREE.Group();

            // Trunk: tall, slender, segmented with a gentle curve
            const trunkH   = 6 + Math.random() * 4;
            const trunkSegs = 10;
            // Slight random lean direction for character
            const leanAngle = 0.10 + Math.random() * 0.14;
            const leanDir   = Math.random() * Math.PI * 2;

            // Sandy-tan bark texture
            const barkData = new Uint8Array(16 * 16 * 4);
            for (let i = 0; i < 16 * 16; i++) {
                const bx = i % 16, by = Math.floor(i / 16);
                // Horizontal ring bands (palm trunk segments)
                const ring  = Math.abs(Math.sin(by * 1.2)) * 22;
                const noise = Math.random() * 8;
                const base  = 110 + ring + noise;
                barkData[i*4]   = Math.min(255, base);
                barkData[i*4+1] = Math.min(255, base * 0.78);
                barkData[i*4+2] = Math.min(255, base * 0.50);
                barkData[i*4+3] = 255;
            }
            const barkTex = new THREE.DataTexture(barkData, 16, 16, THREE.RGBAFormat);
            barkTex.needsUpdate = true;
            barkTex.wrapS = barkTex.wrapT = THREE.RepeatWrapping;
            barkTex.repeat.set(2, 6);
            barkTex.magFilter = THREE.NearestFilter;
            const barkMat = new THREE.MeshStandardMaterial({ map: barkTex, roughness: 0.97, metalness: 0 });

            // Build trunk as stacked tapered segments \u2013 merged into one mesh
            const segH = trunkH / trunkSegs;
            const trunkPieces = [];
            const _tDummy = new THREE.Object3D();
            for (let s = 0; s < trunkSegs; s++) {
                const t   = s / trunkSegs;
                const r0  = 0.22 - t * 0.07;
                const r1  = 0.22 - (t + 1 / trunkSegs) * 0.07;
                const sGeo = new THREE.CylinderGeometry(r1, r0, segH, 8);
                const curve = leanAngle * t * t;
                _tDummy.position.set(
                    Math.cos(leanDir) * curve * trunkH * 0.5,
                    s * segH + segH / 2,
                    Math.sin(leanDir) * curve * trunkH * 0.5
                );
                _tDummy.rotation.set(
                    Math.cos(leanDir + Math.PI / 2) * curve * 0.6,
                    0,
                    Math.sin(leanDir + Math.PI / 2) * curve * 0.6
                );
                _tDummy.scale.set(1, 1, 1);
                _tDummy.updateMatrix();
                trunkPieces.push({ geo: sGeo, matrix: _tDummy.matrix.clone() });
            }
            const mergedTrunkGeo = mergeGeometries(trunkPieces);
            mergedTrunkGeo.computeVertexNormals();
            const trunkMesh = new THREE.Mesh(mergedTrunkGeo, barkMat);
            trunkMesh.castShadow = trunkMesh.receiveShadow = true;
            tree.add(trunkMesh);

            // Crown position (top of curved trunk)
            const crownX = Math.cos(leanDir) * leanAngle * trunkH * 0.35;
            const crownY = trunkH;
            const crownZ = Math.sin(leanDir) * leanAngle * trunkH * 0.35;

            // \u2500\u2500 Palm fronds: merged into 2 meshes (spines + leaflets) \u2500\u2500
            const frondCount = 8 + Math.floor(Math.random() * 5);
            const leafHue    = 0.29 + Math.random() * 0.05;

            // Shared materials (only 2 for the whole crown)
            const spineMat2 = new THREE.MeshStandardMaterial({
                color: new THREE.Color().setHSL(leafHue - 0.01, 0.70, 0.18),
                roughness: 0.97, metalness: 0, side: THREE.DoubleSide
            });
            const leafletMat = new THREE.MeshStandardMaterial({
                color: new THREE.Color().setHSL(leafHue, 0.76, 0.30 + Math.random() * 0.07),
                roughness: 0.82, metalness: 0, side: THREE.DoubleSide,
            });

            // Accumulate transformed geometry pieces for merging
            const spinePieces   = [];
            const leafletPieces = [];
            const _dummy = new THREE.Object3D();

            // Helper: build a refined leaflet shape in local space
            // Returns a BufferGeometry of a curved, tapered leaflet blade
            function makeLeafletGeo(len, width) {
                // 3-segment blade with a natural curve and taper
                const segs = 3;
                const verts = [];
                const idxs  = [];
                for (let i = 0; i <= segs; i++) {
                    const t   = i / segs;
                    const w   = width * (1 - t * 0.82);      // taper to a sharp tip
                    const y   = len * t;
                    const arc = Math.sin(t * Math.PI) * width * 0.18; // slight belly curve
                    // left edge, right edge
                    verts.push(-w * 0.5 - arc, y, 0,
                                w * 0.5 + arc, y, 0);
                }
                for (let i = 0; i < segs; i++) {
                    const a = i * 2, b = a + 1, c = a + 2, d = a + 3;
                    idxs.push(a, b, c,  b, d, c);
                }
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
                geo.setIndex(idxs);
                geo.computeVertexNormals();
                return geo;
            }

            for (let f = 0; f < frondCount; f++) {
                const frondAngle = (f / frondCount) * Math.PI * 2 + (Math.random() - 0.5) * 0.28;
                const frondLen   = 2.8 + Math.random() * 1.8;
                const droop      = 0.30 + Math.random() * 0.30;
                const tiltUp     = 0.22 + Math.random() * 0.28;

                // \u2500\u2500 Spine arc points in frond-local space \u2500\u2500
                const spineSegs  = 9;
                const spinePoints = [];
                for (let s = 0; s <= spineSegs; s++) {
                    const t  = s / spineSegs;
                    const sx = t * frondLen;
                    const sy = Math.sin(tiltUp) * t * frondLen * 0.55 - droop * t * t * frondLen;
                    spinePoints.push(new THREE.Vector3(sx, sy, 0));
                }

                // Matrix that transforms from frond-local \u2192 crown-local
                // (rotate around Y by frondAngle, small Z tilt, then translate to crown)
                const frondMatrix = new THREE.Matrix4()
                    .makeTranslation(crownX, crownY + 0.2, crownZ)
                    .multiply(new THREE.Matrix4().makeRotationY(frondAngle))
                    .multiply(new THREE.Matrix4().makeRotationZ(tiltUp * 0.45));

                // \u2500\u2500 Spine cylinders \u2013 merged \u2500\u2500
                for (let s = 0; s < spineSegs; s++) {
                    const p0  = spinePoints[s], p1 = spinePoints[s + 1];
                    const mid = p0.clone().add(p1).multiplyScalar(0.5);
                    const segLen = p0.distanceTo(p1);
                    const t   = s / spineSegs;
                    const r   = 0.024 * (1 - t * 0.78);
                    const sGeo = new THREE.CylinderGeometry(r * 0.55, r, segLen, 4);
                    // orient along spine dir
                    const dir = p1.clone().sub(p0).normalize();
                    _dummy.position.copy(mid);
                    _dummy.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
                    _dummy.scale.set(1, 1, 1);
                    _dummy.updateMatrix();
                    const localMat = frondMatrix.clone().multiply(_dummy.matrix);
                    spinePieces.push({ geo: sGeo, matrix: localMat });
                }

                // \u2500\u2500 Leaflets \u2013 merged \u2500\u2500
                const leafletCount = 10 + Math.floor(Math.random() * 4);
                for (let l = 0; l < leafletCount; l++) {
                    const t      = (l + 0.5) / leafletCount;
                    const ptIdx  = Math.floor(t * spineSegs);
                    const pt     = spinePoints[ptIdx];
                    const ptN    = spinePoints[Math.min(ptIdx + 1, spineSegs)];
                    const spineDir = ptN.clone().sub(pt).normalize();

                    const lLen   = (0.52 + Math.random() * 0.28) * (1 - t * 0.50);
                    const lWid   = (0.13 + Math.random() * 0.05) * (1 - t * 0.38);
                    const lGeo   = makeLeafletGeo(lLen, lWid);
                    const spineAngle = Math.atan2(spineDir.y, spineDir.x);

                    // Left leaflet
                    _dummy.position.copy(pt);
                    _dummy.rotation.set(
                         0.10 + Math.random() * 0.14,   // fold up slightly
                         Math.PI / 2,
                         spineAngle + 0.18 + Math.random() * 0.10
                    );
                    _dummy.scale.set(1, 1, 1);
                    _dummy.updateMatrix();
                    leafletPieces.push({ geo: lGeo, matrix: frondMatrix.clone().multiply(_dummy.matrix) });

                    // Right leaflet (mirror)
                    _dummy.position.copy(pt);
                    _dummy.rotation.set(
                        -(0.10 + Math.random() * 0.14),
                        -Math.PI / 2,
                         spineAngle + 0.18 + Math.random() * 0.10
                    );
                    _dummy.scale.set(1, 1, 1);
                    _dummy.updateMatrix();
                    leafletPieces.push({ geo: lGeo.clone(), matrix: frondMatrix.clone().multiply(_dummy.matrix) });
                }
            }

            // \u2500\u2500 Build 2 merged meshes for the entire crown \u2500\u2500
            const mergedSpineGeo   = mergeGeometries(spinePieces);
            mergedSpineGeo.computeVertexNormals();
            const spineMesh = new THREE.Mesh(mergedSpineGeo, spineMat2);
            spineMesh.castShadow = true;
            tree.add(spineMesh);

            const mergedLeafGeo = mergeGeometries(leafletPieces);
            mergedLeafGeo.computeVertexNormals();
            const leafMesh = new THREE.Mesh(mergedLeafGeo, leafletMat);
            leafMesh.castShadow = true;
            tree.add(leafMesh);

            // Small coconut cluster at crown
            if (Math.random() > 0.4) {
                const cocoMat = new THREE.MeshStandardMaterial({ color: 0x5a4020, roughness: 0.9 });
                const cocoCount = 2 + Math.floor(Math.random() * 3);
                for (let c = 0; c < cocoCount; c++) {
                    const cocoGeo = new THREE.SphereGeometry(0.12 + Math.random()*0.05, 7, 6);
                    const coco    = new THREE.Mesh(cocoGeo, cocoMat);
                    const ca = Math.random() * Math.PI * 2;
                    coco.position.set(crownX + Math.cos(ca)*0.18, crownY - 0.22, crownZ + Math.sin(ca)*0.18);
                    coco.castShadow = true;
                    tree.add(coco);
                }
            }

            tree.position.set(x, yOffset, z);
            tree.userData.health     = 3;
            tree.userData.type       = 'tree';   // identical to regular tree - same chop logic
            tree.userData.isPalmTree = true;      // flag so GLB-swap loops can tell palms from forest trees
            tree.userData.swayPhase  = Math.random() * Math.PI * 2;
            tree.userData.swaySpeed  = 0.3 + Math.random() * 0.2; // slower sway than forest trees

            trees.push(tree);
            const _desertTreePosEntry = { x, z, radius: 1.5 };
            tree.userData._posEntry = _desertTreePosEntry;
            tree.userData._posArray = treePositions;
            treePositions.push(_desertTreePosEntry);
            scene.add(tree);
        }

        // Spawn 8-12 palm trees spread across the desert
        {
            const dpMargin  = 10;
            const dpCenterZ = -desertOffset + 0.5;
            const dpHalf    = groundSize / 2 - dpMargin;
            const dpXMin    = -groundSize / 2 + dpMargin;
            const dpXMax    =  groundSize / 2 - dpMargin;
            const dpZMin    = dpCenterZ - dpHalf;
            const dpZMax    = dpCenterZ + dpHalf - 18;
            const numPalms  = 8 + Math.floor(Math.random() * 5);

            for (let i = 0; i < numPalms; i++) {
                let attempts = 0, valid = false, fx, fz;
                do {
                    fx = dpXMin + Math.random() * (dpXMax - dpXMin);
                    fz = dpZMin + Math.random() * (dpZMax - dpZMin);
                    valid = true;
                    for (const ob of desertFormationColliders) {
                        if (Math.sqrt((fx-ob.x)**2+(fz-ob.z)**2) < ob.r + 2) { valid=false; break; }
                    }
                    if (!valid) { attempts++; continue; }
                    for (const p of [...treePositions, ...rockPositions, ...orePositions, ...sulfurPositions, ...cactiPositions]) {
                        if (Math.sqrt((fx-p.x)**2+(fz-p.z)**2) < 6) { valid=false; break; }
                    }
                    attempts++;
                } while (!valid && attempts < 80);
                if (valid) createPalmTree(fx, fz);
            }
        }

        // Once Palm Tree.glb loads, swap procedural palms for GLB versions
        _loadAssetGLB('Palm Tree.glb').then(tmpl => {
            if (!tmpl) { console.warn('🌴 Palm Tree.glb failed — keeping procedural palms'); return; }
            console.log(`🌴 Palm Tree.glb loaded — scanning ${trees.length} entries for procedural palms...`);
            let swapped = 0;
            for (let i = trees.length - 1; i >= 0; i--) {
                const old = trees[i];
                // Only swap procedural palm trees: must have type 'tree', the isPalmTree flag, AND swayPhase
                // (isPalmTree + swayPhase = procedural; missing either means already a GLB instance)
                if (old.userData.type !== 'tree') continue;
                if (!old.userData.isPalmTree) continue;       // not a palm — skip
                if (!old.userData.swayPhase) continue;        // already swapped to GLB — skip
                const x = old.position.x, z = old.position.z;
                const targetH = 5.0 + Math.random() * 3.5;
                const inst = _instantiateGLB('Palm Tree.glb', targetH);
                if (!inst) { console.warn('🌴 _instantiateGLB returned null for Palm Tree.glb'); continue; }
                inst.position.set(x, inst.position.y, z);
                inst.rotation.y = Math.random() * Math.PI * 2;
                inst.userData.type = 'tree';
                inst.userData.isPalmTree = true;
                inst.userData.health = old.userData.health ?? 3;
                inst.userData.maxHealth = 3;
                inst.userData.trunkHeight = targetH * 0.75;
                inst.userData.swayPhase = Math.random() * Math.PI * 2;
                inst.userData.swaySpeed = 0.3 + Math.random() * 0.2;
                scene.remove(old);
                scene.add(inst);
                trees[i] = inst;
                swapped++;
                if (swapped === 1) {
                    inst.updateMatrixWorld(true);
                    const wp = new THREE.Vector3();
                    inst.getWorldPosition(wp);
                    const bb = new THREE.Box3().setFromObject(inst);
                    console.log(`🌴 FIRST PALM world pos: (${wp.x.toFixed(1)}, ${wp.y.toFixed(1)}, ${wp.z.toFixed(1)}) | bbox Y: ${bb.min.y.toFixed(2)} → ${bb.max.y.toFixed(2)} | inst.position.y=${inst.position.y.toFixed(3)}`);
                }
            }
            console.log(`🌴 Palm swap done: ${swapped} procedural → GLB`);
        });

        // ── Dead Trees — desert biome only ─────────────────────────────────────────
        function createDeadTree(x, z) {
            if (_assetGLBCache['DeadTree.glb']) {
                const targetH = 3.5 + Math.random() * 3.0;
                const inst = _instantiateGLB('DeadTree.glb', targetH);
                inst.position.set(x, inst.position.y, z);
                inst.rotation.y = Math.random() * Math.PI * 2;
                inst.userData.type         = 'tree';
                inst.userData.isDeadTree   = true;
                inst.userData.health       = 3;
                inst.userData.maxHealth    = 3;
                inst.userData.trunkHeight  = targetH * 0.9;
                inst.userData.swayPhase    = Math.random() * Math.PI * 2;
                inst.userData.swaySpeed    = 0.25 + Math.random() * 0.15;
                trees.push(inst);
                treePositions.push({ x, z, radius: 1.0 });
                scene.add(inst);
                return;
            }
            _loadAssetGLB('DeadTree.glb');

            // Procedural fallback — bare twisted trunk with leafless branches
            const tree = new THREE.Group();
            const trunkH = 4 + Math.random() * 3.5;

            // Bleached/grey bark texture for desert dead tree
            const barkData = new Uint8Array(16 * 16 * 4);
            for (let i = 0; i < 16 * 16; i++) {
                const bx = i % 16, by = Math.floor(i / 16);
                const crack = Math.abs(Math.sin(bx * 1.4 + by * 0.3)) * 16;
                const noise = Math.random() * 10;
                const base  = 120 + crack + noise; // light grey/bleached
                barkData[i*4]   = Math.min(255, base);
                barkData[i*4+1] = Math.min(255, base * 0.92);
                barkData[i*4+2] = Math.min(255, base * 0.82);
                barkData[i*4+3] = 255;
            }
            const barkTex = new THREE.DataTexture(barkData, 16, 16, THREE.RGBAFormat);
            barkTex.needsUpdate = true;
            barkTex.wrapS = barkTex.wrapT = THREE.RepeatWrapping;
            barkTex.repeat.set(2, 5);
            barkTex.magFilter = THREE.NearestFilter;
            const barkMat = new THREE.MeshStandardMaterial({ map: barkTex, roughness: 0.98, metalness: 0 });

            // Leaning trunk — dead trees list dramatically
            const leanAngle = 0.06 + Math.random() * 0.12;
            const leanDir   = Math.random() * Math.PI * 2;
            const trunkGeo  = new THREE.CylinderGeometry(
                0.12 + Math.random() * 0.06,
                0.22 + Math.random() * 0.08,
                trunkH, 7
            );
            const trunk = new THREE.Mesh(trunkGeo, barkMat);
            trunk.position.y  = trunkH / 2;
            trunk.rotation.x  = Math.cos(leanDir + Math.PI / 2) * leanAngle;
            trunk.rotation.z  = Math.sin(leanDir + Math.PI / 2) * leanAngle;
            trunk.castShadow  = true;
            tree.add(trunk);

            // 2–4 bare branches — no foliage
            const numBranches = 2 + Math.floor(Math.random() * 3);
            for (let b = 0; b < numBranches; b++) {
                const bAngle  = Math.random() * Math.PI * 2;
                const bYFrac  = 0.45 + Math.random() * 0.5;
                const bY      = trunkH * bYFrac;
                const bLen    = 0.8 + Math.random() * 1.4;
                const bR      = 0.03 + Math.random() * 0.03;
                const bGeo    = new THREE.CylinderGeometry(bR * 0.3, bR, bLen, 5);
                const branch  = new THREE.Mesh(bGeo, barkMat);
                branch.rotation.z  =  Math.PI / 2;
                branch.rotation.y  =  bAngle;
                branch.rotation.x  = -(0.2 + Math.random() * 0.5);
                branch.position.set(
                    Math.cos(bAngle) * 0.15,
                    bY,
                    Math.sin(bAngle) * 0.15
                );
                branch.castShadow = true;
                tree.add(branch);

                // Smaller sub-branch (50% chance)
                if (Math.random() < 0.5) {
                    const sbLen  = bLen * 0.45;
                    const sbGeo  = new THREE.CylinderGeometry(bR * 0.15, bR * 0.3, sbLen, 5);
                    const sbAngle = bAngle + (Math.random() - 0.5) * 1.2;
                    const sub    = new THREE.Mesh(sbGeo, barkMat);
                    sub.rotation.z = Math.PI / 2;
                    sub.rotation.y = sbAngle;
                    sub.rotation.x = -(0.15 + Math.random() * 0.4);
                    sub.position.set(
                        Math.cos(bAngle) * 0.15 + Math.cos(bAngle) * bLen * 0.6,
                        bY + bLen * 0.2,
                        Math.sin(bAngle) * 0.15 + Math.sin(bAngle) * bLen * 0.6
                    );
                    sub.castShadow = true;
                    tree.add(sub);
                }
            }

            tree.position.set(x, 0, z);
            tree.userData.health     = 3;
            tree.userData.maxHealth  = 3;
            tree.userData.type       = 'tree';
            tree.userData.isDeadTree = true;
            tree.userData.swayPhase  = Math.random() * Math.PI * 2;
            tree.userData.swaySpeed  = 0.25 + Math.random() * 0.15;

            trees.push(tree);
            const _dtPosEntry = { x, z, radius: 1.0 };
            tree.userData._posEntry = _dtPosEntry;
            tree.userData._posArray = treePositions;
            treePositions.push(_dtPosEntry);
            scene.add(tree);
        }

        // Spawn dead trees across the desert
        {
            const dtMargin  = 10;
            const dtCenterZ = -desertOffset + 0.5;
            const dtHalf    = groundSize / 2 - dtMargin;
            const dtXMin    = -groundSize / 2 + dtMargin;
            const dtXMax    =  groundSize / 2 - dtMargin;
            const dtZMin    = dtCenterZ - dtHalf;
            const dtZMax    = dtCenterZ + dtHalf - 18;
            const numDeadTrees = 10 + Math.floor(Math.random() * 8);

            for (let i = 0; i < numDeadTrees; i++) {
                let dx, dz, valid = false, attempts = 0;
                do {
                    dx = dtXMin + Math.random() * (dtXMax - dtXMin);
                    dz = dtZMin + Math.random() * (dtZMax - dtZMin);
                    valid = true;
                    for (const ob of desertFormationColliders) {
                        if (Math.sqrt((dx-ob.x)**2+(dz-ob.z)**2) < ob.r + 2) { valid = false; break; }
                    }
                    if (!valid) { attempts++; continue; }
                    for (const p of [...treePositions, ...rockPositions, ...orePositions, ...sulfurPositions, ...cactiPositions]) {
                        if (Math.sqrt((dx-p.x)**2+(dz-p.z)**2) < 5) { valid = false; break; }
                    }
                    attempts++;
                } while (!valid && attempts < 60);
                if (valid) createDeadTree(dx, dz);
            }
        }

        // Once DeadTree.glb loads, swap procedural dead trees for GLB versions
        _loadAssetGLB('DeadTree.glb').then(tmpl => {
            if (!tmpl) { console.warn('🌵 DeadTree.glb failed — keeping procedural dead trees'); return; }
            console.log(`🌵 DeadTree.glb loaded — scanning ${trees.length} entries for procedural dead trees...`);
            let swappedDT = 0;
            for (let i = trees.length - 1; i >= 0; i--) {
                const old = trees[i];
                if (old.userData.type !== 'tree')  continue;
                if (!old.userData.isDeadTree)       continue;  // only dead trees
                if (!old.userData.swayPhase)        continue;  // already a GLB — skip
                const x = old.position.x, z = old.position.z;
                const targetH = 3.5 + Math.random() * 3.0;
                const inst = _instantiateGLB('DeadTree.glb', targetH);
                if (!inst) { console.warn('🌵 _instantiateGLB returned null for DeadTree.glb'); continue; }
                inst.position.set(x, inst.position.y, z);
                inst.rotation.y = Math.random() * Math.PI * 2;
                inst.userData.type        = 'tree';
                inst.userData.isDeadTree  = true;
                inst.userData.health      = old.userData.health ?? 3;
                inst.userData.maxHealth   = 3;
                inst.userData.trunkHeight = targetH * 0.9;
                inst.userData.swayPhase   = Math.random() * Math.PI * 2;
                inst.userData.swaySpeed   = 0.25 + Math.random() * 0.15;
                inst.userData._posEntry   = old.userData._posEntry;
                inst.userData._posArray   = old.userData._posArray;
                scene.remove(old);
                scene.add(inst);
                trees[i] = inst;
                swappedDT++;
            }
            console.log(`🌵 DeadTree swap done: ${swappedDT} procedural → GLB`);
        });

        // ===== DESERT OASES =====
        (function createOases() {

            // --- Lush grass blade tuft for oasis interior ---
            const oasisGrassMat = new THREE.MeshStandardMaterial({
                side: THREE.DoubleSide, roughness: 0.88, metalness: 0, vertexColors: true,
            });

            function makeOasisGrassTuft(x, z, lushness, groundY = 0.01) {
                // lushness 0=edge (yellow-green) 1=centre (deep green)
                const numBlades = 10 + Math.floor(Math.random() * 8);
                const allPos = [], allNorm = [], allUV = [], allCol = [], allIdx = [];
                let vOff = 0;
                for (let b = 0; b < numBlades; b++) {
                    const h = 0.40 + Math.random() * 0.55 + lushness * 0.25;
                    const w = 0.04 + Math.random() * 0.04;
                    const bx = (Math.random() - 0.5) * 0.32;
                    const bz = (Math.random() - 0.5) * 0.32;
                    const ry = Math.random() * Math.PI * 2;
                    const cr = Math.cos(ry), sr = Math.sin(ry);
                    const segsY = 4, cols = 2, rows = segsY + 1;
                    // Colour: sandy-yellow at edge, vivid green at centre
                    const hue = 0.22 - lushness * 0.05;  // 0.22=yellow-green, 0.17=golden
                    const sat = 0.45 + lushness * 0.38;
                    const lit = 0.30 + lushness * 0.12;
                    const baseCol = new THREE.Color().setHSL(hue, sat, lit);
                    const tipCol  = new THREE.Color().setHSL(hue + 0.04, sat * 0.70, lit + 0.22);
                    for (let row = 0; row < rows; row++) {
                        for (let col2 = 0; col2 < cols; col2++) {
                            const u = col2 / (cols - 1);
                            const v = row  / (rows - 1);
                            const lx = (u - 0.5) * w;
                            const ly = v * h;
                            const bend = ((v + 0.5) ** 2) * (0.12 + Math.random() * 0.08);
                            allPos.push(cr * (lx + bend) + bx, ly, sr * (lx + bend) + bz);
                            allNorm.push(0, 1, 0);
                            allUV.push(u, v);
                            const c = baseCol.clone().lerp(tipCol, v * v);
                            allCol.push(c.r, c.g, c.b);
                        }
                    }
                    for (let row = 0; row < segsY; row++) {
                        const a = vOff + row * cols;
                        const b2 = a + 1, c2 = a + cols, d = c2 + 1;
                        allIdx.push(a, c2, b2,  b2, c2, d);
                    }
                    vOff += rows * cols;
                }
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.Float32BufferAttribute(allPos,  3));
                geo.setAttribute('normal',   new THREE.Float32BufferAttribute(allNorm, 3));
                geo.setAttribute('uv',       new THREE.Float32BufferAttribute(allUV,   2));
                geo.setAttribute('color',    new THREE.Float32BufferAttribute(allCol,  3));
                geo.setIndex(allIdx);
                geo.computeVertexNormals();
                const tuft = new THREE.Mesh(geo, oasisGrassMat);
                tuft.position.set(x, groundY + 0.01, z);
                tuft.userData.windSpeed = 0.45 + Math.random() * 0.30;
                tuft.userData.windPhase = Math.random() * Math.PI * 2;
                tuft.userData.type = 'desert_grass'; // uses same wind update loop
                desertGrassTufts.push(tuft);
                scene.add(tuft);
            }

            // --- Blended ground disc: sand \u2192 brown-green \u2192 green, with vertex colours ---
            // Returns the bowl Y-offset for a given world-radius from oasis centre.
            // Uses the same smoothstep hermite curve as the river channel deformation.
            function oasisBowlY(worldR, outerR, bowlDepth, baseY) {
                const t = Math.min(1, worldR / outerR);   // 0 = centre, 1 = edge
                const s = t * t * (3 - 2 * t);             // smoothstep
                return baseY - bowlDepth * (1 - s);        // deepest at centre
            }

            function makeGroundBlend(cx, cy, cz, innerR, outerR, bowlDepth) {
                // Annular ring from innerR (water edge) to outerR (sand).
                // Each ring of vertices is deformed downward via the same smoothstep as the river.
                const ringCount = 28;
                const segCount  = 48;
                const positions = [], colours = [], normals = [], uvs = [], indices = [];

                function ringColour(t) { // t=0 → lush green (water edge), t=1 → sand
                    if (t < 0.45) {
                        return new THREE.Color(0x2d7a1f).lerp(new THREE.Color(0x8ab84a), t / 0.45);
                    } else if (t < 0.75) {
                        return new THREE.Color(0x8ab84a).lerp(new THREE.Color(0xb89a5a), (t - 0.45) / 0.30);
                    } else {
                        return new THREE.Color(0xb89a5a).lerp(new THREE.Color(0xc8a86a), (t - 0.75) / 0.25);
                    }
                }

                // Rings go from innerR (ri=0) to outerR (ri=ringCount)
                for (let ri = 0; ri <= ringCount; ri++) {
                    const t    = ri / ringCount;                      // 0=inner, 1=outer
                    const r    = innerR + (outerR - innerR) * t;      // world radius
                    const col  = ringColour(t);
                    const yVal = oasisBowlY(r, outerR, bowlDepth, cy);
                    for (let si = 0; si <= segCount; si++) {
                        const angle  = (si / segCount) * Math.PI * 2;
                        const jitter = (ri > 0 && ri < ringCount) ? (Math.random() - 0.5) * (outerR - innerR) * 0.04 : 0;
                        positions.push(cx + (r + jitter) * Math.cos(angle), yVal, cz + (r + jitter) * Math.sin(angle));
                        normals.push(0, 1, 0);
                        uvs.push(si / segCount, t);
                        const cv = col.clone();
                        cv.r = Math.min(1, cv.r + (Math.random()-0.5)*0.04);
                        cv.g = Math.min(1, cv.g + (Math.random()-0.5)*0.04);
                        cv.b = Math.min(1, cv.b + (Math.random()-0.5)*0.04);
                        colours.push(cv.r, cv.g, cv.b);
                    }
                }

                // Stitch all rings into quads
                for (let ri = 0; ri < ringCount; ri++) {
                    const base = ri * (segCount + 1);
                    for (let si = 0; si < segCount; si++) {
                        const a = base + si, b = base + si + 1;
                        const c = base + (segCount+1) + si, d = c + 1;
                        indices.push(a, c, b,  b, c, d);
                    }
                }

                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geo.setAttribute('normal',   new THREE.Float32BufferAttribute(normals,   3));
                geo.setAttribute('uv',       new THREE.Float32BufferAttribute(uvs,       2));
                geo.setAttribute('color',    new THREE.Float32BufferAttribute(colours,   3));
                geo.setIndex(indices);
                geo.computeVertexNormals();
                const mat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.94, metalness: 0, depthWrite: true });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.receiveShadow = true;
                mesh.renderOrder = 1;
                scene.add(mesh);
            }
         // --- Water disc: vivid tropical pool ---
            function makeWaterDisc(cx, cy, cz, r) {
                const segs  = 48;
                const rings = 8;
                const positions = [], normals = [], uvs = [], colours = [], indices = [];

                // Centre \u2014 deep jewel blue
                positions.push(cx, cy, cz);
                normals.push(0, 1, 0);
                uvs.push(0.5, 0.5);
                colours.push(0.0, 0.35, 0.95); // saturated cobalt blue

                for (let ri = 1; ri <= rings; ri++) {
                    const t   = ri / rings;
                    const rad = r * t;
                    for (let si = 0; si < segs; si++) {
                        const angle  = (si / segs) * Math.PI * 2;
                        const ripple = 0.015 * Math.sin(si * 1.5 + ri * 2.3);
                        positions.push(
                            cx + rad * Math.cos(angle),
                            cy + ripple,
                            cz + rad * Math.sin(angle)
                        );
                        normals.push(0, 1, 0);
                        uvs.push(0.5 + Math.cos(angle) * t * 0.5, 0.5 + Math.sin(angle) * t * 0.5);
                        // deep blue centre \u2192 bright teal edge, always vivid
                        colours.push(0.0 + t * 0.10, 0.38 + t * 0.22, 0.92 - t * 0.12);
                    }
                }

                // Centre fan
                for (let si = 0; si < segs; si++) {
                    indices.push(0, 1 + si, 1 + (si + 1) % segs);
                }
                // Stitch rings
                for (let ri = 0; ri < rings - 1; ri++) {
                    const base = 1 + ri * segs;
                    for (let si = 0; si < segs; si++) {
                        const a = base + si, b = base + (si + 1) % segs;
                        const c = base + segs + si, d = base + segs + (si + 1) % segs;
                        indices.push(a, c, b,  b, c, d);
                    }
                }

                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geo.setAttribute('normal',   new THREE.Float32BufferAttribute(normals,   3));
                geo.setAttribute('uv',       new THREE.Float32BufferAttribute(uvs,       2));
                geo.setAttribute('color',    new THREE.Float32BufferAttribute(colours,   3));
                geo.setIndex(indices);
                geo.computeVertexNormals();

                // MeshBasicMaterial ignores ALL lighting \u2014 colour is always vivid
                const mat = new THREE.MeshBasicMaterial({
                    vertexColors: true,
                    depthWrite: true,
                    side: THREE.FrontSide,
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.renderOrder = 0;
                scene.add(mesh);
            }

            // Spawn-exclusion list (used only to keep other features from spawning inside oases)
            const oasisSpawnExclusion = [];

            // --- Build one complete oasis at (cx, cz) ---
            function buildOasis(cx, cz) {
                const waterR     = 5.0 + Math.random() * 2.0;
                const grassR     = waterR + 4.0;
                const blendR     = grassR  + 6.5;
                const BOWL_DEPTH = 1.8;   // metres the centre dips below ground level

                // Water sits at the very bottom of the bowl (r=0)
                const waterLevel = oasisBowlY(0, blendR, BOWL_DEPTH, 0);  // e.g. -1.8

                // 1. Blended ground ring — bowl-deformed, covers waterR → blendR (the slope + sand blend)
                makeGroundBlend(cx, 0, cz, waterR, blendR, BOWL_DEPTH);

                // 2. Water disc sits at the bowl bottom
                makeWaterDisc(cx, waterLevel + 0.05, cz, waterR);

                // 3. Lush grass tufts on the slopes — Y follows bowl surface
                const grassTuftCount = 55 + Math.floor(Math.random() * 20);
                const placedTufts = [];
                let att = 0;
                while (placedTufts.length < grassTuftCount && att < 600) {
                    att++;
                    const angle = Math.random() * Math.PI * 2;
                    const dist  = waterR + 0.4 + Math.pow(Math.random(), 0.6) * (blendR - waterR - 0.4);
                    const tx2 = cx + Math.cos(angle) * dist;
                    const tz2 = cz + Math.sin(angle) * dist;
                    if (Math.sqrt((tx2 - cx) ** 2 + (tz2 - cz) ** 2) < waterR + 0.2) continue;
                    let tooClose = false;
                    for (const p of placedTufts) {
                        if (Math.sqrt((tx2 - p.x) ** 2 + (tz2 - p.z) ** 2) < 1.1) { tooClose = true; break; }
                    }
                    if (tooClose) continue;
                    const lushness = Math.max(0, 1 - (dist - waterR) / (blendR - waterR));
                    const tuftY = oasisBowlY(dist, blendR, BOWL_DEPTH, 0);
                    makeOasisGrassTuft(tx2, tz2, lushness, tuftY);
                    placedTufts.push({ x: tx2, z: tz2 });
                }

                // 4. Palm trees at the water's edge — sit on the slope
                const palmRing  = waterR * (0.85 + Math.random() * 0.30);
                const palmCount = 5 + Math.floor(Math.random() * 4);
                for (let i = 0; i < palmCount; i++) {
                    const angle = (i / palmCount) * Math.PI * 2 + (Math.random() - 0.5) * 0.35;
                    const dist  = palmRing * (0.85 + Math.random() * 0.30);
                    const px = cx + Math.cos(angle) * dist;
                    const pz = cz + Math.sin(angle) * dist;
                    const palmY = oasisBowlY(dist, blendR, BOWL_DEPTH, 0);
                    createPalmTree(px, pz, palmY);
                }

                oasisSpawnExclusion.push({ x: cx, z: cz, r: blendR });
            }
            // --- Pick 2 well-spaced oasis positions deep in the desert ---
            const oasisPositions = [];
            const oz_margin = 20;
            const oz_cx0 = desertXMin + oz_margin;
            const oz_cx1 = desertXMax - oz_margin;
            const oz_cz0 = desertZMin + oz_margin;
            const oz_cz1 = desertZMax - oz_margin;

            let placed2 = 0;
            let tries = 0;
            while (placed2 < 2 && tries < 400) {
                tries++;
                const ox = oz_cx0 + Math.random() * (oz_cx1 - oz_cx0);
                const oz = oz_cz0 + Math.random() * (oz_cz1 - oz_cz0);

                let bad = false;
                for (const p of oasisPositions) {
                    if (Math.sqrt((ox - p.x) ** 2 + (oz - p.z) ** 2) < 50) { bad = true; break; }
                }
                if (bad) continue;
                for (const p of desertFormationPositions) {
                    if (Math.sqrt((ox - p.x) ** 2 + (oz - p.z) ** 2) < 16) { bad = true; break; }
                }
                if (bad) continue;

                buildOasis(ox, oz);
                oasisPositions.push({ x: ox, z: oz });
                placed2++;
            }

        })();

        const berryBushes = [];
        const bushPositions = []; // { x, z, radius } for collision
        
        // Procedural leaf texture \ufffd bright greens with colour variation
        // Foliage texture for berry bush
        function createBushFoliageTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#3a8a18';
            ctx.fillRect(0, 0, 256, 256);
            for (let i = 0; i < 60; i++) {
                const cx = Math.random() * 256, cy = Math.random() * 256;
                const rx = 8 + Math.random() * 20, ry = 5 + Math.random() * 13;
                const bright = Math.random() > 0.35;
                const delta = bright ? (25 + Math.random() * 45) : -(12 + Math.random() * 28);
                const g2 = Math.min(255, Math.max(0, 138 + delta));
                const r2 = Math.min(255, Math.max(0, 58 + delta * 0.3));
                ctx.fillStyle = `rgba(${r2|0},${g2|0},24,0.55)`;
                ctx.beginPath();
                ctx.ellipse(cx, cy, rx, ry, Math.random() * Math.PI, 0, Math.PI * 2);
                ctx.fill();
            }
            for (let i = 0; i < 35; i++) {
                ctx.strokeStyle = `rgba(0,40,0,${0.06 + Math.random() * 0.1})`;
                ctx.lineWidth = 0.6;
                ctx.beginPath();
                const sx = Math.random()*256, sy = Math.random()*256;
                ctx.moveTo(sx, sy);
                ctx.lineTo(sx + (Math.random()-0.5)*30, sy + (Math.random()-0.5)*30);
                ctx.stroke();
            }
            for (let i = 0; i < 30; i++) {
                ctx.fillStyle = `rgba(160,255,80,${0.07 + Math.random() * 0.11})`;
                ctx.beginPath();
                ctx.arc(Math.random()*256, Math.random()*256, 1.5 + Math.random()*3, 0, Math.PI*2);
                ctx.fill();
            }
            return canvas;
        }

        // Helper: merge an array of {geo, matrix} into one BufferGeometry
        function mergeGeometries(pieces) {
            let totalVerts = 0, totalIdx = 0;
            pieces.forEach(p => {
                totalVerts += p.geo.attributes.position.count;
                totalIdx   += p.geo.index ? p.geo.index.count : p.geo.attributes.position.count;
            });

            const positions = new Float32Array(totalVerts * 3);
            const normals   = new Float32Array(totalVerts * 3);
            const uvs       = new Float32Array(totalVerts * 2);
            const indices   = [];

            let vOffset = 0, iOffset = 0;
            const _v  = new THREE.Vector3();
            const _n  = new THREE.Vector3();
            const _m3 = new THREE.Matrix3();

            pieces.forEach(({ geo, matrix }) => {
                const posArr = geo.attributes.position.array;
                const nrmArr = geo.attributes.normal ? geo.attributes.normal.array : null;
                const uvArr  = geo.attributes.uv     ? geo.attributes.uv.array     : null;
                const count  = geo.attributes.position.count;
                _m3.getNormalMatrix(matrix);

                for (let i = 0; i < count; i++) {
                    _v.set(posArr[i*3], posArr[i*3+1], posArr[i*3+2]).applyMatrix4(matrix);
                    positions[(vOffset+i)*3]   = _v.x;
                    positions[(vOffset+i)*3+1] = _v.y;
                    positions[(vOffset+i)*3+2] = _v.z;

                    if (nrmArr) {
                        _n.set(nrmArr[i*3], nrmArr[i*3+1], nrmArr[i*3+2]).applyMatrix3(_m3).normalize();
                        normals[(vOffset+i)*3]   = _n.x;
                        normals[(vOffset+i)*3+1] = _n.y;
                        normals[(vOffset+i)*3+2] = _n.z;
                    }
                    if (uvArr) {
                        uvs[(vOffset+i)*2]   = uvArr[i*2];
                        uvs[(vOffset+i)*2+1] = uvArr[i*2+1];
                    }
                }

                const idxArr = geo.index ? geo.index.array : null;
                const idxCount = idxArr ? idxArr.length : count;
                for (let i = 0; i < idxCount; i++) {
                    indices.push(vOffset + (idxArr ? idxArr[i] : i));
                }

                vOffset += count;
            });

            const merged = new THREE.BufferGeometry();
            merged.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            merged.setAttribute('normal',   new THREE.BufferAttribute(normals,   3));
            merged.setAttribute('uv',       new THREE.BufferAttribute(uvs,       2));
            merged.setIndex(indices);
            return merged;
        }

        async function createBerryBush(x, z) {
            const bush = new THREE.Group();

            // ?? Single shared foliage material ??
            const foliageTex = new THREE.CanvasTexture(createBushFoliageTexture());
            foliageTex.wrapS = foliageTex.wrapT = THREE.RepeatWrapping;
            foliageTex.repeat.set(2, 2);
            const foliageMat = new THREE.MeshStandardMaterial({
                map: foliageTex, roughness: 0.88, metalness: 0, color: 0xffffff
            });

            // ?? Define 4 foliage lumps: positions, radii, scale ??
            // Intentionally asymmetric for a natural look
            const lumpDefs = [
                { x:  0.00, y: 0.40, z:  0.00, r: 0.58, sx: 1.30, sy: 0.80, sz: 1.30 }, // wide flat centre
                { x:  0.48, y: 0.62, z:  0.10, r: 0.40, sx: 1.00, sy: 1.10, sz: 0.95 }, // right side up
                { x: -0.38, y: 0.55, z: -0.25, r: 0.38, sx: 0.95, sy: 1.05, sz: 1.00 }, // left back
                { x:  0.10, y: 0.72, z:  0.38, r: 0.36, sx: 1.05, sy: 0.90, sz: 0.95 }, // front top
            ];

            // Build pieces list for merging
            const pieces = [];
            const dummy = new THREE.Object3D();
            lumpDefs.forEach(d => {
                const geo = new THREE.SphereGeometry(d.r, 9, 7);
                dummy.position.set(d.x, d.y, d.z);
                dummy.scale.set(d.sx, d.sy, d.sz);
                dummy.updateMatrix();
                pieces.push({ geo, matrix: dummy.matrix.clone() });
            });

            const mergedGeo  = mergeGeometries(pieces);
            mergedGeo.computeVertexNormals();
            const foliageMesh = new THREE.Mesh(mergedGeo, foliageMat);
            foliageMesh.castShadow = true;
            foliageMesh.receiveShadow = true;
            bush.add(foliageMesh);

            // ?? Two woody branches visible at the base ??
            const branchMat = await createWoodMaterial(0x4a2e12, 0.9);
            [
                { angle: 0.4,  lean: 0.28, len: 0.70 },
                { angle: 3.5,  lean: 0.22, len: 0.60 },
            ].forEach(b => {
                const geo  = new THREE.CylinderGeometry(0.018, 0.048, b.len, 6);
                const mesh = new THREE.Mesh(geo, branchMat);
                mesh.position.set(Math.cos(b.angle)*b.len*0.38, b.len*0.42, Math.sin(b.angle)*b.len*0.38);
                mesh.rotation.set(b.lean * -Math.sin(b.angle), 0, b.lean * Math.cos(b.angle));
                mesh.castShadow = true;
                bush.add(mesh);
            });

            // ?? BERRIES: 10-14 total, spread across top & upper sides ??
            const berries = [];
            const berryColors = [0xcc1111, 0xaa0808, 0xdd2020, 0xbb1515];
            const berryMat  = new THREE.MeshStandardMaterial({
                color: 0xcc1111, roughness: 0.28, metalness: 0.06,
                emissive: 0x330000, emissiveIntensity: 0.8
            });
            const bCalyxMat = new THREE.MeshStandardMaterial({ color: 0x1e4d08, roughness: 0.9 });

            const totalBerries = 10 + Math.floor(Math.random() * 5); // 10-14
            for (let i = 0; i < totalBerries; i++) {
                const bg = new THREE.Group();
                const br = 0.068 + Math.random() * 0.022;

                // Choose which lump this berry sits on
                const lump = lumpDefs[i % lumpDefs.length];

                // Evenly space phi around 360\ufffd, theta covers top + upper sides (0 to ~75\ufffd)
                const phi   = (i / totalBerries) * Math.PI * 2 + (Math.random()-0.5) * 0.7;
                const theta = Math.random() * Math.PI * 0.70;
                const nx = Math.sin(theta) * Math.cos(phi);
                const ny = Math.cos(theta);
                const nz = Math.sin(theta) * Math.sin(phi);

                // Sit on lump surface (account for lump's non-uniform scale)
                const sx = lump.sx, sy = lump.sy, sz = lump.sz;
                const scaledR = lump.r * Math.sqrt((nx*nx)/(sx*sx) + (ny*ny)/(sy*sy) + (nz*nz)/(sz*sz));
                const outDist = lump.r + br * 0.6;
                const bx = lump.x + nx * outDist;
                const by = lump.y + ny * outDist;
                const bz = lump.z + nz * outDist;

                // Berry sphere
                const col = berryColors[Math.floor(Math.random() * berryColors.length)];
                const bMat = berryMat.clone();
                bMat.color.setHex(col);
                bg.add(new THREE.Mesh(new THREE.SphereGeometry(br, 7, 7), bMat));

                // Calyx nub
                const calyx = new THREE.Mesh(new THREE.ConeGeometry(br*0.28, br*0.5, 5), bCalyxMat);
                calyx.position.y = -br * 0.82;
                calyx.rotation.z = Math.PI;
                bg.add(calyx);


                bg.position.set(bx, by, bz);
                bg.userData.isVisible   = true;
                bg.userData.respawnTime = 0;
                berries.push(bg);
                bush.add(bg);
            }

            bush.updateMatrixWorld(true);
            const bushBox = new THREE.Box3().setFromObject(bush);
            bush.position.set(x, -bushBox.min.y - 0.3, z);
            bush.userData.type   = 'berryBush';
            bush.userData.berries = berries;

            berryBushes.push(bush);
            bushPositions.push({ x, z, radius: 1.2 });
            scene.add(bush);
        }
        
        // ===== GROUND COLLECTIBLES =====
        const groundCollectibles = [];
        const wildPlants = []; // { mesh, seedType, harvestable, respawnAt }
        
        async function createStickPickup(x, z) {
            // Await GLB load so the model is always used instead of procedural fallback
            await _loadAssetGLB('Stick.glb');
            if (_assetGLBCache['Stick.glb']) {
                const inst = _instantiateGLB('Stick.glb', 0.5);
                if (inst) {
                    inst.position.set(x, inst.position.y, z);
                    inst.rotation.y = Math.random() * Math.PI * 2;
                    inst.userData.type = 'stick_pickup';
                    inst.userData.collectible = 'sticks';
                    inst.userData.amount = 3;
                    groundCollectibles.push(inst);
                    scene.add(inst);
                    return;
                }
            }
            // Procedural fallback (only if GLB truly unavailable)

            // Procedural fallback
            const stick = new THREE.Group();
            
            // Create 2-3 sticks bundled together
            const numSticks = 2 + Math.floor(Math.random() * 2);
            for (let i = 0; i < numSticks; i++) {
                const length = 0.35 + Math.random() * 0.15;
                const thickness = 0.015 + Math.random() * 0.01;
                const stickGeo = new THREE.CylinderGeometry(
                    thickness, 
                    thickness * 0.8, 
                    length, 
                    6
                );
                const stickMat = new THREE.MeshStandardMaterial({ 
                    color: 0x6B4423,
                    roughness: 0.9,
                    metalness: 0
                });
                const stickMesh = new THREE.Mesh(stickGeo, stickMat);
                stickMesh.rotation.z = Math.random() * Math.PI;
                stickMesh.rotation.x = Math.random() * 0.5;
                stickMesh.rotation.y = (i / numSticks) * Math.PI * 0.5;
                stickMesh.position.x += (Math.random() - 0.5) * 0.05;
                stickMesh.position.z += (Math.random() - 0.5) * 0.05;
                stickMesh.castShadow = true;
                stick.add(stickMesh);
                
                // Add small branches
                if (Math.random() > 0.5) {
                    const branchGeo = new THREE.CylinderGeometry(thickness * 0.4, thickness * 0.3, length * 0.3, 4);
                    const branch = new THREE.Mesh(branchGeo, stickMat);
                    branch.position.y = length * (0.2 + Math.random() * 0.3);
                    branch.rotation.z = Math.PI / 3;
                    stickMesh.add(branch);
                }
            }
            
            stick.updateMatrixWorld(true);
            const stickBox = new THREE.Box3().setFromObject(stick);
            stick.position.set(x, -stickBox.min.y - 0.05, z);
            stick.userData.type = 'stick_pickup';
            stick.userData.collectible = 'sticks';
            stick.userData.amount = 3;
            
            groundCollectibles.push(stick);
            scene.add(stick);
        }
        
        function createMushroomPickup(x, z) {
            const mushroom = new THREE.Group();
            
            // Stem with texture
            const stemGeo = new THREE.CylinderGeometry(0.08, 0.06, 0.15, 12);
            const stemMat = new THREE.MeshStandardMaterial({ 
                color: 0xF5DEB3,
                roughness: 0.8,
                metalness: 0
            });
            const stem = new THREE.Mesh(stemGeo, stemMat);
            stem.position.y = 0.075;
            stem.castShadow = true;
            mushroom.add(stem);
            
            // Stem rings for detail
            for (let i = 0; i < 2; i++) {
                const ringGeo = new THREE.TorusGeometry(0.07, 0.01, 8, 12);
                const ring = new THREE.Mesh(ringGeo, stemMat);
                ring.rotation.x = Math.PI / 2;
                ring.position.y = 0.05 + i * 0.05;
                mushroom.add(ring);
            }
            
            // Cap with better shape
            const capGeo = new THREE.SphereGeometry(0.12, 16, 16, 0, Math.PI * 2, 0, Math.PI * 0.7);
            const capMat = new THREE.MeshStandardMaterial({ 
                color: 0xDC143C,
                roughness: 0.7,
                metalness: 0
            });
            const cap = new THREE.Mesh(capGeo, capMat);
            cap.scale.y = 0.6;
            cap.position.y = 0.18;
            cap.castShadow = true;
            mushroom.add(cap);
            
            // Gills under cap
            const gillsGeo = new THREE.CylinderGeometry(0.11, 0.11, 0.02, 16);
            const gillsMat = new THREE.MeshStandardMaterial({ 
                color: 0xFFE4C4,
                roughness: 0.9
            });
            const gills = new THREE.Mesh(gillsGeo, gillsMat);
            gills.position.y = 0.17;
            mushroom.add(gills);
            
            // White spots with better distribution
            for (let i = 0; i < 5; i++) {
                const spotSize = 0.02 + Math.random() * 0.015;
                const spotGeo = new THREE.SphereGeometry(spotSize, 8, 8);
                const spotMat = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF,
                    roughness: 0.6
                });
                const spot = new THREE.Mesh(spotGeo, spotMat);
                const angle = Math.random() * Math.PI * 2;
                const radius = 0.06 + Math.random() * 0.04;
                spot.position.set(
                    Math.cos(angle) * radius,
                    0.2 + Math.random() * 0.02,
                    Math.sin(angle) * radius
                );
                mushroom.add(spot);
            }
            
            mushroom.position.set(x, -0.03, z);
            mushroom.userData.type = 'mushroom_pickup';
            mushroom.userData.collectible = 'mushroom';
            mushroom.userData.amount = 2;
            
            groundCollectibles.push(mushroom);
            scene.add(mushroom);
        }
        
        async function createSmallRockPickup(x, z) {
            // Await GLB load so the model is always used instead of procedural fallback
            await _loadAssetGLB('Rockpile.glb');
            if (_assetGLBCache['Rockpile.glb']) {
                const inst = _instantiateGLB('Rockpile.glb', 0.4);
                if (inst) {
                    inst.position.set(x, inst.position.y, z);
                    inst.rotation.y = Math.random() * Math.PI * 2;
                    inst.userData.type = 'rock_pickup';
                    inst.userData.collectible = 'stone';
                    inst.userData.amount = 2;
                    groundCollectibles.push(inst);
                    scene.add(inst);
                    return;
                }
            }
            // Procedural fallback (only if GLB truly unavailable)

            // Procedural fallback
            const rock = new THREE.Group();
            
            // Main rock with better detail
            const rockGeo = new THREE.IcosahedronGeometry(0.12, 0);
            const rockMat = await createStoneMaterial(0x8A8A8A, 0.95);
            rockMat.flatShading = true;
            
            const rockMesh = new THREE.Mesh(rockGeo, rockMat);
            rockMesh.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            rockMesh.castShadow = true;
            rock.add(rockMesh);
            
            // Add 1-2 smaller pebbles nearby
            const numPebbles = 1 + Math.floor(Math.random() * 2);
            for (let i = 0; i < numPebbles; i++) {
                const pebbleSize = 0.04 + Math.random() * 0.04;
                const pebbleGeo = new THREE.DodecahedronGeometry(pebbleSize, 0);
                const pebble = new THREE.Mesh(pebbleGeo, rockMat);
                const angle = Math.random() * Math.PI * 2;
                const dist = 0.15 + Math.random() * 0.1;
                pebble.position.set(
                    Math.cos(angle) * dist,
                    pebbleSize * 0.3,
                    Math.sin(angle) * dist
                );
                pebble.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                pebble.castShadow = true;
                rock.add(pebble);
            }
            
            rock.updateMatrixWorld(true);
            const pickupBox = new THREE.Box3().setFromObject(rock);
            rock.position.set(x, -pickupBox.min.y - 0.05, z);
            rock.userData.type = 'rock_pickup';
            rock.userData.collectible = 'stone';
            rock.userData.amount = 2;
            
            groundCollectibles.push(rock);
            scene.add(rock);
        }
        
        // Generate ground collectibles
        for (let i = 0; i < 30; i++) {
            const x = (Math.random() - 0.5) * 180;
            const z = (Math.random() - 0.5) * 180;
            if (Math.sqrt(x * x + z * z) > 10) {
                createStickPickup(x, z);
            }
        }
        
        for (let i = 0; i < 20; i++) {
            const x = (Math.random() - 0.5) * 180;
            const z = (Math.random() - 0.5) * 180;
            if (Math.sqrt(x * x + z * z) > 10) {
                createMushroomPickup(x, z);
            }
        }
        
        const _sharedMatCache = new Map();

        async function createWoodMaterial(baseColor = 0x8B4513, roughness = 0.85) {
            const matKey = `wood_mat_${baseColor}_${roughness}`;
            if (_sharedMatCache.has(matKey)) return _sharedMatCache.get(matKey);
            const cacheId = `wood_${baseColor}_${roughness}`;
            let canvas = await textureCache.loadTexture(cacheId);
            if (!canvas) {
                textureCache.cacheStats.generated++;
                canvas = document.createElement('canvas');
                canvas.width = 256; canvas.height = 256;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = `#${baseColor.toString(16).padStart(6,'0')}`;
                ctx.fillRect(0,0,256,256);
                for (let i=0;i<30;i++) {
                    const y = Math.random()*256;
                    ctx.strokeStyle=`rgba(0,0,0,${0.1+Math.random()*0.15})`;
                    ctx.lineWidth=1+Math.random()*2; ctx.beginPath(); ctx.moveTo(0,y);
                    ctx.bezierCurveTo(64,y+(Math.random()-0.5)*10,192,y+(Math.random()-0.5)*10,256,y); ctx.stroke();
                }
                for (let i=0;i<3;i++) {
                    ctx.fillStyle=`rgba(0,0,0,0.2)`; ctx.beginPath();
                    ctx.ellipse(Math.random()*256,Math.random()*256,5+Math.random()*10,3+Math.random()*6,Math.random()*Math.PI,0,Math.PI*2); ctx.fill();
                }
                await textureCache.saveTexture(cacheId, canvas);
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.encoding = THREE.sRGBEncoding;
            const mat = new THREE.MeshStandardMaterial({ map:texture, roughness, metalness:0.01, envMapIntensity:0.15 });
            _sharedMatCache.set(matKey, mat); return mat;
        }

        async function createStoneMaterial(baseColor = 0x808080, roughness = 0.95) {
            const matKey = `stone_mat_${baseColor}_${roughness}`;
            if (_sharedMatCache.has(matKey)) return _sharedMatCache.get(matKey);
            const cacheId = `stone_${baseColor}_${roughness}`;
            let canvas = await textureCache.loadTexture(cacheId);
            if (!canvas) {
                textureCache.cacheStats.generated++;
                canvas = document.createElement('canvas');
                canvas.width = 256; canvas.height = 256;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle=`#${baseColor.toString(16).padStart(6,'0')}`; ctx.fillRect(0,0,256,256);
                for (let i=0;i<1000;i++) {
                    const a=0.1+Math.random()*0.2;
                    ctx.fillStyle=Math.random()>0.5?`rgba(0,0,0,${a})`:`rgba(255,255,255,${a*0.5})`;
                    ctx.fillRect(Math.random()*256,Math.random()*256,Math.random()*3,Math.random()*3);
                }
                for (let i=0;i<5;i++) {
                    ctx.strokeStyle=`rgba(0,0,0,0.3)`; ctx.lineWidth=1; ctx.beginPath();
                    ctx.moveTo(Math.random()*256,Math.random()*256);
                    for (let j=0;j<3;j++) ctx.lineTo(Math.random()*256,Math.random()*256);
                    ctx.stroke();
                }
                await textureCache.saveTexture(cacheId, canvas);
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.encoding = THREE.sRGBEncoding;
            const mat = new THREE.MeshStandardMaterial({ map:texture, roughness, metalness:0.08, envMapIntensity:0.2 });
            _sharedMatCache.set(matKey, mat); return mat;
        }

        async function createMetalMaterial(baseColor = 0x888888, roughness = 0.4) {
            const matKey = `metal_mat_${baseColor}_${roughness}`;
            if (_sharedMatCache.has(matKey)) return _sharedMatCache.get(matKey);
            const cacheId = `metal_${baseColor}_${roughness}`;
            let canvas = await textureCache.loadTexture(cacheId);
            if (!canvas) {
                textureCache.cacheStats.generated++;
                canvas = document.createElement('canvas');
                canvas.width = 256; canvas.height = 256;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle=`#${baseColor.toString(16).padStart(6,'0')}`; ctx.fillRect(0,0,256,256);
                for (let i=0;i<100;i++) {
                    const y=Math.random()*256; const a=0.1+Math.random()*0.1;
                    ctx.strokeStyle=Math.random()>0.5?`rgba(255,255,255,${a})`:`rgba(0,0,0,${a})`;
                    ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(0,y);
                    ctx.lineTo(256,y+(Math.random()-0.5)*2); ctx.stroke();
                }
                await textureCache.saveTexture(cacheId, canvas);
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.encoding = THREE.sRGBEncoding;
            const mat = new THREE.MeshStandardMaterial({ map:texture, roughness, metalness:0.15, envMapIntensity:0.3 });
            _sharedMatCache.set(matKey, mat); return mat;
        }

        async function createFabricMaterial(baseColor = 0xFFFFFF, roughness = 0.9) {
            const matKey = `fabric_mat_${baseColor}_${roughness}`;
            if (_sharedMatCache.has(matKey)) return _sharedMatCache.get(matKey);
            const cacheId = `fabric_${baseColor}_${roughness}`;
            let canvas = await textureCache.loadTexture(cacheId);
            if (!canvas) {
                textureCache.cacheStats.generated++;
                canvas = document.createElement('canvas');
                canvas.width = 128; canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle=`#${baseColor.toString(16).padStart(6,'0')}`; ctx.fillRect(0,0,128,128);
                const gs=4;
                for (let x=0;x<128;x+=gs) for (let y=0;y<128;y+=gs) {
                    ctx.fillStyle=((x/gs+y/gs)%2===0)?`rgba(0,0,0,0.1)`:`rgba(255,255,255,0.05)`;
                    ctx.fillRect(x,y,gs,gs);
                }
                await textureCache.saveTexture(cacheId, canvas);
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4,4);
            const mat = new THREE.MeshStandardMaterial({ map:texture, roughness, metalness:0 });
            _sharedMatCache.set(matKey, mat); return mat;
        }

                // ===== ENEMIES — Ghost Skull GLB =====
        const enemies = [];

        const _GHOST_SKULL_URL = 'https://jam110uk.github.io/Crust-Sounds/Ghost%20Skull.glb';
        let _ghostTemplate    = null;
        let _ghostAnimClips   = {};
        let _ghostLoadPromise = null;

        function _loadGhostModel() {
            if (_ghostLoadPromise) return _ghostLoadPromise;
            _ghostLoadPromise = new Promise(resolve => {
                _glbLoadersReady().then(ok => {
                    if (!ok || typeof THREE.GLTFLoader === 'undefined') {
                        console.error('👻 GLTFLoader not available'); resolve([]); return;
                    }
                    const url = new URL(_GHOST_SKULL_URL, window.location.href).href;
                    console.log('👻 Fetching Ghost Skull.glb from:', url);
                    fetch(url)
                        .then(r => {
                            console.log('👻 Fetch:', r.status, r.ok);
                            if (!r.ok) throw new Error('HTTP ' + r.status);
                            return r.arrayBuffer();
                        })
                        .then(buffer => {
                            console.log('👻 Parsing', buffer.byteLength, 'bytes...');
                            _getGLTFLoader().parse(buffer, '',
                                function onLoad(gltf) {
                                    _ghostTemplate = gltf.scene;
                                    const box = new THREE.Box3().setFromObject(_ghostTemplate);
                                    const size = new THREE.Vector3(); box.getSize(size);
                                    _ghostTemplate.userData._rawSize = size.clone();
                                    gltf.animations.forEach(clip => {
                                        _ghostAnimClips[clip.name.toLowerCase()] = clip;
                                    });
                                    console.log('👻 Ghost Skull loaded! size:', size.x.toFixed(2), size.y.toFixed(2), size.z.toFixed(2));
                                    console.log('👻 Animations:', Object.keys(_ghostAnimClips).join(', '));
                                    resolve(gltf.animations);
                                },
                                function onError(err) { console.error('👻 Parse failed:', err); resolve([]); }
                            );
                        })
                        .catch(err => { console.error('👻 Fetch failed:', err.message); resolve([]); });
                });
            });
            return _ghostLoadPromise;
        }

        function _pickGhostClip(keywords) {
            for (const kw of keywords) {
                for (const [k, v] of Object.entries(_ghostAnimClips)) {
                    if (k.includes(kw)) return v;
                }
            }
            const keys = Object.keys(_ghostAnimClips);
            return keys.length ? _ghostAnimClips[keys[0]] : null;
        }

        _loadGhostModel();

        function _buildGhostInstance() {
            if (!_ghostTemplate) return null;

            const model = _ghostTemplate.clone(true);

            // Rebuild skeletons (Three.js r128 clone() breaks SkinnedMesh bone refs)
            // IMPORTANT: do NOT call calculateInverses() — it overwrites the correct
            // original bind pose inverses from the GLB, causing mesh deformation.
            const boneMap = {};
            model.traverse(c => { if (c.isBone) boneMap[c.name] = c; });
            model.traverse(c => {
                if (c.isSkinnedMesh) {
                    const orig = c.skeleton;
                    const newBones = orig.bones.map(b => boneMap[b.name] || b);
                    const newSkel  = new THREE.Skeleton(newBones, orig.boneInverses);
                    c.bind(newSkel, c.bindMatrix); // bind() sets skeleton + bindMatrixInverse correctly
                }
            });

            model.traverse(c => {
                c.visible = true;
                if (c.isMesh || c.isSkinnedMesh) {
                    c.frustumCulled = false;
                    c.castShadow = true;
                    if (c.material) {
                        const mats = Array.isArray(c.material) ? c.material : [c.material];
                        mats.forEach(m => { if (typeof m.skinning !== 'undefined') m.skinning = true; });
                    }
                }
            });

            // Scale to ~1.2 units tall (imposing ghost)
            const rawSize = _ghostTemplate.userData._rawSize;
            const targetHeight = 1.2;
            const scaleFactor = rawSize && rawSize.y > 0 ? targetHeight / rawSize.y : 0.2;
            model.scale.setScalar(scaleFactor);

            // Sink to ground then lift to float height
            model.updateMatrixWorld(true);
            const b = new THREE.Box3().setFromObject(model);
            model.position.y -= b.min.y;

            const mixer = new THREE.AnimationMixer(model);
            const clips = {
                fly:      _pickGhostClip(['fly', 'float', 'hover', 'idle', 'walk']),
                headbutt: _pickGhostClip(['headbutt', 'head', 'attack', 'bite', 'charge']),
                death:    _pickGhostClip(['death', 'die', 'dead', 'fall']),
            };
            console.log('👻 Mapped clips — fly:', clips.fly?.name, 'headbutt:', clips.headbutt?.name, 'death:', clips.death?.name);

            let _active = null;
            function playAnim(name, loop = true, timeScale = 1, onFinish = null) {
                let clip = clips[name];
                if (!clip) clip = clips['fly'];
                if (!clip) return;
                const next = mixer.clipAction(clip);
                next.setLoop(loop ? THREE.LoopRepeat : THREE.LoopOnce, Infinity);
                next.clampWhenFinished = !loop;
                next.timeScale = timeScale;
                if (_active !== next) {
                    if (_active) { next.reset(); _active.crossFadeTo(next, 0.15, true); }
                    next.play();
                    _active = next;
                } else {
                    if (!next.isRunning()) { next.reset(); next.play(); }
                    next.timeScale = timeScale;
                }
                if (onFinish) {
                    const cb = (e) => { if (e.action === next) { mixer.removeEventListener('finished', cb); onFinish(); } };
                    mixer.addEventListener('finished', cb);
                }
            }

            return { model, mixer, playAnim, clips };
        }

        // Procedural fallback ghost skull (shown while GLB loads)
        function _buildProceduralGhost() {
            const grp = new THREE.Group();
            const ghostMat = new THREE.MeshPhongMaterial({ color: 0x88aaff, emissive: 0x2233aa, emissiveIntensity: 0.8, transparent: true, opacity: 0.85, shininess: 60 });
            const eyeMat   = new THREE.MeshPhongMaterial({ color: 0xff3300, emissive: 0xff2200, emissiveIntensity: 3.0 });
            const skull = new THREE.Mesh(new THREE.SphereGeometry(0.45, 10, 8), ghostMat);
            skull.scale.y = 1.15; skull.position.y = 0.5; grp.add(skull);
            [-0.18, 0.18].forEach(ex => {
                const socket = new THREE.Mesh(new THREE.SphereGeometry(0.10, 7, 6), eyeMat);
                socket.position.set(ex, 0.55, 0.35); grp.add(socket);
            });
            const jaw = new THREE.Mesh(new THREE.BoxGeometry(0.42, 0.18, 0.32), ghostMat);
            jaw.position.set(0, 0.12, 0.04); grp.add(jaw);
            for (let t = -2; t <= 2; t++) {
                const tooth = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.10, 0.05), new THREE.MeshPhongMaterial({ color: 0xddddcc }));
                tooth.position.set(t * 0.08, 0.07, 0.20); grp.add(tooth);
            }
            const wisp = new THREE.Mesh(new THREE.ConeGeometry(0.20, 0.6, 7), ghostMat);
            wisp.rotation.x = Math.PI; wisp.position.y = -0.15; grp.add(wisp);
            grp.traverse(c => { c.frustumCulled = false; });
            return grp;
        }

        function createEnemy(x, z) {
            const g = new THREE.Group();
            g.frustumCulled = false;

            // Show procedural ghost while GLB loads
            const _procFallback = _buildProceduralGhost();
            g.userData._fallbackMesh = _procFallback;
            g.add(_procFallback);

            function _attachGhost() {
                console.log('👻 _attachGhost — template:', !!_ghostTemplate);
                const inst = _buildGhostInstance();
                if (!inst) { console.warn('👻 _buildGhostInstance returned null'); return; }
                if (g.userData._fallbackMesh) { g.remove(g.userData._fallbackMesh); g.userData._fallbackMesh = null; }
                g.add(inst.model);
                g.userData.ghostModel    = inst.model;
                g.userData.ghostMixer    = inst.mixer;
                g.userData.ghostPlayAnim = inst.playAnim;
                g.userData.ghostClips    = inst.clips;
                inst.playAnim('fly', true, 1.0);
                console.log('👻 Ghost attached at', g.position.x.toFixed(1), g.position.z.toFixed(1));
            }

            if (_ghostTemplate) {
                _attachGhost();
            } else {
                _loadGhostModel().then(() => { if (g.parent) _attachGhost(); });
            }

            g.position.set(x, 0.9, z);
            g.userData.type            = 'enemy';
            g.userData.health          = 100;
            g.userData.maxHealth       = 100;
            g.userData.damage          = 10;
            g.userData.attackCooldown  = 0;
            g.userData.lastAttackTime  = 0;
            g.userData.soundTimer      = 0;
            g.userData._dying          = false;
            g.userData._deathTimer     = 0;
            g.userData._hoverBase      = 0.9;
            g.userData._hoverPhase     = Math.random() * Math.PI * 2;
            g.userData._attackAnim     = false;

            enemies.push(g);
            scene.add(g);
        }

        // Legacy skin texture kept for reference
        function makeEnemySkinTexture() {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');

            // Base – dark blood red
            ctx.fillStyle = '#6b0000';
            ctx.fillRect(0, 0, size, size);

            // Mid-layer blotchy flesh tones
            for (let i = 0; i < 180; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                const r = 6 + Math.random() * 22;
                const g = ctx.createRadialGradient(x, y, 0, x, y, r);
                const lightness = Math.random();
                if (lightness > 0.65) {
                    g.addColorStop(0, 'rgba(180,20,20,0.55)');
                    g.addColorStop(1, 'rgba(100,0,0,0)');
                } else {
                    g.addColorStop(0, 'rgba(60,0,0,0.6)');
                    g.addColorStop(1, 'rgba(60,0,0,0)');
                }
                ctx.fillStyle = g;
                ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
            }

            // Veins / cracks
            ctx.lineWidth = 1;
            for (let v = 0; v < 28; v++) {
                let vx = Math.random() * size;
                let vy = Math.random() * size;
                const segs = 6 + Math.floor(Math.random() * 8);
                const alpha = 0.3 + Math.random() * 0.4;
                ctx.strokeStyle = `rgba(20,0,0,${alpha})`;
                ctx.beginPath(); ctx.moveTo(vx, vy);
                for (let s = 0; s < segs; s++) {
                    vx += (Math.random() - 0.5) * 28;
                    vy += (Math.random() - 0.5) * 28;
                    ctx.lineTo(vx, vy);
                }
                ctx.stroke();
            }

            // Bright red veins (blood vessels)
            for (let v = 0; v < 14; v++) {
                let vx = Math.random() * size;
                let vy = Math.random() * size;
                const segs = 4 + Math.floor(Math.random() * 6);
                ctx.strokeStyle = `rgba(220,0,0,${0.25 + Math.random() * 0.3})`;
                ctx.lineWidth = 0.5 + Math.random();
                ctx.beginPath(); ctx.moveTo(vx, vy);
                for (let s = 0; s < segs; s++) {
                    vx += (Math.random() - 0.5) * 20;
                    vy += (Math.random() - 0.5) * 20;
                    ctx.lineTo(vx, vy);
                }
                ctx.stroke();
            }

            // Pustule / bump highlights
            for (let b = 0; b < 40; b++) {
                const bx = Math.random() * size;
                const by = Math.random() * size;
                const br = 2 + Math.random() * 5;
                const bg = ctx.createRadialGradient(bx - br*0.3, by - br*0.3, 0, bx, by, br);
                bg.addColorStop(0, 'rgba(220,60,60,0.7)');
                bg.addColorStop(0.5, 'rgba(140,10,10,0.4)');
                bg.addColorStop(1, 'rgba(60,0,0,0)');
                ctx.fillStyle = bg;
                ctx.beginPath(); ctx.arc(bx, by, br, 0, Math.PI * 2); ctx.fill();
            }

            // Dark crevice overlay
            for (let i = 0; i < 60; i++) {
                const cx2 = Math.random() * size;
                const cy2 = Math.random() * size;
                const cr = 3 + Math.random() * 9;
                const cg2 = ctx.createRadialGradient(cx2, cy2, 0, cx2, cy2, cr);
                cg2.addColorStop(0, 'rgba(0,0,0,0.45)');
                cg2.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = cg2;
                ctx.beginPath(); ctx.arc(cx2, cy2, cr, 0, Math.PI * 2); ctx.fill();
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(1.5, 2.5);
            return tex;
        }

        // ═══════════════════════════════════════════════════════════════
        // SCORPION ENEMY SYSTEM — Desert biome only
        // ═══════════════════════════════════════════════════════════════
        const scorpions = [];

        // Shared shiny black material for all scorpion parts
        const _scorpionMat = new THREE.MeshPhongMaterial({
            color: 0x0a0a0a,
            specular: 0x9999cc,
            shininess: 180,
            reflectivity: 1.0,
        });
        const _scorpionAccentMat = new THREE.MeshPhongMaterial({
            color: 0x111118,
            specular: 0xaaaaff,
            shininess: 220,
        });
        const _stingerMat = new THREE.MeshPhongMaterial({
            color: 0x1a0a00,
            specular: 0x66ff44,
            shininess: 200,
            emissive: 0x002200,
            emissiveIntensity: 0.4,
        });
        const _eyeMatS = new THREE.MeshPhongMaterial({
            color: 0xff4400,
            emissive: 0xff2200,
            emissiveIntensity: 2.0,
        });

        function createScorpion(x, z) {
            const g = new THREE.Group();

            // ── Main body (mesosoma) ──
            const bodyGeo = new THREE.BoxGeometry(0.28, 0.12, 0.38);
            const body = new THREE.Mesh(bodyGeo, _scorpionMat);
            body.position.set(0, 0, 0);
            body.castShadow = true;
            g.add(body);

            // Body ridge (dorsal crest)
            const ridgeGeo = new THREE.BoxGeometry(0.14, 0.06, 0.32);
            const ridge = new THREE.Mesh(ridgeGeo, _scorpionAccentMat);
            ridge.position.set(0, 0.09, 0);
            g.add(ridge);

            // ── Head (cephalothorax / prosoma) ──
            const headGeo = new THREE.BoxGeometry(0.22, 0.10, 0.18);
            const head = new THREE.Mesh(headGeo, _scorpionMat);
            head.position.set(0, 0.01, 0.26);
            head.castShadow = true;
            g.add(head);

            // Eyes — two tiny glowing red dots
            const eyeGeo = new THREE.SphereGeometry(0.022, 6, 6);
            const eyeL = new THREE.Mesh(eyeGeo, _eyeMatS);
            eyeL.position.set(-0.065, 0.07, 0.34);
            g.add(eyeL);
            const eyeR = new THREE.Mesh(eyeGeo, _eyeMatS);
            eyeR.position.set(0.065, 0.07, 0.34);
            g.add(eyeR);

            // ── Abdomen segments (metasoma base — 3 segments) ──
            const segW = [0.22, 0.18, 0.14];
            const segD = [0.10, 0.09, 0.08];
            for (let i = 0; i < 3; i++) {
                const segGeo = new THREE.BoxGeometry(segW[i], 0.11, segD[i]);
                const seg = new THREE.Mesh(segGeo, _scorpionMat);
                seg.position.set(0, 0, -(0.22 + i * 0.10));
                seg.castShadow = true;
                g.add(seg);
            }

            // ── Curved tail (5 segments bending upward then forward) ──
            // Each tail segment: smaller cylinder, rotated to form curve
            const tailData = [
                // [radius, length, posX, posY, posZ, rotX]
                [0.055, 0.12,  0,  0.05, -0.54,  -0.30],
                [0.048, 0.12,  0,  0.17, -0.60,  -0.70],
                [0.040, 0.11,  0,  0.30, -0.60,  -1.15],
                [0.033, 0.10,  0,  0.40, -0.54,  -1.55],
                [0.026, 0.09,  0,  0.47, -0.44,  -1.90],
            ];
            tailData.forEach(([r, l, px, py, pz, rx]) => {
                const tGeo = new THREE.CylinderGeometry(r * 0.85, r, l, 8);
                const tSeg = new THREE.Mesh(tGeo, _scorpionMat);
                tSeg.position.set(px, py, pz);
                tSeg.rotation.x = rx;
                tSeg.castShadow = true;
                g.add(tSeg);
            });

            // Stinger (last tail piece — curved cone with toxic glow)
            const stingerGeo = new THREE.ConeGeometry(0.022, 0.11, 7);
            const stinger = new THREE.Mesh(stingerGeo, _stingerMat);
            stinger.position.set(0, 0.50, -0.26);
            stinger.rotation.x = -2.4;  // pointing forward-down
            stinger.castShadow = true;
            g.add(stinger);

            // Stinger bulb (venom sac)
            const sacGeo = new THREE.SphereGeometry(0.035, 8, 8);
            const sac = new THREE.Mesh(sacGeo, _stingerMat);
            sac.position.set(0, 0.48, -0.30);
            g.add(sac);

            // ── Pincers (chelae) — left and right ──
            [-1, 1].forEach(side => {
                const px = side * 0.17;

                // Arm segment (merus)
                const armGeo = new THREE.BoxGeometry(0.06, 0.07, 0.16);
                const arm = new THREE.Mesh(armGeo, _scorpionMat);
                arm.position.set(px, 0.01, 0.36);
                g.add(arm);

                // Fixed finger (immovable claw)
                const fixedGeo = new THREE.BoxGeometry(0.045, 0.055, 0.13);
                const fixed = new THREE.Mesh(fixedGeo, _scorpionAccentMat);
                fixed.position.set(px + side * 0.01, 0.025, 0.47);
                g.add(fixed);

                // Moveable finger tip (dactyl)
                const dactylGeo = new THREE.BoxGeometry(0.035, 0.04, 0.10);
                const dactyl = new THREE.Mesh(dactylGeo, _scorpionMat);
                dactyl.position.set(px + side * 0.04, -0.01, 0.47);
                dactyl.rotation.z = side * 0.25;
                g.add(dactyl);

                // Claw tip spikes
                const spikeGeo = new THREE.ConeGeometry(0.012, 0.055, 5);
                const spike = new THREE.Mesh(spikeGeo, _stingerMat);
                spike.position.set(px + side * 0.02, 0.02, 0.54);
                spike.rotation.x = -Math.PI / 2;
                g.add(spike);
            });

            // ── 8 Legs (4 per side) ──
            const legPositionsZ = [-0.04, 0.04, 0.12, 0.20]; // along body
            [-1, 1].forEach(side => {
                legPositionsZ.forEach((lz, i) => {
                    // Upper leg
                    const upperGeo = new THREE.CylinderGeometry(0.018, 0.015, 0.14, 5);
                    const upper = new THREE.Mesh(upperGeo, _scorpionMat);
                    upper.rotation.z = side * (Math.PI / 2 + 0.3);
                    upper.rotation.x = 0.15;
                    upper.position.set(side * 0.22, -0.02, lz);
                    g.add(upper);

                    // Lower leg (tibia — angles down to ground)
                    const lowerGeo = new THREE.CylinderGeometry(0.014, 0.010, 0.13, 5);
                    const lower = new THREE.Mesh(lowerGeo, _scorpionAccentMat);
                    lower.rotation.z = side * (Math.PI / 2 - 0.5);
                    lower.rotation.x = 0.3;
                    lower.position.set(side * 0.32, -0.08, lz + 0.02);
                    g.add(lower);
                });
            });

            // Position scorpion close to ground
            g.position.set(x, 0.06, z);
            g.scale.set(1.4, 1.4, 1.4); // Scale up slightly for visibility

            g.userData.type       = 'scorpion';
            g.userData.health     = 25;
            g.userData.maxHealth  = 25;
            g.userData.damage     = 3;
            g.userData.lastAttackTime = 0;
            g.userData.animTime   = Math.random() * Math.PI * 2;
            g.userData.scuttleDir = new THREE.Vector3(
                (Math.random() - 0.5), 0, (Math.random() - 0.5)
            ).normalize();
            g.userData.scuttleTimer = 0;

            scene.add(g);
            scorpions.push(g);
            return g;
        }

        // ── Poison debuff state ──
        // Integrated into activeBuffs system: activeBuffs.poison
        // We need to add 'poison' to the debuff system separately since
        // it's a damage-over-time debuff not a positive buff
        let poisonDebuff = null; // { endTime, tickTimer }
        const POISON_DURATION = 30000;  // 30 seconds of poison
        const POISON_TICK_MS  = 1000;   // 1 damage per second

        function applyPoison() {
            if (poisonDebuff) {
                // Refresh duration
                poisonDebuff.endTime = Date.now() + POISON_DURATION;
            } else {
                poisonDebuff = { endTime: Date.now() + POISON_DURATION, tickTimer: Date.now() };
                showMessage('☠️ Poisoned! Losing 1 HP/sec for 30 seconds. Find an antidote or wait it out!');
            }
            updatePoisonHUD();
        }

        function tickPoison() {
            if (!poisonDebuff) return;
            const now = Date.now();
            if (now >= poisonDebuff.endTime) {
                poisonDebuff = null;
                showMessage('✅ Poison has worn off.');
                updatePoisonHUD();
                return;
            }
            if (now - poisonDebuff.tickTimer >= POISON_TICK_MS) {
                poisonDebuff.tickTimer = now;
                health = Math.max(0, health - 1);
                updateUI();
                if (health <= 0) die();
            }
            // Update HUD timer every tick
            updatePoisonHUD();
        }

        function updatePoisonHUD() {
            // Reuse buff-hud — add/remove poison indicator
            let poisonEl = document.getElementById('poison-hud-indicator');
            if (!poisonDebuff) {
                if (poisonEl) poisonEl.remove();
                return;
            }
            const hud = document.getElementById('buff-hud');
            if (!hud) return;
            if (!poisonEl) {
                poisonEl = document.createElement('div');
                poisonEl.id = 'poison-hud-indicator';
                poisonEl.className = 'buff-indicator';
                poisonEl.style.borderColor = 'rgba(80,220,40,0.7)';
                poisonEl.style.background = 'linear-gradient(135deg,rgba(10,40,5,0.95),rgba(15,50,5,0.95))';
                poisonEl.style.color = '#aaff44';
                hud.appendChild(poisonEl);
            }
            const secsLeft = Math.max(0, Math.ceil((poisonDebuff.endTime - Date.now()) / 1000));
            poisonEl.innerHTML = `☠️ Poisoned! -1 HP/sec <span class="buff-indicator-timer">${secsLeft}s</span>`;
        }

        // ── Scorpion spawning in desert biome ──
        function spawnScorpions() {
            if (!isInDesert()) return;
            if (scorpions.length >= 8) return;
            if (Math.random() > 0.003) return; // ~1 spawn attempt every ~5 seconds at 60fps

            const angle = Math.random() * Math.PI * 2;
            const dist  = 15 + Math.random() * 25;
            const sx = camera.position.x + Math.cos(angle) * dist;
            const sz = camera.position.z + Math.sin(angle) * dist;

            // Only spawn if position is actually in desert (z < -80) and NOT in snow biome
            if (sz > -80) return;
            // Block scorpions from entering snow biome territory (snow biome: x~200, z~-200)
            if (Math.abs(sx - SB_CX) < SB_SIZE / 2 + 10 && Math.abs(sz - SB_CZ) < SB_SIZE / 2 + 10) return;
            if (_isInsideBuilding(sx, sz)) return;
            createScorpion(sx, sz);
        }

        // ── Scorpion AI update ──
        function updateScorpions() {
            const now = Date.now();
            for (let i = scorpions.length - 1; i >= 0; i--) {
                const sc = scorpions[i];
                // Full 3D dist for despawn; flat XZ dist for AI/attack (scorpion is ground-level, camera is at eye height ~1.7)
                const dist     = camera.position.distanceTo(sc.position);
                const flatDist = Math.sqrt(
                    Math.pow(camera.position.x - sc.position.x, 2) +
                    Math.pow(camera.position.z - sc.position.z, 2)
                );

                // Leg scuttle animation — body bobs slightly
                sc.userData.animTime += 0.12;
                sc.position.y = 0.06 * sc.scale.y + Math.abs(Math.sin(sc.userData.animTime * 3)) * 0.012;

                // Tail sway
                const tailBob = Math.sin(sc.userData.animTime * 2) * 0.08;
                sc.rotation.z = tailBob * 0.15;

                // ── Shared stuck-check (same pattern as other animals) ──
                if (!sc.userData.stuckCheckTimer) sc.userData.stuckCheckTimer = 0;
                if (!sc.userData.stuckFrames)     sc.userData.stuckFrames     = 0;
                if (!sc.userData.stuckLastPos)    sc.userData.stuckLastPos    = sc.position.clone();
                sc.userData.stuckCheckTimer++;
                if (sc.userData.stuckCheckTimer >= 60) {
                    sc.userData.stuckCheckTimer = 0;
                    const moved = sc.position.distanceTo(sc.userData.stuckLastPos);
                    if (moved < 0.05) {
                        sc.userData.stuckFrames++;
                    } else {
                        sc.userData.stuckFrames = 0;
                    }
                    sc.userData.stuckLastPos = sc.position.clone();
                    // After 3 consecutive stuck checks (~3 seconds), brute-force an escape
                    if (sc.userData.stuckFrames >= 3) {
                        let freed = false;
                        for (let attempt = 0; attempt < 16 && !freed; attempt++) {
                            const escAngle  = Math.random() * Math.PI * 2;
                            const radius    = 0.5 + attempt * 0.3;
                            const escapePos = new THREE.Vector3(
                                sc.position.x + Math.cos(escAngle) * radius,
                                sc.position.y,
                                sc.position.z + Math.sin(escAngle) * radius
                            );
                            const eBox = new THREE.Box3(
                                new THREE.Vector3(escapePos.x - 0.2, escapePos.y - 0.15, escapePos.z - 0.2),
                                new THREE.Vector3(escapePos.x + 0.2, escapePos.y + 0.15, escapePos.z + 0.2)
                            );
                            let blocked = false;
                            for (const b of buildings) {
                                if (b.userData.isDoor && b.userData.isOpen) continue;
                                if (new THREE.Box3().setFromObject(b).intersectsBox(eBox)) { blocked = true; break; }
                            }
                            if (!blocked) {
                                sc.position.copy(escapePos);
                                sc.userData.scuttleDir.set(Math.cos(escAngle), 0, Math.sin(escAngle));
                                freed = true;
                            }
                        }
                        sc.userData.stuckFrames = 0;
                    }
                }

                // ── AI: chase when within 20 units ──
                if (flatDist < 20) {
                    const dir = new THREE.Vector3()
                        .subVectors(camera.position, sc.position);
                    dir.y = 0;
                    dir.normalize();

                    const speed = 0.022;
                    const newPos = sc.position.clone().add(dir.clone().multiplyScalar(speed));
                    newPos.y = sc.position.y;

                    // Building collision check
                    let canMove = true;
                    const scBox = new THREE.Box3(
                        new THREE.Vector3(newPos.x - 0.2, newPos.y - 0.15, newPos.z - 0.2),
                        new THREE.Vector3(newPos.x + 0.2, newPos.y + 0.15, newPos.z + 0.2)
                    );
                    for (const b of buildings) {
                        if (b.userData.isDoor && b.userData.isOpen) continue;
                        if (new THREE.Box3().setFromObject(b).intersectsBox(scBox)) {
                            canMove = false;
                            // Nudge scuttle dir to help unstick while chasing
                            sc.userData.scuttleDir.set(
                                (Math.random() - 0.5), 0, (Math.random() - 0.5)
                            ).normalize();
                            break;
                        }
                    }

                    if (canMove) {
                        sc.position.copy(newPos);
                        sc.rotation.y = Math.atan2(dir.x, dir.z);
                    }

                } else {
                    // Wander randomly in desert
                    sc.userData.scuttleTimer++;
                    if (sc.userData.scuttleTimer > 120) {
                        sc.userData.scuttleDir.set(
                            (Math.random() - 0.5), 0, (Math.random() - 0.5)
                        ).normalize();
                        sc.userData.scuttleTimer = 0;
                    }
                    const wanderPos = sc.position.clone().add(
                        sc.userData.scuttleDir.clone().multiplyScalar(0.01)
                    );
                    wanderPos.y = sc.position.y;

                    // Wander collision check — bounce off buildings immediately
                    const wBox = new THREE.Box3(
                        new THREE.Vector3(wanderPos.x - 0.2, wanderPos.y - 0.15, wanderPos.z - 0.2),
                        new THREE.Vector3(wanderPos.x + 0.2, wanderPos.y + 0.15, wanderPos.z + 0.2)
                    );
                    let wanderBlocked = false;
                    for (const b of buildings) {
                        if (b.userData.isDoor && b.userData.isOpen) continue;
                        if (new THREE.Box3().setFromObject(b).intersectsBox(wBox)) {
                            wanderBlocked = true; break;
                        }
                    }
                    if (wanderBlocked) {
                        sc.userData.scuttleDir.set(
                            (Math.random() - 0.5), 0, (Math.random() - 0.5)
                        ).normalize();
                        sc.userData.scuttleTimer = 0;
                    } else {
                        sc.position.copy(wanderPos);
                        sc.rotation.y = Math.atan2(sc.userData.scuttleDir.x, sc.userData.scuttleDir.z);
                    }
                }

                // ── Attack ──
                if (flatDist < 1.3) {
                    if (now - sc.userData.lastAttackTime > 1200) {
                        sc.userData.lastAttackTime = now;
                        playScorpionAttackSound();
                        health = Math.max(0, health - sc.userData.damage);
                        updateUI();

                        // 10% chance to poison
                        if (Math.random() < 0.10) {
                            applyPoison();
                        } else {
                            showMessage('🦂 Scorpion stings you! -3 HP');
                        }

                        if (health <= 0) die();
                    }
                }

                // ── Despawn if too far, player left desert, or scorpion entered snow biome ──
                const inSnow = Math.abs(sc.position.x - SB_CX) < SB_SIZE / 2 && Math.abs(sc.position.z - SB_CZ) < SB_SIZE / 2;
                if (dist > 80 || !isInDesert() || inSnow) {
                    scene.remove(sc);
                    scorpions.splice(i, 1);
                }
            }

            // Tick poison every frame
            tickPoison();
        }

        // ── Initial scorpion spawn (a few waiting in the desert) ──
        for (let i = 0; i < 4; i++) {
            const angle = (i / 4) * Math.PI * 2;
            const dist  = 180 + Math.random() * 20; // deep in desert
            createScorpion(Math.cos(angle) * 20, -dist / 2);
        }

        // ═══════════════════════════════════════════════════════════════
        // COYOTE ENEMY SYSTEM — Desert biome only
        // ═══════════════════════════════════════════════════════════════
        const coyotes = [];

        // ── Coyote sound assets ──
        const _coyoteHowlAudio  = new Audio('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/wolfhowl.mp3');
        _coyoteHowlAudio.preload = 'auto';
        const _coyoteGrowlAudio = new Audio('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/wolfgrowl.mp3');
        _coyoteGrowlAudio.preload = 'auto';

        // Track all live growl clips so we can silence them on player death
        const _activeCoyoteGrowlClips = [];

        function stopAllCoyoteSounds() {
            for (const clip of _activeCoyoteGrowlClips) {
                try { clip.pause(); clip.currentTime = 0; } catch(e){}
            }
            _activeCoyoteGrowlClips.length = 0;
        }

        function playCoyoteHowl(flatDist) {
            // Proximity volume: full at 5 units, silent at 40
            const proximity = Math.max(0, 1 - (flatDist - 5) / 35);
            const vol = Math.min(1, volumeSettings.enemies * 0.9 * proximity);
            if (vol < 0.01) return;
            const clip = _coyoteHowlAudio.cloneNode();
            clip.volume = vol;
            clip.play().catch(() => {});
        }

        // Growl: proximity volume + random pitch + 3s play / 3s gap cycle
        // Each coyote tracks its own growl timer in userData
        function tickCoyoteGrowl(cy, flatDist) {
            const now = Date.now();
            if (!cy.userData.growlPhase)     cy.userData.growlPhase     = 'gap';
            if (!cy.userData.growlPhaseStart) cy.userData.growlPhaseStart = now;
            if (!cy.userData.growlClip)       cy.userData.growlClip       = null;

            const elapsed = now - cy.userData.growlPhaseStart;

            if (cy.userData.growlPhase === 'gap') {
                if (elapsed >= 3000) {
                    // Start playing
                    const proximity = Math.max(0, 1 - Math.max(0, flatDist - 2) / 25);
                    const vol = Math.min(1, volumeSettings.enemies * 0.85 * proximity);
                    if (vol > 0.01) {
                        const clip = _coyoteGrowlAudio.cloneNode();
                        clip.volume = vol;
                        // Random pitch via playbackRate: 0.85 – 1.15
                        clip.playbackRate = 0.85 + Math.random() * 0.30;
                        clip.play().catch(() => {});
                        _activeCoyoteGrowlClips.push(clip);
                        cy.userData.growlClip = clip;
                    }
                    cy.userData.growlPhase     = 'playing';
                    cy.userData.growlPhaseStart = now;
                }
            } else {
                // playing phase — stop after 3s
                if (elapsed >= 3000) {
                    if (cy.userData.growlClip) {
                        try { cy.userData.growlClip.pause(); cy.userData.growlClip.currentTime = 0; } catch(e){}
                        const idx = _activeCoyoteGrowlClips.indexOf(cy.userData.growlClip);
                        if (idx !== -1) _activeCoyoteGrowlClips.splice(idx, 1);
                        cy.userData.growlClip = null;
                    }
                    cy.userData.growlPhase     = 'gap';
                    cy.userData.growlPhaseStart = now;
                }
            }
        }

        // ── Realistic coyote materials ──
        // Sandy-grey tawny fur (true coyote colouration)

        

        (async () => {
            for (let i = 0; i < 25; i++) {
                const x = (Math.random() - 0.5) * 180;
                const z = (Math.random() - 0.5) * 180;
                if (Math.sqrt(x * x + z * z) > 10) {
                    await createSmallRockPickup(x, z);
                }
            }
        })();
        
        (async () => {
            for (let i = 0; i < 30; i++) {
                let x, z, valid;
                let attempts = 0;
                do {
                    valid = true;
                    x = (Math.random() - 0.5) * 180;
                    z = (Math.random() - 0.5) * 180;
                
                    if (Math.sqrt(x * x + z * z) < 15) {
                        valid = false;
                        continue;
                    }
                    
                    for (let pos of [...treePositions, ...rockPositions]) {
                        const dist = Math.sqrt((x - pos.x) ** 2 + (z - pos.z) ** 2);
                        if (dist < 5) {
                            valid = false;
                            break;
                        }
                    }
                    attempts++;
                } while (!valid && attempts < 50);
                
                if (valid) await createBerryBush(x, z);
            }
        })();

        // ── Foliage Bushes (BushF.glb) — forest biome, harvestable for fibre ──────
        const foliageBushes = [];

        function createFoliageBush(x, z) {
            if (_assetGLBCache['BushF.glb']) {
                const targetH = 1.2 + Math.random() * 1.2;
                const inst = _instantiateGLB('BushF.glb', targetH);
                inst.position.set(x, inst.position.y - 0.25, z);
                inst.rotation.y = Math.random() * Math.PI * 2;
                inst.userData.type           = 'foliageBush';
                inst.userData.harvestable    = true;
                inst.userData.respawnAt      = 0;
                inst.traverse(c => {
                    // frustumCulled left as true (set by _glbSpawn, bounding sphere computed)
                    if (c.isMesh && c.material) {
                        c.renderOrder = 0; // Always behind held weapon (renderOrder 999)
                        const mats = Array.isArray(c.material) ? c.material : [c.material];
                        mats.forEach(m => {
                            if (!m) return;
                            // Fix depth sorting — transparent foliage must write depth
                            // and use alphaTest so flowers don't overdraw distant geometry
                            m.depthWrite = true;
                            m.depthTest  = true;
                            if (m.transparent) m.alphaTest = 0.3;
                            m.needsUpdate = true;
                        });
                    }
                });
                // frustumCulled = true inherited from _glbSpawn (bounding sphere already computed)
                foliageBushes.push(inst);
                bushPositions.push({ x, z, radius: 0.8 });
                scene.add(inst);
                return;
            }
            _loadAssetGLB('BushF.glb').then(() => { /* used on next spawn */ });

            // Procedural fallback — compact rounded green bush
            const bush = new THREE.Group();
            const bushR  = 0.45 + Math.random() * 0.3;
            const lumpCount = 3 + Math.floor(Math.random() * 3);
            const leafData = new Uint8Array(16 * 16 * 4);
            for (let i = 0; i < 16 * 16; i++) {
                const lx = (i % 16) / 16, ly = Math.floor(i / 16) / 16;
                const p = (Math.sin(lx * 8) * Math.cos(ly * 8) + 1) * 0.5;
                const g = Math.round(80 + p * 100 + Math.random() * 20);
                leafData[i*4]   = Math.round(g * 0.38);
                leafData[i*4+1] = g;
                leafData[i*4+2] = Math.round(g * 0.22);
                leafData[i*4+3] = 255;
            }
            const leafTex = new THREE.DataTexture(leafData, 16, 16, THREE.RGBAFormat);
            leafTex.needsUpdate = true;
            leafTex.wrapS = leafTex.wrapT = THREE.RepeatWrapping;
            leafTex.magFilter = THREE.NearestFilter;
            const leafMat = new THREE.MeshStandardMaterial({
                map: leafTex,
                color: new THREE.Color().setHSL(0.30 + Math.random() * 0.05, 0.70, 0.32),
                roughness: 0.9, metalness: 0
            });
            for (let l = 0; l < lumpCount; l++) {
                const r  = bushR * (0.6 + Math.random() * 0.5);
                const a  = (l / lumpCount) * Math.PI * 2 + Math.random() * 0.5;
                const ox = Math.cos(a) * bushR * 0.45;
                const oz = Math.sin(a) * bushR * 0.45;
                const oy = r * 0.55 + Math.random() * 0.1;
                const geo  = new THREE.SphereGeometry(r, 8, 7);
                const mesh = new THREE.Mesh(geo, leafMat);
                mesh.scale.set(1, 0.72, 1);
                mesh.position.set(ox, oy, oz);
                mesh.castShadow = true;
                bush.add(mesh);
            }
            bush.position.set(x, 0, z);
            bush.userData.type        = 'foliageBush';
            bush.userData.harvestable = true;
            bush.userData.respawnAt   = 0;
            bush.traverse(c => { c.frustumCulled = false; });
            bush.frustumCulled = false;

            foliageBushes.push(bush);
            bushPositions.push({ x, z, radius: 0.8 });
            scene.add(bush);
        }

        // Swap procedural foliage bushes for GLB once BushF.glb loads
        _loadAssetGLB('BushF.glb').then(tmpl => {
            if (!tmpl) { console.warn('🌿 BushF.glb failed — keeping procedural foliage bushes'); return; }
            for (let i = foliageBushes.length - 1; i >= 0; i--) {
                const old = foliageBushes[i];
                if (!old.userData.swayPhase && old.userData.type === 'foliageBush' && old.children.length > 0 && old.children[0].isMesh) {
                    // It's procedural (has direct mesh children, not a GLB group)
                    const x = old.position.x, z = old.position.z;
                    const targetH = 1.2 + Math.random() * 1.2;
                    const inst = _instantiateGLB('BushF.glb', targetH);
                    if (!inst) continue;
                    inst.position.set(x, inst.position.y - 0.25, z);
                    inst.rotation.y = Math.random() * Math.PI * 2;
                    inst.userData.type        = 'foliageBush';
                    inst.userData.harvestable = old.userData.harvestable;
                    inst.userData.respawnAt   = old.userData.respawnAt;
                    inst.traverse(c => {
                        // frustumCulled left as true (set by _glbSpawn)
                        if (c.isMesh && c.material) {
                            c.renderOrder = 0;
                            const mats = Array.isArray(c.material) ? c.material : [c.material];
                            mats.forEach(m => {
                                if (!m) return;
                                m.depthWrite = true;
                                m.depthTest  = true;
                                if (m.transparent) m.alphaTest = 0.3;
                                m.needsUpdate = true;
                            });
                        }
                    });
                    // frustumCulled = true inherited from _glbSpawn
                    scene.remove(old);
                    scene.add(inst);
                    foliageBushes[i] = inst;
                }
            }
            console.log('🌿 BushF.glb swap done');
        });

        // Spawn foliage bushes in the forest biome
        (async () => {
            for (let i = 0; i < 50; i++) {
                let x, z, valid;
                let attempts = 0;
                do {
                    valid = true;
                    x = (Math.random() - 0.5) * 175;
                    z = (Math.random() - 0.5) * 175;
                    if (Math.sqrt(x * x + z * z) < 12) { valid = false; continue; }
                    for (const pos of [...treePositions, ...rockPositions, ...bushPositions]) {
                        if (Math.sqrt((x-pos.x)**2+(z-pos.z)**2) < 4) { valid = false; break; }
                    }
                    attempts++;
                } while (!valid && attempts < 50);
                if (valid) createFoliageBush(x, z);
            }
        })();
        // ===== RIVER BIOME RESOURCE SPAWNS =====
        // All spawns use world-space coords centred at (RB_CX=200, RB_CZ=0).
        // Shared helper: returns true if (wx,wz) is safely outside the river channel.
        function _rbOutsideRiver(wx, wz) {
            // Reject if the terrain at this point is carved at all (channel + banks)
            if (rbCarveDepth(wx - RB_CX, wz - RB_CZ) > 0.05) return false;
            const lx = wx - RB_CX, lz = wz - RB_CZ;
            const lt = (lz / 200) + 0.5;
            if (lt < 0 || lt > 1) return true;
            const rcx = rbRiverCX(lt);
            return Math.sqrt((lx - rcx) ** 2 + (lz - rbRiverCZ(lt)) ** 2) >= RIVER_WIDTH / 2 + 4;
        }
        // Generic position picker for the river biome
        function _rbRandPos(margin = 8) {
            return {
                x: RB_CX + (Math.random() - 0.5) * (groundSize - margin * 2),
                z: RB_CZ + (Math.random() - 0.5) * (groundSize - margin * 2),
            };
        }
        function _rbValid(wx, wz, minDist, ...posArrays) {
            if (!_rbOutsideRiver(wx, wz)) return false;
            for (const arr of posArrays)
                for (const p of arr)
                    if (Math.sqrt((wx - p.x) ** 2 + (wz - p.z) ** 2) < minDist) return false;
            return true;
        }

        // ── Rocks (15) ──
        for (let i = 0; i < 15; i++) {
            let p, attempts = 0, ok = false;
            do { p = _rbRandPos(); ok = _rbValid(p.x, p.z, 5, treePositions, rockPositions); }
            while (!ok && ++attempts < 60);
            if (ok) createRock(p.x, p.z);
        }

        // ── Metal ore nodes (6) ──
        for (let i = 0; i < 6; i++) {
            let p, attempts = 0, ok = false;
            do { p = _rbRandPos(); ok = _rbValid(p.x, p.z, 6, treePositions, rockPositions, orePositions); }
            while (!ok && ++attempts < 60);
            if (ok) createMetalOre(p.x, p.z);
        }

        // ── Sulfur ore nodes (5) ──
        for (let i = 0; i < 5; i++) {
            let p, attempts = 0, ok = false;
            do { p = _rbRandPos(); ok = _rbValid(p.x, p.z, 6, treePositions, rockPositions, orePositions, sulfurPositions); }
            while (!ok && ++attempts < 60);
            if (ok) createSulfurOre(p.x, p.z);
        }

        // ── Stick pickups (20) ──
        for (let i = 0; i < 20; i++) {
            let p, attempts = 0, ok = false;
            do { p = _rbRandPos(4); ok = _rbValid(p.x, p.z, 2, treePositions); }
            while (!ok && ++attempts < 40);
            if (ok) createStickPickup(p.x, p.z);
        }

        // ── Small stone pickups (15) ──
        (async () => {
            for (let i = 0; i < 15; i++) {
                const p = _rbRandPos(4);
                if (_rbOutsideRiver(p.x, p.z)) await createSmallRockPickup(p.x, p.z);
            }
        })();

        // ── Foliage bushes / BushF (20) ──
        (async () => {
            for (let i = 0; i < 20; i++) {
                let p, attempts = 0, ok = false;
                do { p = _rbRandPos(); ok = _rbValid(p.x, p.z, 4, treePositions, rockPositions, bushPositions); }
                while (!ok && ++attempts < 60);
                if (ok) createFoliageBush(p.x, p.z);
            }
        })();

        // Small number of fully-grown plants — player's first source of seeds.
        // 15-minute real-time respawn after harvest.
        // ─── PLANT GLB LOADER ──────────────────────────────────────────────────────
        // Maps each seedType to its GLB filename (same host as Wolf.glb)
        const _PLANT_GLB_BASE = 'https://jam110uk.github.io/Crust-Sounds/';
        const _plantGLBFiles = {
            cabbage_seed:     'Cabbage.glb',
            wheat_seed:       'Wheat.glb',
            cucumber_seed:    'Cucumber.glb',
            pumpkin_seed:     'Pumpkin.glb',
            red_berry_seed:   'Bush with Berries.glb',
            black_berry_seed: 'Bush with Berries.glb',
            hemp_seed:        'Suspicious Plant.glb',
            tomato_seed:      'Tomato.glb',
            strawberry_seed:  'Strawberries.glb',
            mushroom_seed:    'Mushrooms.glb',
            carrot_seed:      'Carrot.glb',
            potato_seed:      'Potato.glb',
            corn_seed:        'Corn.glb',
        };

        // Cache: seedType → THREE.Object3D template (or null if load failed)
        const _plantGLBCache = {};
        // Promises so we don't double-fetch
        const _plantGLBPromises = {};

        function _loadPlantGLB(seedType) {
            if (seedType in _plantGLBCache) return Promise.resolve(_plantGLBCache[seedType]);
            if (_plantGLBPromises[seedType]) return _plantGLBPromises[seedType];
            const file = _plantGLBFiles[seedType];
            if (!file) { _plantGLBCache[seedType] = null; return Promise.resolve(null); }

            // Per-crop target height (metres, largest axis)
            const _plantTargetSize = {
                wheat_seed:       1.20,   // 0.55 × ~2.2
                corn_seed:        1.10,   // 0.52 × ~2.1
                hemp_seed:        1.05,   // 0.48 × ~2.2
                red_berry_seed:   0.14,   // 0.42 / 3
                black_berry_seed: 0.14,   // 0.42 / 3
                tomato_seed:      0.095,  // 0.38 / 4
                pumpkin_seed:     0.64,   // 0.32 × 2
                cucumber_seed:    0.30,
                potato_seed:      0.28,
                carrot_seed:      0.28,
                cabbage_seed:     0.30,
                mushroom_seed:    0.24,
                strawberry_seed:  0.22,
            };

            // _glbLoad handles fetch, parse, Draco, texture fix, mesh validation — all for free.
            // We then normalise the template size and ground it so _buildPlantGLBInstance
            // can simply clone without any further scaling.
            _plantGLBPromises[seedType] = _glbLoad(file, _PLANT_GLB_BASE).then(tmpl => {
                if (!tmpl) { _plantGLBCache[seedType] = null; return null; }
                const targetSize = _plantTargetSize[seedType] || 0.28;
                const box = new THREE.Box3().setFromObject(tmpl);
                const sz  = new THREE.Vector3(); box.getSize(sz);
                const maxDim = Math.max(sz.x, sz.y, sz.z);
                if (maxDim > 0) tmpl.scale.setScalar(targetSize / maxDim);
                tmpl.updateMatrixWorld(true);
                const b2 = new THREE.Box3().setFromObject(tmpl);
                if (isFinite(b2.min.y)) tmpl.position.y -= b2.min.y;
                const b3 = new THREE.Box3().setFromObject(tmpl);
                const h = (b3.max.y - b3.min.y).toFixed(3);
                console.log(`🌱 Plant GLB ready: ${file} @ ${targetSize}m — grounded height=${h}m (sink override: ${(_plantSoilSink||{})[seedType]??0}m)`);
                _plantGLBCache[seedType] = tmpl;
                return tmpl;
            });
            return _plantGLBPromises[seedType];
        }

        // Kick off all plant GLB loads immediately in the background
        Object.keys(_plantGLBFiles).forEach(seed => _loadPlantGLB(seed));

        // Build a stage-4 GLB instance from the cached template (deep clone).
        // The template is already normalised to the correct world size by _loadPlantGLB —
        // the `scale` param is a procedural-geometry multiplier and must NOT be reapplied.
        function _buildPlantGLBInstance(seedType, _scale) {
            const tmpl = _plantGLBCache[seedType];
            if (!tmpl) return null;
            const inst = tmpl.clone(true);
            inst.scale.copy(tmpl.scale);   // use pre-normalised scale, ignore _scale
            inst.position.copy(tmpl.position);
            inst.updateMatrixWorld(true);
            // Deep-clone materials per-instance (Three.js r128 shared-material bug)
            inst.traverse(c => {
                if (!c.isMesh) return;
                if (Array.isArray(c.material)) {
                    c.material = c.material.map(m => { const mc = m ? m.clone() : m; if (mc) mc.needsUpdate = true; return mc; });
                } else if (c.material) {
                    c.material = c.material.clone();
                    c.material.needsUpdate = true;
                }
                c.visible = true; c.frustumCulled = true; // static plant — bounding sphere computed below
                if (c.isMesh) { c.castShadow = true; c.receiveShadow = true; if (c.geometry) { c.geometry.computeBoundingBox(); c.geometry.computeBoundingSphere(); } }
            });
            _fixGLBTextures(inst);
            return inst;
        }

        (function spawnWildPlants() {
            const WILD_SEED_TYPES = [
                'pumpkin_seed','wheat_seed','cabbage_seed','cucumber_seed',
                'potato_seed','carrot_seed','hemp_seed','corn_seed','mushroom_seed',
                'red_berry_seed','black_berry_seed','strawberry_seed','tomato_seed'
            ];
            // 1–2 plants per type scattered in the forest (z > 0 = forest side)
            const perType = 2;
            WILD_SEED_TYPES.forEach(seedType => {
                for (let i = 0; i < perType; i++) {
                    let x, z, attempts = 0, valid = false;
                    do {
                        x = (Math.random() - 0.5) * 160;
                        z = 10 + Math.random() * 70; // forest side only
                        // Not too close to spawn
                        if (Math.sqrt(x*x + z*z) < 18) continue;
                        valid = true;
                        for (const pos of [...treePositions, ...rockPositions, ...bushPositions]) {
                            if (Math.sqrt((x-pos.x)**2+(z-pos.z)**2) < 4) { valid = false; break; }
                        }
                        attempts++;
                    } while (!valid && attempts < 80);
                    if (!valid) continue;

                    const _wsc={wheat_seed:7.5,corn_seed:6.8,hemp_seed:6.5,red_berry_seed:1.2,black_berry_seed:1.2,tomato_seed:0.625,pumpkin_seed:5.0,cucumber_seed:2.5,potato_seed:2.5,carrot_seed:2.5,cabbage_seed:2.5,mushroom_seed:2.5,strawberry_seed:2.5};
                    const plant = buildPlantModel(seedType, 4, _wsc[seedType] || 2.5);
                    const _wSink = ({carrot_seed:0.18, potato_seed:0.10, strawberry_seed:0.04})[seedType] || 0;
                    plant.position.set(x, plant.position.y - _wSink, z);
                    plant.rotation.y = Math.random() * Math.PI * 2;
                    plant.userData.isWildPlant = true;
                    plant.userData.seedType = seedType;
                    plant.userData.harvestable = true;
                    plant.userData.respawnAt = 0;
                    scene.add(plant);
                    wildPlants.push(plant);
                }
            });
        })();
        // Bleached driftwood sticks and sandstone pebbles scattered across the desert
        (async () => {
            const dMargin  = 8;
            const dCenterZ = -desertOffset + 0.5;
            const dHalf    = groundSize / 2 - dMargin;
            const dXMin    = -groundSize / 2 + dMargin;
            const dXMax    =  groundSize / 2 - dMargin;
            const dZMin    = dCenterZ - dHalf;
            const dZMax    = dCenterZ + dHalf - 15;

            function randDesertPos() {
                return {
                    x: dXMin + Math.random() * (dXMax - dXMin),
                    z: dZMin + Math.random() * (dZMax - dZMin),
                };
            }

            function tooCloseToFormation(x, z, minDist) {
                for (const p of desertFormationPositions) {
                    if (Math.sqrt((x - p.x) ** 2 + (z - p.z) ** 2) < minDist) return true;
                }
                for (const c of desertFormationColliders) {
                    if (Math.sqrt((x - c.x) ** 2 + (z - c.z) ** 2) < c.r + 1) return true;
                }
                return false;
            }

            // ── Desert sticks: GLB-first, bleached procedural fallback ──
            async function createDesertStickPickup(x, z) {
                await _loadAssetGLB('Stick.glb');
                if (_assetGLBCache['Stick.glb']) {
                    const inst = _instantiateGLB('Stick.glb', 0.5);
                    if (inst) {
                        inst.position.set(x, inst.position.y, z);
                        inst.rotation.y = Math.random() * Math.PI * 2;
                        // Tint to bleached desert driftwood — pale tan/amber
                        inst.traverse(c => {
                            if (c.isMesh && c.material) {
                                const mats = Array.isArray(c.material) ? c.material : [c.material];
                                mats.forEach(m => { if (m) { m.color.multiply(new THREE.Color(0.88, 0.76, 0.54)); m.needsUpdate = true; } });
                            }
                        });
                        inst.userData.type = 'stick_pickup';
                        inst.userData.collectible = 'sticks';
                        inst.userData.amount = 3;
                        groundCollectibles.push(inst);
                        scene.add(inst);
                        return;
                    }
                }
                // Procedural fallback — bleached pale desert wood
                const stick = new THREE.Group();
                const numSticks = 2 + Math.floor(Math.random() * 2);
                for (let i = 0; i < numSticks; i++) {
                    const length = 0.32 + Math.random() * 0.18;
                    const thickness = 0.013 + Math.random() * 0.009;
                    const geo = new THREE.CylinderGeometry(thickness, thickness * 0.7, length, 5);
                    const mat = new THREE.MeshStandardMaterial({ color: 0xc4a97a, roughness: 0.95, metalness: 0 });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.rotation.z = Math.random() * Math.PI;
                    mesh.rotation.x = Math.random() * 0.4;
                    mesh.rotation.y = (i / numSticks) * Math.PI * 0.6;
                    mesh.position.x += (Math.random() - 0.5) * 0.06;
                    mesh.position.z += (Math.random() - 0.5) * 0.06;
                    mesh.castShadow = true;
                    stick.add(mesh);
                }
                stick.updateMatrixWorld(true);
                const box = new THREE.Box3().setFromObject(stick);
                stick.position.set(x, -box.min.y - 0.04, z);
                stick.userData.type = 'stick_pickup';
                stick.userData.collectible = 'sticks';
                stick.userData.amount = 3;
                groundCollectibles.push(stick);
                scene.add(stick);
            }

            // ── Desert pebbles: GLB-first, sandstone procedural fallback ──
            async function createDesertRockPickup(x, z) {
                if (_assetGLBCache['Rockpile.glb']) {
                    const inst = _instantiateGLB('Rockpile.glb', 0.4);
                    if (inst) {
                        inst.position.set(x, inst.position.y, z);
                        inst.rotation.y = Math.random() * Math.PI * 2;
                        // Tint to warm sandstone — golden amber with slight red-brown
                        inst.traverse(c => {
                            if (c.isMesh && c.material) {
                                const mats = Array.isArray(c.material) ? c.material : [c.material];
                                mats.forEach(m => { if (m) { m.color.multiply(new THREE.Color(0.82, 0.66, 0.42)); m.needsUpdate = true; } });
                            }
                        });
                        inst.userData.type = 'rock_pickup';
                        inst.userData.collectible = 'stone';
                        inst.userData.amount = 2;
                        groundCollectibles.push(inst);
                        scene.add(inst);
                        return;
                    }
                }
                // Procedural fallback — warm sandstone tone
                const rock = new THREE.Group();
                const geo  = new THREE.IcosahedronGeometry(0.11, 0);
                const mat  = await createStoneMaterial(0xb09060, 0.96);
                mat.flatShading = true;
                const mesh = new THREE.Mesh(geo, mat);
                mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                mesh.castShadow = true;
                rock.add(mesh);
                const numPebbles = 1 + Math.floor(Math.random() * 2);
                for (let i = 0; i < numPebbles; i++) {
                    const ps = 0.04 + Math.random() * 0.035;
                    const pg = new THREE.DodecahedronGeometry(ps, 0);
                    const pm = new THREE.Mesh(pg, mat);
                    const a  = Math.random() * Math.PI * 2;
                    pm.position.set(Math.cos(a) * 0.14, ps * 0.3, Math.sin(a) * 0.14);
                    pm.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    pm.castShadow = true;
                    rock.add(pm);
                }
                rock.updateMatrixWorld(true);
                const box = new THREE.Box3().setFromObject(rock);
                rock.position.set(x, -box.min.y - 0.04, z);
                rock.userData.type = 'rock_pickup';
                rock.userData.collectible = 'stone';
                rock.userData.amount = 2;
                groundCollectibles.push(rock);
                scene.add(rock);
            }

            // Spawn 40 stick pickups across the desert
            let placed = [];
            for (let i = 0; i < 40; i++) {
                let pos, tries = 0, ok = false;
                do {
                    pos = randDesertPos();
                    ok = !tooCloseToFormation(pos.x, pos.z, 4);
                    if (ok) for (const p of placed) {
                        if (Math.sqrt((pos.x-p.x)**2+(pos.z-p.z)**2) < 2.5) { ok=false; break; }
                    }
                    tries++;
                } while (!ok && tries < 60);
                if (ok) { createDesertStickPickup(pos.x, pos.z); placed.push(pos); }
            }

            // Spawn 35 stone pickups across the desert
            placed = [];
            for (let i = 0; i < 35; i++) {
                let pos, tries = 0, ok = false;
                do {
                    pos = randDesertPos();
                    ok = !tooCloseToFormation(pos.x, pos.z, 4);
                    if (ok) for (const p of placed) {
                        if (Math.sqrt((pos.x-p.x)**2+(pos.z-p.z)**2) < 2.5) { ok=false; break; }
                    }
                    tries++;
                } while (!ok && tries < 60);
                if (ok) { await createDesertRockPickup(pos.x, pos.z); placed.push(pos); }
            }
        })();
        const grassBlades = [];

        // One shared material for all grass ? avoids per-blade material switching
        const sharedGrassMat = new THREE.MeshStandardMaterial({
            color: new THREE.Color().setHSL(0.27, 0.42, 0.22),
            side: THREE.DoubleSide,
            roughness: 0.98,
            metalness: 0,
            vertexColors: true,
        });

        // River biome grass — same as sharedGrassMat, night darkening via emissive
        const riverGrassMat = new THREE.MeshStandardMaterial({
            color: new THREE.Color().setHSL(0.27, 0.42, 0.22),
            side: THREE.DoubleSide,
            roughness: 0.98,
            metalness: 0,
            vertexColors: true,
        });

        for (let i = 0; i < 200; i++) { // 200 clusters (was 400) ? merged geo looks just as dense
            const x = (Math.random() - 0.5) * 180;
            const z = (Math.random() - 0.5) * 180;
            if (Math.sqrt(x * x + z * z) < 10) continue;

            const numBlades = 4 + Math.floor(Math.random() * 3); // 4?6 blades

            // Accumulate geometry data for all blades in this cluster
            const allPos = [], allNorm = [], allUV = [], allCol = [], allIdx = [];
            let vertOffset = 0;

            for (let b = 0; b < numBlades; b++) {
                const bladeHeight = 0.8 + Math.random() * 0.4;
                const bladeWidth  = 0.08 + Math.random() * 0.04;
                const bx = (Math.random() - 0.5) * 0.15;
                const bz = (Math.random() - 0.5) * 0.15;
                const ry = Math.random() * Math.PI * 2;
                const cosR = Math.cos(ry), sinR = Math.sin(ry);

                // PlaneGeometry 1?4 segments: 2 cols ? 5 rows = 10 verts
                const segsY = 4;
                const cols  = 2, rows = segsY + 1; // 2 ? 5

                // Colour variation per blade \ufffd muted naturalistic palette
                // Mix of dark green, mid green, yellow-green and occasional straw
                const palettes = [
                    { h: 0.28, sMin: 0.35, sMax: 0.55, lMin: 0.14, lMax: 0.24 }, // dark rich green
                    { h: 0.27, sMin: 0.30, sMax: 0.50, lMin: 0.20, lMax: 0.32 }, // mid green
                    { h: 0.24, sMin: 0.25, sMax: 0.45, lMin: 0.25, lMax: 0.38 }, // yellow-green
                    { h: 0.20, sMin: 0.20, sMax: 0.35, lMin: 0.30, lMax: 0.42 }, // dry straw-green
                ];
                const pal = palettes[Math.floor(Math.random() * palettes.length)];
                const hue  = pal.h + (Math.random() - 0.5) * 0.04;
                const sat  = pal.sMin + Math.random() * (pal.sMax - pal.sMin);
                const lit  = pal.lMin + Math.random() * (pal.lMax - pal.lMin);
                const col  = new THREE.Color().setHSL(hue, sat, lit);

                for (let row = 0; row < rows; row++) {
                    for (let col2 = 0; col2 < cols; col2++) {
                        const u = col2 / (cols - 1);         // 0 or 1
                        const v = row  / (rows - 1);         // 0..1 bottom to top
                        const lx = (u - 0.5) * bladeWidth;
                        const ly = v * bladeHeight - bladeHeight * 0.5;

                        // Bend: tip bends forward
                        const bendFactor = ((v + 0.5) ** 2);
                        const bendX = bendFactor * (0.1 + Math.random() * 0.05);

                        // Rotate blade around Y by ry, then offset to bx/bz
                        const wx = cosR * (lx + bendX) - sinR * 0 + bx;
                        const wz = sinR * (lx + bendX) + cosR * 0 + bz;

                        allPos.push(wx, ly + bladeHeight * 0.5, wz);
                        allNorm.push(0, 1, 0); // normals recomputed below
                        allUV.push(u, v);
                        allCol.push(col.r, col.g, col.b);
                    }
                }

                // Two quads per row segment
                for (let row = 0; row < segsY; row++) {
                    const a = vertOffset + row * cols;
                    const b = a + 1, c = a + cols, d = c + 1;
                    allIdx.push(a, c, b,  b, c, d);
                }
                vertOffset += rows * cols;
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position',  new THREE.Float32BufferAttribute(allPos,  3));
            geo.setAttribute('normal',    new THREE.Float32BufferAttribute(allNorm, 3));
            geo.setAttribute('uv',        new THREE.Float32BufferAttribute(allUV,   2));
            geo.setAttribute('color',     new THREE.Float32BufferAttribute(allCol,  3));
            geo.setIndex(allIdx);
            geo.computeVertexNormals();

            const grassCluster = new THREE.Mesh(geo, sharedGrassMat);
            grassCluster.position.set(x, 0, z);
            grassCluster.castShadow   = false;
            grassCluster.receiveShadow = false;
            grassCluster.userData.windSpeed = 0.8 + Math.random() * 0.4;
            grassCluster.userData.windPhase = Math.random() * Math.PI * 2;
            grassCluster.userData.type = 'grass';

            grassBlades.push(grassCluster);
            scene.add(grassCluster);
        }
        
        // ===== RIVER BIOME — WILD PLANTS & GRASS =====
        // Plants concentrated near the river, a few scattered elsewhere.
        // Grass clusters denser near banks, thinner away from water.
        {
            const WILD_SEED_TYPES = [
                'pumpkin_seed','wheat_seed','cabbage_seed','cucumber_seed',
                'potato_seed','carrot_seed','hemp_seed','corn_seed','mushroom_seed',
                'red_berry_seed','black_berry_seed','strawberry_seed','tomato_seed'
            ];
            const _wsc = {
                wheat_seed:7.5, corn_seed:6.8, hemp_seed:6.5,
                red_berry_seed:1.2, black_berry_seed:1.2, tomato_seed:0.625,
                pumpkin_seed:5.0, cucumber_seed:2.5, potato_seed:2.5,
                carrot_seed:2.5, cabbage_seed:2.5, mushroom_seed:2.5, strawberry_seed:2.5
            };
            const _wSink = { carrot_seed:0.18, potato_seed:0.10, strawberry_seed:0.04 };

            // Helper: distance from world pos to river centreline (biome-local)
            function _distToRiver(wx, wz) {
                const lx = wx - RB_CX, lz = wz - RB_CZ;
                const lt = Math.max(0, Math.min(1, (lz / 200) + 0.5));
                const rcx = rbRiverCX(lt), rcz = rbRiverCZ(lt);
                return Math.sqrt((lx - rcx) ** 2 + (lz - rcz) ** 2);
            }

            // ── Wild plants near the river (4 per type = 52 total) ──────────────
            // Spawn within RIVER_WIDTH*1.8 of the centreline on valid ground
            WILD_SEED_TYPES.forEach(seedType => {
                for (let i = 0; i < 4; i++) {
                    let wx, wz, attempts = 0, valid = false;
                    do {
                        // Pick a random point along the river then offset perpendicular
                        const t   = 0.05 + Math.random() * 0.90;
                        const cx  = rbRiverCX(t) + RB_CX;
                        const cz  = rbRiverCZ(t) + RB_CZ;
                        const txv = rbRiverTX(t);
                        const tl  = Math.sqrt(txv * txv + 1);
                        const px  =  1 / tl, pz = -txv / tl;
                        // Offset 8–22 units from centreline (just outside the water)
                        const side = Math.random() < 0.5 ? 1 : -1;
                        const off  = (RIVER_WIDTH / 2 + 2 + Math.random() * 14) * side;
                        wx = cx + px * off;
                        wz = cz + pz * off;
                        if (Math.abs(wx - RB_CX) > 95 || Math.abs(wz - RB_CZ) > 95) continue;
                        // Reject if on carved bank/channel
                        if (rbCarveDepth(wx - RB_CX, wz - RB_CZ) > 0.05) continue;
                        valid = true;
                        for (const pos of [...treePositions, ...rockPositions, ...bushPositions])
                            if (Math.sqrt((wx-pos.x)**2+(wz-pos.z)**2) < 3) { valid = false; break; }
                        attempts++;
                    } while (!valid && attempts < 80);
                    if (!valid) continue;

                    const plant = buildPlantModel(seedType, 4, _wsc[seedType] || 2.5);
                    plant.position.set(wx, plant.position.y - (_wSink[seedType] || 0), wz);
                    plant.rotation.y = Math.random() * Math.PI * 2;
                    plant.userData.isWildPlant  = true;
                    plant.userData.seedType     = seedType;
                    plant.userData.harvestable  = true;
                    plant.userData.respawnAt    = 0;
                    scene.add(plant);
                    wildPlants.push(plant);
                }
            });

            // ── Wild plants scattered elsewhere in biome (1 per type = 13 total) ──
            WILD_SEED_TYPES.forEach(seedType => {
                let wx, wz, attempts = 0, valid = false;
                do {
                    wx = RB_CX + (Math.random() - 0.5) * 170;
                    wz = RB_CZ + (Math.random() - 0.5) * 170;
                    if (!_rbOutsideRiver(wx, wz)) continue;
                    if (_distToRiver(wx, wz) < RIVER_WIDTH) continue; // skip near-river (already covered)
                    valid = true;
                    for (const pos of [...treePositions, ...rockPositions, ...bushPositions])
                        if (Math.sqrt((wx-pos.x)**2+(wz-pos.z)**2) < 3) { valid = false; break; }
                    attempts++;
                } while (!valid && attempts < 60);
                if (!valid) return;

                const plant = buildPlantModel(seedType, 4, _wsc[seedType] || 2.5);
                plant.position.set(wx, plant.position.y - (_wSink[seedType] || 0), wz);
                plant.rotation.y = Math.random() * Math.PI * 2;
                plant.userData.isWildPlant  = true;
                plant.userData.seedType     = seedType;
                plant.userData.harvestable  = true;
                plant.userData.respawnAt    = 0;
                scene.add(plant);
                wildPlants.push(plant);
            });

            // ── Grass clusters ────────────────────────────────────────────────────
            // Lush riverbank grass: 180 dense clusters near the river
            // Sparse field grass:    80 clusters spread across the rest of the biome
            // Uses same shared material and geometry pattern as the forest grass.

            // Slightly lusher green palette for river biome
            const rbGrassPalettes = [
                { h: 0.30, sMin: 0.50, sMax: 0.70, lMin: 0.16, lMax: 0.28 }, // deep river green
                { h: 0.28, sMin: 0.45, sMax: 0.65, lMin: 0.20, lMax: 0.32 }, // mid green
                { h: 0.26, sMin: 0.35, sMax: 0.55, lMin: 0.24, lMax: 0.36 }, // yellow-green
                { h: 0.31, sMin: 0.40, sMax: 0.60, lMin: 0.18, lMax: 0.30 }, // mossy green
            ];

            function _spawnRBGrassCluster(wx, wz) {
                const numBlades = 4 + Math.floor(Math.random() * 4); // 4–7 blades, lusher
                const allPos = [], allNorm = [], allUV = [], allCol = [], allIdx = [];
                let vertOffset = 0;
                for (let b = 0; b < numBlades; b++) {
                    const bladeHeight = 0.7 + Math.random() * 0.6; // slightly taller
                    const bladeWidth  = 0.07 + Math.random() * 0.05;
                    const bx = (Math.random() - 0.5) * 0.18;
                    const bz = (Math.random() - 0.5) * 0.18;
                    const ry = Math.random() * Math.PI * 2;
                    const cosR = Math.cos(ry), sinR = Math.sin(ry);
                    const segsY = 4, cols = 2, rows = segsY + 1;
                    const pal = rbGrassPalettes[Math.floor(Math.random() * rbGrassPalettes.length)];
                    const col = new THREE.Color().setHSL(
                        pal.h + (Math.random() - 0.5) * 0.03,
                        pal.sMin + Math.random() * (pal.sMax - pal.sMin),
                        pal.lMin + Math.random() * (pal.lMax - pal.lMin)
                    );
                    for (let row = 0; row < rows; row++) {
                        for (let c2 = 0; c2 < cols; c2++) {
                            const u  = c2 / (cols - 1);
                            const v  = row / (rows - 1);
                            const lx = (u - 0.5) * bladeWidth;
                            const ly = v * bladeHeight - bladeHeight * 0.5;
                            const bf = ((v + 0.5) ** 2);
                            const bndX = bf * (0.1 + Math.random() * 0.06);
                            const wxx = cosR * (lx + bndX) - sinR * 0 + bx;
                            const wzz = sinR * (lx + bndX) + cosR * 0 + bz;
                            allPos.push(wxx, ly + bladeHeight * 0.5, wzz);
                            allNorm.push(0, 1, 0);
                            allUV.push(u, v);
                            allCol.push(col.r, col.g, col.b);
                        }
                    }
                    for (let row = 0; row < segsY; row++) {
                        const a = vertOffset + row * cols;
                        const b = a + 1, c = a + cols, d = c + 1;
                        allIdx.push(a, c, b,  b, c, d);
                    }
                    vertOffset += rows * cols;
                }
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.Float32BufferAttribute(allPos,  3));
                geo.setAttribute('normal',   new THREE.Float32BufferAttribute(allNorm, 3));
                geo.setAttribute('uv',       new THREE.Float32BufferAttribute(allUV,   2));
                geo.setAttribute('color',    new THREE.Float32BufferAttribute(allCol,  3));
                geo.setIndex(allIdx);
                geo.computeVertexNormals();
                const cluster = new THREE.Mesh(geo, riverGrassMat);
                cluster.position.set(wx, 0, wz);
                cluster.castShadow    = false;
                cluster.receiveShadow = false;
                cluster.userData.windSpeed = 0.8 + Math.random() * 0.4;
                cluster.userData.windPhase = Math.random() * Math.PI * 2;
                cluster.userData.type = 'grass';
                grassBlades.push(cluster);
                scene.add(cluster);
            }

            // Dense riverbank grass (180 clusters within 5–28 units of centreline)
            for (let i = 0; i < 180; i++) {
                const t   = 0.02 + Math.random() * 0.96;
                const cx  = rbRiverCX(t) + RB_CX;
                const cz  = rbRiverCZ(t) + RB_CZ;
                const txv = rbRiverTX(t);
                const tl  = Math.sqrt(txv * txv + 1);
                const px  =  1 / tl, pz = -txv / tl;
                const side = Math.random() < 0.5 ? 1 : -1;
                // Start offset just past the carved bank edge
                const off  = (RIVER_WIDTH / 2 + 1 + Math.random() * 18) * side;
                const wx = cx + px * off;
                const wz = cz + pz * off;
                if (Math.abs(wx - RB_CX) > 98 || Math.abs(wz - RB_CZ) > 98) continue;
                // Skip if terrain is carved here (still on bank slope or in water)
                if (rbCarveDepth(wx - RB_CX, wz - RB_CZ) > 0.05) continue;
                _spawnRBGrassCluster(wx, wz);
            }

            // Sparse field grass across rest of biome (80 clusters)
            for (let i = 0; i < 80; i++) {
                const wx = RB_CX + (Math.random() - 0.5) * 185;
                const wz = RB_CZ + (Math.random() - 0.5) * 185;
                if (!_rbOutsideRiver(wx, wz)) continue;
                if (Math.abs(wx - RB_CX) > 98 || Math.abs(wz - RB_CZ) > 98) continue;
                _spawnRBGrassCluster(wx, wz);
            }
        }

        // ===== ANIMALS (Exactly like original with bunny ears and toe beans) =====
        window.animals = [];
        
        function createAnimal(x, z) {
            const animalGroup = new THREE.Group();

            // ── Procedural fur texture ──
            const furCanvas = document.createElement('canvas');
            furCanvas.width = 128; furCanvas.height = 128;
            const fCtx = furCanvas.getContext('2d');
            fCtx.fillStyle = '#8B5E3C';
            fCtx.fillRect(0, 0, 128, 128);
            for (let i = 0; i < 600; i++) {
                const fx = Math.random() * 128, fy = Math.random() * 128;
                const len = 4 + Math.random() * 10;
                const ang = Math.PI * 0.5 + (Math.random() - 0.5) * 0.7;
                fCtx.strokeStyle = Math.random() > 0.5
                    ? `rgba(${55+Math.random()*30|0},${32+Math.random()*18|0},${8+Math.random()*10|0},${0.20+Math.random()*0.25})`
                    : `rgba(${175+Math.random()*45|0},${125+Math.random()*35|0},${65+Math.random()*30|0},${0.14+Math.random()*0.20})`;
                fCtx.lineWidth = 0.4 + Math.random() * 1.2;
                fCtx.beginPath();
                fCtx.moveTo(fx, fy);
                fCtx.lineTo(fx + Math.cos(ang)*len, fy + Math.sin(ang)*len);
                fCtx.stroke();
            }
            const furTex = new THREE.CanvasTexture(furCanvas);
            furTex.wrapS = furTex.wrapT = THREE.RepeatWrapping;
            furTex.repeat.set(3, 2);

            // ── Materials ──
            const furMat   = new THREE.MeshStandardMaterial({ map: furTex, roughness: 0.97, metalness: 0.0 });
            const earOutMat= new THREE.MeshStandardMaterial({ map: furTex, roughness: 0.97, metalness: 0.0 });
            const earInMat = new THREE.MeshStandardMaterial({ color: 0xf5ede0, roughness: 0.95, metalness: 0.0 });
            const eyeMat   = new THREE.MeshStandardMaterial({ color: 0x1a0d00, roughness: 0.3, metalness: 0.1 });
            const eyeShine = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1 });
            const beanMat  = new THREE.MeshStandardMaterial({ color: 0xffb6c1, roughness: 0.9 });

            // ── Body — original boxy shape ──
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 1.2), furMat);
            body.castShadow = true;
            animalGroup.add(body);

            // ── Head — boxy too, matches body style ──
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.38, 0.42), furMat);
            head.position.set(0, 0.12, 0.72);
            head.castShadow = true;
            animalGroup.add(head);
            animalGroup.userData.head = head;

            // Eyes
            [-0.14, 0.14].forEach(sx => {
                const eye = new THREE.Mesh(new THREE.SphereGeometry(0.040, 8, 7), eyeMat);
                eye.position.set(sx, 0.055, 0.19);
                head.add(eye);
                const glint = new THREE.Mesh(new THREE.SphereGeometry(0.013, 5, 5), eyeShine);
                glint.position.set(sx * 0.18, 0.014, 0.036);
                eye.add(glint);
            });

            // ── 4 Realistic deer-style ears ──
            // Large triangular cones (4-sided) with white inner face, splayed naturally
            const earDefs = [
                { pos: [-0.18, 0.24,  0.06], rotZ:  0.38, rotX: -0.10 },
                { pos: [ 0.18, 0.24,  0.06], rotZ: -0.38, rotX: -0.10 },
                { pos: [-0.14, 0.22, -0.10], rotZ:  0.25, rotX:  0.20 },
                { pos: [ 0.14, 0.22, -0.10], rotZ: -0.25, rotX:  0.20 },
            ];
            earDefs.forEach(({ pos, rotZ, rotX }) => {
                const earGroup = new THREE.Group();
                earGroup.position.set(...pos);
                earGroup.rotation.z = rotZ;
                earGroup.rotation.x = rotX;
                // Outer ear — fur texture, triangular cone
                const outer = new THREE.Mesh(new THREE.ConeGeometry(0.10, 0.32, 4, 1), earOutMat);
                outer.castShadow = true;
                earGroup.add(outer);
                // White inner face — slightly smaller, inset forward
                const inner = new THREE.Mesh(new THREE.ConeGeometry(0.065, 0.24, 4, 1), earInMat);
                inner.position.set(0, 0.006, 0.016);
                earGroup.add(inner);
                head.add(earGroup);
            });

            // ── Paw beans — kept from original ──
            const beanGeo = new THREE.SphereGeometry(0.06, 8, 8);
            [[-0.25, 0.5], [0.25, 0.5], [-0.25, -0.4], [0.25, -0.4]].forEach(([bx, bz]) => {
                const bean = new THREE.Mesh(beanGeo, beanMat);
                bean.position.set(bx, -0.25, bz);
                bean.scale.y = 0.6;
                animalGroup.add(bean);
            });

            // ── Placement & metadata ──
            animalGroup.position.set(x, 0.3, z);
            animalGroup.userData.health    = 50;
            animalGroup.userData.type      = 'animal';
            animalGroup.userData.velocity  = new THREE.Vector3(
                (Math.random() - 0.5) * 0.02, 0, (Math.random() - 0.5) * 0.02
            );
            animalGroup.userData.soundTimer = Math.random() * 30;
            animalGroup.userData.animTime   = Math.random() * Math.PI * 2;

            window.animals.push(animalGroup);
            scene.add(animalGroup);
        }
        
        for (let i = 0; i < 40; i++) {
            const x = (Math.random() - 0.5) * 160;
            const z = (Math.random() - 0.5) * 160;
            if (Math.sqrt(x * x + z * z) > 20) {
                createAnimal(x, z);
            }
        }
        
        // ===== SQUIRRELS =====
        window.squirrels = [];

        const _SQUIRREL_URL = 'https://jam110uk.github.io/Crust-Sounds/squirril.glb';
        let _squirrelTemplate   = null;
        let _squirrelAnimClips  = {};
        let _squirrelLoadPromise = null;

        function _loadSquirrelModel() {
            if (_squirrelLoadPromise) return _squirrelLoadPromise;
            _squirrelLoadPromise = new Promise(resolve => {
                _glbLoadersReady().then(ok => {
                    if (!ok || typeof THREE.GLTFLoader === 'undefined') {
                        console.error('🐿️ GLTFLoader not available');
                        resolve([]); return;
                    }
                    const url = new URL(_SQUIRREL_URL, window.location.href).href;
                    console.log('🐿️ Fetching squirril.glb from:', url);
                    fetch(url)
                        .then(r => {
                            console.log('🐿️ Fetch response:', r.status, r.statusText, 'ok:', r.ok);
                            if (!r.ok) throw new Error('HTTP ' + r.status);
                            return r.arrayBuffer();
                        })
                        .then(buffer => {
                            console.log('🐿️ Got buffer:', buffer.byteLength, 'bytes — parsing...');
                            _getGLTFLoader().parse(buffer, '',
                                function onLoad(gltf) {
                                    console.log('🐿️ squirril.glb parsed! Animations:', gltf.animations.length);
                                    _squirrelTemplate = gltf.scene;
                                    let meshCount = 0, skinnedCount = 0, boneCount = 0;
                                    _squirrelTemplate.traverse(c => {
                                        if (c.isMesh) meshCount++;
                                        if (c.isSkinnedMesh) skinnedCount++;
                                        if (c.isBone) boneCount++;
                                    });
                                    console.log('🐿️ Scene contents — meshes:', meshCount, 'skinnedMeshes:', skinnedCount, 'bones:', boneCount);
                                    const box = new THREE.Box3().setFromObject(_squirrelTemplate);
                                    const size = new THREE.Vector3(); box.getSize(size);
                                    _squirrelTemplate.userData._rawSize = size.clone();
                                    console.log('🐿️ Raw size:', size.x.toFixed(2), size.y.toFixed(2), size.z.toFixed(2));
                                    gltf.animations.forEach(clip => {
                                        _squirrelAnimClips[clip.name.toLowerCase()] = clip;
                                    });
                                    console.log('🐿️ Animations:', Object.keys(_squirrelAnimClips).join(', '));
                                    resolve(gltf.animations);
                                },
                                function onError(err) { console.error('🐿️ Parse failed:', err); resolve([]); }
                            );
                        })
                        .catch(err => { console.error('🐿️ Fetch failed:', err.message); resolve([]); });
                });
            });
            return _squirrelLoadPromise;
        }

        function _pickSquirrelClip(keywords) {
            for (const kw of keywords) {
                for (const [k, v] of Object.entries(_squirrelAnimClips)) {
                    if (k.includes(kw)) return v;
                }
            }
            const keys = Object.keys(_squirrelAnimClips);
            return keys.length ? _squirrelAnimClips[keys[0]] : null;
        }

        // Kick off load immediately
        _loadSquirrelModel();

        // Procedural fallback squirrel — shown when GLB isn't loaded yet
        function _buildProceduralSquirrel() {
            const grp = new THREE.Group();
            const fur  = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 });
            const dark = new THREE.MeshStandardMaterial({ color: 0x5C2E00, roughness: 0.9 });
            const eye  = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.3 });
            // Body
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.30, 0.55), fur);
            body.position.y = 0.28;
            grp.add(body);
            // Head
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.24, 0.22, 0.24), fur);
            head.position.set(0, 0.53, 0.22);
            grp.add(head);
            // Ears
            [-0.08, 0.08].forEach(ex => {
                const ear = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.14, 4), fur);
                ear.position.set(ex, 0.68, 0.22);
                grp.add(ear);
            });
            // Eyes
            [-0.07, 0.07].forEach(ex => {
                const e = new THREE.Mesh(new THREE.SphereGeometry(0.025, 6, 6), eye);
                e.position.set(ex, 0.55, 0.33);
                grp.add(e);
            });
            // Bushy tail (arched back)
            const tail = new THREE.Mesh(new THREE.SphereGeometry(0.18, 8, 6), dark);
            tail.scale.set(0.7, 1.2, 0.7);
            tail.position.set(0, 0.55, -0.30);
            grp.add(tail);
            // Legs
            [[-0.12, -0.30], [0.12, -0.30], [-0.10, 0.18], [0.10, 0.18]].forEach(([lx, lz]) => {
                const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.03, 0.20, 6), fur);
                leg.position.set(lx, 0.10, lz);
                grp.add(leg);
            });
            grp.traverse(c => { c.frustumCulled = false; if (c.isMesh) c.castShadow = true; });
            return grp;
        }

        function _buildSquirrelInstance() {
            if (!_squirrelTemplate) return null;

            // Three.js r128 clone() breaks SkinnedMesh bone refs.
            // Instead: clone the scene graph, then rebuild skeleton from scratch.
            const model = _squirrelTemplate.clone(true);

            // Collect cloned bones by name
            const boneMap = {};
            model.traverse(c => { if (c.isBone) boneMap[c.name] = c; });

            model.traverse(c => {
                if (c.isSkinnedMesh) {
                    const origSkeleton = c.skeleton;
                    const newBones = origSkeleton.bones.map(b => boneMap[b.name] || b);
                    const newSkeleton = new THREE.Skeleton(newBones, origSkeleton.boneInverses);
                    c.bind(newSkeleton, c.bindMatrix);
                }
            });

            model.traverse(c => {
                c.visible = true;
                if (c.isMesh || c.isSkinnedMesh) {
                    c.frustumCulled = false;
                    c.castShadow = true;
                    if (c.material) {
                        const mats = Array.isArray(c.material) ? c.material : [c.material];
                        mats.forEach(m => { if (typeof m.skinning !== 'undefined') m.skinning = true; });
                    }
                }
            });

            // Scale to 1/2 of coyote size (0.85 / 2 ≈ 0.42 units tall)
            const rawSize = _squirrelTemplate.userData._rawSize;
            const targetHeight = 0.85 / 2;
            const scaleFactor = rawSize && rawSize.y > 0 ? targetHeight / rawSize.y : 0.08;
            model.scale.setScalar(scaleFactor);

            // Sink feet to ground after scaling
            model.updateMatrixWorld(true);
            const b = new THREE.Box3().setFromObject(model);
            model.position.y -= b.min.y;

            // Face forward
            model.rotation.y = 0;

            const mixer = new THREE.AnimationMixer(model);
            const clips = {
                idle: _pickSquirrelClip(['idle', 'stand']),
                walk: _pickSquirrelClip(['walk', 'sneak', 'move']),
                run:  _pickSquirrelClip(['run', 'sprint', 'gallop']),
                sit:  _pickSquirrelClip(['sit', 'rest', 'pause', 'look']),
            };

            let _active = null;
            function playAnim(name, loop = true, timeScale = 1) {
                let clip = clips[name];
                if (!clip) clip = clips['walk'];
                if (!clip) clip = clips['idle'];
                if (!clip) return;
                const next = mixer.clipAction(clip);
                next.setLoop(loop ? THREE.LoopRepeat : THREE.LoopOnce, Infinity);
                next.clampWhenFinished = !loop;
                next.timeScale = timeScale;
                if (_active !== next) {
                    if (_active) { next.reset(); _active.crossFadeTo(next, 0.2, true); }
                    next.play();
                    _active = next;
                } else {
                    if (!next.isRunning()) { next.reset(); next.play(); }
                    next.timeScale = timeScale;
                }
            }

            return { model, mixer, playAnim };
        }

        function createSquirrel(x, z) {
            const g = new THREE.Group();
            g.frustumCulled = false;

            // Show procedural fallback immediately while GLB loads
            const _procFallback = _buildProceduralSquirrel();
            _procFallback.name = '_squirrelProcFallback';
            g.userData._fallbackMesh = _procFallback;
            g.add(_procFallback);

            function _attachSquirrel() {
                console.log('🐿️ _attachSquirrel called — template:', !!_squirrelTemplate);
                const inst = _buildSquirrelInstance();
                if (!inst) {
                    console.warn('🐿️ _buildSquirrelInstance returned null — GLB may have failed to load. Check fetch logs above.');
                    return;
                }
                // Remove both debug fallbacks once GLB is ready
                if (g.userData._fallbackMesh) { g.remove(g.userData._fallbackMesh); g.userData._fallbackMesh = null; }
                let meshCount = 0;
                inst.model.traverse(c => { if (c.isMesh || c.isSkinnedMesh) meshCount++; });
                console.log('🐿️ GLB model attached — mesh count:', meshCount, '| pos:', g.position.x.toFixed(1), g.position.z.toFixed(1));
                g.add(inst.model);
                g.userData.sqModel    = inst.model;
                g.userData.sqMixer    = inst.mixer;
                g.userData.sqPlayAnim = inst.playAnim;
                inst.playAnim('idle');
            }

            if (_squirrelTemplate) {
                _attachSquirrel();
            } else {
                _loadSquirrelModel().then(() => { if (g.parent) _attachSquirrel(); });
            }

            g.position.set(x, 0, z);
            g.userData.type         = 'squirrel';
            g.userData.health       = 20;
            g.userData.maxHealth    = 20;
            g.userData.velocity     = new THREE.Vector3((Math.random()-0.5)*0.03, 0, (Math.random()-0.5)*0.03);
            g.userData.soundTimer   = Math.random() * 2;
            g.userData.animTime     = Math.random() * Math.PI * 2;
            g.userData.state        = 'wander'; // 'wander' | 'sit'
            g.userData.sitTimer     = 0;
            g.userData.sitDuration  = 0;
            g.userData.wanderTimer  = Math.random() * 3;
            g.userData.stuckFrames  = 0;

            window.squirrels.push(g);
            scene.add(g);
        }
        
        for (let i = 0; i < 10; i++) {
            const x = (Math.random() - 0.5) * 160;
            const z = (Math.random() - 0.5) * 160;
            if (Math.sqrt(x * x + z * z) > 20) {
                createSquirrel(x, z);
            }
        }

        // River biome squirrels — spawned here so _squirrelTemplate is already declared
        for (let i = 0; i < 6; i++) {
            let p, attempts = 0, ok = false;
            do { p = _rbRandPos(); ok = _rbOutsideRiver(p.x, p.z); }
            while (!ok && ++attempts < 40);
            if (ok) createSquirrel(p.x, p.z);
        }
        
        // ===== MATERIAL HELPER FUNCTIONS =====
        // Create wood material with grain detail (CACHED VERSION)
        // In-memory material object cache — same params = same object = shader compiled once

        // ===== WOLF GLB MODEL + ANIMATION SYSTEM =====
        // Wolf.glb — use relative path since it's in the same repo as index.html
        // If this fails, check Wolf.glb is committed & pushed to the same GitHub repo
        const _WOLF_BASE = 'https://jam110uk.github.io/Crust-Sounds/Wolf.glb';
        const _WOLF_PROXY = null;
        let _WOLF_URL = _WOLF_BASE;
        console.log('🐺 Game origin:', window.location.href);
        let _wolfTemplate   = null;
        let _wolfAnimClips  = {};
        let _wolfLoadPromise = null;
        const _wolfClock    = new THREE.Clock(); // for mixer delta

        function _loadWolfModel() {
            if (_wolfLoadPromise) return _wolfLoadPromise;
            _wolfLoadPromise = new Promise(resolve => {
                _glbLoadersReady().then(ok => {
                    if (!ok || typeof THREE.GLTFLoader === 'undefined') {
                        console.error('🐺 GLTFLoader not available');
                        resolve([]);
                        return;
                    }
                    const _wolfFullURL = new URL(_WOLF_URL, window.location.href).href;
                    console.log('🐺 Fetching Wolf.glb from:', _wolfFullURL);
                    fetch(_wolfFullURL)
                        .then(r => {
                            console.log('🐺 Fetch status:', r.status, r.statusText);
                            if (!r.ok) throw new Error('HTTP ' + r.status);
                            return r.arrayBuffer();
                        })
                        .then(buffer => {
                            console.log('🐺 Got buffer:', buffer.byteLength, 'bytes — parsing...');
                            _getGLTFLoader().parse(buffer, '',
                                function onLoad(gltf) {
                                    console.log('🐺 Wolf.glb loaded successfully!');
                                    _wolfTemplate = gltf.scene;
                                    // template not added to scene, so no need to hide it

                                    // Measure raw size and store for use in _buildWolfInstance
                                    const box = new THREE.Box3().setFromObject(_wolfTemplate);
                                    const size = new THREE.Vector3();
                                    box.getSize(size);
                                    _wolfTemplate.userData._rawSize = size.clone();
                                    console.log('🐺 Raw size:', size.x.toFixed(2), size.y.toFixed(2), size.z.toFixed(2));

                                    // Store animations
                                    gltf.animations.forEach(clip => {
                                        _wolfAnimClips[clip.name.toLowerCase()] = clip;
                                    });
                                    console.log('🐺 Animations:', gltf.animations.length, Object.keys(_wolfAnimClips).join(', '));
                                    resolve(gltf.animations);
                                },
                                function onError(err) {
                                    console.error('🐺 GLTFLoader.parse failed:', err);
                                    resolve([]);
                                }
                            );
                        })
                        .catch(err => {
                            console.error('🐺 Fetch failed:', err.message);
                            resolve([]);
                        });
                });
            });
            return _wolfLoadPromise;
        }

        function _pickClip(keywords) {
            for (const kw of keywords) {
                for (const [k, v] of Object.entries(_wolfAnimClips)) {
                    if (k.includes(kw)) return v;
                }
            }
            const keys = Object.keys(_wolfAnimClips);
            return keys.length ? _wolfAnimClips[keys[0]] : null;
        }

        // Kick off load immediately
        _loadWolfModel();

        function _buildWolfInstance() {
            if (!_wolfTemplate) return null;

            // Three.js r128 clone() breaks SkinnedMesh bone refs.
            // Instead: clone the scene graph, then rebuild skeleton from scratch.
            const model = _wolfTemplate.clone(true);

            // Collect cloned bones by name
            const boneMap = {};
            model.traverse(c => { if (c.isBone) boneMap[c.name] = c; });

            model.traverse(c => {
                if (c.isSkinnedMesh) {
                    const origSkeleton = c.skeleton;
                    const newBones = origSkeleton.bones.map(b => boneMap[b.name] || b);
                    const newSkeleton = new THREE.Skeleton(newBones, origSkeleton.boneInverses);
                    c.bind(newSkeleton, c.bindMatrix);
                }
            });

            // Apply scale: raw size is 1.15 x 3.62 x 5.28 — Y is height, scale to 0.85 units tall
            const rawSize = _wolfTemplate.userData._rawSize;
            if (rawSize) {
                const scale = rawSize.y > 0 ? 0.85 / rawSize.y : 0.161;
                model.scale.setScalar(scale);
            } else {
                model.scale.setScalar(0.161);
            }

            // Sink feet to ground after scaling
            model.updateMatrixWorld(true);
            const b = new THREE.Box3().setFromObject(model);
            model.position.y -= b.min.y;

            // Face forward
            model.rotation.y = 0;

            // Preserve the GLB's own materials — do NOT override with a flat colour.
            // Just make sure every mesh is visible, casts shadows, and has skinning enabled.
            model.traverse(c => {
                c.visible = true;
                if (c.isMesh || c.isSkinnedMesh) {
                    c.frustumCulled = false;
                    c.castShadow    = true;
                    if (c.material) {
                        const mats = Array.isArray(c.material) ? c.material : [c.material];
                        mats.forEach(m => { if (typeof m.skinning !== 'undefined') m.skinning = true; });
                    }
                }
            });

            const mixer = new THREE.AnimationMixer(model);
            const clips = {
                idle:   _pickClip(['idle']),
                walk:   _pickClip(['walk', 'sneak']),
                trot:   _pickClip(['trot', 'walk', 'sneak']),  // trot → walk if no trot clip
                run:    _pickClip(['run']),
                attack: _pickClip(['bite', 'attack']),
                howl:   _pickClip(['howl', 'bark']),
            };

            let _active = null;
            function playAnim(name, loop = true, timeScale = 1) {
                // Resolve the clip; fall back to walk, then idle
                let clip = clips[name];
                if (!clip) clip = clips['walk'];
                if (!clip) clip = clips['idle'];
                if (!clip) return;
                const next = mixer.clipAction(clip);
                next.setLoop(loop ? THREE.LoopRepeat : THREE.LoopOnce, Infinity);
                next.clampWhenFinished = !loop;
                next.timeScale = timeScale;
                if (_active !== next) {
                    // Switching animation — crossfade from old to new
                    if (_active) {
                        next.reset();
                        _active.crossFadeTo(next, 0.15, true);
                    }
                    next.play();
                    _active = next;
                } else {
                    // Same animation — make sure it hasn't stalled (e.g. after a LoopOnce finished)
                    if (!next.isRunning()) {
                        next.reset();
                        next.play();
                    }
                    next.timeScale = timeScale;
                }
            }

            return { model, mixer, playAnim };
        }


        const _coyFurMat    = new THREE.MeshPhongMaterial({ color: 0x9e7b4a, specular: 0x1a0d00, shininess: 14 });
        // Pale cream underbelly / muzzle
        const _coyBellyMat  = new THREE.MeshPhongMaterial({ color: 0xe8d4a8, specular: 0x110800, shininess: 8  });
        // Dark charcoal back saddle, leg tips, ear backs
        const _coyDarkMat   = new THREE.MeshPhongMaterial({ color: 0x3d2a10, specular: 0x110800, shininess: 10 });
        // Black nose / claws
        const _coyNoseMat   = new THREE.MeshPhongMaterial({ color: 0x100c08, shininess: 70 });
        // Glowing amber-yellow predator eyes
        const _coyEyeMat    = new THREE.MeshPhongMaterial({ color: 0xf0b000, emissive: 0xb06000, emissiveIntensity: 1.2, shininess: 180 });
        // Rusty-orange leg fur (coyote legs are often more orange)
        const _coyLegMat    = new THREE.MeshPhongMaterial({ color: 0xb5642a, specular: 0x1a0d00, shininess: 12 });
        // Pink inner ear
        const _coyEarInMat  = new THREE.MeshPhongMaterial({ color: 0xe88080, shininess: 6 });
        // Tail tip white
        const _coyTailTipMat= new THREE.MeshPhongMaterial({ color: 0xf0ead8, shininess: 6 });

        function createCoyote(x, z) {
            const g = new THREE.Group();

            function _attachWolf() {
                console.log('🐺 _attachWolf called, _wolfTemplate:', !!_wolfTemplate);
                const inst = _buildWolfInstance();
                if (!inst) { console.warn('🐺 _buildWolfInstance returned null'); return; }
                if (g.userData._fallbackMesh) {
                    g.remove(g.userData._fallbackMesh);
                    g.userData._fallbackMesh = null;
                }
                g.add(inst.model);
                g.userData.wolfModel    = inst.model;
                g.userData.wolfMixer    = inst.mixer;
                g.userData.wolfPlayAnim = inst.playAnim;
                inst.playAnim('idle');
                let meshCount = 0, skinnedCount = 0;
                inst.model.traverse(c => {
                    if (c.isSkinnedMesh) skinnedCount++;
                    else if (c.isMesh) meshCount++;
                });
                console.log('🐺 Wolf attached | Mesh:', meshCount, 'SkinnedMesh:', skinnedCount, '| pos:', g.position.x.toFixed(1), g.position.z.toFixed(1));
            }

            if (_wolfTemplate) {
                _attachWolf();
            } else {
                _loadWolfModel().then(() => {
                    console.log('🐺 .then fired, _wolfTemplate:', !!_wolfTemplate, 'g.parent:', !!g.parent);
                    if (g.parent) _attachWolf();
                });
            }

            g.userData.legs = [];
            g.position.set(x, 0, z);
            g.userData.type            = 'coyote';
            g.userData.health          = 60;
            g.userData.maxHealth       = 60;
            g.userData.damage          = 8;
            g.userData.state           = 'wander';
            g.userData.animTime        = Math.random() * Math.PI * 2;
            g.userData.wanderDir       = new THREE.Vector3((Math.random()-0.5), 0, (Math.random()-0.5)).normalize();
            g.userData.wanderTimer     = 0;
            g.userData.lastAttackTime  = 0;
            g.userData.howlTimer       = 0;
            g.userData.howlPlayed      = false;
            g.userData.backoffTimer    = 0;
            g.userData.circleAngle     = Math.random() * Math.PI * 2;
            g.userData.circleDir       = Math.random() < 0.5 ? 1 : -1;
            g.userData.circleTimer     = 0;
            g.userData.biteTimer       = 0;
            g.userData.growlPhase      = 'gap';
            g.userData.growlPhaseStart = Date.now() + Math.random() * 3000;
            g.userData.growlClip       = null;
            g.userData.stuckCheckTimer = 0;
            g.userData.stuckFrames     = 0;
            g.userData.stuckLastPos    = g.position.clone();
            g.userData.coyoteId        = Date.now() + Math.random();

            scene.add(g);
            coyotes.push(g);
            return g;
        }

        // Helper: try to move a coyote to newPos, checking buildings + other coyotes
        function _coyoteTryMove(cy, newPos) {
            const box = new THREE.Box3(
                new THREE.Vector3(newPos.x - 0.28, newPos.y - 0.35, newPos.z - 0.28),
                new THREE.Vector3(newPos.x + 0.28, newPos.y + 0.35, newPos.z + 0.28)
            );
            // Building collision
            for (const b of buildings) {
                if (b.userData.isDoor && b.userData.isOpen) continue;
                if (new THREE.Box3().setFromObject(b).intersectsBox(box)) return false;
            }
            // Inter-coyote separation — push apart if overlapping
            for (const other of coyotes) {
                if (other === cy) continue;
                const sep = newPos.distanceTo(other.position);
                if (sep < 0.80) return false; // personal space radius
            }
            return true;
        }

        // ── Coyote spawning ──
        function spawnCoyotes() {
            if (!isInDesert()) return;
            if (coyotes.length >= 4) return;
            if (Math.random() > 0.002) return;

            const angle = Math.random() * Math.PI * 2;
            const spawnDist = 20 + Math.random() * 30;
            const sx = camera.position.x + Math.cos(angle) * spawnDist;
            const sz = camera.position.z + Math.sin(angle) * spawnDist;
            if (sz > -80) return;
            // Block coyotes from spawning in snow biome territory
            if (Math.abs(sx - SB_CX) < SB_SIZE / 2 + 10 && Math.abs(sz - SB_CZ) < SB_SIZE / 2 + 10) return;
            if (_isInsideBuilding(sx, sz)) return;
            createCoyote(sx, sz);
        }

        // ── Coyote AI update ──
        function _tickWolfMixer(cy) {
            if (!cy.userData.wolfMixer) return;
            const now = performance.now();
            if (!cy.userData._mixerLast) cy.userData._mixerLast = now;
            const dt = Math.min((now - cy.userData._mixerLast) / 1000, 0.1);
            cy.userData._mixerLast = now;
            cy.userData.wolfMixer.update(dt);
        }

        function updateCoyotes() {
            const now = Date.now();

            for (let i = coyotes.length - 1; i >= 0; i--) {
                const cy = coyotes[i];

                const flatDist = Math.sqrt(
                    (camera.position.x - cy.position.x) ** 2 +
                    (camera.position.z - cy.position.z) ** 2
                );
                const dist3d = camera.position.distanceTo(cy.position);

                // ── Stuck check ──
                cy.userData.stuckCheckTimer++;
                if (cy.userData.stuckCheckTimer >= 60) {
                    cy.userData.stuckCheckTimer = 0;
                    const moved = cy.position.distanceTo(cy.userData.stuckLastPos);
                    cy.userData.stuckFrames = moved < 0.05 ? cy.userData.stuckFrames + 1 : 0;
                    cy.userData.stuckLastPos = cy.position.clone();
                    if (cy.userData.stuckFrames >= 3) {
                        let freed = false;
                        for (let a = 0; a < 16 && !freed; a++) {
                            const ea  = Math.random() * Math.PI * 2;
                            const er  = 0.5 + a * 0.3;
                            const ep  = new THREE.Vector3(cy.position.x + Math.cos(ea)*er, cy.position.y, cy.position.z + Math.sin(ea)*er);
                            if (_coyoteTryMove(cy, ep)) {
                                cy.position.copy(ep);
                                cy.userData.wanderDir.set(Math.cos(ea), 0, Math.sin(ea));
                                freed = true;
                            }
                        }
                        cy.userData.stuckFrames = 0;
                    }
                }

                cy.userData.animTime += 0.10;
                const at = cy.userData.animTime;

                // ── Tick animation mixer every frame regardless of state ──
                _tickWolfMixer(cy);

                // ── Direction to player (XZ only) ──
                const toPlayerXZ = new THREE.Vector3(
                    camera.position.x - cy.position.x, 0,
                    camera.position.z - cy.position.z
                ).normalize();

                // ═══════ STATE MACHINE ═══════

                if (cy.userData.state === 'wander') {
                    cy.userData.wanderTimer++;
                    if (cy.userData.wanderTimer > 180) {
                        cy.userData.wanderDir.set((Math.random()-0.5), 0, (Math.random()-0.5)).normalize();
                        cy.userData.wanderTimer = 0;
                    }
                    const wp = cy.position.clone().addScaledVector(cy.userData.wanderDir, 0.008);
                    wp.y = cy.position.y;
                    if (_coyoteTryMove(cy, wp)) {
                        cy.position.copy(wp);
                        const targetYaw = Math.atan2(cy.userData.wanderDir.x, cy.userData.wanderDir.z);
                        let diff = targetYaw - cy.rotation.y;
                        while (diff >  Math.PI) diff -= Math.PI * 2;
                        while (diff < -Math.PI) diff += Math.PI * 2;
                        cy.rotation.y += diff * 0.10;
                    } else {
                        cy.userData.wanderDir.set((Math.random()-0.5), 0, (Math.random()-0.5)).normalize();
                        cy.userData.wanderTimer = 0;
                    }

                    // Walk animation
                    if (cy.userData.wolfPlayAnim) cy.userData.wolfPlayAnim('walk', true, 0.8);
                    cy.position.y = 0;

                    // Spot player → howl
                    if (flatDist < 28) {
                        cy.userData.state     = 'howl';
                        cy.userData.howlTimer = 0;
                        cy.userData.howlPlayed = false;
                    }

                } else if (cy.userData.state === 'howl') {
                    cy.userData.howlTimer++;
                    // Face player and freeze
                    cy.rotation.y = Math.atan2(toPlayerXZ.x, toPlayerXZ.z);

                    if (!cy.userData.howlPlayed) {
                        playCoyoteHowl(flatDist);
                        cy.userData.howlPlayed = true;
                    }

                    // Head tilts up for howl
                    // Howl animation
                    if (cy.userData.wolfPlayAnim) cy.userData.wolfPlayAnim('howl', false, 1.0);

                    // ~2 seconds → charge
                    if (cy.userData.howlTimer > 120) {
                        cy.userData.state = 'chase';
                        // Start growl cycle immediately
                        cy.userData.growlPhase      = 'gap';
                        cy.userData.growlPhaseStart = now;
                    }

                } else if (cy.userData.state === 'chase') {
                    // Sprint hard at player
                    const speed = 0.060;
                    const np = cy.position.clone().addScaledVector(toPlayerXZ, speed);
                    np.y = cy.position.y;

                    if (_coyoteTryMove(cy, np)) {
                        cy.position.copy(np);
                        cy.rotation.y = Math.atan2(toPlayerXZ.x, toPlayerXZ.z);
                    } else {
                        // Slide around obstacle — try lateral offset
                        const right = new THREE.Vector3(-toPlayerXZ.z, 0, toPlayerXZ.x);
                        const slide = cy.position.clone().addScaledVector(right, speed);
                        slide.y = cy.position.y;
                        if (_coyoteTryMove(cy, slide)) {
                            cy.position.copy(slide);
                            // Face the slide direction so no sideways gliding
                            cy.rotation.y = Math.atan2(right.x, right.z);
                        }
                    }

                    // Gallop / attack animation
                    if (cy.userData.wolfPlayAnim) {
                        if (cy.userData.biteTimer > 0) {
                            cy.userData.biteTimer--;
                            cy.userData.wolfPlayAnim('attack', false, 1.4);
                        } else {
                            cy.userData.wolfPlayAnim('run', true, 1.2);
                        }
                    }
                    cy.position.y = 0;

                    // Growl sound cycle while chasing
                    tickCoyoteGrowl(cy, flatDist);

                    // ── Bite attack ──
                    if (flatDist < 1.5) {
                        if (now - cy.userData.lastAttackTime > 1200) {
                            cy.userData.lastAttackTime = now;
                            cy.userData.biteTimer = 28; // trigger jaw snap animation
                            health = Math.max(0, health - cy.userData.damage);
                            updateUI();
                            showMessage('🐺 Coyote bites you! -8 HP');
                            if (health <= 0) die();

                            // Back off after biting
                            cy.userData.state       = 'backoff';
                            cy.userData.backoffTimer = 0;
                            // Back-off direction = away from player
                            cy.userData.backoffDir  = toPlayerXZ.clone().negate();
                        }
                    }

                } else if (cy.userData.state === 'backoff') {
                    cy.userData.backoffTimer++;

                    // Run backwards / away from player for ~0.7s
                    const bSpeed = 0.045;
                    const bp = cy.position.clone().addScaledVector(cy.userData.backoffDir, bSpeed);
                    bp.y = cy.position.y;
                    if (_coyoteTryMove(cy, bp)) cy.position.copy(bp);

                    // Face the direction of travel (away from player) so animation matches movement
                    cy.rotation.y = Math.atan2(cy.userData.backoffDir.x, cy.userData.backoffDir.z);

                    // Trot animation
                    if (cy.userData.wolfPlayAnim) cy.userData.wolfPlayAnim('trot', true, 1.0);

                    // Growl continues while backing off
                    tickCoyoteGrowl(cy, flatDist);

                    // Transition to circle
                    if (cy.userData.backoffTimer > 42) {
                        cy.userData.state       = 'circle';
                        cy.userData.circleTimer = 0;
                        // Lock circle radius at current distance
                        cy.userData.circleRadius = Math.max(2.5, flatDist);
                        cy.userData.circleAngle  = Math.atan2(
                            cy.position.z - camera.position.z,
                            cy.position.x - camera.position.x
                        );
                    }

                } else if (cy.userData.state === 'circle') {
                    cy.userData.circleTimer++;

                    // Orbit around player at circleRadius
                    cy.userData.circleAngle += cy.userData.circleDir * 0.018;
                    const r   = cy.userData.circleRadius;
                    const tx  = camera.position.x + Math.cos(cy.userData.circleAngle) * r;
                    const tz  = camera.position.z + Math.sin(cy.userData.circleAngle) * r;
                    const cp  = new THREE.Vector3(tx, cy.position.y, tz);

                    // Move toward that orbit point
                    const toOrbit = new THREE.Vector3().subVectors(cp, cy.position);
                    const toOrbitLen = toOrbit.length();
                    if (toOrbitLen > 0.01) {
                        toOrbit.normalize();
                        const circlePos = cy.position.clone().addScaledVector(toOrbit, Math.min(toOrbitLen, 0.035));
                        circlePos.y = cy.position.y;
                        if (_coyoteTryMove(cy, circlePos)) {
                            cy.position.copy(circlePos);
                            // Face the direction of travel so the walk animation matches movement
                            const targetYaw = Math.atan2(toOrbit.x, toOrbit.z);
                            // Smoothly interpolate rotation to avoid snapping
                            let diff = targetYaw - cy.rotation.y;
                            while (diff >  Math.PI) diff -= Math.PI * 2;
                            while (diff < -Math.PI) diff += Math.PI * 2;
                            cy.rotation.y += diff * 0.15;
                        }
                    }

                    // Circle trot animation
                    if (cy.userData.wolfPlayAnim) cy.userData.wolfPlayAnim('walk', true, 1.0);
                    cy.position.y = 0;

                    // Growl continues while circling
                    tickCoyoteGrowl(cy, flatDist);

                    // After circling 1–2 seconds, lunge again
                    if (cy.userData.circleTimer > 80 + Math.random() * 60) {
                        cy.userData.state = 'chase';
                        cy.userData.circleTimer = 0;
                    }
                }

                // ── Despawn if too far, left desert, or entered snow biome ──
                const cyInSnow = Math.abs(cy.position.x - SB_CX) < SB_SIZE / 2 && Math.abs(cy.position.z - SB_CZ) < SB_SIZE / 2;
                if (dist3d > 100 || !isInDesert() || cyInSnow) {
                    // Stop this coyote's growl
                    if (cy.userData.growlClip) {
                        try { cy.userData.growlClip.pause(); cy.userData.growlClip.currentTime = 0; } catch(e){}
                        const idx = _activeCoyoteGrowlClips.indexOf(cy.userData.growlClip);
                        if (idx !== -1) _activeCoyoteGrowlClips.splice(idx, 1);
                    }
                    if (cy.userData.wolfMixer) cy.userData.wolfMixer.stopAllAction();
                    scene.remove(cy);
                    coyotes.splice(i, 1);
                }
            }
            // Each coyote tracks its own mixer delta in cy.userData._mixerLast
        }

        // ── Initial coyote spawn ──
        // Spawn one close to player for testing, rest in desert
        createCoyote(5, 5); // debug: close spawn
        for (let i = 0; i < 2; i++) {
            const angle = (i / 2) * Math.PI * 2;
            const dist  = 155 + Math.random() * 30;
            createCoyote(Math.cos(angle) * 25, -dist / 2);
        }

        function _isInsideBuilding(x, z, padding) {
            padding = (padding !== undefined) ? padding : 2.5;
            for (let i = 0; i < buildings.length; i++) {
                const b = buildings[i];
                const dx = x - b.position.x, dz = z - b.position.z;
                if (dx * dx + dz * dz < padding * padding) return true;
                const box = b.userData.collisionBox;
                if (box &&
                    x >= box.min.x - padding && x <= box.max.x + padding &&
                    z >= box.min.z - padding && z <= box.max.z + padding) return true;
            }
            return false;
        }

        function spawnEnemies() {
            const isNight = time >= 18 || time < 6;
            if (isNight && enemies.length < 10) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 30 + Math.random() * 20;
                const x = camera.position.x + Math.cos(angle) * distance;
                const z = camera.position.z + Math.sin(angle) * distance;
                if (_isInsideBuilding(x, z)) return;
                createEnemy(x, z);
            }
        }
        
        // Enemies only spawn at night via spawnEnemies()

        // ===================================================================
        // ===== SNOW BIOME — east of desert ================================
        // ===================================================================

        // Crystal node arrays declared in outer scope so handleAttack() and
        // the ore-respawn system can access them (the snow biome IIFE below
        // would otherwise hide them from the outer scope).
        const crystalNodes = [];
        const crystalNodePositions = [];
        const snowTreePositions = [];  // { x, z } for map display
        const snowRockPositions = [];  // { x, z } for map display
        let createCrystalNode = null; // defined inside IIFE below, exported here

        (() => {
            const SUBDIV = 80; // mesh resolution — higher = smoother deformation

            // ── Snow ground texture (procedural canvas) ───────────────────
            const snowCanvas = document.createElement('canvas');
            snowCanvas.width = snowCanvas.height = 512;
            const sCtx = snowCanvas.getContext('2d');

            // Base white-blue snow
            const snowGrad = sCtx.createLinearGradient(0, 0, 512, 512);
            snowGrad.addColorStop(0,    '#e8f0f8');
            snowGrad.addColorStop(0.3,  '#d8eaf6');
            snowGrad.addColorStop(0.6,  '#cce4f4');
            snowGrad.addColorStop(1,    '#e4eef8');
            sCtx.fillStyle = snowGrad;
            sCtx.fillRect(0, 0, 512, 512);

            // Surface texture: tiny sparkle dots and soft shadow patches
            for (let i = 0; i < 4000; i++) {
                const sx = Math.random() * 512;
                const sy = Math.random() * 512;
                const r  = Math.random() * 3 + 0.5;
                const lv = Math.floor(Math.random() * 60 + 190);
                sCtx.fillStyle = `rgba(${lv},${lv+8},${lv+18},${Math.random()*0.55+0.15})`;
                sCtx.beginPath();
                sCtx.arc(sx, sy, r, 0, Math.PI * 2);
                sCtx.fill();
            }
            // Subtle wind-scallop lines
            sCtx.globalAlpha = 0.07;
            for (let i = 0; i < 30; i++) {
                const y0 = Math.random() * 512;
                sCtx.strokeStyle = '#a8c8e8';
                sCtx.lineWidth = 1 + Math.random() * 2;
                sCtx.beginPath();
                sCtx.moveTo(0, y0);
                for (let x = 0; x <= 512; x += 16) {
                    sCtx.lineTo(x, y0 + Math.sin(x * 0.04 + i) * 4);
                }
                sCtx.stroke();
            }
            sCtx.globalAlpha = 1;

            const snowTex = new THREE.CanvasTexture(snowCanvas);
            snowTex.wrapS = snowTex.wrapT = THREE.RepeatWrapping;
            snowTex.repeat.set(14, 14);

            // ── Build displaced mesh ──────────────────────────────────────
            // Extend geometry by SEAM_PAD units on all sides — just enough to
            // overlap the neighbouring mesh edges and hide the pixel-level gap.
            const SEAM_PAD  = 2;                       // minimal overlap, seam cover only
            const MESH_SIZE = SB_SIZE + SEAM_PAD * 2;  // 204 × 204 world units
            const SUBDIV_X  = SUBDIV + 1;              // barely more verts

            const sbGeo = new THREE.PlaneGeometry(MESH_SIZE, MESH_SIZE, SUBDIV_X, SUBDIV_X);
            sbGeo.rotateX(-Math.PI / 2);

            const pos = sbGeo.attributes.position;
            for (let i = 0; i < pos.count; i++) {
                const wx = pos.getX(i) + SB_CX;
                const wz = pos.getZ(i) + SB_CZ;
                pos.setY(i, snowTerrainY(wx, wz));
            }
            pos.needsUpdate = true;
            sbGeo.computeVertexNormals();

            const sbMat = new THREE.MeshStandardMaterial({
                map:        snowTex,
                color:      0xd6e8f5,
                roughness:  0.88,
                metalness:  0.02,
                envMapIntensity: 0.3,
                polygonOffset: true,
                polygonOffsetFactor: -1,
                polygonOffsetUnits:  -1,
            });

            const sbGround = new THREE.Mesh(sbGeo, sbMat);
            sbGround.position.set(SB_CX, 0, SB_CZ);
            sbGround.receiveShadow = true;
            scene.add(sbGround);

            // ── Snow accumulation drifts (extra thick snow piles) ─────────
            // Store drift data so the player movement system can walk over them.
            const _snowDrifts = []; // { x, z, rx, rz, h, baseH }

            // Simple value noise helpers for irregular drift shapes
            function _driftHash(n) {
                // fast deterministic hash → 0..1
                let x = Math.sin(n * 127.1 + 311.7) * 43758.5453;
                return x - Math.floor(x);
            }
            function _driftNoise2(px, pz) {
                // bilinear value noise on integer grid
                const ix = Math.floor(px), iz = Math.floor(pz);
                const fx = px - ix, fz = pz - iz;
                const ux = fx * fx * (3 - 2 * fx), uz = fz * fz * (3 - 2 * fz);
                const a = _driftHash(ix     + iz     * 57);
                const b = _driftHash(ix + 1 + iz     * 57);
                const c = _driftHash(ix     + (iz+1) * 57);
                const d = _driftHash(ix + 1 + (iz+1) * 57);
                return a + (b-a)*ux + (c-a)*uz + (b-a+d-c-b+a)*ux*uz;
            }

            function makeDrift(x, z, scaleX, scaleZ, h) {
                // Higher-res hemisphere so vertex displacement looks smooth
                const dGeo = new THREE.SphereGeometry(1, 24, 14, 0, Math.PI * 2, 0, Math.PI / 2);
                const pos = dGeo.attributes.position;

                // Unique noise offset per drift so each one looks different
                const noiseOX = Math.random() * 100;
                const noiseOZ = Math.random() * 100;

                for (let i = 0; i < pos.count; i++) {
                    let vx = pos.getX(i);
                    let vy = pos.getY(i);
                    let vz = pos.getZ(i);

                    // Angle around Y axis (0..2π) and normalised height (0..1)
                    const angle  = Math.atan2(vz, vx);
                    const normY  = vy; // hemisphere top = 1, rim = 0 (before scale)

                    // Radial noise: stronger near the rim, fades to 0 at top
                    // so the peak stays centred while the edges become irregular
                    const rimFactor = 1 - normY; // 0 at top, 1 at rim
                    const nx = Math.cos(angle) * 2.5 + noiseOX;
                    const nz = Math.sin(angle) * 2.5 + noiseOZ;
                    const n1 = _driftNoise2(nx, nz);
                    const n2 = _driftNoise2(nx * 2.1 + 3.3, nz * 2.1 + 1.7); // octave 2
                    const noise = (n1 * 0.65 + n2 * 0.35) * 2 - 1; // -1..1

                    // Displace radially: up to ±35% of radius, weighted to rim
                    const radialDisp = 1 + noise * 0.35 * rimFactor;
                    pos.setX(i, vx * radialDisp * scaleX);
                    pos.setY(i, vy * h);
                    pos.setZ(i, vz * radialDisp * scaleZ);
                }
                pos.needsUpdate = true;
                dGeo.computeVertexNormals();

                const dMat = new THREE.MeshStandardMaterial({
                    color: 0xddeef9, roughness: 0.9, metalness: 0,
                });
                const drift = new THREE.Mesh(dGeo, dMat);
                const baseH = snowTerrainY(x, z);
                drift.position.set(x, baseH + h * 0.02, z);
                drift.rotation.y = Math.random() * Math.PI * 2;
                drift.receiveShadow = true;
                drift.castShadow   = true;
                scene.add(drift);

                // Register for collision — use average of scaleX/Z as effective radius
                const avgR = (scaleX + scaleZ) * 0.5 * 1.2; // slightly generous for safety
                _snowDrifts.push({ x, z, rx: avgR, rz: avgR, h, baseH });
            }

            // Returns the height contribution of snow drifts at world position wx,wz.
            // Uses a smooth hemisphere falloff matching the SphereGeometry shape.
            function driftTerrainY(wx, wz) {
                let maxH = 0;
                for (const d of _snowDrifts) {
                    const dx = (wx - d.x) / d.rx;
                    const dz = (wz - d.z) / d.rz;
                    const r2 = dx * dx + dz * dz;
                    if (r2 >= 1) continue; // outside ellipse footprint
                    // Hemisphere: height = baseH + h * sqrt(1 - r²)
                    const surfaceH = d.baseH + d.h * Math.sqrt(1 - r2);
                    if (surfaceH > maxH) maxH = surfaceH;
                }
                return maxH;
            }
            window.driftTerrainY = driftTerrainY;

            // Scatter drifts across the biome — only on flat/low ground (not raised terrain)
            for (let i = 0; i < 90; i++) {
                const px = SB_CX + (Math.random() - 0.5) * (SB_SIZE - 20);
                const pz = SB_CZ + (Math.random() - 0.5) * (SB_SIZE - 20);
                const terrainH = snowTerrainY(px, pz);
                // Only place drifts where terrain is genuinely flat
                if (terrainH > 0.4) continue;
                const sx = 3 + Math.random() * 8;
                const sz = 2 + Math.random() * 6;
                const h  = 0.4 + Math.random() * 1.8;
                makeDrift(px, pz, sx, sz, h);
            }

            // ── Snow-covered pine trees ───────────────────────────────────
            // ── Snow trees: two GLB types, spawned once models load ──────
            // Sink factor: partial burial so trunks don't float above uneven terrain
            function _spawnSnowTree(x, z, filename, targetSize, sinkFraction) {
                const inst = _glbSpawn(filename, targetSize);
                if (!inst) return;
                const baseH = snowTerrainY(x, z);
                // Sink model slightly into terrain so it looks grounded on slopes
                const sinkAmt = targetSize * sinkFraction;
                inst.position.set(x, baseH - sinkAmt, z);
                inst.rotation.y = Math.random() * Math.PI * 2;
                // Slight random lean for natural variation
                inst.rotation.x = (Math.random() - 0.5) * 0.06;
                inst.rotation.z = (Math.random() - 0.5) * 0.06;
                // Wind sway — faster and more pronounced than forest trees (blizzard feel)
                inst.userData.swayPhase = Math.random() * Math.PI * 2;
                inst.userData.swaySpeed = 0.6 + Math.random() * 0.5;
                inst.userData.swayAmp   = 0.045 + Math.random() * 0.03; // stored for updateTrees
                scene.add(inst);
                trees.push(inst); // register with updateTrees so sway runs every frame
                inst.userData.isSnowTree = true;
                snowTreePositions.push({ x, z });
            }
            const sbHalf = SB_SIZE / 2 - 12;
            Promise.all([
                _loadAssetGLB('Snowtree1.glb'),
                _loadAssetGLB('Snowtree2.glb')
            ]).then(() => {
                let treeCount = 0;
                const maxTrees = 180;
                let attempts = 0;
                while (treeCount < maxTrees && attempts < 1400) {
                    attempts++;
                    const px = SB_CX + (Math.random() - 0.5) * 2 * sbHalf;
                    const pz = SB_CZ + (Math.random() - 0.5) * 2 * sbHalf;
                    const h  = snowTerrainY(px, pz);
                    // Denser on raised terrain, sparser on flats
                    const prob = 0.25 + h * 0.12;
                    if (Math.random() > prob) continue;

                    // Alternate between two tree types; type 1 is larger/rarer
                    const useType1 = Math.random() < 0.45;
                    if (useType1) {
                        const sz = 5.0 + Math.random() * 4.0;
                        _spawnSnowTree(px, pz, 'Snowtree1.glb', sz, 0.06);
                    } else {
                        const sz = 3.5 + Math.random() * 3.0;
                        _spawnSnowTree(px, pz, 'Snowtree2.glb', sz, 0.05);
                    }
                    treeCount++;
                }
            });

            // ── Snow bushes ───────────────────────────────────────────────
            _loadAssetGLB('Snowbush.glb').then(() => {
                let bushCount = 0;
                const maxBushes = 80;
                let bAttempts = 0;
                while (bushCount < maxBushes && bAttempts < 600) {
                    bAttempts++;
                    const px = SB_CX + (Math.random() - 0.5) * 2 * sbHalf;
                    const pz = SB_CZ + (Math.random() - 0.5) * 2 * sbHalf;
                    const h  = snowTerrainY(px, pz);
                    // Bushes prefer flat/low areas, avoid steep peaks
                    if (h > 4.5) continue;
                    if (Math.random() > 0.6) continue;

                    const inst = _glbSpawn('Snowbush.glb', 0.8 + Math.random() * 0.8);
                    if (!inst) continue;
                    const baseH = snowTerrainY(px, pz);
                    // Sink into ground slightly so base never floats
                    inst.position.set(px, baseH - 0.12, pz);
                    inst.rotation.y = Math.random() * Math.PI * 2;
                    // frustumCulled = true inherited from _glbSpawn (bounding sphere computed)
                    scene.add(inst);
                    bushCount++;
                }
            });

            // ── Ice-crusted rock formations ───────────────────────────────
            function makeIceRock(x, z) {
                const baseH = snowTerrainY(x, z);
                const targetSize = 2.0 + Math.random() * 3.5; // varied sizes

                const rock = _glbSpawn('Snowrock.glb', targetSize);
                if (!rock) {
                    // GLB not loaded yet — silently skip (snow biome loads async)
                    return;
                }
                rock.position.set(x, baseH, z);
                // Random Y rotation for variety, slight tilt for natural look
                rock.rotation.set(
                    (Math.random() - 0.5) * 0.15,
                    Math.random() * Math.PI * 2,
                    (Math.random() - 0.5) * 0.15
                );
                // Slight non-uniform squash for shape variety
                rock.scale.multiplyScalar(1);
                const stretchY = 0.7 + Math.random() * 0.5;
                rock.scale.y *= stretchY;
                scene.add(rock);
                rock.userData.isSnowRock = true;
                snowRockPositions.push({ x, z });
            }

            // Rocks are spawned after GLB loads (see _loadAssetGLB promise below)
            _loadAssetGLB('Snowrock.glb').then(() => {
                for (let i = 0; i < 55; i++) {
                    const rx = SB_CX + (Math.random() - 0.5) * (SB_SIZE - 16);
                    const rz = SB_CZ + (Math.random() - 0.5) * (SB_SIZE - 16);
                    makeIceRock(rx, rz);
                }
            });


            // ── Crystal Nodes (Mineral.glb) — harvestable for Crystal Shards ──
            // NOTE: crystalNodes, crystalNodePositions and createCrystalNode are
            // declared in the outer scope so handleAttack() can reach them.

            createCrystalNode = function(x, z) {
                _loadAssetGLB('Mineral.glb').then(() => {
                    const targetSize = 1.4 + Math.random() * 1.2;
                    const inst = _glbSpawn('Mineral.glb', targetSize);
                    if (!inst) return;

                    // Sample terrain height at centre + 8 points around the footprint
                    // and use the MAX so the node sits on the highest nearby ground point.
                    // This prevents floating on slopes and over-sinking on flat snow.
                    const sampleR = targetSize * 0.4;
                    let maxH = snowTerrainY(x, z);
                    for (let i = 0; i < 8; i++) {
                        const a = (i / 8) * Math.PI * 2;
                        const sh = snowTerrainY(x + Math.cos(a) * sampleR, z + Math.sin(a) * sampleR);
                        if (sh > maxH) maxH = sh;
                    }
                    // Sit the GLB bbox-bottom exactly on maxH, with a tiny cosmetic tuck (0.05)
                    inst.position.set(x, maxH - 0.05, z);
                    inst.rotation.y = Math.random() * Math.PI * 2;
                    inst.rotation.x = (Math.random() - 0.5) * 0.06;
                    inst.userData.type       = 'crystal_node';
                    inst.userData.health     = 3;
                    inst.userData.maxHealth  = 3;
                    // frustumCulled = true inherited from _glbSpawn (bounding sphere computed)

                    // ── Crystal shading: replace GLB materials with MeshPhysicalMaterial
                    // so facets are perfectly smooth, refractive, and env-reflective.
                    _buildCrystalEnvMap();
                    inst.traverse(c => {
                        if (!c.isMesh) return;
                        // Pick a hue per-face for natural variation (main purple + accent tint)
                        const tints = [0xd444ff, 0xbb33ee, 0xee55ff, 0xcc44dd];
                        const tint  = tints[Math.floor(Math.random() * tints.length)];
                        c.material = new THREE.MeshPhysicalMaterial({
                            color:              new THREE.Color(tint),
                            emissive:           new THREE.Color(0x8800cc),
                            emissiveIntensity:  0.18,
                            roughness:          0.0,    // mirror-smooth facets
                            metalness:          0.05,
                            transmission:       0.55,   // light passes through like real crystal
                            thickness:          0.6,    // refraction depth
                            ior:                2.2,    // crystal refractive index (≈ quartz–topaz)
                            clearcoat:          1.0,    // glossy outer layer
                            clearcoatRoughness: 0.0,
                            envMap:             _crystalEnvMap,
                            envMapIntensity:    4.0,    // strong mirror-like reflections
                            transparent:        true,
                            opacity:            0.88,
                            side:               THREE.DoubleSide,
                        });
                        c.material.needsUpdate = true;
                    });

                    const posEntry = { x, z, radius: 1.8 };
                    inst.userData._posEntry  = posEntry;
                    inst.userData._posArray  = crystalNodePositions;
                    inst.userData.isCrystalNode = true;
                    crystalNodes.push(inst);
                    crystalNodePositions.push(posEntry);
                    scene.add(inst);
                });
            }; // end createCrystalNode
            (function spawnCrystalNodes() {
                let placed = 0;
                let attempts = 0;
                while (placed < 12 && attempts < 200) {
                    attempts++;
                    const nx = SB_CX + (Math.random() - 0.5) * (SB_SIZE - 24);
                    const nz = SB_CZ + (Math.random() - 0.5) * (SB_SIZE - 24);
                    // Keep away from player spawn
                    if (Math.sqrt((nx - SB_CX) ** 2 + (nz - SB_CZ) ** 2) < 14) continue;
                    // Space out from each other
                    let tooClose = false;
                    for (const p of crystalNodePositions) {
                        if (Math.sqrt((nx - p.x) ** 2 + (nz - p.z) ** 2) < 10) { tooClose = true; break; }
                    }
                    if (tooClose) continue;
                    crystalNodePositions.push({ x: nx, z: nz, radius: 1.8 }); // reserve slot
                    createCrystalNode(nx, nz);
                    placed++;
                }
            })();

                        // ── Ambient snow particles (falling flakes near player) ────────
            // We create a simple Points cloud that drifts downward each frame
            const FLAKE_COUNT  = 780;  // +30% from original 600
            const flakePositions = new Float32Array(FLAKE_COUNT * 3);
            // Per-flake horizontal wind velocity for blown-snow effect
            const flakeWindX = new Float32Array(FLAKE_COUNT);
            const flakeWindZ = new Float32Array(FLAKE_COUNT);
            for (let i = 0; i < FLAKE_COUNT; i++) {
                flakePositions[i * 3]     = SB_CX + (Math.random() - 0.5) * SB_SIZE;
                flakePositions[i * 3 + 1] = Math.random() * 22;
                flakePositions[i * 3 + 2] = SB_CZ + (Math.random() - 0.5) * SB_SIZE;
                // Each flake gets its own wind speed so the cloud looks turbulent
                flakeWindX[i] = 0.04 + Math.random() * 0.06;  // strong rightward base wind
                flakeWindZ[i] = (Math.random() - 0.5) * 0.03; // slight Z turbulence
            }
            const flakeGeo  = new THREE.BufferGeometry();
            flakeGeo.setAttribute('position', new THREE.BufferAttribute(flakePositions, 3));
            const flakeMat  = new THREE.PointsMaterial({ color: 0xffffff, size: 0.18, transparent: true, opacity: 0.75, depthWrite: false, map: _snowCircleTex, alphaTest: 0.01 });
            const flakeMesh = new THREE.Points(flakeGeo, flakeMat);
            scene.add(flakeMesh);

            // Store reference for animation loop
            window._snowFlakeMesh    = flakeMesh;
            window._snowFlakePos     = flakePositions;
            window._snowFlakeGeo     = flakeGeo;
            window._snowFlakeWindX   = flakeWindX;
            window._snowFlakeWindZ   = flakeWindZ;
            window.snowTerrainY      = snowTerrainY; // expose for movement system

            // ── Subtle blue-white fog plane at ground level ────────────────
            // A large translucent quad at y≈0 that gives the icy misty look
            const fogPlaneGeo = new THREE.PlaneGeometry(SB_SIZE * 0.9, SB_SIZE * 0.9);
            const fogPlaneMat = new THREE.MeshBasicMaterial({
                color: 0xb8d8f0, transparent: true, opacity: 0.08, depthWrite: false,
            });
            const fogPlane = new THREE.Mesh(fogPlaneGeo, fogPlaneMat);
            fogPlane.rotation.x = -Math.PI / 2;
            fogPlane.position.set(SB_CX, 0.08, SB_CZ);
            fogPlane.renderOrder = 1;
            scene.add(fogPlane);

            console.log('❄️  Snow biome created');
        })();

        // ===== PARTICLE SYSTEM FOR FIRE AND SMOKE =====
        // Uses THREE.Points pools ? all fire in 1 draw call, all smoke in 1 draw call.
        const MAX_FIRE  = 80;
        const MAX_SMOKE = 60;

        // Internal particle state arrays (CPU side)
        const _firePx  = new Float32Array(MAX_FIRE);
        const _firePy  = new Float32Array(MAX_FIRE);
        const _firePz  = new Float32Array(MAX_FIRE);
        const _fireVx  = new Float32Array(MAX_FIRE);
        const _fireVy  = new Float32Array(MAX_FIRE);
        const _fireVz  = new Float32Array(MAX_FIRE);
        const _fireOx  = new Float32Array(MAX_FIRE); // spawn origin X (for taper)
        const _fireOz  = new Float32Array(MAX_FIRE); // spawn origin Z (for taper)
        const _fireLife= new Float32Array(MAX_FIRE);  // 0 = dead
        const _fireMax = new Float32Array(MAX_FIRE);

        const _smokePx  = new Float32Array(MAX_SMOKE);
        const _smokePy  = new Float32Array(MAX_SMOKE);
        const _smokePz  = new Float32Array(MAX_SMOKE);
        const _smokeVx  = new Float32Array(MAX_SMOKE);
        const _smokeVy  = new Float32Array(MAX_SMOKE);
        const _smokeVz  = new Float32Array(MAX_SMOKE);
        const _smokeLife= new Float32Array(MAX_SMOKE);
        const _smokeMax = new Float32Array(MAX_SMOKE);

        // ── Furnace door-fire particle pool ──────────────────────────────────────
        const MAX_DOOR_FIRE = 40;
        // Bounds in furnace LOCAL space (furnace GROUP is scale 1 but GLB child is scale 3)
        // Opening appears visually ~1.2–1.6 units high, but group local = visual / 3 ≈ 0.40–0.53
        // Opening is at the front face of the body, roughly centred X
        const _DF_XMIN = -0.08, _DF_XMAX =  0.08;
        const _DF_YMIN =  0.38, _DF_YMAX =  0.55;
        const _DF_ZMIN = -0.04, _DF_ZMAX =  0.04;
        const _doorFireMat = new THREE.PointsMaterial({
            color: 0xff5500, size: 0.10, sizeAttenuation: true,
            transparent: true, opacity: 0.9,
            blending: THREE.AdditiveBlending, depthWrite: false,
            map: _fireCircleTex, alphaTest: 0.01,
        });

        // GPU geometry — positions updated each frame
        const _firePosAttr  = new THREE.BufferAttribute(new Float32Array(MAX_FIRE  * 3), 3);
        const _smokePosAttr = new THREE.BufferAttribute(new Float32Array(MAX_SMOKE * 3), 3);
        _firePosAttr.setUsage(THREE.DynamicDrawUsage);
        _smokePosAttr.setUsage(THREE.DynamicDrawUsage);

        const _fireGeo = new THREE.BufferGeometry();
        _fireGeo.setAttribute('position', _firePosAttr);
        const _fireMat = new THREE.PointsMaterial({
            color: 0xff6600, size: 0.35, sizeAttenuation: true,
            transparent: true, opacity: 0.85,
            blending: THREE.AdditiveBlending, depthWrite: false,
            map: _fireCircleTex, alphaTest: 0.01,
        });
        const _firePoints = new THREE.Points(_fireGeo, _fireMat);
        _firePoints.frustumCulled = false;
        scene.add(_firePoints);

        const _smokeGeo = new THREE.BufferGeometry();
        _smokeGeo.setAttribute('position', _smokePosAttr);
        const _smokeMat = new THREE.PointsMaterial({
            color: 0x888888, size: 0.55, sizeAttenuation: true,
            transparent: true, opacity: 0.45, depthWrite: false,
            map: _smokeCircleTex, alphaTest: 0.01,
        });
        const _smokePoints = new THREE.Points(_smokeGeo, _smokeMat);
        _smokePoints.frustumCulled = false;
        scene.add(_smokePoints);

        // ── Fire-light helper ─────────────────────────────────────────────────────
        // Creates and attaches a PointLight (plus an emissive glow sprite) to any
        // campfire, furnace, or cooking-station building object.
        function _attachFireLight(building) {
            // Already wired up
            if (building.userData.fireLight) return;

            const isCampfire       = building.userData.isCampfire;
            const isFurnace        = building.userData.isFurnace;
            const isCookingStation = building.userData.isCookingStation;
            if (!isCampfire && !isFurnace && !isCookingStation) return;

            // --- PointLight ---
            // Campfire: warm orange, wide radius, starts off
            // Furnace:  hotter orange-red, tighter radius
            // Cooking:  warm amber, medium radius
            let color, intensity, distance, yOffset;
            if (isCampfire) {
                color = 0xff6a00; intensity = 0; distance = 14; yOffset = 0.5;
            } else if (isFurnace) {
                color = 0xff3300; intensity = 0; distance = 10; yOffset = 1.2;
            } else {
                color = 0xff8800; intensity = 0; distance = 10; yOffset = 0.9;
            }

            const light = new THREE.PointLight(color, intensity, distance);
            light.position.set(0, yOffset, 0);
            light.castShadow = false;
            building.add(light);
            building.userData.fireLight = light;

            // Furnace: attach local-space door-fire particle pool
            if (isFurnace) {
                const dfPosAttr = new THREE.BufferAttribute(new Float32Array(MAX_DOOR_FIRE * 3), 3);
                dfPosAttr.setUsage(THREE.DynamicDrawUsage);
                for (let i = 0; i < MAX_DOOR_FIRE; i++) dfPosAttr.setXYZ(i, 0, -9999, 0);
                const dfGeo = new THREE.BufferGeometry();
                dfGeo.setAttribute('position', dfPosAttr);
                const dfPoints = new THREE.Points(dfGeo, _doorFireMat);
                dfPoints.frustumCulled = false;
                // Add to scene (world space) not to building, so rotation doesn't matter
                scene.add(dfPoints);
                building.userData._dfPool = {
                    px: new Float32Array(MAX_DOOR_FIRE), py: new Float32Array(MAX_DOOR_FIRE),
                    pz: new Float32Array(MAX_DOOR_FIRE), vx: new Float32Array(MAX_DOOR_FIRE),
                    vy: new Float32Array(MAX_DOOR_FIRE), vz: new Float32Array(MAX_DOOR_FIRE),
                    life: new Float32Array(MAX_DOOR_FIRE), max: new Float32Array(MAX_DOOR_FIRE),
                    posAttr: dfPosAttr, points: dfPoints,
                };
                building.userData._dfTimer = 0;
            }
        }
        // ─────────────────────────────────────────────────────────────────────────

        function createFireParticle(position) {
            // Find a dead slot
            for (let i = 0; i < MAX_FIRE; i++) {
                if (_fireLife[i] <= 0) {
                    _firePx[i] = position.x + (Math.random() - 0.5) * 0.20;
                    _firePy[i] = position.y;
                    _firePz[i] = position.z + (Math.random() - 0.5) * 0.20;
                    _fireOx[i] = position.x;
                    _fireOz[i] = position.z;
                    _fireVx[i] = (Math.random() - 0.5) * 0.012;
                    _fireVy[i] = 0.012 + Math.random() * 0.010;
                    _fireVz[i] = (Math.random() - 0.5) * 0.012;
                    _fireMax[i] = 0.18 + Math.random() * 0.14;
                    _fireLife[i] = _fireMax[i];
                    break;
                }
            }
        }

        function createSmokeParticle(position) {
            for (let i = 0; i < MAX_SMOKE; i++) {
                if (_smokeLife[i] <= 0) {
                    _smokePx[i] = position.x; _smokePy[i] = position.y; _smokePz[i] = position.z;
                    _smokeVx[i] = (Math.random() - 0.5) * 0.008;
                    _smokeVy[i] = 0.015 + Math.random() * 0.01;
                    _smokeVz[i] = (Math.random() - 0.5) * 0.008;
                    _smokeMax[i] = 2.0 + Math.random() * 1.5;
                    _smokeLife[i] = _smokeMax[i];
                    break;
                }
            }
        }

        // World-space door-fire offset from furnace origin:
        // Opening is ~1.35 world units up (GLB scale 3 * ~0.45 local) and ~0.55 units forward (local +Z)
        const _DF_OPEN_Y   = 1.35;  // height of arch opening in world units
        const _DF_OPEN_FWD = 0.30;  // how far forward from centre toward the open face
        const _DF_SPREAD_X = 0.18;  // half-width of opening
        const _DF_SPREAD_Y = 0.22;  // vertical height of opening
        const _dfFwd = new THREE.Vector3();

        function _spawnDoorFire(furnace) {
            const pool = furnace.userData._dfPool;
            if (!pool) return;
            for (let i = 0; i < MAX_DOOR_FIRE; i++) {
                if (pool.life[i] > 0) continue;

                // Get furnace facing direction (local +Z rotated into world)
                _dfFwd.set(0, 0, 1).applyEuler(furnace.rotation);

                // World-space spawn position = furnace origin + up + forward
                const wx = furnace.position.x + _dfFwd.x * _DF_OPEN_FWD + (Math.random() - 0.5) * _DF_SPREAD_X * 2;
                const wy = furnace.position.y + _DF_OPEN_Y + Math.random() * _DF_SPREAD_Y;
                const wz = furnace.position.z + _dfFwd.z * _DF_OPEN_FWD + (Math.random() - 0.5) * _DF_SPREAD_X * 2;

                pool.px[i]  = wx;
                pool.py[i]  = wy;
                pool.pz[i]  = wz;
                pool.vx[i]  = (Math.random() - 0.5) * 0.012;
                pool.vy[i]  = 0.015 + Math.random() * 0.015;
                pool.vz[i]  = (Math.random() - 0.5) * 0.012;
                pool.max[i] = 0.25 + Math.random() * 0.20;
                pool.life[i]= pool.max[i];
                break;
            }
        }

        function _updateDoorFireParticles() {
            for (let b = 0; b < buildings.length; b++) {
                const bd = buildings[b];
                if (!bd.userData.isFurnace) continue;
                const pool = bd.userData._dfPool;
                if (!pool) continue;
                const posAttr = pool.posAttr;
                for (let i = 0; i < MAX_DOOR_FIRE; i++) {
                    if (pool.life[i] <= 0) { posAttr.setXYZ(i, 0, -9999, 0); continue; }
                    pool.life[i] -= 0.018;
                    pool.px[i]   += pool.vx[i];
                    pool.py[i]   += pool.vy[i];
                    pool.pz[i]   += pool.vz[i];
                    posAttr.setXYZ(i, pool.px[i], pool.py[i], pool.pz[i]);
                }
                posAttr.needsUpdate = true;
            }
        }

        // Scratch arrays kept outside updateParticles to avoid per-frame allocation
        const _fireParticles  = []; // legacy alias ? kept for any code that checks .length
        const fireParticles   = _fireParticles;
        const smokeParticles  = [];

        let _fireDecayMult = 1; // boosted to kill particles fast when no campfire active

        function updateParticles() {
            // ?? Fire ????????????????????????????????????????????????????????
            let fireVisible = 0;
            for (let i = 0; i < MAX_FIRE; i++) {
                if (_fireLife[i] <= 0) {
                    _firePosAttr.setXYZ(i, 0, -9999, 0);
                    continue;
                }
                _fireLife[i] -= 0.016 * _fireDecayMult;
                if (_fireLife[i] <= 0) { _firePosAttr.setXYZ(i, 0, -9999, 0); continue; }
                _firePx[i] += _fireVx[i];
                _firePy[i] += _fireVy[i];
                _firePz[i] += _fireVz[i];

                // Taper inward: pull toward spawn origin, strength grows with height risen
                const _riseAmt = (_fireLife[i] <= 0 ? _fireMax[i] : _fireMax[i] - _fireLife[i]);
                const _taperStr = _riseAmt * 0.06;
                _fireVx[i] += (_fireOx[i] - _firePx[i]) * _taperStr;
                _fireVz[i] += (_fireOz[i] - _firePz[i]) * _taperStr;

                _firePosAttr.setXYZ(i, _firePx[i], _firePy[i], _firePz[i]);
                fireVisible++;
            }
            // Always upload if anything was visible last frame or this frame (clears frozen ghosts)
            _firePosAttr.needsUpdate = true; // always upload so parked particles clear from GPU
            _firePoints.visible = fireVisible > 0;
            // Colour shift: use ratio of living particles instead of expensive reduce()
            const fireLifeRatio = fireVisible / MAX_FIRE;
            if      (fireLifeRatio > 0.35) _fireMat.color.setHex(0xffdd00);
            else if (fireLifeRatio > 0.10) _fireMat.color.setHex(0xff8800);
            else                           _fireMat.color.setHex(0xff3300);

            // ?? Smoke ???????????????????????????????????????????????????????
            let smokeVisible = 0;
            for (let i = 0; i < MAX_SMOKE; i++) {
                if (_smokeLife[i] <= 0) {
                    _smokePosAttr.setXYZ(i, 0, -9999, 0);
                    continue;
                }
                _smokeLife[i] -= 0.008;
                _smokeVx[i] *= 0.99; _smokeVy[i] *= 0.99; _smokeVz[i] *= 0.99;
                _smokePx[i] += _smokeVx[i];
                _smokePy[i] += _smokeVy[i];
                _smokePz[i] += _smokeVz[i];
                _smokePosAttr.setXYZ(i, _smokePx[i], _smokePy[i], _smokePz[i]);
                smokeVisible++;
            }
            _smokePosAttr.needsUpdate = true; // always upload so parked particles clear from GPU
            
            // Furnace door-fire particles (local-space, clamped)
            _updateDoorFireParticles();

            // Update muzzle flash particles (from gun shooting)
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                if (!particle.userData || particle.userData.life === undefined) {
                    // Remove invalid particles
                    scene.remove(particle);
                    particles.splice(i, 1);
                    continue;
                }
                
                particle.userData.life++;
                
                if (particle.userData.life >= particle.userData.maxLife) {
                    scene.remove(particle);
                    particles.splice(i, 1);
                } else {
                    // Update position with velocity
                    if (particle.userData.velocity) {
                        particle.position.add(particle.userData.velocity);
                        // Apply slight gravity/slowdown
                        particle.userData.velocity.multiplyScalar(0.96);
                        particle.userData.velocity.y -= 0.005;
                    }
                    
                    // Fade out and scale
                    const lifeRatio = particle.userData.life / particle.userData.maxLife;
                    particle.material.opacity = (1 - lifeRatio) * 0.9;
                    
                    if (particle.userData.startSize) {
                        const scale = particle.userData.startSize * (1 + lifeRatio * 0.5);
                        particle.scale.set(scale, scale, scale);
                    }
                }
            }
        }
        
        // ===== AUDIO (Keep original sounds) =====
        // audioContext already declared earlier
        
        function playHitSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.1);
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.1);
        }
        
        function playCollectSound() { /* replaced by specific MP3 sounds */ }
        
        function playAnimalSound(volume = 0.15) {
            // Play 2-3 chirps with random delays
            const numChirps = 2 + Math.floor(Math.random() * 2); // 2 or 3 chirps
            
            for (let i = 0; i < numChirps; i++) {
                const delay = i * (0.15 + Math.random() * 0.15); // 0.15-0.3 seconds between chirps
                
                setTimeout(() => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    const filter = audioContext.createBiquadFilter();
                    
                    oscillator.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    // Vary the pitch for each chirp
                    const basePitch = 160 + Math.random() * 40; // Random base pitch 160-200 Hz
                    const endPitch = basePitch - 20 - Math.random() * 20; // End 20-40 Hz lower
                    
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(basePitch, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(endPitch, audioContext.currentTime + 0.3);
                    
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(550 + Math.random() * 100, audioContext.currentTime); // Vary filter 550-650 Hz
                    
                    gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.3);
                }, delay * 1000);
            }
        }
        
        function playSquirrelSound(volume = 0.2) {
            // Play 2-3 chirps with random delays
            const numChirps = 2 + Math.floor(Math.random() * 2); // 2 or 3 chirps
            
            for (let i = 0; i < numChirps; i++) {
                const delay = i * (0.12 + Math.random() * 0.1); // 0.12-0.22 seconds between chirps (faster than animals)
                
                setTimeout(() => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    // Vary the pitch for each chirp
                    const basePitch = 1100 + Math.random() * 200; // Random base pitch 1100-1300 Hz
                    const midPitch = basePitch + 100 + Math.random() * 100; // Go up 100-200 Hz
                    
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(basePitch, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(midPitch, audioContext.currentTime + 0.05);
                    oscillator.frequency.exponentialRampToValueAtTime(basePitch, audioContext.currentTime + 0.1);
                    
                    gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.1);
                }, delay * 1000);
            }
        }
        
        function playEnemySound(volume = 0.3) {
            const now = audioContext.currentTime;
            const masterGain = audioContext.createGain();
            masterGain.connect(audioContext.destination);
            masterGain.gain.setValueAtTime(volume * 0.55, now);
            masterGain.gain.exponentialRampToValueAtTime(0.001, now + 1.8);

            // Layer 1: deep guttural sub-growl
            const sub = audioContext.createOscillator();
            const subGain = audioContext.createGain();
            const subFilter = audioContext.createBiquadFilter();
            sub.type = 'sawtooth';
            sub.frequency.setValueAtTime(38, now);
            sub.frequency.setValueAtTime(32, now + 0.3);
            sub.frequency.exponentialRampToValueAtTime(22, now + 1.8);
            subFilter.type = 'lowpass';
            subFilter.frequency.setValueAtTime(180, now);
            subFilter.Q.setValueAtTime(8, now);
            subGain.gain.setValueAtTime(1.0, now);
            sub.connect(subFilter); subFilter.connect(subGain); subGain.connect(masterGain);
            sub.start(now); sub.stop(now + 1.8);

            // Layer 2: raspy mid growl with tremolo
            const mid = audioContext.createOscillator();
            const midGain = audioContext.createGain();
            const midFilter = audioContext.createBiquadFilter();
            const tremolo = audioContext.createOscillator();
            const tremoloGain = audioContext.createGain();
            tremolo.type = 'sine';
            tremolo.frequency.setValueAtTime(7 + Math.random() * 4, now);
            tremoloGain.gain.setValueAtTime(0.4, now);
            tremolo.connect(tremoloGain);
            tremoloGain.connect(midGain.gain);
            mid.type = 'sawtooth';
            mid.frequency.setValueAtTime(65 + Math.random() * 15, now);
            mid.frequency.exponentialRampToValueAtTime(45, now + 1.4);
            midFilter.type = 'bandpass';
            midFilter.frequency.setValueAtTime(220, now);
            midFilter.Q.setValueAtTime(4, now);
            midGain.gain.setValueAtTime(0.7, now);
            mid.connect(midFilter); midFilter.connect(midGain); midGain.connect(masterGain);
            tremolo.start(now); tremolo.stop(now + 1.8);
            mid.start(now); mid.stop(now + 1.8);

            // Layer 3: high scratchy inhale-exhale breath
            const breath = audioContext.createOscillator();
            const breathGain = audioContext.createGain();
            const breathFilter = audioContext.createBiquadFilter();
            breath.type = 'square';
            breath.frequency.setValueAtTime(120, now);
            breath.frequency.setValueAtTime(180, now + 0.6);
            breath.frequency.exponentialRampToValueAtTime(90, now + 1.2);
            breathFilter.type = 'highpass';
            breathFilter.frequency.setValueAtTime(400, now);
            breathFilter.Q.setValueAtTime(2, now);
            breathGain.gain.setValueAtTime(0, now);
            breathGain.gain.linearRampToValueAtTime(0.3, now + 0.4);
            breathGain.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
            breath.connect(breathFilter); breathFilter.connect(breathGain); breathGain.connect(masterGain);
            breath.start(now); breath.stop(now + 1.8);
        }
        
        // Preload enemy attack sound
        let _enemyAttackAudio = null;
        const _activeBiteClips = [];

        function playEnemyAttackSound(volume) {
            if (!_enemyAttackAudio) return;
            const attackVolume = (volume !== undefined) ? volume : (volumeSettings.enemies * 0.9);
            const clip = _enemyAttackAudio.cloneNode();
            clip.volume = Math.min(1, Math.max(0, attackVolume));
            _activeBiteClips.push(clip);
            clip.addEventListener('ended', () => {
                const i = _activeBiteClips.indexOf(clip);
                if (i !== -1) _activeBiteClips.splice(i, 1);
            });
            clip.play().catch(e => { console.error('playEnemyAttackSound error:', e); });
        }

        function stopAllBiteSounds() {
            for (const clip of _activeBiteClips) {
                clip.pause();
                clip.currentTime = 0;
            }
            _activeBiteClips.length = 0;
        }

        // Preload scorpion attack sound
        let _scorpionAttackAudio = new Audio('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/scorp.mp3');
        _scorpionAttackAudio.preload = 'auto';

        function playScorpionAttackSound() {
            if (!_scorpionAttackAudio) return;
            const clip = _scorpionAttackAudio.cloneNode();
            clip.volume = Math.min(1, Math.max(0, volumeSettings.enemies * 0.85));
            clip.play().catch(e => { console.error('playScorpionAttackSound error:', e); });
        }
        
        // Mechanical recycler sound
        let recyclerSound = null;
        let recyclerGainNode = null;

        let _recyclerBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/recycler.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _recyclerBuffer = buf; console.log('Recycler sound loaded OK'); })
            .catch(e => { console.error('Recycler sound fetch error:', e); });

        // Proximity audio constants for recycler
        const RECYCLER_AUDIO_MAX_DIST = 20;
        const RECYCLER_AUDIO_MIN_DIST = 3;
        const RECYCLER_AUDIO_MAX_VOL = 0.49;

        function startRecyclerSound() {
            if (recyclerSound) return;
            if (!_recyclerBuffer) return;
            recyclerGainNode = audioContext.createGain();
            recyclerGainNode.gain.setValueAtTime(0.0, audioContext.currentTime);
            recyclerGainNode.connect(audioContext.destination);
            recyclerSound = audioContext.createBufferSource();
            recyclerSound.buffer = _recyclerBuffer;
            recyclerSound.loop = true;
            recyclerSound.connect(recyclerGainNode);
            recyclerSound.start();
        }

        function updateRecyclerProximityAudio() {
            if (!recyclerSound || !recyclerGainNode) return;
            if (!currentRecycler) {
                recyclerGainNode.gain.setValueAtTime(0.21, audioContext.currentTime);
                return;
            }
            const rPos = currentRecycler.position;
            const cPos = camera.position;
            const dx = rPos.x - cPos.x;
            const dz = rPos.z - cPos.z;
            const dist = Math.sqrt(dx * dx + dz * dz);
            let vol;
            if (dist <= RECYCLER_AUDIO_MIN_DIST) {
                vol = RECYCLER_AUDIO_MAX_VOL;
            } else if (dist >= RECYCLER_AUDIO_MAX_DIST) {
                vol = 0.0;
            } else {
                const t = (dist - RECYCLER_AUDIO_MIN_DIST) / (RECYCLER_AUDIO_MAX_DIST - RECYCLER_AUDIO_MIN_DIST);
                vol = RECYCLER_AUDIO_MAX_VOL * (1 - t);
            }
            recyclerGainNode.gain.setValueAtTime(vol, audioContext.currentTime);
        }

        function stopRecyclerSound() {
            if (recyclerSound) {
                recyclerGainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                setTimeout(() => {
                    if (recyclerSound) { try { recyclerSound.stop(); } catch(e){} recyclerSound = null; }
                    recyclerGainNode = null;
                }, 400);
            }
        }
        
        // Fire/burning sounds for campfire and furnace
        let fireSound = null;
        let fireGainNode = null;
        let furnaceSound = null;
        let furnaceGainNode = null;
        let _prevAnyCampfireActive = false;

        // Preload campfire sound
        let _campfireBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/campfire.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _campfireBuffer = buf; console.log('Campfire sound loaded OK'); })
            .catch(e => { console.error('Campfire sound fetch error:', e); });

        // Preload Hive ambient sound
        let _hiveBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/Hive.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _hiveBuffer = buf; console.log('Hive sound loaded OK'); })
            .catch(e => { console.warn('Hive sound fetch error:', e); });

        // ── BEE GLB SYSTEM ────────────────────────────────────────────────────
        // Each bee is a cloned Bee.glb with its own AnimationMixer running the
        // fly animation. Bees orbit the hive with multi-sine erratic flight paths.
        const BEE_PER_HIVE = 28;
        const BEE_CULL_R   = 35; // hide bees beyond this distance

        // Map: hive building → array of bee objects { inst, mixer, mixerLast, ...params }
        const _hiveBeeMap = new Map();

        function _spawnBeesForHive(hive) {
            if (_hiveBeeMap.has(hive)) return;
            const key  = _ASSET_GLB_BASE + 'Bee.glb';
            const tmpl = _assetGLBCache[key] || _assetGLBCache['Bee.glb'];
            if (!tmpl) return;

            const bees = [];
            for (let i = 0; i < BEE_PER_HIVE; i++) {
                const inst = tmpl.clone(true);
                inst.traverse(c => {
                    c.frustumCulled = false;
                    if (!c.isMesh) return;
                    if (Array.isArray(c.material)) {
                        c.material = c.material.map(m => m ? m.clone() : m);
                    } else if (c.material) {
                        c.material = c.material.clone();
                    }
                });

                // Scale to ~0.12 m on the longest axis
                const bbox = new THREE.Box3().setFromObject(inst);
                const bsz  = new THREE.Vector3(); bbox.getSize(bsz);
                const maxD = Math.max(bsz.x, bsz.y, bsz.z);
                if (maxD > 0) inst.scale.setScalar(0.06 / maxD);

                // ── Find wing nodes by name; fall back to all direct children ──
                const wingNodes = [];
                inst.traverse(c => {
                    if (c === inst) return;
                    const n = c.name.toLowerCase();
                    if (n.includes('wing')) wingNodes.push({ node: c, side: n.includes('r') ? 1 : -1 });
                });
                // No named wings — treat every direct child as a wing half
                if (wingNodes.length === 0) {
                    inst.children.forEach((c, ci) => {
                        wingNodes.push({ node: c, side: ci % 2 === 0 ? 1 : -1 });
                    });
                }
                // Snapshot rest rotations to oscillate around them
                const wingRest = wingNodes.map(w => ({
                    x: w.node.rotation.x,
                    y: w.node.rotation.y,
                    z: w.node.rotation.z
                }));

                // GLB animation mixer (body/antennae if present)
                let mixer = null;
                const clips = tmpl.userData._animClips;
                if (clips && Object.keys(clips).length > 0) {
                    mixer = new THREE.AnimationMixer(inst);
                    const clip   = Object.values(clips)[0];
                    const action = mixer.clipAction(clip);
                    action.time  = Math.random() * (clip.duration || 1);
                    action.play();
                }

                scene.add(inst);

                bees.push({
                    inst, mixer,
                    mixerLast: performance.now(),
                    wingNodes, wingRest,
                    // Each bee has a unique phase and speed so wings never sync visually
                    wingPhase: Math.random() * Math.PI * 2,
                    wingSpeed: 5000 + Math.random() * 1000, // rad/s — vibrating blur like real bee wings
                    wingAmp:   0.55 + Math.random() * 0.25, // radians of arc per wing
                    angle:  Math.random() * Math.PI * 2,
                    radius: 0.2 + Math.random() * 0.4,
                    height: 1.0 + Math.random() * 0.8,
                    speed:  (0.01 + Math.random() * 0.022) * (Math.random() < 0.3 ? -1 : 1),
                    wobA:   0.07 + Math.random() * 0.16,
                    wobF:   1.8  + Math.random() * 2.8,
                    wobP:   Math.random() * Math.PI * 2,
                    dartA:  0.04 + Math.random() * 0.18,
                    dartF:  0.9  + Math.random() * 2.2,
                    dartP:  Math.random() * Math.PI * 2,
                    tiltP:  Math.random() * Math.PI * 2,
                });
            }
            _hiveBeeMap.set(hive, bees);
        }

        function _removeHiveBees(hive) {
            const bees = _hiveBeeMap.get(hive);
            if (!bees) return;
            for (const bee of bees) {
                scene.remove(bee.inst);
                if (bee.mixer) bee.mixer.stopAllAction();
            }
            _hiveBeeMap.delete(hive);
        }

        function updateBees() {
            const t   = performance.now() * 0.001;
            const now = performance.now();

            for (const b of buildings) {
                if (b.userData.isBeeHive && !_hiveBeeMap.has(b)) _spawnBeesForHive(b);
            }

            for (const [hive, bees] of _hiveBeeMap) {
                const camDist = hive.position.distanceTo(camera.position);
                const visible = camDist < BEE_CULL_R;

                for (const bee of bees) {
                    bee.inst.visible = visible;
                    if (!visible) continue;

                    bee.angle += bee.speed;
                    const r  = bee.radius + Math.sin(t * bee.dartF + bee.dartP) * bee.dartA;
                    const wx = hive.position.x + Math.cos(bee.angle) * r;
                    const wz = hive.position.z + Math.sin(bee.angle) * r;
                    const wy = hive.position.y
                        + bee.height
                        + Math.sin(t * bee.wobF        + bee.wobP) * bee.wobA
                        + Math.sin(t * bee.wobF * 1.61 + bee.wobP + 0.9) * bee.wobA * 0.45;

                    bee.inst.position.set(wx, wy, wz);

                    const tangent = bee.angle + (bee.speed > 0 ? Math.PI * 0.5 : -Math.PI * 0.5);
                    bee.inst.rotation.set(
                        Math.sin(t * 5.8 + bee.tiltP) * 0.15,
                        -tangent,
                        Math.sin(t * 4.9 + bee.tiltP + 0.6) * 0.2
                    );

                    // ── Wing flap: rapid sine oscillation on Z-axis (up/down arc) ──
                    // Uses abs(sin) so wings snap back sharply — more like a real insect
                    // than a smooth sine. Left/right wings mirror each other.
                    const flapAngle = bee.wingAmp * Math.abs(Math.sin(t * bee.wingSpeed + bee.wingPhase));
                    for (let wi = 0; wi < bee.wingNodes.length; wi++) {
                        const wn   = bee.wingNodes[wi];
                        const rest = bee.wingRest[wi];
                        // side = +1 right wing folds up, -1 left wing mirrors
                        wn.node.rotation.x = rest.x;
                        wn.node.rotation.y = rest.y;
                        wn.node.rotation.z = rest.z + flapAngle * wn.side;
                    }

                    if (bee.mixer) {
                        const dt = Math.min((now - bee.mixerLast) / 1000, 0.1);
                        bee.mixer.update(dt);
                        bee.mixerLast = now;
                    }
                }
            }
        }

        // Preload ChickenCoop ambient sound
        let _chickenCoopBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/ChickenCoop.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _chickenCoopBuffer = buf; console.log('ChickenCoop sound loaded OK'); })
            .catch(e => { console.warn('ChickenCoop sound fetch error:', e); });

        // ── Spatial proximity sound engine ────────────────────────────────────
        // Each entry: { building, source, panner, gain }
        // We keep one looping source per placed hive/coop. Sources are created
        // lazily on first proximity and destroyed when the building is out of range
        // for more than SPATIAL_CULL_MS so we never leak AudioNodes.
        const HIVE_RANGE      = 14;   // metres — max audible distance
        const COOP_RANGE      = 14;
        const HIVE_VOL        = 0.55; // peak gain at distance 0
        const COOP_VOL        = 0.65;
        const SPATIAL_CULL_MS = 8000; // stop source after this long out of range

        // Map from building object → { source, panner, gain, lastInRange }
        const _hiveSources = new Map();
        const _coopSources = new Map();

        function _startSpatialSource(buffer, building, map, peakVol) {
            if (map.has(building)) return; // already playing
            if (!buffer || audioContext.state === 'suspended') return;
            const panner = audioContext.createPanner();
            panner.panningModel   = 'HRTF';
            panner.distanceModel  = 'inverse';
            panner.refDistance    = 1;
            panner.maxDistance    = 20;
            panner.rolloffFactor  = 1.2;
            panner.coneInnerAngle = 360;
            panner.coneOuterAngle = 360;
            const gain = audioContext.createGain();
            gain.gain.setValueAtTime(peakVol, audioContext.currentTime);
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.loop   = true;
            source.connect(panner);
            panner.connect(gain);
            gain.connect(audioContext.destination);
            source.start();
            map.set(building, { source, panner, gain, lastInRange: Date.now() });
        }

        function _stopSpatialSource(building, map) {
            const entry = map.get(building);
            if (!entry) return;
            try { entry.gain.gain.setTargetAtTime(0, audioContext.currentTime, 0.3); }
            catch(e) {}
            setTimeout(() => {
                try { entry.source.stop(); } catch(e) {}
            }, 400);
            map.delete(building);
        }

        function _updateSpatialSources(map, buffer, range, peakVol) {
            // Update listener position + orientation from camera
            const lx = camera.position.x, ly = camera.position.y, lz = camera.position.z;
            const al = audioContext.listener;
            if (al.positionX) {
                al.positionX.setValueAtTime(lx, audioContext.currentTime);
                al.positionY.setValueAtTime(ly, audioContext.currentTime);
                al.positionZ.setValueAtTime(lz, audioContext.currentTime);
                // Forward vector from camera quaternion
                const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                const up  = new THREE.Vector3(0, 1,  0).applyQuaternion(camera.quaternion);
                al.forwardX.setValueAtTime(fwd.x, audioContext.currentTime);
                al.forwardY.setValueAtTime(fwd.y, audioContext.currentTime);
                al.forwardZ.setValueAtTime(fwd.z, audioContext.currentTime);
                al.upX.setValueAtTime(up.x, audioContext.currentTime);
                al.upY.setValueAtTime(up.y, audioContext.currentTime);
                al.upZ.setValueAtTime(up.z, audioContext.currentTime);
            } else {
                // Legacy Firefox API
                al.setPosition(lx, ly, lz);
                const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                const up  = new THREE.Vector3(0, 1,  0).applyQuaternion(camera.quaternion);
                al.setOrientation(fwd.x, fwd.y, fwd.z, up.x, up.y, up.z);
            }

            const now = Date.now();
            for (const [b, entry] of map.entries()) {
                const dist = b.position.distanceTo(camera.position);
                if (dist < range) {
                    entry.lastInRange = now;
                    // Move panner to building world position
                    const bx = b.position.x, by = b.position.y + 1, bz = b.position.z;
                    if (entry.panner.positionX) {
                        entry.panner.positionX.setValueAtTime(bx, audioContext.currentTime);
                        entry.panner.positionY.setValueAtTime(by, audioContext.currentTime);
                        entry.panner.positionZ.setValueAtTime(bz, audioContext.currentTime);
                    } else {
                        entry.panner.setPosition(bx, by, bz);
                    }
                    // Distance-based gain envelope on top of panner rolloff
                    const vol = Math.max(0, (1 - dist / range)) * peakVol;
                    entry.gain.gain.setTargetAtTime(vol, audioContext.currentTime, 0.2);
                } else if (now - entry.lastInRange > SPATIAL_CULL_MS) {
                    _stopSpatialSource(b, map);
                }
            }
        }

        // Preload furnace sound
        let _furnaceBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/furnace.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _furnaceBuffer = buf; console.log('Furnace sound loaded OK'); })
            .catch(e => { console.error('Furnace sound fetch error:', e); });

        function startFireSound() {
            if (fireSound) return;
            if (!_campfireBuffer) return;
            fireGainNode = audioContext.createGain();
            fireGainNode.gain.setValueAtTime(0.0, audioContext.currentTime);
            fireGainNode.connect(audioContext.destination);
            fireSound = audioContext.createBufferSource();
            fireSound.buffer = _campfireBuffer;
            fireSound.loop = true;
            fireSound.connect(fireGainNode);
            fireSound.start();
        }

        function stopFireSound() {
            if (fireSound) {
                fireGainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                setTimeout(() => {
                    if (fireSound) { try { fireSound.stop(); } catch(e){} fireSound = null; }
                    fireGainNode = null;
                }, 600);
            }
        }

        function startFurnaceSound() {
            if (furnaceSound) return;
            if (!_furnaceBuffer) return;
            furnaceGainNode = audioContext.createGain();
            furnaceGainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
            furnaceGainNode.connect(audioContext.destination);
            furnaceSound = audioContext.createBufferSource();
            furnaceSound.buffer = _furnaceBuffer;
            furnaceSound.loop = true;
            furnaceSound.connect(furnaceGainNode);
            furnaceSound.start();
        }

        function stopFurnaceSound() {
            if (furnaceSound) {
                furnaceGainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                setTimeout(() => {
                    if (furnaceSound) { try { furnaceSound.stop(); } catch(e){} furnaceSound = null; }
                    furnaceGainNode = null;
                }, 600);
            }
        }
        
        // ===== CRAFTING SYSTEM =====
        // ? IMPORTANT FOR DEVELOPERS: When adding new items to any recipe system (craftingRecipes, 
        // workbenchRecipes, buildingBenchRecipes, furnaceRecipes, or buildingTypes), make sure to:
        // 1. Add an icon to the itemIcons object above (search for "const itemIcons")
        // 2. OR use registerItem('item_name', '\u2753', 'Category') to register it programmatically
        // 3. The admin menu will automatically include all items from all recipe systems
        // 4. Run validateAllItemsHaveIcons() in console to check for missing icons
        const craftingRecipes = {
            fishing_rod: {
                name: '🎣 Fishing Rod',
                cost: { wood: 4, fiber: 3, sticks: 2 },
                type: 'tool'
            },
            axe: {
                name: '\ud83e\ude93 Wooden Axe',
                cost: { wood: 3, stone: 2 },
                type: 'tool'
            },
            pickaxe: {
                name: '\u26cf\ufe0f Stone Pickaxe',
                cost: { wood: 2, stone: 4 },
                type: 'tool'
            },
            sword: {
                name: '\u2694\ufe0f Stone Sword',
                cost: { wood: 2, stone: 3 },
                type: 'weapon'
            },
            spear: {
                name: '\ud83d\udde1\ufe0f Wooden Spear',
                cost: { wood: 4, fiber: 2 },
                type: 'weapon'
            },
            building_hammer: {
                name: '\ud83d\udd28 Building Hammer',
                cost: { wood: 3, stone: 2 },
                type: 'tool'
            },
            sleeping_bag: {
                name: '\ud83d\udecf\ufe0f Sleeping Bag',
                cost: { fiber: 10, wood: 2 },
                type: 'building'
            },
            workbench: {
                name: '\ud83d\udd27 Workbench',
                cost: { wood: 10, stone: 5 },
                type: 'crafting_station'
            },
            furnace: {
                name: '\ud83d\udd25 Furnace',
                cost: { wood: 5, stone: 15 },
                type: 'crafting_station'
            },
            storage_box: {
                name: '📦 Large Storage',
                cost: { wood: 8, stone: 2 },
                type: 'building'
            },
            cloth_helmet: {
                name: '🪖 Cloth Hood',
                cost: { cloth: 3 },
                type: 'armor'
            },
            cloth_vest: {
                name: '🧥 Cloth Vest',
                cost: { cloth: 5 },
                type: 'armor'
            },
            cloth_gloves: {
                name: '🧤 Cloth Gloves',
                cost: { cloth: 2 },
                type: 'armor'
            },
            cloth_pants: {
                name: '👖 Cloth Pants',
                cost: { cloth: 4 },
                type: 'armor'
            },
            cloth_boots: {
                name: '🥾 Cloth Boots',
                cost: { cloth: 3 },
                type: 'armor'
            },
        };
        
        // Workbench recipes (accessed via workbench)
        const workbenchRecipes = {
            bow: {
                name: '\ud83c\udff9 Wooden Bow',
                cost: { wood: 5, fiber: 3 },
                type: 'weapon'
            },
            arrows: {
                name: '\ud83c\udff9 Arrows (x5)',
                cost: { wood: 2, stone: 1 },
                count: 5,
                type: 'ammo'
            },
            pistol: {
                name: '🔫 Pistol',
                cost: { iron_ingot: 20 },
                type: 'weapon'
            },
            pistol_ammo: {
                name: '🔫 Pistol Ammo (x8)',
                cost: { iron_ingot: 2, gunpowder: 1 },
                count: 8,
                type: 'ammo'
            },
            machine_gun: {
                name: '🔫 Machine Gun',
                cost: { iron_ingot: 35, gunpowder: 5, crystal_shard: 4 },
                type: 'weapon'
            },
            mg_ammo: {
                name: '🔫 MG Ammo (x20)',
                cost: { iron_ingot: 4, gunpowder: 2 },
                count: 20,
                type: 'ammo'
            },
            bandage: {
                name: '\ud83e\ude79 Bandage',
                cost: { fiber: 3 },
                type: 'consumable'
            },
            medkit: {
                name: '\ud83c\udfe5 Medkit',
                cost: { bandage: 2, fiber: 6 },
                type: 'consumable'
            },
            code_lock: {
                name: '\ud83d\udd12 Code Lock',
                cost: { iron_ingot: 8 },
                type: 'tool'
            },
            gunpowder: {
                name: '\ud83d\udca5 Gunpowder (x10)',
                cost: { coal: 1, smelted_sulfur: 1 },
                count: 10,
                type: 'material'
            },
            small_backpack: {
                name: '🎒 Small Backpack',
                cost: { fiber: 15, sticks: 8, wood: 5 },
                type: 'equipment'
            },
            building_bench: {
                name: '\ud83e\ude9a Building Bench',
                cost: { wood: 8, stone: 6 },
                type: 'tool'
            },
            sewing_table: {
                name: '\ud83e\uddf5 Sewing Table',
                cost: { wood: 8, iron_ingot: 3 },
                type: 'tool'
            },
            recycler: {
                name: '\u267b\ufe0f Recycler',
                cost: { iron_ingot: 15, wood: 5 },
                type: 'tool'
            }
        };
        
        // Sewing Table recipes (accessed via sewing table)
        const sewingTableRecipes = {
            cloth: {
                name: '\ud83e\uddf5 Cloth',
                cost: { fiber: 5 },
                type: 'material'
            },
            curtain_red: {
                name: '\ud83d\udd34 Red Curtain',
                cost: { cloth: 2 },
                type: 'decoration'
            },
            curtain_blue: {
                name: '\ud83d\udd35 Blue Curtain',
                cost: { cloth: 2 },
                type: 'decoration'
            },
            curtain_green: {
                name: '\ud83d\udfe2 Green Curtain',
                cost: { cloth: 2 },
                type: 'decoration'
            },
            curtain_white: {
                name: '\u2b1c White Curtain',
                cost: { cloth: 2 },
                type: 'decoration'
            },
            curtain_beige: {
                name: '\ud83d\udfe4 Beige Curtain',
                cost: { cloth: 2 },
                type: 'decoration'
            },
            floor_rug_red: {
                name: '\ud83d\udfe5 Red Floor Rug',
                cost: { fiber: 8 },
                type: 'decoration'
            },
            floor_rug_blue: {
                name: '\ud83d\udfe6 Blue Floor Rug',
                cost: { fiber: 8 },
                type: 'decoration'
            },
            floor_rug_green: {
                name: '\ud83d\udfe9 Green Floor Rug',
                cost: { fiber: 8 },
                type: 'decoration'
            },
            sofa: {
                name: '🛋️ Sofa',
                cost: { wood: 6, cloth: 4, fiber: 3 },
                type: 'furniture'
            },
            bookcase: {
                name: '📚 Bookcase',
                cost: { wood: 10, iron_ingot: 2 },
                type: 'furniture'
            },
            table: {
                name: '🪑 Table',
                cost: { wood: 6, iron_ingot: 1 },
                type: 'furniture'
            },
            chair: {
                name: '🪑 Chair',
                cost: { wood: 4, cloth: 2 },
                type: 'furniture'
            },
            wall_shelf_b: {
                name: '🪵 Wall Shelf B',
                cost: { wood: 5, iron_ingot: 1 },
                type: 'furniture'
            },
            candle: {
                name: '🕯️ Candle',
                cost: { cloth: 1, stone: 1 },
                type: 'decoration'
            },
            wall_light: {
                name: '💡 Wall Light',
                cost: { iron_ingot: 3, cloth: 1 },
                type: 'decoration'
            },
            bee_hive: {
                name: '🐝 Bee Hive',
                cost: { wood: 12, fiber: 6, sticks: 4 },
                type: 'building'
            },
            chicken_coop: {
                name: '🐔 Chicken Coop',
                cost: { wood: 16, fiber: 8, iron_ingot: 2 },
                type: 'building'
            },
            oil_smelter: {
                name: '🛢️ Oil Smelter',
                cost: { iron_ingot: 12, stone: 8, coal: 4 },
                type: 'crafting_station'
            },
            // Cloth Armor (Starter - 1% reduction per piece)
            cloth_helmet: {
                name: '🪖 Cloth Hood',
                cost: { cloth: 3 },
                type: 'armor'
            },
            cloth_vest: {
                name: '🧥 Cloth Vest',
                cost: { cloth: 5 },
                type: 'armor'
            },
            cloth_gloves: {
                name: '🧤 Cloth Gloves',
                cost: { cloth: 2 },
                type: 'armor'
            },
            cloth_pants: {
                name: '👖 Cloth Pants',
                cost: { cloth: 4 },
                type: 'armor'
            },
            cloth_boots: {
                name: '🥾 Cloth Boots',
                cost: { cloth: 3 },
                type: 'armor'
            },
            // Bronze Armor (Early Game - 2% reduction per piece)
            bronze_helmet: {
                name: '\u26d1\ufe0f Bronze Helmet',
                cost: { stone: 8, iron_ore: 3 },
                type: 'armor'
            },
            bronze_vest: {
                name: '\ud83e\uddba Bronze Vest',
                cost: { stone: 12, iron_ore: 5 },
                type: 'armor'
            },
            bronze_gloves: {
                name: '\ud83e\udde4 Bronze Gloves',
                cost: { stone: 6, iron_ore: 2 },
                type: 'armor'
            },
            bronze_pants: {
                name: '\ud83d\udc56 Bronze Pants',
                cost: { stone: 10, iron_ore: 4 },
                type: 'armor'
            },
            bronze_boots: {
                name: '\ud83d\udc62 Bronze Boots',
                cost: { stone: 8, iron_ore: 3 },
                type: 'armor'
            },
            // Iron Armor (Mid Game - 5% reduction per piece)
            iron_helmet: {
                name: '\u26d1\ufe0f Iron Helmet',
                cost: { iron_ingot: 10 },
                type: 'armor'
            },
            iron_vest: {
                name: '\ud83e\uddba Iron Vest',
                cost: { iron_ingot: 15 },
                type: 'armor'
            },
            iron_gloves: {
                name: '\ud83e\udde4 Iron Gloves',
                cost: { iron_ingot: 8 },
                type: 'armor'
            },
            iron_pants: {
                name: '\ud83d\udc56 Iron Pants',
                cost: { iron_ingot: 12 },
                type: 'armor'
            },
            iron_boots: {
                name: '\ud83d\udc62 Iron Boots',
                cost: { iron_ingot: 10 },
                type: 'armor'
            },
            // Thermal Clothing — high insulation, low armour (sewing table exclusive)
            thermal_hood: {
                name: '🧣 Thermal Hood',
                cost: { cloth: 4, fiber: 6 },
                type: 'armor'
            },
            thermal_jacket: {
                name: '🧥 Thermal Jacket',
                cost: { cloth: 7, fiber: 10 },
                type: 'armor'
            },
            thermal_gloves: {
                name: '🧤 Thermal Gloves',
                cost: { cloth: 3, fiber: 4 },
                type: 'armor'
            },
            thermal_pants: {
                name: '👖 Thermal Pants',
                cost: { cloth: 6, fiber: 8 },
                type: 'armor'
            },
            thermal_boots: {
                name: '🥾 Thermal Boots',
                cost: { cloth: 4, fiber: 6 },
                type: 'armor'
            }
        };
        const recycleRecipes = {
            // Tools
            'axe': { wood: 2, stone: 1 },
            'pickaxe': { wood: 1, stone: 2 },
            'sword': { wood: 1, stone: 2 },
            'spear': { wood: 2, fiber: 1 },
            'bow': { wood: 3, fiber: 2 },
            'building_hammer': { wood: 2, stone: 1 },
            
            // Buildings
            'wall': { wood: 3 },
            'floor': { wood: 2 },
            'ceiling': { wood: 2 },
            'door': { wood: 3, fiber: 1 },
            'campfire': { wood: 3, stone: 2 },
            'cooking_station': { stone: 6, iron_ingot: 2, wood: 3 },
            'workbench': { wood: 5, stone: 3 },
            'building_bench': { wood: 4, stone: 3 },
            'furnace': { wood: 3, stone: 8 },
            'storage_box': { wood: 4, stone: 1 },
            'small_storage_box': { wood: 2, stone: 1 },
            'storage_shelf': { iron_ingot: 2 },
            'wall_shelf': { wood: 6, iron_ingot: 2 },
            'sewing_table': { wood: 4, iron_ingot: 2 },
            
            // Consumables/Materials
            'arrows': { wood: 1 },
            'pistol': { iron_ingot: 10 },
            'machine_gun': { iron_ingot: 17, crystal_shard: 2 },
            'mg_ammo': { iron_ingot: 2 },
            'pistol_ammo': { iron_ingot: 1 },
            'cloth': { fiber: 3 },
            'bandage': { fiber: 2 },
            'medkit': { fiber: 3 },
            'code_lock': { iron_ingot: 4 },
            
            // Armor (50% return)
            'cloth_helmet': { cloth: 1 },
            'cloth_vest': { cloth: 2 },
            'cloth_gloves': { cloth: 1 },
            'cloth_pants': { cloth: 2 },
            'cloth_boots': { cloth: 1 },
            'iron_helmet': { iron_ingot: 5 },
            'iron_vest': { iron_ingot: 8 },
            'iron_gloves': { iron_ingot: 4 },
            'iron_pants': { iron_ingot: 6 },
            'iron_boots': { iron_ingot: 5 },
            'bronze_helmet': { stone: 4, iron_ore: 2 },
            'bronze_vest': { stone: 6, iron_ore: 3 },
            'bronze_gloves': { stone: 3, iron_ore: 1 },
            'bronze_pants': { stone: 5, iron_ore: 2 },
            'bronze_boots': { stone: 4, iron_ore: 2 },
            'thermal_hood': { cloth: 2, fiber: 3 },
            'thermal_jacket': { cloth: 4, fiber: 5 },
            'thermal_gloves': { cloth: 1, fiber: 2 },
            'thermal_pants': { cloth: 3, fiber: 4 },
            'thermal_boots': { cloth: 2, fiber: 3 },
            
            // Decorations
            'curtain_red': { cloth: 1 },
            'curtain_blue': { cloth: 1 },
            'curtain_green': { cloth: 1 },
            'curtain_white': { cloth: 1 },
            'curtain_beige': { cloth: 1 },
            'floor_rug_red': { fiber: 4 },
            'floor_rug_blue': { fiber: 4 },
            'floor_rug_green': { fiber: 4 }
        };
        
        // Recycler state
        const recyclerState = {
            inputSlots: [null, null, null, null, null],
            outputSlots: [null, null, null, null, null],
            isProcessing: false,
            currentSlot: 0,
            progress: 0,
            processTime: 3000,
            isPaused: false,        // Track if we're in pause between items
            pauseTime: 500,         // 0.5 second pause between items in same slot
            pauseProgress: 0        // Track pause progress
        };
        
        // Well State — persists progress across rain sessions
        const waterCatcherState = {
            outputSlots: [null, null, null, null, null], // up to 5 water bottles waiting to be collected
            progress: 0,         // 0-100 fill progress for current bottle (real-time ms)
            fillTime: 120000,    // 2 real minutes per bottle (120,000 ms)
            isOpen: false        // whether UI is open
        };
        
        // Building Bench recipes
        const buildingBenchRecipes = {
            wall: {
                name: '\ud83e\uddf1 Wooden Wall',
                cost: { wood: 5 },
                type: 'building_piece'
            },
            window_wall: {
                name: '\ud83e\ude9f Window Wall',
                cost: { wood: 5, stone: 2 },
                type: 'building_piece'
            },
            floor: {
                name: '\ud83d\udfeb Wooden Floor',
                cost: { wood: 4 },
                type: 'building_piece'
            },
            ceiling: {
                name: '\ud83d\udfeb Wooden Ceiling',
                cost: { wood: 4 },
                type: 'building_piece'
            },
            ladder_ceiling: {
                name: '\ud83e\ude9c Ladder Ceiling',
                cost: { wood: 3 },
                type: 'building_piece'
            },
            stairs: {
                name: '\ud83e\ude9c Wooden Stairs',
                cost: { wood: 8, stone: 2 },
                type: 'building_piece'
            },
            corner_stairs_left: {
                name: '\ud83e\ude9c Corner Stairs (Left)',
                cost: { wood: 10, stone: 3 },
                type: 'building_piece'
            },
            corner_stairs_right: {
                name: '🪜 Corner Stairs (Right)',
                cost: { wood: 10, stone: 3 },
                create: async () => {
                    const g = new THREE.Group();
                    const plankMat  = await createWoodMaterial(0x9C7A3C, 0.82);
                    const supportMat = await createWoodMaterial(0x5C3A1E, 0.78);
                    const n=5, halfH=1.5, legD=2.0, stepW=1.8;
                    const stepH=halfH/n, stepD=legD/n;
                    for (let i=0;i<n;i++) {
                        const y=(i+1)*stepH, z=-2+i*stepD+stepD*0.5;
                        const tread=new THREE.Mesh(new THREE.BoxGeometry(stepW,0.06,stepD+0.02),plankMat.clone());
                        tread.position.set(-1.0,y-0.03,z); tread.castShadow=true; tread.receiveShadow=true; g.add(tread);
                        const riser=new THREE.Mesh(new THREE.BoxGeometry(stepW,stepH,0.06),supportMat.clone());
                        riser.position.set(-1.0,y-stepH*0.5,-2+i*stepD); g.add(riser);
                    }
                    const landing=new THREE.Mesh(new THREE.BoxGeometry(2.0,0.06,2.0),plankMat.clone());
                    landing.position.set(-1.0,halfH-0.03,1.0); landing.castShadow=true; landing.receiveShadow=true; g.add(landing);
                    for (let i=0;i<n;i++) {
                        const y=halfH+(i+1)*stepH, x=-2+i*stepD+stepD*0.5;
                        const tread=new THREE.Mesh(new THREE.BoxGeometry(stepD+0.02,0.06,stepW),plankMat.clone());
                        tread.position.set(x,y-0.03,1.0); tread.castShadow=true; tread.receiveShadow=true; g.add(tread);
                        const riser=new THREE.Mesh(new THREE.BoxGeometry(0.06,stepH,stepW),supportMat.clone());
                        riser.position.set(-2+i*stepD,y-stepH*0.5,1.0); g.add(riser);
                    }
                    g.userData.isStairs=true; g.userData.isCornerStairs=true; g.userData.cornerDir='right';
                    g.userData.collisionBox=new THREE.Box3().setFromObject(g); return g;
                }
            },
            ladder: {
                name: '\ud83e\ude9c Ladder',
                cost: { wood: 4 },
                type: 'building_piece'
            },
            door_frame: {
                name: '\ud83d\udeaa Door Frame',
                cost: { wood: 4 },
                type: 'building_piece'
            },
            double_door_frame: {
                name: '\ud83d\udeaa Double Door Frame',
                cost: { wood: 5 },
                type: 'building_piece'
            },
            door: {
                name: '🚪 Wooden Door',
                cost: { wood: 6, fiber: 2 },
                type: 'building_piece'
            },
            double_door: {
                name: '🚪 Double Wooden Door',
                cost: { wood: 10, fiber: 3 },
                type: 'building_piece'
            },
            stone_door: {
                name: '🪨 Stone Door',
                cost: { wood: 8, stone: 12 },
                type: 'building_piece'
            },
            stone_double_door: {
                name: '🪨 Stone Double Door',
                cost: { wood: 12, stone: 20 },
                type: 'building_piece'
            },
            metal_door: {
                name: '⚙️ Metal Door',
                cost: { iron_ingot: 6, wood: 4 },
                type: 'building_piece'
            },
            metal_double_door: {
                name: '⚙️ Metal Double Door',
                cost: { iron_ingot: 10, wood: 6 },
                type: 'building_piece'
            },
            campfire: {
                name: '\ud83d\udd25 Campfire',
                cost: { wood: 5, stone: 3 },
                type: 'building_piece'
            },
            cooking_station: {
                name: '\ud83c\udf73 Cooking Station',
                cost: { stone: 12, iron_ingot: 4, wood: 6 },
                type: 'building_piece'
            },
            small_storage_box: {
                name: '\ud83d\udce6 Small Storage',
                cost: { wood: 4, stone: 1 },
                type: 'building_piece'
            },
            storage_shelf: {
                name: '\ud83d\udce6 Storage Shelf',
                cost: { iron_ingot: 4 },
                type: 'building_piece'
            },
            planter_box: {
                name: '\ud83c\udf31 Planter Box (4 Slot)',
                cost: { wood: 12, stone: 4 },
                type: 'building_piece'
            },
            large_planter: {
                name: '\ud83c\udf31 Large Planter (12 Slot)',
                cost: { wood: 28, stone: 10 },
                type: 'building_piece'
            },
            water_catcher: {
                name: '🪣 Well',
                cost: { wood: 8, stone: 4, fiber: 6 },
                type: 'building_piece'
            }
        };
        
        // Furnace recipes
        const furnaceRecipes = {
            iron_ingot: {
                name: '\ud83d\udd29 Iron Ingot',
                cost: { iron_ore: 2 },
                type: 'material'
            }
        };
        
        function updateCraftingMenu() {
            const list = document.getElementById('crafting-list');
            list.innerHTML = '';
            
            // Group recipes by category
            const categories = {
                'Tools': [],
                'Weapons': [],
                'Armor': [],
                'Materials': [],
                'Consumables': []
            };
            
            for (let id in craftingRecipes) {
                const recipe = craftingRecipes[id];
                if (!recipe.type) recipe.type = 'materials';
                
                const categoryName = recipe.type === 'tool' ? 'Tools' :
                                    recipe.type === 'weapon' ? 'Weapons' :
                                    recipe.type === 'armor' ? 'Armor' :
                                    recipe.type === 'consumable' ? 'Consumables' : 'Materials';
                
                categories[categoryName].push({ id, recipe });
            }
            
            // Create grid for each category
            for (let categoryName in categories) {
                if (categories[categoryName].length === 0) continue;
                
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'menu-category';
                
                const titleDiv = document.createElement('div');
                titleDiv.className = 'category-title';
                titleDiv.textContent = categoryName;
                categoryDiv.appendChild(titleDiv);
                
                const gridDiv = document.createElement('div');
                gridDiv.className = 'category-grid';
                
                categories[categoryName].forEach(({ id, recipe }) => {
                    const canCraft = Object.entries(recipe.cost).every(
                        ([resource, amount]) => inventory[resource] >= amount
                    );
                    
                    const item = document.createElement('div');
                    item.className = 'grid-item' + (canCraft ? '' : ' disabled');
                    
                    const icon = itemIcons[id] || '\u2753';
                    const costText = Object.entries(recipe.cost)
                        .map(([r, a]) => `${a} ${r}`)
                        .join(', ');
                    
                    item.innerHTML = `
                        <div class="grid-item-icon">${icon}</div>
                        <div class="grid-item-name">${recipe.name.replace(/^[^\s]+\s/, '')}</div>
                        <div class="grid-item-cost">${costText}</div>
                    `;
                    
                    if (canCraft) {
                        item.onclick = () => craftItem(id, recipe);
                    }
                    
                    gridDiv.appendChild(item);
                });
                
                categoryDiv.appendChild(gridDiv);
                list.appendChild(categoryDiv);
            }
        }
        
        function craftItem(id, recipe) {
            for (let resource in recipe.cost) {
                inventory[resource] -= recipe.cost[resource];
            }
            
            // Add crafted item to inventory
            if (!inventory[id]) inventory[id] = 0;
            inventory[id]++;
            
            showMessage(`\u2705 Crafted ${recipe.name}!`);
            playCollectSound();
            updateUI();
            updateCraftingMenu();
        }
        
        // Workbench Menu
        let currentWorkbench = null;
        
        function openWorkbenchMenu(workbench) {
            currentWorkbench = workbench;
            playBenchSound();
            document.getElementById('workbench-menu').style.display = 'block';
            document.getElementById('workbench-menu').querySelector('.menu-title').textContent = '\ud83d\udd27 Workbench';
            uiOpen();
            updateWorkbenchMenu();
        }
        
        function closeWorkbenchMenu() {
            closeAllUI();
        }
        
        function updateWorkbenchMenu() {
            const list = document.getElementById('workbench-list');
            list.innerHTML = '';
            
            // Group recipes by category
            const categories = {
                'Weapons': [],
                'Ammo': [],
                'Tools': [],
                'Consumables': [],
                'Materials': []
            };
            
            for (let id in workbenchRecipes) {
                const recipe = workbenchRecipes[id];
                const categoryName = recipe.type === 'tool' ? 'Tools' :
                                     recipe.type === 'ammo' ? 'Ammo' :
                                     recipe.type === 'consumable' ? 'Consumables' :
                                     recipe.type === 'material' ? 'Materials' : 'Weapons';
                categories[categoryName].push({ id, recipe });
            }
            
            // Create grid for each category
            for (let categoryName in categories) {
                if (categories[categoryName].length === 0) continue;
                
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'menu-category';
                
                const titleDiv = document.createElement('div');
                titleDiv.className = 'category-title';
                titleDiv.textContent = categoryName;
                categoryDiv.appendChild(titleDiv);
                
                const gridDiv = document.createElement('div');
                gridDiv.className = 'category-grid';
                
                categories[categoryName].forEach(({ id, recipe }) => {
                    const canCraft = Object.entries(recipe.cost).every(
                        ([resource, amount]) => inventory[resource] >= amount
                    );
                    
                    const item = document.createElement('div');
                    item.className = 'grid-item' + (canCraft ? '' : ' disabled');
                    
                    const icon = itemIcons[id] || '\u2753';
                    const costText = Object.entries(recipe.cost)
                        .map(([r, a]) => `${a} ${r}`)
                        .join(', ');
                    
                    item.innerHTML = `
                        <div class="grid-item-icon">${icon}</div>
                        <div class="grid-item-name">${recipe.name.replace(/^[^\s]+\s/, '')}</div>
                        <div class="grid-item-cost">${costText}</div>
                    `;
                    
                    if (canCraft) {
                        item.onclick = () => craftWorkbenchItem(id, recipe);
                    }
                    
                    gridDiv.appendChild(item);
                });
                
                categoryDiv.appendChild(gridDiv);
                list.appendChild(categoryDiv);
            }
        }
        
        function craftWorkbenchItem(id, recipe) {
            for (let resource in recipe.cost) {
                inventory[resource] -= recipe.cost[resource];
            }
            
            if (!inventory[id]) inventory[id] = 0;
            inventory[id] += recipe.count || 1;
            
            showMessage(`\u2705 Crafted ${recipe.name}!`);
            playCollectSound();
            updateUI();
            updateWorkbenchMenu();
        }
        
        // Building Bench Menu
        let currentBuildingBench = null;
        
        function openBuildingBenchMenu(bench) {
            currentBuildingBench = bench;
            playBenchSound();
            document.getElementById('workbench-menu').style.display = 'block';
            document.getElementById('workbench-menu').querySelector('.menu-title').textContent = '\ud83e\ude9a Building Bench';
            uiOpen();
            updateBuildingBenchMenu();
        }
        
        function closeBuildingBenchMenu() {
            closeAllUI();
        }
        
        function updateBuildingBenchMenu() {
            const list = document.getElementById('workbench-list');
            list.innerHTML = '';
            
            // Group recipes by category
            const categories = {
                'Structure': [],
                'Doors & Windows': [],
                'Crafting Stations': [],
                'Storage': [],
                'Decorations': []
            };
            
            for (let id in buildingBenchRecipes) {
                const recipe = buildingBenchRecipes[id];
                
                let categoryName = 'Structure';
                if (recipe.type === 'crafting_station') categoryName = 'Crafting Stations';
                else if (recipe.type === 'storage') categoryName = 'Storage';
                else if (recipe.type === 'decoration') categoryName = 'Decorations';
                else if (id.includes('door') || id.includes('window')) categoryName = 'Doors & Windows';
                
                categories[categoryName].push({ id, recipe });
            }
            
            // Create grid for each category
            for (let categoryName in categories) {
                if (categories[categoryName].length === 0) continue;
                
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'menu-category';
                
                const titleDiv = document.createElement('div');
                titleDiv.className = 'category-title';
                titleDiv.textContent = categoryName;
                categoryDiv.appendChild(titleDiv);
                
                const gridDiv = document.createElement('div');
                gridDiv.className = 'category-grid';
                
                categories[categoryName].forEach(({ id, recipe }) => {
                    const canCraft = Object.entries(recipe.cost).every(
                        ([resource, amount]) => inventory[resource] >= amount
                    );
                    
                    const item = document.createElement('div');
                    item.className = 'grid-item' + (canCraft ? '' : ' disabled');
                    
                    const icon = itemIcons[id] || '\u2753';
                    const costText = Object.entries(recipe.cost)
                        .map(([r, a]) => `${a} ${r}`)
                        .join(', ');
                    
                    item.innerHTML = `
                        <div class="grid-item-icon">${icon}</div>
                        <div class="grid-item-name">${recipe.name.replace(/^[^\s]+\s/, '')}</div>
                        <div class="grid-item-cost">${costText}</div>
                    `;
                    
                    if (canCraft) {
                        item.onclick = () => craftBuildingItem(id, recipe);
                    }
                    
                    gridDiv.appendChild(item);
                });
                
                categoryDiv.appendChild(gridDiv);
                list.appendChild(categoryDiv);
            }
        }
        
        function craftBuildingItem(id, recipe) {
            for (let resource in recipe.cost) {
                inventory[resource] -= recipe.cost[resource];
            }
            
            if (!inventory[id]) inventory[id] = 0;
            inventory[id]++;
            
            showMessage(`\u2705 Crafted ${recipe.name}!`);
            playCollectSound();
            updateUI();
            updateBuildingBenchMenu();
        }
        
        // Sewing Table Menu
        let currentSewingTable = null;
        
        function openSewingTableMenu(table) {
            currentSewingTable = table;
            playBenchSound();
            document.getElementById('workbench-menu').style.display = 'block';
            document.getElementById('workbench-menu').querySelector('.menu-title').textContent = '\ud83e\uddf5 Sewing Table';
            uiOpen();
            updateSewingTableMenu();
        }
        
        function closeSewingTableMenu() {
            closeAllUI();
        }

        // Smart dispatcher — close whichever bench/table menu is currently open
        function closeAnyWorkbenchMenu() {
            closeAllUI();
        }
        
        function updateSewingTableMenu() {
            const list = document.getElementById('workbench-list');
            list.innerHTML = '';
            
            // Group recipes by category
            const categories = {
                'Cloth Armor': [],
                'Bronze Armor': [],
                'Iron Armor': [],
                'Materials': [],
                'Curtains': [],
                'Rugs': []
            };
            
            for (let id in sewingTableRecipes) {
                const recipe = sewingTableRecipes[id];
                
                let categoryName = 'Materials';
                if (id.startsWith('cloth_')) categoryName = 'Cloth Armor';
                else if (id.startsWith('bronze_')) categoryName = 'Bronze Armor';
                else if (id.startsWith('iron_')) categoryName = 'Iron Armor';
                else if (id.includes('curtain')) categoryName = 'Curtains';
                else if (id.includes('rug')) categoryName = 'Rugs';
                
                categories[categoryName].push({ id, recipe });
            }
            
            // Create grid for each category
            for (let categoryName in categories) {
                if (categories[categoryName].length === 0) continue;
                
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'menu-category';
                
                const titleDiv = document.createElement('div');
                titleDiv.className = 'category-title';
                titleDiv.textContent = categoryName;
                categoryDiv.appendChild(titleDiv);
                
                const gridDiv = document.createElement('div');
                gridDiv.className = 'category-grid';
                
                categories[categoryName].forEach(({ id, recipe }) => {
                    const canCraft = Object.entries(recipe.cost).every(
                        ([resource, amount]) => inventory[resource] >= amount
                    );
                    
                    const item = document.createElement('div');
                    item.className = 'grid-item' + (canCraft ? '' : ' disabled');
                    
                    const icon = itemIcons[id] || '\u2753';
                    const costText = Object.entries(recipe.cost)
                        .map(([r, a]) => `${a} ${r}`)
                        .join(', ');
                    
                    item.innerHTML = `
                        <div class="grid-item-icon">${icon}</div>
                        <div class="grid-item-name">${recipe.name.replace(/^[^\s]+\s/, '')}</div>
                        <div class="grid-item-cost">${costText}</div>
                    `;
                    
                    if (canCraft) {
                        item.onclick = () => craftSewingItem(id, recipe);
                    }
                    
                    gridDiv.appendChild(item);
                });
                
                categoryDiv.appendChild(gridDiv);
                list.appendChild(categoryDiv);
            }
        }
        
        function craftSewingItem(id, recipe) {
            for (let resource in recipe.cost) {
                inventory[resource] -= recipe.cost[resource];
            }
            
            if (!inventory[id]) inventory[id] = 0;
            inventory[id] += recipe.count || 1;
            
            showMessage(`\u2705 Crafted ${recipe.name}!`);
            playCollectSound();
            updateUI();
            updateSewingTableMenu();
        }
        
        // ===== RECYCLER SYSTEM =====
        let currentRecycler = null;
        
        function openRecyclerMenu(recycler) {
            currentRecycler = recycler;
            playBenchSound();
            const recyclerMenu = document.getElementById('recycler-menu');
            const inventoryPanel = document.getElementById('inventory-panel');
            
            // Position recycler on the left
            recyclerMenu.style.display = 'block';
            recyclerMenu.style.left = '28%';
            recyclerMenu.style.transform = 'translate(-50%, -50%)';
            
            positionInventoryRight(inventoryPanel);
            inventoryPanel.style.display = 'block';
            uiOpen();
            updateInventoryDisplay();
            updateRecyclerDisplay();
        }
        
        function closeRecyclerMenu() {
            closeAllUI();
        }
        
        // ===== WATER CATCHER UI =====
        let currentWaterCatcher = null;
        
        // ── Bee Hive Menu ───────────────────────────────────────────────────
        let currentBeeHive = null;
        function openBeeHiveMenu(hive) {
            currentBeeHive = hive;
            const menu = document.getElementById('bee-hive-menu');
            if (!menu) return;
            uiOpen();
            updateBeeHiveDisplay();
            menu.style.display = 'block';
        }
        function closeBeeHiveMenu() {
            const menu = document.getElementById('bee-hive-menu');
            if (menu) menu.style.display = 'none';
            currentBeeHive = null;
            setTimeout(_tryLock, 80);
        }
        function collectHoney() {
            if (!currentBeeHive) return;
            const data = currentBeeHive.userData.beeHiveData;
            if (!data || !data.isReady) return;
            const amount = data.honey;
            _addToInventory('honey', amount);
            data.honey = 0;
            data.isReady = false;
            data.lastCollect = Date.now();
            showMessage(`🍯 Collected ${amount} Honey!`);
            updateBeeHiveDisplay();
            updateInventoryUI();
        }

        function collectEggs() {
            if (!currentChickenCoop) return;
            const data = currentChickenCoop.userData.chickenCoopData;
            if (!data || !data.isReady) return;
            const amount = data.eggs;
            _addToInventory('egg', amount);
            data.eggs = 0;
            data.isReady = false;
            data.lastCollect = Date.now();
            showMessage(`🥚 Collected ${amount} Egg(s)!`);
            updateChickenCoopDisplay();
            updateInventoryUI();
        }

        function updateBeeHiveDisplay() {
            const menu = document.getElementById('bee-hive-menu');
            if (!menu || !currentBeeHive) return;
            const data = currentBeeHive.userData.beeHiveData || { honey: 0, isReady: false, lastCollect: Date.now() };
            document.getElementById('bh-honey-count').textContent = data.honey;
            const fillEl = document.getElementById('bh-progress-fill');
            const textEl = document.getElementById('bh-progress-text');
            const btn    = document.getElementById('bh-collect-btn');
            if (data.isReady || data.honey >= BEE_MAX) {
                document.getElementById('bh-status').textContent = '🍯 Honey ready to collect!';
                if (fillEl) fillEl.style.width = '100%';
                if (textEl) textEl.textContent = 'Ready!';
                btn.disabled = false;
                btn.style.opacity = '1';
            } else {
                document.getElementById('bh-status').textContent = '🐝 Bees are working...';
                const elapsed = Date.now() - (data.lastCollect || Date.now());
                const pct     = Math.min(100, (elapsed / BEE_INTERVAL_MS) * 100);
                const secsLeft = Math.max(0, Math.ceil((BEE_INTERVAL_MS - elapsed) / 1000));
                const mins = Math.floor(secsLeft / 60);
                const secs = secsLeft % 60;
                if (fillEl) fillEl.style.width = pct.toFixed(1) + '%';
                if (textEl) textEl.textContent = data.honey >= BEE_MAX ? 'Ready!' : `${mins}:${String(secs).padStart(2,'0')}`;
                btn.disabled = true;
                btn.style.opacity = '0.5';
            }
        }

        // ── Chicken Coop Menu ──────────────────────────────────────────────
        let currentChickenCoop = null;
        function openChickenCoopMenu(coop) {
            currentChickenCoop = coop;
            const menu = document.getElementById('chicken-coop-menu');
            if (!menu) return;
            uiOpen();
            updateChickenCoopDisplay();
            menu.style.display = 'block';
        }
        function closeChickenCoopMenu() {
            const menu = document.getElementById('chicken-coop-menu');
            if (menu) menu.style.display = 'none';
            currentChickenCoop = null;
            setTimeout(_tryLock, 80);
        }
        function updateChickenCoopDisplay() {
            const menu = document.getElementById('chicken-coop-menu');
            if (!menu || !currentChickenCoop) return;
            const data = currentChickenCoop.userData.chickenCoopData || { eggs: 0, isReady: false, lastCollect: Date.now() };
            document.getElementById('cc-egg-count').textContent = data.eggs;
            const fillEl = document.getElementById('cc-progress-fill');
            const textEl = document.getElementById('cc-progress-text');
            const btn    = document.getElementById('cc-collect-btn');
            if (data.isReady || data.eggs >= COOP_MAX) {
                document.getElementById('cc-status').textContent = '🥚 Eggs ready to collect!';
                if (fillEl) fillEl.style.width = '100%';
                if (textEl) textEl.textContent = 'Ready!';
                btn.disabled = false;
                btn.style.opacity = '1';
            } else {
                document.getElementById('cc-status').textContent = '🐔 Chickens are laying...';
                const elapsed = Date.now() - (data.lastCollect || Date.now());
                const pct     = Math.min(100, (elapsed / COOP_INTERVAL_MS) * 100);
                const secsLeft = Math.max(0, Math.ceil((COOP_INTERVAL_MS - elapsed) / 1000));
                const mins = Math.floor(secsLeft / 60);
                const secs = secsLeft % 60;
                if (fillEl) fillEl.style.width = pct.toFixed(1) + '%';
                if (textEl) textEl.textContent = data.eggs >= COOP_MAX ? 'Ready!' : `${mins}:${String(secs).padStart(2,'0')}`;
                btn.disabled = true;
                btn.style.opacity = '0.5';
            }
        }

        // ── Expose to window so inline onclick handlers can reach them ──────
        window.closeBeeHiveMenu   = closeBeeHiveMenu;
        window.collectHoney       = collectHoney;
        window.closeChickenCoopMenu = closeChickenCoopMenu;
        window.collectEggs        = collectEggs;

        // ── Production ticks ────────────────────────────────────────────────
        // Honey: 1 jar every 5 minutes, up to 5 jars max
        const BEE_INTERVAL_MS  = 5 * 60 * 1000;
        const BEE_MAX          = 5;
        // Eggs: 1 egg every 8 minutes, up to 6 eggs max
        const COOP_INTERVAL_MS = 8 * 60 * 1000;
        const COOP_MAX         = 6;

        function updateBeeHives() {
            const now = Date.now();
            for (const b of buildings) {
                if (!b.userData.isBeeHive) continue;
                const d = b.userData.beeHiveData;
                if (!d) continue;
                if (d.honey >= BEE_MAX) { d.isReady = true; continue; }
                if (now - d.lastCollect >= BEE_INTERVAL_MS) {
                    d.honey = Math.min(BEE_MAX, d.honey + 1);
                    d.lastCollect = now;
                    if (d.honey >= BEE_MAX) d.isReady = true;
                }
            }
            if (currentBeeHive) updateBeeHiveDisplay();
        }

        function updateChickenCoops() {
            const now = Date.now();
            for (const b of buildings) {
                if (!b.userData.isChickenCoop) continue;
                const d = b.userData.chickenCoopData;
                if (!d) continue;
                if (d.eggs >= COOP_MAX) { d.isReady = true; continue; }
                if (now - d.lastCollect >= COOP_INTERVAL_MS) {
                    d.eggs = Math.min(COOP_MAX, d.eggs + 1);
                    d.lastCollect = now;
                    if (d.eggs >= COOP_MAX) d.isReady = true;
                }
            }
            if (currentChickenCoop) updateChickenCoopDisplay();
        }

        // Run production checks every 30 seconds (no need to check every frame)
        setInterval(() => { updateBeeHives(); updateChickenCoops(); }, 30_000);

        // Live progress bar refresh — called every frame from animate() when a menu is open
        function _tickOpenHiveMenus() {
            if (currentBeeHive)     updateBeeHiveDisplay();
            if (currentChickenCoop) updateChickenCoopDisplay();
        }

        function openWaterCatcherMenu(wc) {
            currentWaterCatcher = wc;
            waterCatcherState.isOpen = true;
            playBenchSound();
            const wcMenu = document.getElementById('water-catcher-menu');
            const inventoryPanel = document.getElementById('inventory-panel');
            wcMenu.style.display = 'block';
            positionInventoryRight(inventoryPanel);
            inventoryPanel.style.display = 'block';
            uiOpen();
            updateInventoryDisplay();
            updateWaterCatcherDisplay();
        }
        
        function closeWaterCatcherMenu() {
            closeAllUI();
        }
        
        function updateWaterCatcherDisplay() {
            const pct = Math.min(100, (waterCatcherState.progress / waterCatcherState.fillTime) * 100);
            const fillEl = document.getElementById('wc-progress-fill');
            const textEl = document.getElementById('wc-progress-text');
            const statusEl = document.getElementById('wc-rain-status');
            if (!fillEl) return;
            fillEl.style.width = pct.toFixed(1) + '%';
            const secsLeft = Math.ceil((waterCatcherState.fillTime - waterCatcherState.progress) / 1000);
            textEl.textContent = pct >= 100 ? 'Bottle ready!' : `Filling... ${secsLeft}s remaining`;
            statusEl.className = 'wc-rain-status wc-rain-active';
            statusEl.textContent = isRaining ? '🌧️ Raining — collecting water!' : '💧 Collecting water...';
            // Update output slots
            for (let i = 0; i < 5; i++) {
                const slot = document.querySelector(`.wc-slot[data-wc-slot="${i}"]`);
                if (!slot) continue;
                const slotData = waterCatcherState.outputSlots[i];
                if (slotData) {
                    slot.classList.add('filled');
                    slot.innerHTML = `<span class="wc-slot-icon">${itemIcons['water_bottle'] || '🧴'}</span><span class="wc-slot-count">${slotData.count}</span>`;
                } else {
                    slot.classList.remove('filled');
                    slot.innerHTML = '';
                }
            }
        }
        
        // Called every frame from animate() — progresses filling at all times
        function updateWaterCatcher(deltaMs) {
            // Only run if a well has actually been placed in the world
            const wellExists = buildings.some(b => b.userData.isWaterCatcher);
            if (!wellExists) return;

            // Check if there's space in output
            const totalOut = waterCatcherState.outputSlots.reduce((s, sl) => s + (sl ? sl.count : 0), 0);
            if (totalOut >= 25) return; // max 5 slots * 5 bottles — don't overfill
            
            waterCatcherState.progress += deltaMs;
            
            if (waterCatcherState.progress >= waterCatcherState.fillTime) {
                // Produce one water bottle
                waterCatcherState.progress = 0;
                let added = false;
                for (let i = 0; i < 5; i++) {
                    if (!waterCatcherState.outputSlots[i]) {
                        waterCatcherState.outputSlots[i] = { item: 'water_bottle', count: 1 };
                        added = true;
                        break;
                    } else if (waterCatcherState.outputSlots[i].item === 'water_bottle' && waterCatcherState.outputSlots[i].count < 5) {
                        waterCatcherState.outputSlots[i].count++;
                        added = true;
                        break;
                    }
                }
                if (added) showMessage('🪣 Water bottle ready in the Well!');
            }
            if (waterCatcherState.isOpen) updateWaterCatcherDisplay();
        }
        
        function updatePlayerTemperature() {
            const px = camera.position.x;
            const pz = camera.position.z;

            // Desert blend (0 = forest, 1 = deep desert) — already computed each frame
            const desertHeat = _biomeBlend;

            // Snow biome proximity — offset by fadeSnow/2 so snowBlend=0.5 at the biome
            // boundary (x=100 or x=300, z=-100 or z=-300), matching the UI map exactly.
            const dxSnow = px - SB_CX;
            const dzSnow = pz - SB_CZ;
            const halfSnow = SB_SIZE / 2;
            const fadeSnow = 40;
            const snowRawX = (halfSnow + fadeSnow / 2 - Math.abs(dxSnow)) / fadeSnow;
            const snowRawZ = (halfSnow + fadeSnow / 2 - Math.abs(dzSnow)) / fadeSnow;
            const snowBlend = Math.max(0, Math.min(1, Math.min(snowRawX, snowRawZ)));

            // Check nearby active heat sources (campfire, furnace, cooking station)
            // Distance-based: closer = warmer target, further = less effect
            const heatRadius = 7; // max range units
            let heatInfluence = 0; // 0..1, higher = closer
            for (const b of buildings) {
                let isActiveHeat = false;
                if (b.userData.isCampfire && b.userData.smeltingState && b.userData.smeltingState.isProcessing) {
                    isActiveHeat = true;
                } else if (b.userData.isFurnace && b.userData.smeltingState && b.userData.smeltingState.isProcessing) {
                    isActiveHeat = true;
                } else if (b.userData.isCookingStation && b.userData.cookingState && b.userData.cookingState.isProcessing) {
                    isActiveHeat = true;
                }
                if (isActiveHeat) {
                    const dist = b.position.distanceTo(camera.position);
                    if (dist < heatRadius) {
                        // Linear falloff: distance 0 = full heat (1.0), distance heatRadius = no heat (0.0)
                        const influence = 1 - (dist / heatRadius);
                        if (influence > heatInfluence) heatInfluence = influence;
                    }
                }
            }

            // Calculate target temperature
            // Priority: heat source > desert > rain/snow
            let targetTemp = 0;

            // Biome effects — snow always wins over desert (they share the same Z band)
            // Use whichever biome has the stronger blend, with snow taking priority on a tie
            if (snowBlend > 0.05 && snowBlend >= desertHeat) {
                targetTemp = -snowBlend;          // cold in snow biome
            } else if (desertHeat > 0.05) {
                targetTemp = desertHeat;          // hot in desert biome
            }

            // Rain makes the player cold (only in non-desert biomes, and not under a roof)
            if (isRaining && desertHeat < 0.3 && !isPlayerUnderRoof()) {
                targetTemp = Math.min(targetTemp, -0.5);
            }

            // Active heat source nearby — heat target scales with proximity (0=no effect, 1=very hot)
            // Standing right next to fire = 0.85 (very hot), halfway = ~0.4 (warm), edge of range = ~0.1
            if (heatInfluence > 0) {
                const heatTarget = heatInfluence * 0.85;
                targetTemp = Math.max(targetTemp, heatTarget);
            }

            // Smoothly lerp player temp toward target
            // Insulation slows how fast temperature changes — fully insulated = 85% slower
            const insulation = calculateInsulation();
            // Warmth buff: when getting colder, slow the rate by 60%
            const _warmthFactor = (activeBuffs.warmth && targetTemp < playerTemp) ? 0.4 : 1.0;
            const lerpSpeed = 0.003 * (1 - insulation) * _warmthFactor;
            playerTemp += (targetTemp - playerTemp) * lerpSpeed;
            playerTemp = Math.max(-1, Math.min(1, playerTemp));

            // Update HUD
            const pct = ((playerTemp + 1) / 2) * 100;
            const indicator = document.getElementById('temp-indicator');
            const label     = document.getElementById('temp-label');
            if (indicator) indicator.style.left = pct.toFixed(1) + '%';
            if (label) {
                if (playerTemp > 0.6)        label.textContent = '🔥 Very Hot';
                else if (playerTemp > 0.25)  label.textContent = '☀️ Warm';
                else if (playerTemp < -0.6)  label.textContent = '🥶 Freezing';
                else if (playerTemp < -0.25) label.textContent = '❄️ Cold';
                else                         label.textContent = '🌡️ Normal';
            }
        }

        // ═══════════════════════════════════════════════════════════════
        //  JUNK PILE SYSTEM
        // ═══════════════════════════════════════════════════════════════
        const junkPiles = [];
        let currentJunkPile = null;

        // Loot table — weights control rarity
        const _junkLootTable = [
            // Food (common)
            { item: 'berries',      count: 1, weight: 8 },
            { item: 'mushroom',     count: 1, weight: 7 },
            { item: 'meat',         count: 1, weight: 6 },
            { item: 'cooked_meat',  count: 1, weight: 5 },
            { item: 'corn',         count: 1, weight: 5 },
            { item: 'potato',       count: 1, weight: 5 },
            { item: 'tomato',       count: 1, weight: 4 },
            { item: 'pumpkin',      count: 1, weight: 4 },
            // Cooking station results (uncommon)
            { item: 'meat_stew',    count: 1, weight: 3 },
            { item: 'vegetable_stew', count: 1, weight: 3 },
            { item: 'berry_jam',    count: 1, weight: 3 },
            { item: 'corn_bread',   count: 1, weight: 3 },
            { item: 'hearty_meal',  count: 1, weight: 2 },
            // Medical
            { item: 'bandage',      count: 1, weight: 6 },
            { item: 'medkit',       count: 1, weight: 3 },
            // Clothing (uncommon)
            { item: 'cloth_helmet', count: 1, weight: 3 },
            { item: 'cloth_vest',   count: 1, weight: 2 },
            { item: 'cloth_gloves', count: 1, weight: 3 },
            { item: 'cloth_pants',  count: 1, weight: 3 },
            { item: 'cloth_boots',  count: 1, weight: 3 },
            // Water
            { item: 'water_bottle', count: 1, weight: 5 },
            // Ammo (rare, up to 6)
            { item: 'pistol_ammo',  count: [1,6], weight: 2 },
            { item: 'mg_ammo',      count: [1,6], weight: 1 },
            { item: 'arrows',       count: [1,6], weight: 3 },
            // Gunpowder (rare, up to 6)
            { item: 'gunpowder',    count: [1,6], weight: 1 },
            // Large backpack (very rare — only found in junk piles)
            { item: 'large_backpack', count: 1, weight: 0.3 },
        ];

        const _junkTotalWeight = _junkLootTable.reduce((s, e) => s + e.weight, 0);

        function _pickJunkItem() {
            let r = Math.random() * _junkTotalWeight;
            for (const entry of _junkLootTable) {
                r -= entry.weight;
                if (r <= 0) {
                    const count = Array.isArray(entry.count)
                        ? Math.floor(Math.random() * (entry.count[1] - entry.count[0] + 1)) + entry.count[0]
                        : entry.count;
                    return { item: entry.item, count };
                }
            }
            return { item: 'bandage', count: 1 }; // fallback
        }

        function _generateJunkLoot() {
            // 6 slots, some may be empty (30% chance each)
            const slots = [];
            const usedItems = new Set();
            for (let i = 0; i < 6; i++) {
                if (Math.random() < 0.3) { slots.push(null); continue; }
                let pick, attempts = 0;
                do { pick = _pickJunkItem(); attempts++; } while (usedItems.has(pick.item) && attempts < 20);
                usedItems.add(pick.item);
                slots.push(pick);
            }
            return slots;
        }

        async function spawnJunkPile(x, z, biome) {
            await _loadAssetGLB('Rubbish.glb');
            const inst = _instantiateGLB('Rubbish.glb', 1.2);
            if (!inst) return;
            inst.position.set(x, 0, z);
            inst.rotation.y = Math.random() * Math.PI * 2;
            inst.userData.isJunkPile = true;
            inst.userData.loot   = _generateJunkLoot();
            inst.userData.looted = false;
            inst.userData.biome  = biome || 'forest';
            inst.traverse(c => { /* frustumCulled = true from _glbSpawn */ if (c.isMesh) { c.renderOrder = 0; } });
            junkPiles.push(inst);
            scene.add(inst);
        }

        const JUNK_RESPAWN_MS = 5 * 60 * 1000; // 5 minutes

        function _pickRespawnPos(biome) {
            const minDist = 8;
            const occupied = junkPiles.map(p => ({ x: p.position.x, z: p.position.z }));
            for (let attempt = 0; attempt < 80; attempt++) {
                let ox, oz;
                if (biome === 'snow') {
                    ox = SB_CX + (Math.random() - 0.5) * SB_SIZE * 0.8;
                    oz = SB_CZ + (Math.random() - 0.5) * SB_SIZE * 0.8;
                } else if (biome === 'desert') {
                    const allPos = [...rockPositions, ...bushPositions].filter(p => p.z <= -80);
                    if (!allPos.length) continue;
                    const base = allPos[Math.floor(Math.random() * allPos.length)];
                    ox = base.x + (Math.random() - 0.5) * 4;
                    oz = base.z + (Math.random() - 0.5) * 4;
                } else {
                    const allPos = [...rockPositions, ...bushPositions].filter(p => Math.abs(p.x) <= 90 && p.z <= 10 && p.z >= -80);
                    if (!allPos.length) continue;
                    const base = allPos[Math.floor(Math.random() * allPos.length)];
                    ox = base.x + (Math.random() - 0.5) * 4;
                    oz = base.z + (Math.random() - 0.5) * 4;
                }
                if (occupied.some(u => Math.hypot(ox - u.x, oz - u.z) < minDist)) continue;
                if (_isInsideBuilding(ox, oz)) continue;
                return { x: ox, z: oz };
            }
            return null;
        }

        function _markJunkLooted(pile) {
            const biome = pile.userData.biome || 'forest';
            // Remove from scene and array immediately
            scene.remove(pile);
            const idx = junkPiles.indexOf(pile);
            if (idx !== -1) junkPiles.splice(idx, 1);
            // Schedule respawn at a new location in the same biome
            setTimeout(() => _respawnJunkPile(biome), JUNK_RESPAWN_MS);
        }

        async function _respawnJunkPile(biome) {
            const pos = _pickRespawnPos(biome);
            if (!pos) return; // no free spot found
            await spawnJunkPile(pos.x, pos.z, biome);
        }

        function _formatRespawnTimer(ms) {
            const s = Math.ceil(ms / 1000);
            const m = Math.floor(s / 60), sec = s % 60;
            return m > 0 ? `${m}m ${sec}s` : `${sec}s`;
        }

        function openJunkPile(pile, _silent) {
            if (!_silent) playLootSound();
            currentJunkPile = pile;
            const grid = document.getElementById('junkpile-grid');
            const takeAllBtn = document.getElementById('junkpile-take-all');
            const respawnLabel = document.getElementById('junkpile-respawn-label');
            grid.innerHTML = '';
            respawnLabel.style.display = 'none';

            const hasItems = pile.userData.loot.some(s => s);
            takeAllBtn.disabled = !hasItems;
            takeAllBtn.style.opacity = hasItems ? '1' : '0.4';
            takeAllBtn.style.cursor = hasItems ? 'pointer' : 'default';

            pile.userData.loot.forEach((slot, i) => {
                const div = document.createElement('div');
                div.style.cssText = `
                    background:rgba(0,0,0,0.5); border:2px solid rgba(160,120,60,0.35);
                    border-radius:10px; padding:10px 6px; text-align:center;
                    min-height:80px; display:flex; flex-direction:column;
                    align-items:center; justify-content:center; gap:4px;
                    ${slot ? 'cursor:pointer;' : 'opacity:0.3;'}
                    transition:border-color 0.2s, background 0.15s;
                `;
                if (slot) {
                    const icon = itemIcons[slot.item] || '❓';
                    const name = getItemDisplayName(slot.item);
                    div.innerHTML = `<div style="width:36px;height:36px;">${icon}</div>
                        <div style="font-size:10px;opacity:0.8;">${name}</div>
                        ${slot.count > 1 ? `<div style="font-size:11px;font-weight:bold;color:#f9ca24;">x${slot.count}</div>` : ''}`;
                    div.addEventListener('mouseenter', () => { div.style.background = 'rgba(160,120,60,0.2)'; div.style.borderColor = 'rgba(160,120,60,0.7)'; });
                    div.addEventListener('mouseleave', () => { div.style.background = 'rgba(0,0,0,0.5)'; div.style.borderColor = 'rgba(160,120,60,0.35)'; });
                    div.addEventListener('click', () => {
                        inventory[slot.item] = (inventory[slot.item] || 0) + slot.count;
                        pile.userData.loot[i] = null;
                        updateUI();
                        updateInventoryDisplay();
                        showMessage(`✅ Took ${slot.count > 1 ? slot.count + 'x ' : ''}${getItemDisplayName(slot.item)}`);
                        openJunkPile(pile, true);
                        if (pile.userData.loot.every(s => !s)) {
                            _markJunkLooted(pile);
                            document.getElementById('junkpile-panel').style.display = 'none';
                            uiClose();
                        }
                    });
                } else {
                    div.innerHTML = `<div style="font-size:20px;opacity:0.3;">—</div>`;
                }
                grid.appendChild(div);
            });

            document.getElementById('junkpile-panel').style.display = 'block';
            uiOpen();
        }

        // Spawn junk piles near rocks and bushes across all biomes
        (async () => {
            await new Promise(r => setTimeout(r, 5000)); // wait for world + save load to settle

            const allPositions = [...rockPositions, ...bushPositions];
            const used = [];
            const minDist = 8;

            // Forest/main map — 20 piles
            let forestCount = 0;
            for (const pos of allPositions) {
                if (forestCount >= 20) break;
                if (Math.abs(pos.x) > 90 || pos.z > 10 || pos.z < -80) continue; // forest zone
                const ox = pos.x + (Math.random() - 0.5) * 4;
                const oz = pos.z + (Math.random() - 0.5) * 4;
                if (used.some(u => Math.hypot(ox - u.x, oz - u.z) < minDist)) continue;
                if (_isInsideBuilding(ox, oz)) continue;
                used.push({ x: ox, z: oz });
                await spawnJunkPile(ox, oz, 'forest');
                forestCount++;
            }

            // Desert biome (z < -80) — 10 piles
            let desertCount = 0;
            for (const pos of allPositions) {
                if (desertCount >= 10) break;
                if (pos.z > -80) continue;
                const ox = pos.x + (Math.random() - 0.5) * 4;
                const oz = pos.z + (Math.random() - 0.5) * 4;
                if (used.some(u => Math.hypot(ox - u.x, oz - u.z) < minDist)) continue;
                if (_isInsideBuilding(ox, oz)) continue;
                used.push({ x: ox, z: oz });
                await spawnJunkPile(ox, oz, 'desert');
                desertCount++;
            }

            // Snow biome — 10 piles near snow rocks
            let snowCount = 0;
            const snowAttempts = 60;
            for (let a = 0; a < snowAttempts && snowCount < 10; a++) {
                const ox = SB_CX + (Math.random() - 0.5) * SB_SIZE * 0.8;
                const oz = SB_CZ + (Math.random() - 0.5) * SB_SIZE * 0.8;
                if (used.some(u => Math.hypot(ox - u.x, oz - u.z) < minDist)) continue;
                if (_isInsideBuilding(ox, oz)) continue;
                used.push({ x: ox, z: oz });
                await spawnJunkPile(ox, oz, 'snow');
                snowCount++;
            }

            console.log(`🗑️ Spawned ${used.length} junk piles`);
        })();

        function updateRecyclerDisplay() {
            // Update input slots
            for (let i = 0; i < 5; i++) {
                const slotDiv = document.querySelector(`.recycler-slot[data-slot="input"][data-index="${i}"]`);
                const slotData = recyclerState.inputSlots[i];
                
                if (slotData) {
                    slotDiv.classList.add('filled');
                    slotDiv.innerHTML = `
                        <span class="recycler-slot-icon">${itemIcons[slotData.item] || '\u2753'}</span>
                        <span class="recycler-slot-count">${slotData.count}</span>
                    `;
                    if (typeof _bindStationSlotDragSource === 'function')
                        _bindStationSlotDragSource(slotDiv, 'recycler-input', slotData.item, slotData.count, i);
                } else {
                    slotDiv.classList.remove('filled');
                    slotDiv.innerHTML = '';
                    slotDiv.removeAttribute('draggable');
                }
            }
            
            // Update output slots
            for (let i = 0; i < 5; i++) {
                const slotDiv = document.querySelector(`.recycler-slot[data-slot="output"][data-index="${i}"]`);
                const slotData = recyclerState.outputSlots[i];
                
                if (slotData) {
                    slotDiv.classList.add('filled');
                    slotDiv.innerHTML = `
                        <span class="recycler-slot-icon">${itemIcons[slotData.item] || '\u2753'}</span>
                        <span class="recycler-slot-count">${slotData.count}</span>
                    `;
                    if (typeof _bindStationSlotDragSource === 'function')
                        _bindStationSlotDragSource(slotDiv, 'recycler-output', slotData.item, slotData.count, i);
                } else {
                    slotDiv.classList.remove('filled');
                    slotDiv.innerHTML = '';
                    slotDiv.removeAttribute('draggable');
                }
            }
            
            // Update progress bar
            const progressBar = document.getElementById('recycler-progress');
            const progressText = document.getElementById('recycler-progress-text');
            progressBar.style.width = recyclerState.progress + '%';
            progressText.textContent = Math.floor(recyclerState.progress) + '%';
            
            // Update start button
            const startBtn = document.getElementById('recycler-start-btn');
            if (recyclerState.isProcessing) {
                startBtn.textContent = '\u2699\ufe0f PROCESSING...';
                startBtn.disabled = true;
            } else {
                const hasInput = recyclerState.inputSlots.some(slot => slot !== null);
                startBtn.textContent = '\u267b\ufe0f START RECYCLING';
                startBtn.disabled = !hasInput;
            }
        }
        
        function addToRecyclerSlot(slotType, slotIndex, itemName = null) {
            if (slotType === 'input') {
                // If no item specified, do nothing (will be called from inventory double-click)
                if (!itemName) return;
                
                // Check if item exists in inventory
                if (!inventory[itemName] || inventory[itemName] === 0) {
                    showMessage('\u274c Item not found in inventory!');
                    return;
                }
                
                // Check if item can be recycled
                if (!recycleRecipes[itemName]) {
                    showMessage('\u274c This item cannot be recycled!');
                    return;
                }
                
                // Add 1 item by default (can be modified to prompt for amount later)
                const count = 1;
                
                // Remove from inventory
                inventory[itemName] -= count;
                
                // Add to recycler input slot
                if (recyclerState.inputSlots[slotIndex]) {
                    // Slot occupied, try to stack
                    if (recyclerState.inputSlots[slotIndex].item === itemName) {
                        recyclerState.inputSlots[slotIndex].count += count;
                    } else {
                        showMessage('\u26a0\ufe0f Slot already occupied!');
                        inventory[itemName] += count; // Return to inventory
                        return;
                    }
                } else {
                    recyclerState.inputSlots[slotIndex] = { item: itemName, count };
                }
                
                showMessage(`\u267b\ufe0f Added ${itemName} to recycler`);
                updateUI();
                updateRecyclerDisplay();
                updateInventoryDisplay();
                
            } else if (slotType === 'output') {
                // Take from recycler output to inventory
                const slotData = recyclerState.outputSlots[slotIndex];
                if (!slotData) return;
                
                // Add to inventory
                if (!inventory[slotData.item]) inventory[slotData.item] = 0;
                inventory[slotData.item] += slotData.count;
                
                // Clear output slot
                recyclerState.outputSlots[slotIndex] = null;
                
                updateUI();
                updateRecyclerDisplay();
                updateInventoryDisplay();
                playCollectSound();
            }
        }
        
        // Function to add item from inventory to next available recycler slot
        function addItemToRecycler(itemName) {
            if (!currentRecycler) return;
            
            // Check if item can be recycled
            if (!recycleRecipes[itemName]) {
                showMessage('\u274c This item cannot be recycled!');
                return;
            }
            
            // Find first empty slot
            let emptySlotIndex = -1;
            for (let i = 0; i < 5; i++) {
                if (!recyclerState.inputSlots[i]) {
                    emptySlotIndex = i;
                    break;
                }
                // Or if same item, can stack
                if (recyclerState.inputSlots[i].item === itemName) {
                    emptySlotIndex = i;
                    break;
                }
            }
            
            if (emptySlotIndex === -1) {
                showMessage('\u26a0\ufe0f All recycler slots are full!');
                return;
            }
            
            // Add to that slot
            addToRecyclerSlot('input', emptySlotIndex, itemName);
        }
        
        function startRecycling() {
            if (recyclerState.isProcessing) return;
            
            const hasInput = recyclerState.inputSlots.some(slot => slot !== null);
            if (!hasInput) {
                showMessage('\u26a0\ufe0f No items to recycle!');
                return;
            }
            
            recyclerState.isProcessing = true;
            recyclerState.currentSlot = 0;
            recyclerState.progress = 0;
            recyclerState.isPaused = false;
            recyclerState.pauseProgress = 0;
            
            // Find first non-empty slot
            while (recyclerState.currentSlot < 5 && !recyclerState.inputSlots[recyclerState.currentSlot]) {
                recyclerState.currentSlot++;
            }
            
            updateRecyclerDisplay();
            
            // Turn on green light on recycler
            if (currentRecycler && currentRecycler.userData.statusLight) {
                currentRecycler.userData.statusLight.visible = true;
            }
            
            // Start mechanical sound
            startRecyclerSound();
            
            showMessage('\u267b\ufe0f Recycling started!');
        }
        
        // Real-time progress bar update — called every frame during recycling
        function _updateRecyclerProgressBar() {
            const progressBar = document.getElementById('recycler-progress');
            const progressText = document.getElementById('recycler-progress-text');
            if (!progressBar || !progressText) return;
            const pct = Math.min(100, Math.max(0, recyclerState.progress));
            progressBar.style.width = pct + '%';
            progressText.textContent = Math.floor(pct) + '%';
        }

        function updateRecycling(deltaTime) {
            if (!recyclerState.isProcessing) return;
            
            // Update recycler sound volume based on player proximity
            updateRecyclerProximityAudio();
            
            // Animate recycler if it exists in the scene
            if (currentRecycler) {
                // Rotate drum
                if (currentRecycler.userData.drum) {
                    currentRecycler.userData.drum.rotation.x += deltaTime * 0.002;
                }
                // Vibrate hopper
                if (currentRecycler.userData.hopper) {
                    currentRecycler.userData.hopper.position.y = 0.95 + Math.sin(Date.now() * 0.01) * 0.02;
                }
            }
            
            // Handle pause between items in same slot
            if (recyclerState.isPaused) {
                recyclerState.pauseProgress += deltaTime;
                if (recyclerState.pauseProgress >= recyclerState.pauseTime) {
                    // Pause complete, continue processing same slot
                    recyclerState.isPaused = false;
                    recyclerState.pauseProgress = 0;
                    recyclerState.progress = 0;
                }
                // Update bar even while paused (shows 0%)
                _updateRecyclerProgressBar();
                return;
            }
            
            // Increment progress
            const progressIncrement = (deltaTime / recyclerState.processTime) * 100;
            recyclerState.progress += progressIncrement;
            
            // Update bar in real-time every frame
            _updateRecyclerProgressBar();
            
            if (recyclerState.progress >= 100) {
                // Process current item
                const inputSlot = recyclerState.inputSlots[recyclerState.currentSlot];
                if (inputSlot) {
                    const recipe = recycleRecipes[inputSlot.item];
                    if (recipe) {
                        // Calculate 50% return
                        const materials = {};
                        for (let mat in recipe) {
                            materials[mat] = recipe[mat];
                        }
                        
                        // Try to add materials to output slots
                        let allAdded = true;
                        for (let mat in materials) {
                            let amountToAdd = materials[mat];
                            let added = false;
                            
                            // Try to find existing slot with this material
                            for (let i = 0; i < 5; i++) {
                                if (recyclerState.outputSlots[i] && recyclerState.outputSlots[i].item === mat) {
                                    recyclerState.outputSlots[i].count += amountToAdd;
                                    added = true;
                                    break;
                                }
                            }
                            
                            // If not found, try to find empty slot
                            if (!added) {
                                for (let i = 0; i < 5; i++) {
                                    if (!recyclerState.outputSlots[i]) {
                                        recyclerState.outputSlots[i] = { item: mat, count: amountToAdd };
                                        added = true;
                                        break;
                                    }
                                }
                            }
                            
                            if (!added) {
                                allAdded = false;
                                showMessage('\u26a0\ufe0f Output slots full! Recycling stopped.');
                                break;
                            }
                        }
                        
                        if (allAdded) {
                            // Remove one item from input
                            inputSlot.count--;
                            if (inputSlot.count <= 0) {
                                // Slot is empty, move to next slot
                                recyclerState.inputSlots[recyclerState.currentSlot] = null;
                                recyclerState.progress = 0;
                                
                                // Move to next slot
                                recyclerState.currentSlot++;
                                while (recyclerState.currentSlot < 5 && !recyclerState.inputSlots[recyclerState.currentSlot]) {
                                    recyclerState.currentSlot++;
                                }
                                
                                // If no more items, stop
                                if (recyclerState.currentSlot >= 5) {
                                    recyclerState.isProcessing = false;
                                    recyclerState.progress = 0;
                                    
                                    // Turn off green light
                                    if (currentRecycler && currentRecycler.userData.statusLight) {
                                        currentRecycler.userData.statusLight.visible = false;
                                    }
                                    
                                    // Stop mechanical sound
                                    stopRecyclerSound();
                                    
                                    showMessage('\u267b\ufe0f Recycling complete!');
                                }
                            } else {
                                // More items in same slot, enter pause state
                                recyclerState.isPaused = true;
                                recyclerState.pauseProgress = 0;
                                recyclerState.progress = 0;
                            }
                        } else {
                            // Couldn't add all materials, stop processing
                            recyclerState.isProcessing = false;
                            recyclerState.progress = 0;
                            
                            // Turn off green light
                            if (currentRecycler && currentRecycler.userData.statusLight) {
                                currentRecycler.userData.statusLight.visible = false;
                            }
                            
                            // Stop mechanical sound
                            stopRecyclerSound();
                        }
                    }
                }
                
                updateRecyclerDisplay();
            }
        }
        
        // ===== FURNACE AND CAMPFIRE SMELTING SYSTEM =====
        let currentFurnace = null;
        let currentCampfire = null;
        
        // Helper function to create individual smelting state for each station
        function createSmeltingState(processTime) {
            return {
                // Multi-slot input for furnace (3 slots); campfire only uses slot 0
                inputSlots: [null, null, null], // each: {item, count} or null
                // Legacy single-slot properties kept for campfire compatibility
                inputItem: null,
                inputCount: 0,
                fuelItem: null,
                fuelCount: 0,
                // Furnace uses outputSlots[0] (iron ingot) and outputSlots[1] (smelted sulfur)
                // Campfire uses outputItem/outputCount
                outputSlots: [{ item: 'iron_ingot', count: 0 }, { item: 'smelted_sulfur', count: 0 }],
                outputItem: null,
                outputCount: 0,
                // Campfire queue: array of {item} waiting to be cooked
                cookQueue: [],
                // Campfire 4 output slots: array of {item, count} or null
                campfireOutputSlots: [null, null, null, null],
                wasteCount: 0,
                progress: 0,
                isProcessing: false,
                processTime: processTime,
                currentInputSlot: 0  // which slot is currently being smelted (furnace only)
            };
        }
        
        function openFurnaceMenu(furnace) {
            currentFurnace = furnace;
            playFurnaceInteractSound();
            const furnaceMenu = document.getElementById('furnace-menu');
            const inventoryPanel = document.getElementById('inventory-panel');
            
            // Position furnace on the left, inventory on the right (like recycler)
            furnaceMenu.style.display = 'block';
            furnaceMenu.style.left = '30%';
            furnaceMenu.style.transform = 'translate(-50%, -50%)';
            
            positionInventoryRight(inventoryPanel);
            inventoryPanel.style.display = 'block';
            uiOpen();
            updateInventoryDisplay();
            updateSmeltingDisplay('furnace');
        }
        
        function closeFurnaceMenu() {
            closeAllUI();
        }
        
        function openCampfireMenu(campfire) {
            currentCampfire = campfire;
            playFurnaceInteractSound();
            const campfireMenu = document.getElementById('campfire-menu');
            const inventoryPanel = document.getElementById('inventory-panel');
            
            // Position campfire on the left, inventory on the right
            campfireMenu.style.display = 'block';
            campfireMenu.style.left = '30%';
            campfireMenu.style.transform = 'translate(-50%, -50%)';
            
            positionInventoryRight(inventoryPanel);
            inventoryPanel.style.display = 'block';
            uiOpen();
            updateInventoryDisplay();
            updateSmeltingDisplay('campfire');
        }
        
        function closeCampfireMenu() {
            closeAllUI();
        }
        
        function updateSmeltingDisplay(type) {
            const building = type === 'furnace' ? currentFurnace : currentCampfire;
            if (!building || !building.userData.smeltingState) return;
            
            const state = building.userData.smeltingState;
            const prefix = type;
            
            if (type === 'furnace') {
                // Multi-slot input display
                for (let i = 0; i < 3; i++) {
                    const slotEl = document.getElementById(`furnace-input-slot-${i}`);
                    if (!slotEl) continue;
                    const slotData = state.inputSlots[i];
                    slotEl.classList.toggle('active-smelt', state.isProcessing && i === state.currentInputSlot && slotData);
                    if (slotData && slotData.count > 0) {
                        const icon = itemIcons[slotData.item] || '\u2753';
                        slotEl.innerHTML = `${icon}<div class="smelting-slot-count">${slotData.count}</div>`;
                        if (typeof _bindStationSlotDragSource === 'function')
                            _bindStationSlotDragSource(slotEl, 'furnace-input', slotData.item, slotData.count, i);
                    } else {
                        slotEl.innerHTML = '+';
                        slotEl.removeAttribute('draggable');
                    }
                }
                // Active slot label
                const lbl = document.getElementById('furnace-active-label');
                if (lbl) {
                    if (state.isProcessing) {
                        const activeSlot = state.inputSlots[state.currentInputSlot];
                        lbl.textContent = activeSlot ? `Smelting: ${activeSlot.item.replace(/_/g,' ')}` : '';
                    } else {
                        lbl.textContent = '';
                    }
                }
            } else {
                // Campfire single input slot
                const inputSlot = document.getElementById(`${prefix}-input-slot`);
                if (state.inputItem && state.inputCount > 0) {
                    const icon = itemIcons[state.inputItem] || '\u2753';
                    inputSlot.innerHTML = `${icon}<div class="smelting-slot-count">${state.inputCount}</div>`;
                    if (typeof _bindStationSlotDragSource === 'function')
                        _bindStationSlotDragSource(inputSlot, 'campfire-input', state.inputItem, state.inputCount, 0);
                } else {
                    inputSlot.innerHTML = '+';
                    inputSlot.removeAttribute('draggable');
                }
            }
            
            // Fuel slot
            const fuelSlot = document.getElementById(`${prefix}-fuel-slot`);
            if (state.fuelItem && state.fuelCount > 0) {
                const icon = itemIcons[state.fuelItem] || '\u2753';
                fuelSlot.innerHTML = `${icon}<div class="smelting-slot-count">${state.fuelCount}</div>`;
                fuelSlot.draggable = true;
                fuelSlot.dataset.itemName = state.fuelItem;
                fuelSlot.dataset.slotType = prefix + '-fuel';
                fuelSlot.dataset.slotIndex = '0';
            } else {
                fuelSlot.innerHTML = '+';
                fuelSlot.draggable = false;
                delete fuelSlot.dataset.itemName;
                fuelSlot.dataset.slotType = prefix + '-fuel';
                fuelSlot.dataset.slotIndex = '0';
            }
            
            // Output slot(s)
            if (type === 'furnace') {
                // Two output slots for furnace
                for (let oi = 0; oi < 2; oi++) {
                    const outEl = document.getElementById(`furnace-output-slot-${oi}`);
                    if (!outEl) continue;
                    const outData = state.outputSlots && state.outputSlots[oi];
                    if (outData && outData.count > 0) {
                        const icon = itemIcons[outData.item] || '\u2753';
                        outEl.innerHTML = `${icon}<div class="smelting-slot-count">${outData.count}</div>`;
                        if (typeof _bindStationSlotDragSource === 'function')
                            _bindStationSlotDragSource(outEl, 'furnace-output', outData.item, outData.count, oi);
                    } else {
                        outEl.innerHTML = '';
                        outEl.removeAttribute('draggable');
                    }
                }
            } else {
                const outputSlot = document.getElementById(`${prefix}-output-slot`);
                if (outputSlot) {
                    if (state.outputCount > 0) {
                        const icon = itemIcons[state.outputItem] || '\u2753';
                        outputSlot.innerHTML = `${icon}<div class="smelting-slot-count">${state.outputCount}</div>`;
                        if (typeof _bindStationSlotDragSource === 'function')
                            _bindStationSlotDragSource(outputSlot, 'campfire-output', state.outputItem, state.outputCount, 0);
                    } else {
                        outputSlot.innerHTML = '';
                        outputSlot.removeAttribute('draggable');
                    }
                }
                // 4 campfire output slots
                if (!state.campfireOutputSlots) state.campfireOutputSlots = [null,null,null,null];
                for (let oi = 0; oi < 4; oi++) {
                    const outEl = document.getElementById(`campfire-output-slot-${oi}`);
                    if (!outEl) continue;
                    const outData = state.campfireOutputSlots[oi];
                    if (outData && outData.count > 0) {
                        const icon = itemIcons[outData.item] || '\u2753';
                        outEl.innerHTML = `${icon}<div class="smelting-slot-count">${outData.count}</div>`;
                        outEl.draggable = true;
                        outEl.dataset.itemName = outData.item;
                        outEl.dataset.slotType = 'campfire-output-new';
                        outEl.dataset.slotIndex = String(oi);
                    } else {
                        outEl.innerHTML = '';
                        outEl.draggable = false;
                        delete outEl.dataset.itemName;
                    }
                }
                // Queue display
                if (!state.cookQueue) state.cookQueue = [];
                const queueEl = document.getElementById('campfire-queue-display');
                if (queueEl) {
                    queueEl.innerHTML = '';
                    state.cookQueue.forEach((entry, idx) => {
                        const icon = itemIcons[entry.item] || '?';
                        const qItem = document.createElement('div');
                        qItem.style.cssText = 'display:flex;flex-direction:column;align-items:center;gap:3px;';
                        qItem.innerHTML = `<div style="width:44px;height:44px;background:rgba(0,0,0,0.5);border:2px solid rgba(255,140,0,0.5);border-radius:6px;display:flex;align-items:center;justify-content:center;font-size:22px;">${icon}</div><div style="font-size:9px;color:rgba(255,200,100,0.8);">${(itemDisplayNames&&itemDisplayNames[entry.item])||entry.item}</div>`;
                        queueEl.appendChild(qItem);
                    });
                    if (state.cookQueue.length === 0) {
                        queueEl.innerHTML = '<div style="color:rgba(255,255,255,0.3);font-size:11px;">Empty — add food to input slot</div>';
                    }
                }
            }
            
            // Waste slot
            const wasteSlot = document.getElementById(`${prefix}-waste-slot`);
            const wasteItem = type === 'furnace' ? 'coal' : 'ash';
            if (state.wasteCount > 0) {
                const icon = itemIcons[wasteItem] || '\u2753';
                wasteSlot.innerHTML = `${icon}<div class="smelting-slot-count">${state.wasteCount}</div>`;
                if (typeof _bindStationSlotDragSource === 'function')
                    _bindStationSlotDragSource(wasteSlot, type + '-waste', wasteItem, state.wasteCount, 0);
            } else {
                wasteSlot.innerHTML = '';
                wasteSlot.removeAttribute('draggable');
            }
            
            // Progress bar
            const progressFill = document.getElementById(`${prefix}-progress`);
            const progressText = document.getElementById(`${prefix}-progress-text`);
            const percentage = Math.floor(state.progress);
            progressFill.style.width = percentage + '%';
            progressText.textContent = percentage + '%';
        }
        
        // Valid items per station type
        const FURNACE_VALID_ORES = ['iron_ore', 'sulfur_ore'];
        const CAMPFIRE_VALID_FOODS = ['meat', 'mushroom', 'mushroom_crop'];

        function addToSmeltingSlot(type, slotType, slotIndex = null, dragItemName = null) {
            const building = type === 'furnace' ? currentFurnace : currentCampfire;
            if (!building || !building.userData.smeltingState) return;
            
            const state = building.userData.smeltingState;
            
            if (slotType === 'input') {
                if (type === 'furnace') {
                    // Multi-slot furnace input
                    if (dragItemName !== null) {
                        // Drag path: specific item, specific slot index
                        const targetSlotIdx = (slotIndex !== null) ? slotIndex : null;
                        if (targetSlotIdx === null) return;
                        if (!FURNACE_VALID_ORES.includes(dragItemName)) {
                            showMessage('\u26a0\ufe0f Only ores can be placed in the furnace!');
                            return;
                        }
                        if (inventory[dragItemName] <= 0) return;
                        const slotData = state.inputSlots[targetSlotIdx];
                        if (slotData && slotData.item !== dragItemName) {
                            showMessage('\u26a0\ufe0f That slot already contains a different ore!');
                            return;
                        }
                        // Move all of dragged item into this slot
                        const amount = inventory[dragItemName];
                        if (!slotData) {
                            state.inputSlots[targetSlotIdx] = { item: dragItemName, count: amount };
                        } else {
                            slotData.count += amount;
                        }
                        inventory[dragItemName] = 0;
                        updateUI();
                        updateSmeltingDisplay('furnace');
                    } else {
                        // Click path: pick first valid ore from inventory and put in first empty/matching slot
                        for (let ore of FURNACE_VALID_ORES) {
                            if (inventory[ore] > 0) {
                                // Find a slot that has this ore, or first empty slot
                                let placed = false;
                                for (let i = 0; i < 3; i++) {
                                    const sd = state.inputSlots[i];
                                    if (sd && sd.item === ore) {
                                        sd.count++;
                                        inventory[ore]--;
                                        placed = true;
                                        break;
                                    }
                                }
                                if (!placed) {
                                    for (let i = 0; i < 3; i++) {
                                        if (!state.inputSlots[i]) {
                                            state.inputSlots[i] = { item: ore, count: 1 };
                                            inventory[ore]--;
                                            placed = true;
                                            break;
                                        }
                                    }
                                }
                                if (placed) {
                                    updateUI();
                                    updateSmeltingDisplay('furnace');
                                    return;
                                }
                            }
                        }
                        showMessage('\u26a0\ufe0f No ores in inventory!');
                    }
                } else {
                    // Campfire single input — now uses queue system
                    if (dragItemName !== null) {
                        if (!CAMPFIRE_VALID_FOODS.includes(dragItemName)) {
                            showMessage('\u26a0\ufe0f Only food items can be placed in the campfire!');
                            return;
                        }
                        if (inventory[dragItemName] <= 0) return;
                        if (!state.cookQueue) state.cookQueue = [];
                        if (state.cookQueue.length >= 4) {
                            showMessage('\u26a0\ufe0f Campfire queue is full! Collect cooked food first.');
                            return;
                        }
                        // Add all of this food type to queue (one item per queue slot)
                        const amount = inventory[dragItemName];
                        let added = 0;
                        for (let a = 0; a < amount && state.cookQueue.length < 4; a++) {
                            state.cookQueue.push({ item: dragItemName });
                            added++;
                        }
                        inventory[dragItemName] = Math.max(0, inventory[dragItemName] - added);
                        // If not already processing, prime the input slot
                        if (!state.inputItem && state.cookQueue.length > 0) {
                            const next = state.cookQueue.shift();
                            state.inputItem = next.item;
                            state.inputCount = 1;
                        }
                        updateUI();
                        updateSmeltingDisplay('campfire');
                    } else {
                        // Click path
                        if (!state.cookQueue) state.cookQueue = [];
                        for (let food of CAMPFIRE_VALID_FOODS) {
                            if (inventory[food] > 0) {
                                if (state.cookQueue.length >= 4) {
                                    showMessage('\u26a0\ufe0f Campfire queue is full!');
                                    return;
                                }
                                state.cookQueue.push({ item: food });
                                inventory[food]--;
                                // Prime input if not already set
                                if (!state.inputItem && !state.isProcessing) {
                                    const next = state.cookQueue.shift();
                                    state.inputItem = next.item;
                                    state.inputCount = 1;
                                }
                                updateUI();
                                updateSmeltingDisplay('campfire');
                                return;
                            }
                        }
                        showMessage('\u26a0\ufe0f No valid food in inventory!');
                    }
                }
            } else if (slotType === 'fuel') {
                // Add fuel
                if (inventory.wood > 0) {
                    if (!state.fuelItem) state.fuelItem = 'wood';
                    inventory.wood--;
                    state.fuelCount++;
                } else if (inventory.sticks > 0) {
                    if (!state.fuelItem) state.fuelItem = 'sticks';
                    inventory.sticks--;
                    state.fuelCount++;
                } else {
                    showMessage('\u26a0\ufe0f No fuel available!');
                    return;
                }
                updateUI();
                updateSmeltingDisplay(type);
            } else if (slotType === 'output') {
                // Take output - furnace uses outputSlots[slotIndex], campfire uses outputCount
                if (type === 'furnace') {
                    const idx = slotIndex !== null ? slotIndex : 0;
                    if (state.outputSlots && state.outputSlots[idx] && state.outputSlots[idx].count > 0) {
                        const outItem = state.outputSlots[idx].item;
                        if (!inventory[outItem]) inventory[outItem] = 0;
                        inventory[outItem] += state.outputSlots[idx].count;
                        state.outputSlots[idx].count = 0;
                        updateUI();
                        updateSmeltingDisplay(type);
                        playCollectSound();
                    }
                } else {
                    if (state.outputCount > 0) {
                        if (!inventory[state.outputItem]) inventory[state.outputItem] = 0;
                        inventory[state.outputItem] += state.outputCount;
                        state.outputCount = 0;
                        updateUI();
                        updateSmeltingDisplay(type);
                        playCollectSound();
                    }
                    // Also check new campfire output slots
                    if (!state.campfireOutputSlots) state.campfireOutputSlots = [null,null,null,null];
                    const idx = slotIndex !== null ? slotIndex : 0;
                    const outData = state.campfireOutputSlots[idx];
                    if (outData && outData.count > 0) {
                        inventory[outData.item] = (inventory[outData.item]||0) + outData.count;
                        state.campfireOutputSlots[idx] = null;
                        updateUI();
                        updateSmeltingDisplay(type);
                        playCollectSound();
                    }
                }
            } else if (slotType === 'waste') {
                // Take waste
                if (state.wasteCount > 0) {
                    const wasteItem = type === 'furnace' ? 'coal' : 'ash';
                    if (!inventory[wasteItem]) inventory[wasteItem] = 0;
                    inventory[wasteItem] += state.wasteCount;
                    state.wasteCount = 0;
                    updateUI();
                    updateSmeltingDisplay(type);
                    playCollectSound();
                }
            }
        }
        
        function updateSmelting() {
            // Update particles and sounds for all active campfires and furnaces
            let anyCampfireActive = false;
            let anyFurnaceActive = false;
            
            buildings.forEach(building => {
                if (building.userData.isCampfire && building.userData.smeltingState) {
                    // Update this campfire's smelting process
                    updateSmeltingProcess(building, 'campfire');
                    
                    if (building.userData.smeltingState.isProcessing) {
                        anyCampfireActive = true;
                        
                        // Turn on fire light — flicker
                        if (building.userData.fireLight) {
                            building.userData.fireLight.intensity = 2.5 + Math.random() * 1.5;
                        }
                        if (building.userData.fireGlow) {
                            building.userData.fireGlow.visible = true;
                            building.userData.fireGlow.material.opacity = 0.6 + Math.random() * 0.2;
                            building.userData.fireGlow.scale.y = 0.9 + Math.random() * 0.2;
                        }
                        
                        // Spawn fire particles
                        building.userData.particleTimer = (building.userData.particleTimer || 0) + 1;
                        if (building.userData.particleTimer >= 2) {
                            building.userData.particleTimer = 0;
                            const pos = building.position.clone();
                            pos.y += 0.15;
                            createFireParticle(pos);
                            createFireParticle(pos);
                            createFireParticle(pos);
                        }
                        
                        // Spawn smoke particles
                        building.userData.smokeTimer = (building.userData.smokeTimer || 0) + 1;
                        if (building.userData.smokeTimer >= 8) {
                            building.userData.smokeTimer = 0;
                            const pos = building.position.clone();
                            pos.y += 0.6;
                            createSmokeParticle(pos);
                        }
                    } else {
                        // Turn off fire light when not active
                        if (building.userData.fireLight) {
                            building.userData.fireLight.intensity = 0;
                        }
                        
                        // Hide fire glow when not active
                        if (building.userData.fireGlow) {
                            building.userData.fireGlow.visible = false;
                        }
                    }
                }
                
                if (building.userData.isFurnace && building.userData.smeltingState) {
                    // Update this furnace's smelting process
                    updateSmeltingProcess(building, 'furnace');
                    
                    if (building.userData.smeltingState.isProcessing) {
                        anyFurnaceActive = true;
                        
                        // Turn on fire light — flicker
                        if (building.userData.fireLight) {
                            building.userData.fireLight.intensity = 1.8 + Math.random() * 1.2;
                        }

                        // Animate interior fire glow planes
                        if (building.userData._glowMesh) {
                            const flicker = 0.75 + Math.random() * 0.25;
                            building.userData._glowMesh.visible = true;
                            building.userData._glowMesh.material.opacity = 0.85 * flicker;
                            building.userData._glowMesh.scale.set(
                                0.92 + Math.random() * 0.16,
                                0.92 + Math.random() * 0.16, 1);
                        }
                        if (building.userData._glowMesh2) {
                            const flicker2 = 0.6 + Math.random() * 0.4;
                            building.userData._glowMesh2.visible = true;
                            building.userData._glowMesh2.material.opacity = 0.45 * flicker2;
                            building.userData._glowMesh2.scale.set(
                                0.90 + Math.random() * 0.20,
                                0.90 + Math.random() * 0.20, 1);
                        }
                        
                        // Spawn door-fire particles
                        if (building.userData._dfPool) {
                            building.userData._dfTimer = (building.userData._dfTimer || 0) + 1;
                            if (building.userData._dfTimer >= 2) {
                                building.userData._dfTimer = 0;
                                _spawnDoorFire(building);
                                _spawnDoorFire(building);
                            }
                            _doorFireMat.color.setHex(Math.random() > 0.5 ? 0xff7700 : 0xffcc00);
                        }

                        // Spawn smoke from chimney
                        building.userData.smokeTimer = (building.userData.smokeTimer || 0) + 1;
                        if (building.userData.smokeTimer >= 6) {
                            building.userData.smokeTimer = 0;
                            const pos = building.position.clone();
                            pos.y += 2.8; // Top of chimney
                            createSmokeParticle(pos);
                        }
                    } else {
                        if (building.userData.fireLight) {
                            building.userData.fireLight.intensity = 0;
                        }
                        if (building.userData._dfPool) {
                            building.userData._dfPool.life.fill(0);
                        }
                        if (building.userData._glowMesh)  { building.userData._glowMesh.visible  = true; building.userData._glowMesh.material.opacity  = 0.18; }
                        if (building.userData._glowMesh2) { building.userData._glowMesh2.visible = true; building.userData._glowMesh2.material.opacity = 0.10; }
                    }
                }
            });
            
            // Control campfire sound — proximity-based volume (max 0.75, +50% vs old 0.5)
            if (anyCampfireActive) {
                _prevAnyCampfireActive = true;
                _fireDecayMult = 1; // normal decay while burning
                if (!fireSound) startFireSound();
                if (fireGainNode) {
                    const _fireSoundRadius = 12;
                    let closestFireDist = Infinity;
                    for (const b of buildings) {
                        if (b.userData.isCampfire && b.userData.smeltingState && b.userData.smeltingState.isProcessing) {
                            const d = b.position.distanceTo(camera.position);
                            if (d < closestFireDist) closestFireDist = d;
                        }
                    }
                    const _fireVol = Math.max(0, (1 - closestFireDist / _fireSoundRadius)) * 0.75;
                    fireGainNode.gain.setTargetAtTime(_fireVol, audioContext.currentTime, 0.15);
                }
            } else {
                _fireDecayMult = 20; // drain remaining particles in ~1 frame
                if (fireSound) stopFireSound();
                if (_prevAnyCampfireActive) {
                    _prevAnyCampfireActive = false;
                }
            }

            if (anyFurnaceActive) {
                if (!furnaceSound) startFurnaceSound();
            } else {
                if (furnaceSound) stopFurnaceSound();
            }
            
            // Update UI if a menu is currently open
            if (currentCampfire) {
                updateSmeltingDisplay('campfire');
            }
            if (currentFurnace) {
                updateSmeltingDisplay('furnace');
            }

            // Cooking station visuals (glow + smoke when processing)
            buildings.forEach(building => {
                if (!building.userData.isCookingStation || !building.userData.cookingState) return;
                const isActive = building.userData.cookingState.isProcessing;
                if (building.userData.fireLight) {
                    building.userData.fireLight.intensity = isActive ? (1.5 + Math.random() * 0.5) : 0;
                }
                if (isActive) {
                    building.userData.smokeTimer = (building.userData.smokeTimer || 0) + 1;
                    if (building.userData.smokeTimer >= 10) {
                        building.userData.smokeTimer = 0;
                        const pos = building.position.clone();
                        pos.y += 1.8; pos.x += 0.35;
                        createSmokeParticle(pos);
                    }
                }
            });
        }
        
        function updateSmeltingProcess(building, type) {
            if (!building || !building.userData.smeltingState) return;
            
            const state = building.userData.smeltingState;
            
            if (type === 'furnace') {
                // Reset currentInputSlot to 0 if it ran past the end but new ores may exist
                if (state.currentInputSlot >= 3) {
                    state.currentInputSlot = 0;
                }
                // Advance currentInputSlot to first non-empty slot
                while (state.currentInputSlot < 3 && (!state.inputSlots[state.currentInputSlot] || state.inputSlots[state.currentInputSlot].count <= 0)) {
                    state.currentInputSlot++;
                }
                const hasInput = state.currentInputSlot < 3;
                
                // Start as soon as fuel is available — even if some input slots are empty
                if (!state.isProcessing && hasInput && state.fuelCount > 0) {
                    state.isProcessing = true;
                    state.progress = 0;
                }
                
                if (state.isProcessing) {
                    const progressIncrement = (1000 / 60 / state.processTime) * 100;
                    state.progress += progressIncrement;
                    
                    if (state.progress >= 100) {
                        const slotData = state.inputSlots[state.currentInputSlot];
                        if (slotData && slotData.count > 0) {
                            slotData.count--;
                            state.fuelCount--;
                            
                            // Route output to the correct slot based on ore type
                            if (!state.outputSlots) {
                                state.outputSlots = [{ item: 'iron_ingot', count: 0 }, { item: 'smelted_sulfur', count: 0 }];
                            }
                            if (slotData.item === 'sulfur_ore') {
                                state.outputSlots[1].count++;
                            } else {
                                state.outputSlots[0].count++;
                            }
                            state.wasteCount++;
                            
                            state.progress = 0;
                            
                            // If slot is now empty, advance to next
                            if (slotData.count <= 0) {
                                state.inputSlots[state.currentInputSlot] = null;
                                state.currentInputSlot++;
                            }
                            
                            // Check if we can continue
                            while (state.currentInputSlot < 3 && (!state.inputSlots[state.currentInputSlot] || state.inputSlots[state.currentInputSlot].count <= 0)) {
                                state.currentInputSlot++;
                            }
                            const stillHasInput = state.currentInputSlot < 3;
                            if (!stillHasInput || state.fuelCount <= 0) {
                                state.isProcessing = false;
                            }
                        } else {
                            state.isProcessing = false;
                        }
                    }
                }
            } else {
                    // Campfire - queue-based logic
                if (!state.cookQueue) state.cookQueue = [];
                if (!state.campfireOutputSlots) state.campfireOutputSlots = [null,null,null,null];
                
                // If no input is loaded, try to pull from queue
                if (!state.inputItem && state.cookQueue.length > 0) {
                    const next = state.cookQueue.shift();
                    state.inputItem = next.item;
                    state.inputCount = 1;
                }
                
                if (!state.isProcessing && state.inputCount > 0 && state.fuelCount > 0) {
                    // Check if there's space in output slots
                    const hasOutputSpace = state.campfireOutputSlots.some(s => !s);
                    if (hasOutputSpace) {
                        state.isProcessing = true;
                        state.progress = 0;
                    }
                }
                
                if (state.isProcessing) {
                    const progressIncrement = (1000 / 60 / state.processTime) * 100;
                    state.progress += progressIncrement;
                    
                    if (state.progress >= 100) {
                        state.inputCount--;
                        state.fuelCount--;
                        
                        const cookedItem = (state.inputItem === 'mushroom' || state.inputItem === 'mushroom_crop') ? 'roasted_mushroom' : 'cooked_meat';
                        
                        // Find a free output slot (left to right)
                        let placed = false;
                        for (let i = 0; i < 4; i++) {
                            if (!state.campfireOutputSlots[i]) {
                                state.campfireOutputSlots[i] = { item: cookedItem, count: 1 };
                                placed = true;
                                break;
                            } else if (state.campfireOutputSlots[i].item === cookedItem) {
                                state.campfireOutputSlots[i].count++;
                                placed = true;
                                break;
                            }
                        }
                        if (!placed) {
                            // Output full, drop to legacy
                            state.outputItem = cookedItem;
                            state.outputCount++;
                        }
                        
                        state.wasteCount++;
                        state.progress = 0;
                        state.isProcessing = false;
                        
                        // Clear input if done, try to load next queued item
                        if (state.inputCount <= 0) {
                            state.inputItem = null;
                            if (state.cookQueue.length > 0) {
                                const next = state.cookQueue.shift();
                                state.inputItem = next.item;
                                state.inputCount = 1;
                            }
                        }
                        
                        // Check if can continue
                        if (state.inputCount > 0 && state.fuelCount > 0) {
                            const hasSpace = state.campfireOutputSlots.some(s => !s);
                            if (hasSpace) {
                                state.isProcessing = true;
                            }
                        }
                    }
                }
            }
        }
        
        // ===== COOKING STATION SYSTEM =====
        let currentCookingStation = null;

        // All valid ingredients for the cooking station
        const CS_VALID_FOODS = new Set([
            'meat','cooked_meat','mushroom','roasted_mushroom',
            'potato','carrot','corn','cabbage','tomato','pumpkin','wheat',
            'cucumber','strawberry','red_berries','black_berries','berries',
            'mushroom_crop','hemp_fiber','water_bottle','flour','bread',
            'blackcurrant_jam','strawberry_jam','egg','honey',
            'raw_fish','red_berries','pumpkin','cabbage'
        ]);

        // All cooking station recipes with display info
        const CS_RECIPES = [
            {
                id: 'cooked_meat_cs',
                cookTime: 20000,
                label: 'Cooked Meat',
                desc: '+35 Hunger, +10 Health',
                ingredients: ['meat'],
                result: 'cooked_meat'
            },
            {
                id: 'roasted_mushroom_cs',
                cookTime: 20000,
                label: 'Roasted Mushroom',
                desc: '+25 Hunger, +5 Health',
                ingredients: ['mushroom_crop'],
                result: 'roasted_mushroom'
            },
            {
                id: 'corn_bread',
                cookTime: 45000,
                label: 'Corn Bread',
                desc: '+45 Hunger',
                // Egg binds the batter in real cornbread
                ingredients: ['corn','wheat','egg'],
                result: 'corn_bread'
            },
            {
                id: 'hearty_meal',
                cookTime: 110000,
                label: 'Hearty Meal',
                desc: '+80 Hunger, +25 Health, +15 Thirst',
                // Egg adds protein to a full cooked spread
                ingredients: ['cooked_meat','carrot','corn','potato','tomato','egg'],
                result: 'hearty_meal',
                buff: { id: 'hearty', icon: '⚒️', label: 'Double Gathering', desc: 'Doubles resources from all gathering activities', duration: 600000 }
            },
            {
                id: 'flour',
                cookTime: 15000,
                label: 'Flour',
                desc: 'Crafting ingredient',
                ingredients: ['wheat','water_bottle'],
                result: 'flour'
            },
            {
                id: 'bread',
                cookTime: 40000,
                label: 'Bread',
                desc: '+35 Hunger',
                // Egg enriches the dough for a proper loaf
                ingredients: ['flour','water_bottle','egg'],
                result: 'bread'
            },
            {
                id: 'blackcurrant_jam',
                cookTime: 35000,
                label: 'Blackcurrant Jam',
                desc: '+20 Hunger, +10 Thirst',
                // Honey replaces refined sugar as the sweetener
                ingredients: ['black_berries','black_berries','black_berries','honey'],
                result: 'blackcurrant_jam'
            },
            {
                id: 'strawberry_jam',
                cookTime: 35000,
                label: 'Strawberry Jam',
                desc: '+20 Hunger, +10 Thirst, +5 Health',
                // Honey sets the jam and adds depth
                ingredients: ['strawberry','strawberry','strawberry','honey'],
                result: 'strawberry_jam'
            },
            {
                id: 'vegetable_stew',
                cookTime: 75000,
                label: 'Vegetable Stew',
                desc: '+50 Hunger, +20 Thirst, +10 Health',
                ingredients: ['mushroom_crop','carrot','potato','water_bottle'],
                result: 'vegetable_stew',
                buff: { id: 'veggi_stew', icon: '🥬', label: 'Stamina Saver', desc: 'Reduces stamina drain by 50% while sprinting', duration: 600000 }
            },
            {
                id: 'meat_stew',
                label: 'Meat Stew',
                desc: '+60 Hunger, +15 Health',
                ingredients: ['cooked_meat','potato','water_bottle'],
                result: 'meat_stew',
                buff: { id: 'meat_stew',
                cookTime: 60000, icon: '❤️', label: 'Fortified', desc: 'Gain 30% additional max health', duration: 600000 }
            },
            {
                id: 'toast_jam_blackcurrant',
                cookTime: 20000,
                label: 'Toast with Blackcurrant Jam',
                desc: '+50 Hunger, +5 Health',
                ingredients: ['bread','blackcurrant_jam'],
                result: 'toast_jam'
            },
            {
                id: 'toast_jam_strawberry',
                cookTime: 20000,
                label: 'Toast with Strawberry Jam',
                desc: '+50 Hunger, +5 Health',
                ingredients: ['bread','strawberry_jam'],
                result: 'toast_jam'
            },
            {
                id: 'ham_sandwich',
                cookTime: 50000,
                label: 'Ham Sandwich',
                desc: '+65 Hunger, +10 Health, +10 Thirst',
                ingredients: ['cucumber','tomato','cooked_meat','bread'],
                result: 'ham_sandwich'
            },
            {
                id: 'omelette',
                cookTime: 40000,
                label: 'Omelette',
                desc: '+50 Hunger, +15 Health',
                ingredients: ['egg','egg','mushroom_crop'],
                result: 'omelette',
                buff: { id: 'well_fed', icon: '🍰', label: 'Well Fed', desc: 'Hunger drains 40% slower for 3 minutes', duration: 180000 }
            },
            {
                id: 'scrambled_eggs',
                cookTime: 25000,
                label: 'Scrambled Eggs',
                desc: '+40 Hunger, +10 Health',
                ingredients: ['egg','egg'],
                result: 'scrambled_eggs',
                buff: { id: 'fortified_gut', icon: '🛡️', label: 'Fortified Gut', desc: 'Hunger & thirst paused for 2 minutes', duration: 120000 }
            },
            {
                id: 'honey_cake',
                cookTime: 90000,
                label: 'Honey Cake',
                desc: '+70 Hunger, +20 Health',
                ingredients: ['flour','egg','egg','honey','honey'],
                result: 'honey_cake',
                buff: { id: 'sugar_rush', icon: '⚡', label: 'Sugar Rush', desc: '+15% move speed for 90 seconds', duration: 90000 }
            },
            {
                id: 'honey_porridge',
                cookTime: 55000,
                label: 'Honey Porridge',
                desc: '+45 Hunger, +10 Thirst',
                ingredients: ['wheat','honey','water_bottle'],
                result: 'honey_porridge',
                buff: { id: 'hydrated', icon: '💧', label: 'Hydrated + Warmth', desc: 'Thirst drains 35% slower & cold resist for 4-5 mins', duration: 240000 }
            },
            {
                id: 'cooked_fish_cs',
                cookTime: 18000,
                label: 'Cooked Fish',
                desc: '+40 Hunger, +8 Health',
                ingredients: ['raw_fish'],
                result: 'cooked_fish'
            },
            {
                id: 'grilled_fish_stew',
                cookTime: 60000,
                label: 'Grilled Fish Stew',
                desc: '+65 Hunger, +20 Thirst, +15 Health',
                ingredients: ['raw_fish','potato','water_bottle'],
                result: 'grilled_fish_stew',
                buff: { id: 'well_fed', icon: '🍲', label: 'Well Fed', desc: 'Hunger drains 40% slower for 3 minutes', duration: 180000 }
            },
            {
                id: 'pumpkin_soup',
                cookTime: 40000,
                label: 'Pumpkin Soup',
                desc: '+45 Hunger, +25 Thirst, +8 Health',
                ingredients: ['pumpkin','water_bottle'],
                result: 'pumpkin_soup',
                buff: { id: 'warmth', icon: '🔥', label: 'Warmth', desc: 'Resists cold and slows temperature drain for 5 minutes', duration: 300000 }
            },
            {
                id: 'stuffed_pumpkin',
                cookTime: 90000,
                label: 'Stuffed Pumpkin',
                desc: '+75 Hunger, +15 Thirst, +20 Health',
                ingredients: ['pumpkin','cooked_meat','mushroom_crop'],
                result: 'stuffed_pumpkin',
                buff: { id: 'hearty', icon: '⚒️', label: 'Double Gathering', desc: 'Doubles resources from all gathering activities', duration: 600000 }
            },
            {
                id: 'pickled_cabbage',
                cookTime: 30000,
                label: 'Pickled Cabbage',
                desc: '+25 Hunger, +20 Thirst, +10 Health',
                ingredients: ['cabbage','water_bottle'],
                result: 'pickled_cabbage'
            },
            {
                id: 'cabbage_stew',
                cookTime: 65000,
                label: 'Cabbage Stew',
                desc: '+55 Hunger, +25 Thirst, +10 Health',
                ingredients: ['cabbage','potato','carrot','water_bottle'],
                result: 'cabbage_stew',
                buff: { id: 'veggi_stew', icon: '🥬', label: 'Stamina Saver', desc: 'Reduces stamina drain by 50% while sprinting', duration: 600000 }
            },
            {
                id: 'red_berry_jam',
                cookTime: 35000,
                label: 'Red Berry Jam',
                desc: '+20 Hunger, +15 Thirst, +5 Health',
                ingredients: ['red_berries','red_berries','red_berries','honey'],
                result: 'red_berry_jam'
            },
            {
                id: 'summer_salad',
                cookTime: 25000,
                label: 'Summer Salad',
                desc: '+30 Hunger, +35 Thirst, +12 Health',
                ingredients: ['cucumber','tomato','red_berries'],
                result: 'summer_salad',
                buff: { id: 'hydrated', icon: '💧', label: 'Hydrated', desc: 'Thirst drains 35% slower for 4 minutes', duration: 240000 }
            },
        ];

        function _csGetFilledIngredients(state) {
            const items = [];
            for (let slot of state.csInputSlots) {
                if (slot && slot.item) items.push(slot.item);
            }
            return items.sort();
        }

        function _csMatchRecipe(state) {
            const filled = _csGetFilledIngredients(state);
            if (filled.length === 0) return null;
            for (const recipe of CS_RECIPES) {
                const sorted = [...recipe.ingredients].sort();
                if (sorted.length !== filled.length) continue;
                if (sorted.join(',') === filled.join(',')) return recipe;
            }
            return null;
        }

        function createCookingStationState() {
            return {
                csInputSlots: [null, null, null, null, null],
                outputItem: null,
                outputCount: 0,
                // 4 output slots for cooked items
                csOutputSlots: [null, null, null, null],
                // Queue: array of {recipe, ingredients snapshot} pending cooking
                cookQueue: [],
                wasteCount: 0,
                progress: 0,
                isProcessing: false,
                processTime: 20000, // 20 seconds
                currentRecipe: null
            };
        }

        // Populate recipe book
        function _csPopulateRecipeBook() {
            const list = document.getElementById('cs-recipe-list');
            if (!list) return;
            list.innerHTML = '';
            CS_RECIPES.forEach(recipe => {
                const div = document.createElement('div');
                div.className = 'cs-recipe-entry';

                // Check if player has all ingredients
                const needed = {};
                recipe.ingredients.forEach(ing => { needed[ing] = (needed[ing]||0) + 1; });
                const canMake = Object.entries(needed).every(([item, count]) => (inventory[item]||0) >= count);
                if (canMake) {
                    div.style.background = 'rgba(0,180,60,0.18)';
                    div.style.borderColor = 'rgba(0,220,80,0.55)';
                    div.style.boxShadow = '0 0 8px rgba(0,200,60,0.25)';
                    div.style.cursor = 'pointer';
                } else {
                    div.style.cursor = 'default';
                    div.style.opacity = '0.75';
                }

                // Result row — large icon + name + stats
                const resultIcon = itemIcons[recipe.result] || '';
                const resultName = itemDisplayNames[recipe.result] || recipe.result;
                const resultRow = `<div class="cs-recipe-result-row">
                    <div class="cs-ricon">${resultIcon}</div>
                    <div class="cs-recipe-result-info">
                        <div class="cs-recipe-result-name">${resultName}</div>
                        <div class="cs-recipe-result-desc">${recipe.desc}</div>
                    </div>
                    ${canMake ? '<span style="margin-left:auto;font-size:11px;color:#4eff88;font-weight:bold;">✓ Can Cook</span>' : ''}
                </div>`;

                // Divider
                const divider = '<hr class="cs-recipe-divider">';

                // Ingredient icons — deduplicated with count prefix
                const ingCountMap = {};
                recipe.ingredients.forEach(i => { ingCountMap[i] = (ingCountMap[i]||0)+1; });
                const seen = {};
                const ingParts = [];
                recipe.ingredients.forEach(i => {
                    if (seen[i]) return;
                    seen[i] = true;
                    const count = ingCountMap[i];
                    const icon = itemIcons[i] || '';
                    const rawName = itemDisplayNames[i] || i;
                    const name = count > 1 ? count+'× ' + rawName : rawName;
                    const has = (inventory[i]||0) >= count;
                    const borderColor = has ? 'rgba(0,220,80,0.6)' : 'rgba(255,140,0,0.3)';
                    ingParts.push(`<div class="cs-recipe-ing-item">
                        <div class="cs-ricon" style="border-color:${borderColor};">${icon}</div>
                        <div class="cs-rname" style="color:${has ? 'rgba(100,255,130,0.9)' : 'rgba(255,220,150,0.85)'};">${name}</div>
                    </div>`);
                });
                const ingsRow = `<div class="cs-recipe-ings-row">${ingParts.join('<span class="cs-recipe-plus">+</span>')}</div>`;

                // Buff tag + cook time
                const cookSecs = recipe.cookTime ? Math.round(recipe.cookTime / 1000) : 20;
                const cookTimeStr = cookSecs >= 60 ? (cookSecs / 60).toFixed(0) + 'm' : cookSecs + 's';
                const buffTag = recipe.buff
                    ? `<span class="cs-recipe-buff-tag">${recipe.buff.icon} ${recipe.buff.label}</span>`
                    : '';
                const timeTag = `<span class="cs-recipe-buff-tag" style="background:rgba(80,80,120,0.5);border-color:rgba(150,150,200,0.4);color:rgba(200,200,255,0.9);">⏱ ${cookTimeStr}</span>`;

                div.innerHTML = resultRow + divider + ingsRow + buffTag + timeTag;

                // Hover tooltip for buff details
                if (recipe.buff) {
                    const durSecs = (recipe.buff.duration || 600000) / 1000;
                    const durStr = durSecs >= 60 ? Math.round(durSecs/60) + ' min' : durSecs + 's';
                    const tip = document.createElement('div');
                    tip.className = 'cs-recipe-tip';
                    tip.innerHTML = `<div class="cs-recipe-tip-title">${recipe.buff.icon} ${recipe.buff.label}</div><div class="cs-recipe-tip-buff">${recipe.buff.desc}</div><div class="cs-recipe-tip-duration">⏱ Lasts ${durStr}</div>`;
                    div.appendChild(tip);
                }

                div.title = canMake ? `Click to cook ${resultName} instantly!` : `${recipe.desc} — missing ingredients`;
                div.addEventListener('click', () => _csAutoFillRecipe(recipe));
                list.appendChild(div);
            });
        }

        function _csAutoFillRecipe(recipe) {
            const station = currentCookingStation;
            if (!station || !station.userData.cookingState) return;
            const state = station.userData.cookingState;
            if (!state.csOutputSlots) state.csOutputSlots = [null,null,null,null];
            if (!state.cookQueue)     state.cookQueue = [];

            // Check if player has all ingredients
            const needed = {};
            recipe.ingredients.forEach(ing => { needed[ing] = (needed[ing]||0) + 1; });
            const canMake = Object.entries(needed).every(([item, count]) => (inventory[item]||0) >= count);

            if (canMake) {
                // Green recipe = one-click cook: check queue space and start immediately
                const queueOccupied = state.cookQueue.length + state.csOutputSlots.filter(s => s).length;
                if (queueOccupied >= 4) {
                    showMessage('⚠️ Queue full! Collect cooked food first.');
                    return;
                }
                // Deduct ingredients from inventory
                recipe.ingredients.forEach(ing => { inventory[ing] = Math.max(0, (inventory[ing]||0) - 1); });
                // Build ingredient snapshot and push to queue
                const snap = recipe.ingredients.map(ing => ({ item: ing, count: 1 }));
                // Pad to 5 slots
                while (snap.length < 5) snap.push(null);
                state.cookQueue.push({ recipe, result: recipe.result, ingredientSlots: snap });
                const secs = Math.round((recipe.cookTime||20000) / 1000);
                showMessage(`🍳 Cooking ${itemDisplayNames[recipe.result]||recipe.result}! (${secs}s)`);
                updateUI(); updateInventoryDisplay(); updateCookingStationDisplay();
                _csPopulateRecipeBook(); // refresh green/grey after ingredients deducted
            } else {
                // Can't cook yet — just auto-fill the slots so player can see what's needed
                // Return whatever is currently in slots
                state.csInputSlots.forEach((slot, i) => {
                    if (slot) { inventory[slot.item] = (inventory[slot.item]||0) + slot.count; }
                    state.csInputSlots[i] = null;
                });
                // Fill with as many ingredients as we have
                recipe.ingredients.forEach((ing, i) => {
                    if ((inventory[ing]||0) > 0) {
                        state.csInputSlots[i] = { item: ing, count: 1 };
                        inventory[ing]--;
                    }
                });
                showMessage('⚠️ Missing ingredients — filled what you have.');
                updateUI(); updateInventoryDisplay(); updateCookingStationDisplay();
                _csPopulateRecipeBook(); // refresh green/grey after slot fill
            }
        }

        // Cooking sound
        let _cookingBuffer = null;
        let cookingSound = null;
        let cookingGainNode = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/cooking.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _cookingBuffer = buf; console.log('Cooking sound loaded OK'); })
            .catch(e => { console.error('Cooking sound fetch error:', e); });

        function startCookingSound() {
            if (cookingSound) return;
            if (!_cookingBuffer) return;
            cookingGainNode = audioContext.createGain();
            cookingGainNode.gain.setValueAtTime(0.55, audioContext.currentTime);
            cookingGainNode.connect(audioContext.destination);
            cookingSound = audioContext.createBufferSource();
            cookingSound.buffer = _cookingBuffer;
            cookingSound.loop = true;
            cookingSound.connect(cookingGainNode);
            cookingSound.start();
        }

        function stopCookingSound() {
            if (cookingSound) {
                const dyingNode = cookingSound;
                const dyingGain = cookingGainNode;
                // Clear immediately so next queue item can call startCookingSound()
                cookingSound = null;
                cookingGainNode = null;
                try { dyingGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4); } catch(e){}
                setTimeout(() => { try { dyingNode.stop(); } catch(e){} }, 500);
            }
        }

        function openCookingStationMenu(station) {
            currentCookingStation = station;
            playBenchSound();
            const menu = document.getElementById('cooking-station-menu');
            const inventoryPanel = document.getElementById('inventory-panel');
            menu.style.display = 'block';
            positionInventoryRight(inventoryPanel);
            inventoryPanel.style.display = 'block';
            uiOpen();
            _csPopulateRecipeBook();
            updateInventoryDisplay();
            updateCookingStationDisplay();
        }

        function closeCookingStationMenu() {
            closeAllUI();
        }

        function updateCookingStationDisplay() {
            const station = currentCookingStation;
            if (!station || !station.userData.cookingState) return;
            const state = station.userData.cookingState;
            if (!state.cookQueue) state.cookQueue = [];
            if (!state.csOutputSlots) state.csOutputSlots = [null,null,null,null];

            // NOTE: _csPopulateRecipeBook() intentionally NOT called here.
            // Calling it every frame destroys/recreates recipe cards 60x/sec,
            // breaking click events (mousedown and mouseup land on different elements).
            // Recipe book is refreshed only when the menu opens and after cooking completes.

            // Input slots
            for (let i = 0; i < 5; i++) {
                const el = document.getElementById(`cs-input-${i}`);
                if (!el) continue;
                const slot = state.csInputSlots[i];
                const container = el.closest('.cs-slot-container');
                let nameEl = container ? container.querySelector('.cs-item-name') : null;
                if (!nameEl && container) {
                    nameEl = document.createElement('div');
                    nameEl.className = 'cs-item-name';
                    container.appendChild(nameEl);
                }
                if (slot && slot.item) {
                    el.innerHTML = `${itemIcons[slot.item] || '?'}<div class="cs-slot-count">${slot.count}</div>`;
                    if (nameEl) nameEl.textContent = itemDisplayNames[slot.item] || slot.item;
                } else {
                    el.innerHTML = '+';
                    if (nameEl) nameEl.textContent = '';
                }
            }

            // Recipe hint & cook button
            const hint = document.getElementById('cs-recipe-hint');
            // cookBtn removed — recipe cards handle cooking directly
            const recipe = _csMatchRecipe(state);
            state.currentRecipe = recipe;
            const queueFull = (state.cookQueue.length >= 4);
            if (state.isProcessing) {
                const activeRecipe = state.cookQueue[0] ? state.cookQueue[0].recipe : state.currentRecipe;
                hint.textContent = `🍳 Cooking: ${itemDisplayNames[activeRecipe?.result] || '...'}`;
                hint.style.color = 'rgba(100,255,130,0.95)';
            } else if (queueFull) {
                hint.textContent = '⏳ Queue full — collect cooked food!';
                hint.style.color = 'rgba(255,180,80,0.9)';
            } else if (recipe) {
                const resultName = itemDisplayNames[recipe.result] || recipe.result;
                const resultIconHtml = itemIcons[recipe.result] ? `<span style="display:inline-flex;width:20px;height:20px;vertical-align:middle;flex-shrink:0;">${itemIcons[recipe.result]}</span>` : '';
                hint.innerHTML = `✅ Recipe ready: ${resultIconHtml} <strong>${resultName}</strong>`;
                hint.style.color = 'rgba(100,255,130,0.95)';
            } else if (_csGetFilledIngredients(state).length > 0) {
                hint.textContent = 'No recipe found for these ingredients...';
                hint.style.color = 'rgba(255,180,80,0.9)';
            } else {
                hint.textContent = '👆 Click a green recipe card to cook!';
                hint.style.color = 'rgba(255,200,100,0.9)';
            }

            // 4 Output slots
            if (!state.csOutputSlots) state.csOutputSlots = [null,null,null,null];
            for (let oi = 0; oi < 4; oi++) {
                const outEl = document.getElementById(`cs-output-slot-${oi}`);
                if (!outEl) continue;
                const outData = state.csOutputSlots[oi];
                if (outData && outData.count > 0) {
                    outEl.innerHTML = `${itemIcons[outData.item] || '?'}<div class="cs-slot-count">${outData.count}</div>`;
                    outEl.draggable = true;
                    outEl.dataset.itemName = outData.item;
                    outEl.dataset.slotType = 'cs-output-new';
                    outEl.dataset.slotIndex = String(oi);
                } else {
                    outEl.innerHTML = '';
                    outEl.draggable = false;
                    delete outEl.dataset.itemName;
                }
            }

            // Legacy single output slot (hidden but still functional for compat)
            const outEl = document.getElementById('cs-output-slot');
            if (outEl) {
                if (state.outputCount > 0) {
                    outEl.innerHTML = `${itemIcons[state.outputItem] || '?'}<div class="cs-slot-count">${state.outputCount}</div>`;
                } else {
                    outEl.innerHTML = '';
                }
            }

            // Queue display
            if (!state.cookQueue) state.cookQueue = [];
            const csQueueEl = document.getElementById('cs-queue-display');
            if (csQueueEl) {
                csQueueEl.innerHTML = '';
                state.cookQueue.forEach((entry) => {
                    const resultName = itemDisplayNames[entry.result] || entry.result;
                    const resultIcon = itemIcons[entry.result] || '?';
                    const qItem = document.createElement('div');
                    qItem.style.cssText = 'display:flex;flex-direction:column;align-items:center;gap:3px;';
                    qItem.innerHTML = `<div style="width:36px;height:36px;background:rgba(0,0,0,0.5);border:2px solid rgba(255,140,0,0.5);border-radius:6px;display:flex;align-items:center;justify-content:center;">${resultIcon}</div><div style="font-size:8px;color:rgba(255,200,100,0.8);text-align:center;width:38px;">${resultName}</div>`;
                    csQueueEl.appendChild(qItem);
                });
                if (state.cookQueue.length === 0) {
                    csQueueEl.innerHTML = '<div style="color:rgba(255,255,255,0.3);font-size:11px;">Empty — click a green recipe to cook!</div>';
                }
            }

            // Waste slot
            const wasteEl = document.getElementById('cs-waste-slot');
            if (wasteEl) {
                if (state.wasteCount > 0) {
                    wasteEl.innerHTML = `${itemIcons['ash'] || '💨'}<div class="cs-slot-count">${state.wasteCount}</div>`;
                } else {
                    wasteEl.innerHTML = '';
                }
            }

            // Progress bar
            const pct = Math.floor(state.progress);
            const progEl = document.getElementById('cs-progress');
            const textEl = document.getElementById('cs-progress-text');
            const queueInfo = state.cookQueue.length > 0 ? ` (${state.cookQueue.length} queued)` : '';
            if (progEl) progEl.style.width = pct + '%';
            if (textEl) textEl.textContent = state.isProcessing ? pct + '%' + queueInfo : (state.cookQueue.length > 0 ? '⏳ Starting...' : '0%');
        }

        function addToCookingSlot(slotType, slotIndex) {
            const station = currentCookingStation;
            if (!station || !station.userData.cookingState) return;
            const state = station.userData.cookingState;
            if (!state.csOutputSlots) state.csOutputSlots = [null,null,null,null];

            if (slotType === 'input') {
                const slot = state.csInputSlots[slotIndex];
                // If slot has item, return it to inventory
                if (slot && slot.item) {
                    inventory[slot.item] = (inventory[slot.item]||0) + slot.count;
                    state.csInputSlots[slotIndex] = null;
                    updateUI(); updateInventoryDisplay(); updateCookingStationDisplay();
                    return;
                }
                // Otherwise try to add from inventory
                let placed = false;
                for (const itemName of CS_VALID_FOODS) {
                    if ((inventory[itemName]||0) > 0) {
                        state.csInputSlots[slotIndex] = { item: itemName, count: 1 };
                        inventory[itemName]--;
                        placed = true;
                        break;
                    }
                }
                if (!placed) { showMessage('⚠️ No valid ingredients in inventory!'); return; }
                updateUI(); updateCookingStationDisplay();
            } else if (slotType === 'output') {
                // Legacy single output slot
                if (state.outputCount > 0) {
                    inventory[state.outputItem] = (inventory[state.outputItem]||0) + state.outputCount;
                    state.outputCount = 0; state.outputItem = null;
                    playInventoryMoveSound(); updateUI(); updateCookingStationDisplay();
                }
            } else if (slotType === 'output-new') {
                // New 4-slot output
                const outData = state.csOutputSlots[slotIndex];
                if (outData && outData.count > 0) {
                    inventory[outData.item] = (inventory[outData.item]||0) + outData.count;
                    state.csOutputSlots[slotIndex] = null;
                    playInventoryMoveSound(); updateUI(); updateCookingStationDisplay();
                }
            } else if (slotType === 'waste') {
                if (state.wasteCount > 0) {
                    inventory.ash = (inventory.ash||0) + state.wasteCount;
                    state.wasteCount = 0;
                    playInventoryMoveSound(); updateUI(); updateCookingStationDisplay();
                }
            }
        }

        function _csDragDropToInputSlot(slotIndex, dragItemName, dragCount) {
            const station = currentCookingStation;
            if (!station || !station.userData.cookingState) return;
            const state = station.userData.cookingState;
            if (state.isProcessing) { showMessage('⚠️ Cooking in progress!'); return; }
            if (!CS_VALID_FOODS.has(dragItemName)) {
                showMessage('⚠️ That item cannot be cooked!');
                return;
            }
            const slot = state.csInputSlots[slotIndex];
            if (slot && slot.item !== dragItemName) {
                showMessage('⚠️ That slot already has a different ingredient!');
                return;
            }
            const actual = Math.min(dragCount, inventory[dragItemName] || 0);
            if (actual <= 0) return;
            if (!slot) {
                state.csInputSlots[slotIndex] = { item: dragItemName, count: actual };
            } else {
                slot.count += actual;
            }
            if (draggedFromType === 'inventory') {
                inventory[dragItemName] = Math.max(0, (inventory[dragItemName] || 0) - actual);
                if (inventorySlotCounts[draggedFromSlot] !== null) {
                    inventorySlotCounts[draggedFromSlot] = Math.max(0, inventorySlotCounts[draggedFromSlot] - actual);
                    if (inventorySlotCounts[draggedFromSlot] <= 0) { inventorySlotCounts[draggedFromSlot] = null; inventorySlots[draggedFromSlot] = null; }
                } else if (inventory[dragItemName] <= 0) { inventorySlots[draggedFromSlot] = null; }
            } else if (draggedFromType === 'hotbar') {
                inventory[dragItemName] = Math.max(0, (inventory[dragItemName] || 0) - actual);
                if (inventory[dragItemName] <= 0) hotbar[draggedFromSlot].item = null;
            }
            updateInventoryDisplay();
            updateHotbar();
            updateCookingStationDisplay();
        }

        function updateCookingProcess() {
            buildings.forEach(building => {
                if (!building.userData.isCookingStation || !building.userData.cookingState) return;
                const state = building.userData.cookingState;
                if (!state.cookQueue) state.cookQueue = [];
                if (!state.csOutputSlots) state.csOutputSlots = [null,null,null,null];

                // If not processing, try to start next queued recipe
                if (!state.isProcessing && state.cookQueue.length > 0) {
                    // Check output space
                    const hasSpace = state.csOutputSlots.some(s => !s);
                    if (hasSpace) {
                        const next = state.cookQueue[0];
                        // Load ingredients into slots
                        state.csInputSlots = next.ingredientSlots;
                        state.currentRecipe = next.recipe;
                        state.processTime = next.recipe.cookTime || 20000;
                        state.isProcessing = true;
                        state.progress = 0;
                        startCookingSound();
                    }
                }

                if (!state.isProcessing) return;

                const recipe = state.currentRecipe || _csMatchRecipe(state);
                if (!recipe) { state.isProcessing = false; stopCookingSound(); return; }

                const inc = (1000 / 60 / state.processTime) * 100;
                state.progress += inc;

                if (state.progress >= 100) {
                    state.progress = 0;
                    state.isProcessing = false;
                    stopCookingSound();
                    // Consume ingredients
                    const toConsume = [...recipe.ingredients];
                    for (let i = 0; i < 5; i++) {
                        const slot = state.csInputSlots[i];
                        if (!slot) continue;
                        const idx = toConsume.indexOf(slot.item);
                        if (idx !== -1) {
                            toConsume.splice(idx, 1);
                            slot.count--;
                            if (slot.count <= 0) state.csInputSlots[i] = null;
                        }
                    }
                    // Remove from queue
                    state.cookQueue.shift();
                    // Clear input slots for next recipe
                    state.csInputSlots = [null,null,null,null,null];
                    
                    // Place output in first available output slot
                    let placed = false;
                    for (let i = 0; i < 4; i++) {
                        if (!state.csOutputSlots[i]) {
                            state.csOutputSlots[i] = { item: recipe.result, count: 1 };
                            placed = true;
                            break;
                        } else if (state.csOutputSlots[i].item === recipe.result) {
                            state.csOutputSlots[i].count++;
                            placed = true;
                            break;
                        }
                    }
                    if (!placed) {
                        // Fallback legacy
                        if (!state.outputItem) state.outputItem = recipe.result;
                        if (state.outputItem === recipe.result) state.outputCount++;
                        else inventory[recipe.result] = (inventory[recipe.result]||0) + 1;
                    }
                    state.wasteCount++;
                    state.currentRecipe = null;
                    showMessage(`🍳 ${itemDisplayNames[recipe.result]||recipe.result} is ready!`);
                    // Refresh recipe book green/grey availability after cooking
                    if (currentCookingStation) _csPopulateRecipeBook();
                }
            });

            if (currentCookingStation) updateCookingStationDisplay();
        }

        // ===== BUILDING SYSTEM =====
        const buildings = [];
        let buildMode = null;
        let buildPreview = null;
        let snapToGrid = true; // Toggle for snapping
        let buildRotation = 0; // Current rotation angle
        
        // Upgrade system: defines upgrade paths and costs for each building piece
        const buildingUpgrades = {
            wall: {
                tiers: ['wall', 'stone_wall', 'metal_wall'],
                costs: {
                    stone_wall: { stone: 10 },
                    metal_wall: { iron_ingot: 5 }
                }
            },
            window_wall: {
                tiers: ['window_wall', 'stone_window_wall', 'metal_window_wall'],
                costs: {
                    stone_window_wall: { stone: 10 },
                    metal_window_wall: { iron_ingot: 5 }
                }
            },
            floor: {
                tiers: ['floor', 'stone_floor', 'metal_floor'],
                costs: {
                    stone_floor: { stone: 10 },
                    metal_floor: { iron_ingot: 5 }
                }
            },
            ceiling: {
                tiers: ['ceiling', 'stone_ceiling', 'metal_ceiling'],
                costs: {
                    stone_ceiling: { stone: 10 },
                    metal_ceiling: { iron_ingot: 5 }
                }
            },
            stairs: {
                tiers: ['stairs', 'stone_stairs', 'metal_stairs'],
                costs: {
                    stone_stairs: { stone: 8 },
                    metal_stairs: { iron_ingot: 4 }
                }
            },
            corner_stairs_left: {
                tiers: ['corner_stairs_left', 'stone_corner_stairs_left', 'metal_corner_stairs_left'],
                costs: {
                    stone_corner_stairs_left: { stone: 8 },
            metal_corner_stairs_left: {
                name: '🪜 Metal Corner Stairs (Left)',
                cost: { iron_ingot: 4 },
                create: async () => {
                    const g = new THREE.Group();
                    const treadMat=await createMetalMaterial(0xB0B8C0,0.3);
                    const frameMat=await createMetalMaterial(0x888E96,0.5);
                    const n=5, halfH=1.5, legD=2.0, stepW=1.8;
                    const stepH=halfH/n, stepD=legD/n;
                    for (let i=0;i<n;i++) {
                        const y=(i+1)*stepH, z=-2+i*stepD+stepD*0.5;
                        const tread=new THREE.Mesh(new THREE.BoxGeometry(stepW,0.05,stepD+0.02),treadMat.clone());
                        tread.position.set(1.0,y,z); tread.castShadow=true; tread.receiveShadow=true; g.add(tread);
                    }
                    const landing=new THREE.Mesh(new THREE.BoxGeometry(2.0,0.05,2.0),treadMat.clone());
                    landing.position.set(1.0,halfH,1.0); landing.castShadow=true; landing.receiveShadow=true; g.add(landing);
                    for (let i=0;i<n;i++) {
                        const y=halfH+(i+1)*stepH, x=2-i*stepD-stepD*0.5;
                        const tread=new THREE.Mesh(new THREE.BoxGeometry(stepD+0.02,0.05,stepW),treadMat.clone());
                        tread.position.set(x,y,1.0); tread.castShadow=true; tread.receiveShadow=true; g.add(tread);
                    }
                    g.userData.isStairs=true; g.userData.isCornerStairs=true; g.userData.cornerDir='left';
                    g.userData.collisionBox=new THREE.Box3().setFromObject(g); return g;
                }
            },
            stone_corner_stairs_right: {
                name: '🪜 Stone Corner Stairs (Right)',
                cost: { stone: 8 },
                create: async () => {
                    const g = new THREE.Group();
                    const stoneMat=await createStoneMaterial(0x808080,0.9);
                    const n=5, halfH=1.5, legD=2.0, stepW=1.8;
                    const stepH=halfH/n, stepD=legD/n;
                    for (let i=0;i<n;i++) {
                        const step=new THREE.Mesh(new THREE.BoxGeometry(stepW,stepH*(i+1),stepD),stoneMat.clone());
                        step.position.set(-1.0,(i+1)*stepH*0.5,-2+i*stepD+stepD*0.5);
                        step.castShadow=true; step.receiveShadow=true; g.add(step);
                    }
                    const landing=new THREE.Mesh(new THREE.BoxGeometry(2.0,stepH,2.0),stoneMat.clone());
                    landing.position.set(-1.0,halfH-stepH*0.5,1.0); landing.castShadow=true; landing.receiveShadow=true; g.add(landing);
                    for (let i=0;i<n;i++) {
                        const step=new THREE.Mesh(new THREE.BoxGeometry(stepD,stepH*(i+1),stepW),stoneMat.clone());
                        step.position.set(-2+i*stepD+stepD*0.5,halfH+(i+1)*stepH*0.5,1.0);
                        step.castShadow=true; step.receiveShadow=true; g.add(step);
                    }
                    g.userData.isStairs=true; g.userData.isCornerStairs=true; g.userData.cornerDir='right';
                    g.userData.collisionBox=new THREE.Box3().setFromObject(g); return g;
                }
            },
                }
            },
            door_frame: {
                tiers: ['door_frame', 'stone_door_frame', 'metal_door_frame'],
                costs: {
                    stone_door_frame: { stone: 8 },
                    metal_door_frame: { iron_ingot: 4 }
                }
            },
            double_door_frame: {
                tiers: ['double_door_frame', 'stone_double_door_frame', 'metal_double_door_frame'],
                costs: {
                    stone_double_door_frame: { stone: 10 },
                    metal_double_door_frame: { iron_ingot: 5 }
                }
            }
        };
        
        // Helper function to get upgrade info for a building
        function getUpgradeInfo(buildingType) {
            for (const baseType in buildingUpgrades) {
                const upgrade = buildingUpgrades[baseType];
                const currentIndex = upgrade.tiers.indexOf(buildingType);
                if (currentIndex !== -1 && currentIndex < upgrade.tiers.length - 1) {
                    const nextTier = upgrade.tiers[currentIndex + 1];
                    return {
                        canUpgrade: true,
                        nextTier: nextTier,
                        cost: upgrade.costs[nextTier],
                        currentTier: currentIndex + 1,
                        maxTier: upgrade.tiers.length
                    };
                } else if (currentIndex === upgrade.tiers.length - 1) {
                    return { canUpgrade: false, maxed: true };
                }
            }
            return { canUpgrade: false };
        }
        
        // Helper function to check if a building type is a floor or ceiling
        function isFloorOrCeiling(buildingType) {
            return buildingType === 'floor' || buildingType === 'stone_floor' || buildingType === 'metal_floor' ||
                   buildingType === 'ceiling' || buildingType === 'stone_ceiling' || buildingType === 'metal_ceiling';
        }
        
        // Check if player is standing under a ceiling/roof
        function isPlayerUnderRoof() {
            const playerX = camera.position.x;
            const playerY = camera.position.y;
            const playerZ = camera.position.z;
            
            for (let building of buildings) {
                const bt = building.userData.buildingType;
                // Check if it's a ceiling
                if (bt === 'ceiling' || bt === 'stone_ceiling' || bt === 'metal_ceiling') {
                    const box = new THREE.Box3().setFromObject(building);
                    
                    // Check if player is under this ceiling (XZ within bounds, Y below ceiling)
                    if (playerX >= box.min.x && playerX <= box.max.x &&
                        playerZ >= box.min.z && playerZ <= box.max.z &&
                        playerY < box.max.y && playerY > box.min.y - 4) { // Within 4 units below ceiling
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Helper function to check if player has enough resources
        function hasResources(cost) {
            for (const resource in cost) {
                if (!inventory[resource] || inventory[resource] < cost[resource]) {
                    return false;
                }
            }
            return true;
        }
        
        // Helper function to deduct resources
        function deductResources(cost) {
            for (const resource in cost) {
                inventory[resource] -= cost[resource];
            }
        }
        
        // ── Shared planter mesh builder (used by both planter_box and large_planter) ──
        // slotXArr and slotZArr are parallel arrays of local X,Z positions for each slot
        function _buildPlanterMesh(W, D, slotCount, slotXArr, slotZArr) {
            const group = new THREE.Group();
            const H = 0.52, plankT = 0.07;
            const woodMat  = new THREE.MeshStandardMaterial({ color: 0x8B6418, roughness: 0.9 });
            const frameMat = new THREE.MeshStandardMaterial({ color: 0x6B4C10, roughness: 0.85 });
            const linerMat = new THREE.MeshStandardMaterial({ color: 0x2255AA, roughness: 0.95, side: THREE.FrontSide });
            const dirtMat  = new THREE.MeshStandardMaterial({ color: 0x5C3D1E, roughness: 1.0 });
            const stoneMat = new THREE.MeshStandardMaterial({ color: 0x888877, roughness: 0.95 });
            const divotMat = new THREE.MeshStandardMaterial({ color: 0x3A2510, roughness: 1.0 });

            const pc = 5; // planks per side
            // Long sides (x-axis)
            for (let side=0; side<2; side++) {
                const zSign = side===0?-1:1;
                for (let p=0; p<pc; p++) {
                    const py = -H/2 + plankT/2 + p*(H-plankT)/(pc-1);
                    const m = new THREE.Mesh(new THREE.BoxGeometry(W, plankT*1.1, plankT), woodMat);
                    m.position.set(0, py, zSign*(D/2-plankT/2));
                    m.castShadow = m.receiveShadow = true;
                    group.add(m);
                }
            }
            // Short sides (z-axis)
            for (let side=0; side<2; side++) {
                const xSign = side===0?-1:1;
                for (let p=0; p<4; p++) {
                    const py = -H/2 + plankT/2 + p*(H-plankT)/3;
                    const m = new THREE.Mesh(new THREE.BoxGeometry(plankT, plankT*1.1, D-plankT*2), woodMat);
                    m.position.set(xSign*(W/2-plankT/2), py, 0);
                    m.castShadow = true;
                    group.add(m);
                }
            }
            // Corner posts
            const postS = 0.1, postH = H+0.14;
            [[-1,-1],[1,-1],[-1,1],[1,1]].forEach(([xs,zs]) => {
                const p = new THREE.Mesh(new THREE.BoxGeometry(postS, postH, postS), frameMat);
                p.position.set(xs*(W/2-postS/2), 0, zs*(D/2-postS/2));
                p.castShadow = p.receiveShadow = true;
                group.add(p);
            });
            // Bottom board
            const btm = new THREE.Mesh(new THREE.BoxGeometry(W-plankT*2, plankT, D-plankT*2), woodMat);
            btm.position.set(0, -H/2+plankT/2, 0);
            group.add(btm);
            // Blue liner
            const lD = H-plankT;
            [-1,1].forEach(zs => {
                const l = new THREE.Mesh(new THREE.BoxGeometry(W-plankT*2, lD, 0.01), linerMat);
                l.position.set(0, -plankT/2, zs*(D/2-plankT-0.005));
                group.add(l);
            });
            [-1,1].forEach(xs => {
                const l = new THREE.Mesh(new THREE.BoxGeometry(0.01, lD, D-plankT*2), linerMat);
                l.position.set(xs*(W/2-plankT-0.005), -plankT/2, 0);
                group.add(l);
            });
            // Dirt
            const dirtY = H/2 - 0.1;
            const dirt = new THREE.Mesh(new THREE.BoxGeometry(W-plankT*2-0.02, 0.18, D-plankT*2-0.02), dirtMat);
            dirt.position.set(0, dirtY-0.09, 0);
            dirt.receiveShadow = true;
            group.add(dirt);
            // Pebbles
            for (let i=0; i<10; i++) {
                const sr = 0.03+Math.random()*0.04;
                const s = new THREE.Mesh(new THREE.DodecahedronGeometry(sr,0), stoneMat);
                s.position.set((Math.random()-0.5)*(W-plankT*2-0.2), dirtY+sr*0.3, (Math.random()-0.5)*(D-plankT*2-0.15));
                s.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
                group.add(s);
            }
            // Slot divots
            for (let i=0; i<slotCount; i++) {
                const divot = new THREE.Mesh(new THREE.CylinderGeometry(0.07,0.05,0.04,8), divotMat);
                divot.position.set(slotXArr[i], dirtY+0.01, slotZArr[i]||0);
                group.add(divot);
            }
            // Plant container
            const plantContainer = new THREE.Group();
            plantContainer.name = 'plantContainer';
            group.add(plantContainer);

            // Build slot position objects for the userData
            const slotDefs = [];
            for (let i=0; i<slotCount; i++) slotDefs.push({x: slotXArr[i], z: slotZArr[i]||0});

            group.userData.isPlanterBox = true;
            group.userData.dirtY = dirtY;
            group.userData.slotDefs = slotDefs;          // [{x,z}] — new format
            group.userData.slotPositions = slotXArr;     // legacy compat (x only)
            group.userData.slotZPositions = slotZArr || slotXArr.map(()=>0);
            group.userData.seeds = new Array(slotCount).fill(null);
            group.userData.plantContainer = plantContainer;
            group.userData.wateredThisRain = false;
            return group;
        }

        const buildingTypes = {
            // ═══════════════════════════════════════════════════════════════
            //  WALLS
            // ═══════════════════════════════════════════════════════════════
            wall: {
                name: '🧱 Wooden Wall',
                cost: { wood: 5 },
                create: async () => {
                    const g = new THREE.Group();
                    const plankMat = await createWoodMaterial(0x9C7A3C, 0.82);
                    const frameMat = await createWoodMaterial(0x5C3A1E, 0.75);

                    // Single solid panel — no z-fighting
                    const panel = new THREE.Mesh(
                        new THREE.BoxGeometry(4, 3, 0.18),
                        plankMat
                    );
                    panel.castShadow = true;
                    panel.receiveShadow = true;
                    g.add(panel);

                    // Outer frame — set back so planks proud of frame, polygonOffset prevents z-fight
                    const frameOffMat = frameMat.clone();
                    frameOffMat.polygonOffset = true;
                    frameOffMat.polygonOffsetFactor = -1;
                    frameOffMat.polygonOffsetUnits  = -1;

                    // Top & bottom rails
                    for (const y of [1.45, -1.45]) {
                        const rail = new THREE.Mesh(new THREE.BoxGeometry(4.06, 0.2, 0.22), frameOffMat);
                        rail.position.set(0, y, 0);
                        rail.castShadow = true;
                        g.add(rail);
                    }
                    // Left & right posts
                    for (const x of [-1.96, 1.96]) {
                        const post = new THREE.Mesh(new THREE.BoxGeometry(0.2, 3.1, 0.22), frameOffMat);
                        post.position.set(x, 0, 0);
                        post.castShadow = true;
                        g.add(post);
                    }
                    // Centre horizontal rail
                    const midRail = new THREE.Mesh(new THREE.BoxGeometry(4.06, 0.16, 0.22), frameOffMat);
                    midRail.position.set(0, 0, 0);
                    midRail.castShadow = true;
                    g.add(midRail);

                    // X-brace planks sit in front of the panel
                    const braceLen = Math.sqrt(16 + 9);
                    const braceMat = frameMat.clone();
                    braceMat.polygonOffset = true;
                    braceMat.polygonOffsetFactor = -2;
                    braceMat.polygonOffsetUnits  = -2;
                    for (const sign of [1, -1]) {
                        const brace = new THREE.Mesh(new THREE.BoxGeometry(braceLen, 0.1, 0.08), braceMat);
                        brace.rotation.z = sign * Math.atan2(3, 4);
                        brace.position.z = 0.13;
                        g.add(brace);
                    }

                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            stone_wall: {
                name: '🧱 Stone Wall',
                cost: { stone: 10 },
                create: async () => {
                    const g = new THREE.Group();
                    const stoneMat = await createStoneMaterial(0x7A7A7A, 0.92);
                    const mortarMat = new THREE.MeshStandardMaterial({ color: 0x4A4A4A, roughness: 0.98 });

                    // Solid backing panel
                    const backing = new THREE.Mesh(new THREE.BoxGeometry(4, 3, 0.32), stoneMat);
                    backing.receiveShadow = true;
                    backing.castShadow = true;
                    g.add(backing);

                    // Horizontal mortar lines proud of backing — no z-fight via polygonOffset
                    const mortarOff = mortarMat.clone();
                    mortarOff.polygonOffset = true;
                    mortarOff.polygonOffsetFactor = -1;
                    mortarOff.polygonOffsetUnits  = -1;

                    const rowH = 0.75; // 4 rows in 3 units
                    for (let r = 1; r < 4; r++) {
                        const line = new THREE.Mesh(new THREE.BoxGeometry(4, 0.04, 0.34), mortarOff);
                        line.position.set(0, -1.5 + r * rowH, 0);
                        g.add(line);
                    }
                    // Vertical mortar joints — alternating per row
                    const cols = [5, 4, 5, 4];
                    for (let r = 0; r < 4; r++) {
                        const n = cols[r];
                        const bw = 4 / n;
                        const offset = (r % 2 === 0) ? 0 : bw * 0.5;
                        for (let c = 1; c < n; c++) {
                            const joint = new THREE.Mesh(new THREE.BoxGeometry(0.04, rowH - 0.04, 0.34), mortarOff);
                            joint.position.set(-2 + offset + c * bw, -1.5 + r * rowH + rowH * 0.5, 0);
                            g.add(joint);
                        }
                    }

                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            metal_wall: {
                name: '🧱 Metal Wall',
                cost: { iron_ingot: 5 },
                create: async () => {
                    const g = new THREE.Group();
                    const sheetMat  = await createMetalMaterial(0xB0B8C0, 0.28);
                    const frameMat  = await createMetalMaterial(0x888E96, 0.45);
                    const rivetMat  = await createMetalMaterial(0x555960, 0.6);

                    // Solid sheet backing
                    const sheet = new THREE.Mesh(new THREE.BoxGeometry(4, 3, 0.12), sheetMat);
                    sheet.castShadow = true;
                    sheet.receiveShadow = true;
                    g.add(sheet);

                    // Frame channels — proud of sheet, polygonOffset prevents fight
                    const frameOff = frameMat.clone();
                    frameOff.polygonOffset = true;
                    frameOff.polygonOffsetFactor = -1;
                    frameOff.polygonOffsetUnits  = -1;

                    // Vertical posts
                    for (const x of [-1.85, 0, 1.85]) {
                        const post = new THREE.Mesh(new THREE.BoxGeometry(0.14, 3.1, 0.16), frameOff);
                        post.position.set(x, 0, 0);
                        post.castShadow = true;
                        g.add(post);
                    }
                    // Horizontal rails
                    for (const y of [1.42, 0, -1.42]) {
                        const rail = new THREE.Mesh(new THREE.BoxGeometry(4.1, 0.12, 0.16), frameOff);
                        rail.position.set(0, y, 0);
                        rail.castShadow = true;
                        g.add(rail);
                    }

                    // Corrugation ridges on panels — proud, polygonOffset
                    const ridgeOff = (await createMetalMaterial(0xC5CBD2, 0.32)).clone();
                    ridgeOff.polygonOffset = true;
                    ridgeOff.polygonOffsetFactor = -2;
                    ridgeOff.polygonOffsetUnits  = -2;
                    const panelXs = [-0.925, 0.925];
                    for (const px of panelXs) {
                        for (let j = 0; j < 6; j++) {
                            const ridge = new THREE.Mesh(new THREE.BoxGeometry(0.03, 2.9, 0.04), ridgeOff);
                            ridge.position.set(px - 0.75 + j * 0.3, 0, 0.08);
                            g.add(ridge);
                        }
                    }

                    // Rivets at frame intersections
                    const rivetOff = rivetMat.clone();
                    rivetOff.polygonOffset = true;
                    rivetOff.polygonOffsetFactor = -3;
                    rivetOff.polygonOffsetUnits  = -3;
                    for (const x of [-1.85, 0, 1.85]) {
                        for (const y of [1.42, 0, -1.42]) {
                            const rivet = new THREE.Mesh(new THREE.CylinderGeometry(0.035, 0.035, 0.06, 8), rivetOff);
                            rivet.rotation.x = Math.PI / 2;
                            rivet.position.set(x, y, 0.14);
                            g.add(rivet);
                        }
                    }

                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            // ═══════════════════════════════════════════════════════════════
            //  WINDOW WALLS
            // ═══════════════════════════════════════════════════════════════
            window_wall: {
                name: '🪟 Window Wall',
                cost: { wood: 5, stone: 2 },
                create: async () => {
                    const g = new THREE.Group();
                    const plankMat = await createWoodMaterial(0x9C7A3C, 0.82);
                    const frameMat = await createWoodMaterial(0x5C3A1E, 0.75);
                    const glassMat = new THREE.MeshStandardMaterial({
                        color: 0xADD8E6, transparent: true, opacity: 0.28,
                        roughness: 0.05, metalness: 0.25, side: THREE.DoubleSide, depthWrite: false
                    });

                    const frameOff = frameMat.clone();
                    frameOff.polygonOffset = true;
                    frameOff.polygonOffsetFactor = -1;
                    frameOff.polygonOffsetUnits  = -1;

                    // Bottom solid panel
                    const bottom = new THREE.Mesh(new THREE.BoxGeometry(4, 1.1, 0.18), plankMat);
                    bottom.position.y = -0.95;
                    bottom.castShadow = true; bottom.receiveShadow = true;
                    g.add(bottom);

                    // Top solid panel
                    const top = new THREE.Mesh(new THREE.BoxGeometry(4, 0.85, 0.18), plankMat);
                    top.position.y = 1.075;
                    top.castShadow = true; top.receiveShadow = true;
                    g.add(top);

                    // Frame — outer posts and rails
                    for (const x of [-1.96, 1.96]) {
                        const post = new THREE.Mesh(new THREE.BoxGeometry(0.2, 3.1, 0.22), frameOff);
                        post.position.set(x, 0, 0);
                        post.castShadow = true;
                        g.add(post);
                    }
                    for (const y of [1.45, -1.45]) {
                        const rail = new THREE.Mesh(new THREE.BoxGeometry(4.06, 0.18, 0.22), frameOff);
                        rail.position.set(0, y, 0);
                        rail.castShadow = true;
                        g.add(rail);
                    }
                    // Sill and lintel
                    for (const y of [0.62, -0.39]) {
                        const beam = new THREE.Mesh(new THREE.BoxGeometry(4.06, 0.14, 0.22), frameOff);
                        beam.position.set(0, y, 0);
                        beam.castShadow = true;
                        g.add(beam);
                    }

                    // Glass pane — centred in opening
                    const glass = new THREE.Mesh(new THREE.BoxGeometry(3.62, 0.96, 0.04), glassMat);
                    glass.position.set(0, 0.115, 0);
                    g.add(glass);

                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            stone_window_wall: {
                name: '🪟 Stone Window Wall',
                cost: { stone: 10 },
                create: async () => {
                    const g = new THREE.Group();
                    const stoneMat = await createStoneMaterial(0x7A7A7A, 0.92);
                    const mortarMat = new THREE.MeshStandardMaterial({ color: 0x4A4A4A, roughness: 0.98 });
                    const glassMat = new THREE.MeshStandardMaterial({
                        color: 0xADD8E6, transparent: true, opacity: 0.32,
                        roughness: 0.05, metalness: 0.25, side: THREE.DoubleSide, depthWrite: false
                    });

                    const mortarOff = mortarMat.clone();
                    mortarOff.polygonOffset = true;
                    mortarOff.polygonOffsetFactor = -1;
                    mortarOff.polygonOffsetUnits  = -1;

                    // Bottom panel
                    const bottom = new THREE.Mesh(new THREE.BoxGeometry(4, 1.0, 0.32), stoneMat);
                    bottom.position.y = -1.0;
                    bottom.castShadow = true; bottom.receiveShadow = true;
                    g.add(bottom);
                    // Top panel
                    const top = new THREE.Mesh(new THREE.BoxGeometry(4, 0.8, 0.32), stoneMat);
                    top.position.y = 1.1;
                    top.castShadow = true; top.receiveShadow = true;
                    g.add(top);
                    // Side pillars
                    for (const x of [-1.75, 1.75]) {
                        const pillar = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.2, 0.32), stoneMat);
                        pillar.position.set(x, 0.15, 0);
                        pillar.castShadow = true;
                        g.add(pillar);
                    }

                    // Stone arch / lintel detail
                    const lintel = new THREE.Mesh(new THREE.BoxGeometry(4, 0.12, 0.34), mortarOff);
                    lintel.position.y = 0.66;
                    g.add(lintel);
                    const sill = new THREE.Mesh(new THREE.BoxGeometry(4, 0.12, 0.34), mortarOff);
                    sill.position.y = -0.36;
                    g.add(sill);

                    // Glass
                    const glass = new THREE.Mesh(new THREE.BoxGeometry(3.0, 0.96, 0.05), glassMat);
                    glass.position.set(0, 0.15, 0);
                    g.add(glass);

                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            metal_window_wall: {
                name: '🪟 Metal Window Wall',
                cost: { iron_ingot: 5 },
                create: async () => {
                    const g = new THREE.Group();
                    const sheetMat = await createMetalMaterial(0xB0B8C0, 0.28);
                    const frameMat = await createMetalMaterial(0x888E96, 0.45);
                    const glassMat = new THREE.MeshStandardMaterial({
                        color: 0xB0D8F8, transparent: true, opacity: 0.30,
                        roughness: 0.05, metalness: 0.5, side: THREE.DoubleSide, depthWrite: false
                    });

                    const frameOff = frameMat.clone();
                    frameOff.polygonOffset = true;
                    frameOff.polygonOffsetFactor = -1;
                    frameOff.polygonOffsetUnits  = -1;

                    // Bottom sheet panel
                    const bottom = new THREE.Mesh(new THREE.BoxGeometry(4, 1.0, 0.12), sheetMat);
                    bottom.position.y = -1.0;
                    bottom.castShadow = true; bottom.receiveShadow = true;
                    g.add(bottom);
                    // Top sheet panel
                    const top = new THREE.Mesh(new THREE.BoxGeometry(4, 0.8, 0.12), sheetMat);
                    top.position.y = 1.1;
                    top.castShadow = true; top.receiveShadow = true;
                    g.add(top);

                    // Outer frame posts
                    for (const x of [-1.85, 1.85]) {
                        const post = new THREE.Mesh(new THREE.BoxGeometry(0.14, 3.1, 0.16), frameOff);
                        post.position.set(x, 0, 0);
                        g.add(post);
                    }
                    // Rails
                    for (const y of [1.42, 0.65, -0.38, -1.42]) {
                        const rail = new THREE.Mesh(new THREE.BoxGeometry(4.1, 0.1, 0.16), frameOff);
                        rail.position.set(0, y, 0);
                        g.add(rail);
                    }

                    // Window frame cross-members
                    for (const x of [-0.5, 0.5]) {
                        const mullion = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.96, 0.1), frameOff);
                        mullion.position.set(x, 0.135, 0.04);
                        g.add(mullion);
                    }

                    // Glass
                    const glass = new THREE.Mesh(new THREE.BoxGeometry(3.68, 0.96, 0.04), glassMat);
                    glass.position.set(0, 0.135, 0);
                    g.add(glass);

                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            // ═══════════════════════════════════════════════════════════════
            //  DOOR FRAME
            // ═══════════════════════════════════════════════════════════════
            door_frame: {
                name: '🚪 Door Frame',
                cost: { wood: 6 },
                create: async () => {
                    const g = new THREE.Group();
                    const plankMat = await createWoodMaterial(0x9C7A3C, 0.82);
                    const frameMat = await createWoodMaterial(0x5C3A1E, 0.75);

                    // Full wall is 4 wide, 3 tall. Door opening is 1.6 wide × 2.84 tall
                    // centred in the wall. Side panels fill the rest.
                    const openW  = 1.64;  // matches door panel width (1.6) + tiny gap
                    const openH  = 2.84;  // matches door panel height (2.8) + tiny gap
                    const wallH  = 3.0;
                    const wallW  = 4.0;
                    const wallD  = 0.18;

                    // Left solid panel: from x=-2 to x=-(openW/2)
                    const leftW  = wallW / 2 - openW / 2;   // 2 - 0.82 = 1.18
                    const leftPanel = new THREE.Mesh(new THREE.BoxGeometry(leftW, wallH, wallD), plankMat);
                    leftPanel.position.x = -(wallW / 2 - leftW / 2);  // -2 + 0.59 = -1.41
                    leftPanel.castShadow = true; leftPanel.receiveShadow = true;
                    g.add(leftPanel);

                    // Right solid panel: mirror
                    const rightPanel = new THREE.Mesh(new THREE.BoxGeometry(leftW, wallH, wallD), plankMat);
                    rightPanel.position.x = wallW / 2 - leftW / 2;
                    rightPanel.castShadow = true; rightPanel.receiveShadow = true;
                    g.add(rightPanel);

                    // Top panel above door opening
                    const topH = wallH - openH;   // 3.0 - 2.84 = 0.16
                    const topPanel = new THREE.Mesh(new THREE.BoxGeometry(openW, topH, wallD), plankMat);
                    topPanel.position.set(0, wallH / 2 - topH / 2, 0);  // flush with top
                    topPanel.castShadow = true; topPanel.receiveShadow = true;
                    g.add(topPanel);

                    // Frame trim — left jamb
                    const jambMat = frameMat.clone();
                    for (const x of [-(openW / 2), openW / 2]) {
                        const jamb = new THREE.Mesh(new THREE.BoxGeometry(0.08, openH, 0.24), jambMat);
                        jamb.position.set(x, -(wallH / 2 - openH / 2), 0);
                        g.add(jamb);
                    }
                    // Lintel trim
                    const lintel = new THREE.Mesh(new THREE.BoxGeometry(openW + 0.08, 0.08, 0.24), jambMat);
                    lintel.position.set(0, wallH / 2 - topH - 0.04, 0);
                    g.add(lintel);
                    // Outer frame border (sides + top)
                    for (const x of [-wallW / 2, wallW / 2]) {
                        const border = new THREE.Mesh(new THREE.BoxGeometry(0.12, wallH, 0.22), jambMat);
                        border.position.x = x;
                        g.add(border);
                    }
                    const topBorder = new THREE.Mesh(new THREE.BoxGeometry(wallW, 0.12, 0.22), jambMat);
                    topBorder.position.y = wallH / 2;
                    g.add(topBorder);

                    g.userData.isDoorFrame = true;
                    g.userData.frameType   = 'single';
                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            // ═══════════════════════════════════════════════════════════════
            //  SINGLE DOOR WALLS
            // ═══════════════════════════════════════════════════════════════



            // ═══════════════════════════════════════════════════════════════
            //  DOUBLE DOOR WALLS
            // ═══════════════════════════════════════════════════════════════



            // ═══════════════════════════════════════════════════════════════
            //  DOUBLE DOOR FRAME
            // ═══════════════════════════════════════════════════════════════
            double_door_frame: {
                name: '🚪 Double Door Frame',
                cost: { wood: 8 },
                create: async () => {
                    const g = new THREE.Group();
                    const plankMat = await createWoodMaterial(0x9C7A3C, 0.82);
                    const frameMat = await createWoodMaterial(0x5C3A1E, 0.75);

                    // Full wall 4 wide × 3 tall. Double opening = 3.2 wide (2 × 1.6) × 2.84 tall
                    const openW  = 3.24;  // 2 leaves × 1.6 + small gap
                    const openH  = 2.84;
                    const wallH  = 3.0;
                    const wallW  = 4.0;
                    const wallD  = 0.18;

                    // Narrow side panels
                    const sideW  = (wallW - openW) / 2;   // (4 - 3.24) / 2 = 0.38
                    for (const side of [-1, 1]) {
                        const panel = new THREE.Mesh(new THREE.BoxGeometry(sideW, wallH, wallD), plankMat);
                        panel.position.x = side * (wallW / 2 - sideW / 2);
                        panel.castShadow = true; panel.receiveShadow = true;
                        g.add(panel);
                    }

                    // Top panel above opening
                    const topH = wallH - openH;
                    const topPanel = new THREE.Mesh(new THREE.BoxGeometry(openW, topH, wallD), plankMat);
                    topPanel.position.set(0, wallH / 2 - topH / 2, 0);
                    topPanel.castShadow = true; topPanel.receiveShadow = true;
                    g.add(topPanel);

                    // Frame trim
                    const jambMat = frameMat.clone();
                    // Side jambs
                    for (const x of [-(openW / 2), openW / 2]) {
                        const jamb = new THREE.Mesh(new THREE.BoxGeometry(0.08, openH, 0.24), jambMat);
                        jamb.position.set(x, -(wallH / 2 - openH / 2), 0);
                        g.add(jamb);
                    }
                    // No centre post — fully open for double door
                    // Lintel trim
                    const lintel = new THREE.Mesh(new THREE.BoxGeometry(openW + 0.08, 0.08, 0.24), jambMat);
                    lintel.position.set(0, wallH / 2 - topH - 0.04, 0);
                    g.add(lintel);
                    // Outer border
                    for (const x of [-wallW / 2, wallW / 2]) {
                        const border = new THREE.Mesh(new THREE.BoxGeometry(0.12, wallH, 0.22), jambMat);
                        border.position.x = x;
                        g.add(border);
                    }
                    const topBorder = new THREE.Mesh(new THREE.BoxGeometry(wallW, 0.12, 0.22), jambMat);
                    topBorder.position.y = wallH / 2;
                    g.add(topBorder);

                    g.userData.isDoorFrame = true;
                    g.userData.frameType   = 'double';
                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            // ═══════════════════════════════════════════════════════════════
            //  STONE DOOR FRAME
            // ═══════════════════════════════════════════════════════════════
            stone_door_frame: {
                name: '🪨 Stone Door Frame',
                cost: { stone: 8 },
                create: async () => {
                    const g = new THREE.Group();
                    const stoneMat = await createStoneMaterial(0x7A7A7A, 0.92);
                    const mortarMat = new THREE.MeshStandardMaterial({ color: 0x4A4A4A, roughness: 0.98 });
                    const mortarOff = mortarMat.clone();
                    mortarOff.polygonOffset = true; mortarOff.polygonOffsetFactor = -1; mortarOff.polygonOffsetUnits = -1;

                    const openW = 1.64, openH = 2.84, wallH = 3.0, wallW = 4.0, wallD = 0.32;
                    const leftW = wallW / 2 - openW / 2;
                    const topH = wallH - openH;

                    const leftPanel = new THREE.Mesh(new THREE.BoxGeometry(leftW, wallH, wallD), stoneMat);
                    leftPanel.position.x = -(wallW / 2 - leftW / 2);
                    leftPanel.castShadow = true; leftPanel.receiveShadow = true; g.add(leftPanel);
                    const rightPanel = new THREE.Mesh(new THREE.BoxGeometry(leftW, wallH, wallD), stoneMat);
                    rightPanel.position.x = wallW / 2 - leftW / 2;
                    rightPanel.castShadow = true; rightPanel.receiveShadow = true; g.add(rightPanel);
                    const topPanel = new THREE.Mesh(new THREE.BoxGeometry(openW, topH, wallD), stoneMat);
                    topPanel.position.set(0, wallH / 2 - topH / 2, 0);
                    topPanel.castShadow = true; topPanel.receiveShadow = true; g.add(topPanel);

                    // Stone mortar lines on side panels
                    for (const side of [-1, 1]) {
                        const px = side * (wallW / 2 - leftW / 2);
                        for (let r = 1; r < 4; r++) {
                            const line = new THREE.Mesh(new THREE.BoxGeometry(leftW, 0.04, wallD + 0.02), mortarOff);
                            line.position.set(px, -1.5 + r * 0.75, 0); g.add(line);
                        }
                    }

                    // Jambs
                    const jambMat = stoneMat.clone();
                    for (const x of [-(openW / 2), openW / 2]) {
                        const jamb = new THREE.Mesh(new THREE.BoxGeometry(0.1, openH, 0.36), jambMat);
                        jamb.position.set(x, -(wallH / 2 - openH / 2), 0); g.add(jamb);
                    }
                    const lintel = new THREE.Mesh(new THREE.BoxGeometry(openW + 0.1, 0.12, 0.36), jambMat);
                    lintel.position.set(0, wallH / 2 - topH - 0.06, 0); g.add(lintel);
                    for (const x of [-wallW / 2, wallW / 2]) {
                        const border = new THREE.Mesh(new THREE.BoxGeometry(0.14, wallH, 0.34), jambMat);
                        border.position.x = x; g.add(border);
                    }
                    const topBorder = new THREE.Mesh(new THREE.BoxGeometry(wallW, 0.14, 0.34), jambMat);
                    topBorder.position.y = wallH / 2; g.add(topBorder);

                    g.userData.isDoorFrame = true;
                    g.userData.frameType   = 'single';
                    g.userData.buildingType = 'stone_door_frame';
                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            // ═══════════════════════════════════════════════════════════════
            //  METAL DOOR FRAME
            // ═══════════════════════════════════════════════════════════════
            metal_door_frame: {
                name: '⚙️ Metal Door Frame',
                cost: { iron_ingot: 4 },
                create: async () => {
                    const g = new THREE.Group();
                    // Match exact metal wall colours
                    const sheetMat  = await createMetalMaterial(0xB0B8C0, 0.28); // panel sheets - silver grey
                    const frameMat  = await createMetalMaterial(0x888E96, 0.45); // structural channels - darker grey
                    const rivetMat  = await createMetalMaterial(0x555960, 0.6);  // rivets / trim - dark grey

                    const openW = 1.64, openH = 2.84, wallH = 3.0, wallW = 4.0, wallD = 0.12;
                    const leftW = wallW / 2 - openW / 2;
                    const topH = wallH - openH;

                    // Sheet backing panels
                    const leftPanel = new THREE.Mesh(new THREE.BoxGeometry(leftW, wallH, wallD), sheetMat);
                    leftPanel.position.x = -(wallW / 2 - leftW / 2);
                    leftPanel.castShadow = true; leftPanel.receiveShadow = true; g.add(leftPanel);
                    const rightPanel = new THREE.Mesh(new THREE.BoxGeometry(leftW, wallH, wallD), sheetMat);
                    rightPanel.position.x = wallW / 2 - leftW / 2;
                    rightPanel.castShadow = true; rightPanel.receiveShadow = true; g.add(rightPanel);
                    const topPanel = new THREE.Mesh(new THREE.BoxGeometry(openW, topH, wallD), sheetMat);
                    topPanel.position.set(0, wallH / 2 - topH / 2, 0);
                    topPanel.castShadow = true; topPanel.receiveShadow = true; g.add(topPanel);

                    // Frame channels (vertical posts & horizontal rails) matching metal wall style
                    const frameOff = frameMat.clone();
                    frameOff.polygonOffset = true; frameOff.polygonOffsetFactor = -1; frameOff.polygonOffsetUnits = -1;
                    // Outer vertical posts
                    for (const x of [-wallW / 2, wallW / 2]) {
                        const post = new THREE.Mesh(new THREE.BoxGeometry(0.14, wallH + 0.1, 0.16), frameOff);
                        post.position.x = x; g.add(post);
                    }
                    // Top rail
                    const topRail = new THREE.Mesh(new THREE.BoxGeometry(wallW + 0.1, 0.12, 0.16), frameOff);
                    topRail.position.y = wallH / 2; g.add(topRail);
                    // Horizontal rails on side panels
                    for (const y of [1.0, 0, -1.0]) {
                        for (const side of [-1, 1]) {
                            const px = side * (wallW / 2 - leftW / 2);
                            const rail = new THREE.Mesh(new THREE.BoxGeometry(leftW, 0.12, 0.16), frameOff);
                            rail.position.set(px, y, 0); g.add(rail);
                        }
                    }
                    // Door jamb channels
                    for (const x of [-(openW / 2), openW / 2]) {
                        const jamb = new THREE.Mesh(new THREE.BoxGeometry(0.14, openH, 0.2), frameOff);
                        jamb.position.set(x, -(wallH / 2 - openH / 2), 0); g.add(jamb);
                    }
                    const lintel = new THREE.Mesh(new THREE.BoxGeometry(openW + 0.14, 0.14, 0.2), frameOff);
                    lintel.position.set(0, wallH / 2 - topH - 0.07, 0); g.add(lintel);

                    // Corrugation ridges on panels (same as metal wall)
                    const ridgeOff = (await createMetalMaterial(0xC5CBD2, 0.32)).clone();
                    ridgeOff.polygonOffset = true; ridgeOff.polygonOffsetFactor = -2; ridgeOff.polygonOffsetUnits = -2;
                    for (const side of [-1, 1]) {
                        const px = side * (wallW / 2 - leftW / 2);
                        for (let j = 0; j < 4; j++) {
                            const ridge = new THREE.Mesh(new THREE.BoxGeometry(0.03, wallH - 0.1, 0.04), ridgeOff);
                            ridge.position.set(px - leftW / 2 + 0.15 + j * (leftW / 4), 0, 0.07); g.add(ridge);
                        }
                    }

                    // Rivets at channel intersections
                    const rivetOff = rivetMat.clone();
                    rivetOff.polygonOffset = true; rivetOff.polygonOffsetFactor = -3; rivetOff.polygonOffsetUnits = -3;
                    for (const x of [-wallW / 2, wallW / 2]) {
                        for (const y of [wallH / 2, 0, -wallH / 2]) {
                            const rivet = new THREE.Mesh(new THREE.CylinderGeometry(0.035, 0.035, 0.06, 8), rivetOff);
                            rivet.rotation.x = Math.PI / 2; rivet.position.set(x, y, 0.14); g.add(rivet);
                        }
                    }

                    g.userData.isDoorFrame = true;
                    g.userData.frameType   = 'single';
                    g.userData.buildingType = 'metal_door_frame';
                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            // ═══════════════════════════════════════════════════════════════
            //  STONE DOUBLE DOOR FRAME
            // ═══════════════════════════════════════════════════════════════
            stone_double_door_frame: {
                name: '🪨 Stone Double Door Frame',
                cost: { stone: 10 },
                create: async () => {
                    const g = new THREE.Group();
                    const stoneMat = await createStoneMaterial(0x7A7A7A, 0.92);
                    const mortarMat = new THREE.MeshStandardMaterial({ color: 0x4A4A4A, roughness: 0.98 });
                    const mortarOff = mortarMat.clone();
                    mortarOff.polygonOffset = true; mortarOff.polygonOffsetFactor = -1; mortarOff.polygonOffsetUnits = -1;

                    const openW = 3.24, openH = 2.84, wallH = 3.0, wallW = 4.0, wallD = 0.32;
                    const sideW = (wallW - openW) / 2;
                    const topH = wallH - openH;

                    for (const side of [-1, 1]) {
                        const panel = new THREE.Mesh(new THREE.BoxGeometry(sideW, wallH, wallD), stoneMat);
                        panel.position.x = side * (wallW / 2 - sideW / 2);
                        panel.castShadow = true; panel.receiveShadow = true; g.add(panel);
                        for (let r = 1; r < 4; r++) {
                            const line = new THREE.Mesh(new THREE.BoxGeometry(sideW, 0.04, wallD + 0.02), mortarOff);
                            line.position.set(side * (wallW / 2 - sideW / 2), -1.5 + r * 0.75, 0); g.add(line);
                        }
                    }
                    const topPanel = new THREE.Mesh(new THREE.BoxGeometry(openW, topH, wallD), stoneMat);
                    topPanel.position.set(0, wallH / 2 - topH / 2, 0);
                    topPanel.castShadow = true; topPanel.receiveShadow = true; g.add(topPanel);

                    const jambMat = stoneMat.clone();
                    for (const x of [-(openW / 2), openW / 2]) {
                        const jamb = new THREE.Mesh(new THREE.BoxGeometry(0.1, openH, 0.36), jambMat);
                        jamb.position.set(x, -(wallH / 2 - openH / 2), 0); g.add(jamb);
                    }
                    const lintel = new THREE.Mesh(new THREE.BoxGeometry(openW + 0.1, 0.12, 0.36), jambMat);
                    lintel.position.set(0, wallH / 2 - topH - 0.06, 0); g.add(lintel);
                    for (const x of [-wallW / 2, wallW / 2]) {
                        const border = new THREE.Mesh(new THREE.BoxGeometry(0.14, wallH, 0.34), jambMat);
                        border.position.x = x; g.add(border);
                    }
                    const topBorder = new THREE.Mesh(new THREE.BoxGeometry(wallW, 0.14, 0.34), jambMat);
                    topBorder.position.y = wallH / 2; g.add(topBorder);

                    g.userData.isDoorFrame = true;
                    g.userData.frameType   = 'double';
                    g.userData.buildingType = 'stone_double_door_frame';
                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            // ═══════════════════════════════════════════════════════════════
            //  METAL DOUBLE DOOR FRAME
            // ═══════════════════════════════════════════════════════════════
            metal_double_door_frame: {
                name: '⚙️ Metal Double Door Frame',
                cost: { iron_ingot: 5 },
                create: async () => {
                    const g = new THREE.Group();
                    // Match exact metal wall colours
                    const sheetMat  = await createMetalMaterial(0xB0B8C0, 0.28);
                    const frameMat  = await createMetalMaterial(0x888E96, 0.45);
                    const rivetMat  = await createMetalMaterial(0x555960, 0.6);

                    const openW = 3.24, openH = 2.84, wallH = 3.0, wallW = 4.0, wallD = 0.12;
                    const sideW = (wallW - openW) / 2;
                    const topH = wallH - openH;

                    // Sheet backing panels
                    for (const side of [-1, 1]) {
                        const panel = new THREE.Mesh(new THREE.BoxGeometry(sideW, wallH, wallD), sheetMat);
                        panel.position.x = side * (wallW / 2 - sideW / 2);
                        panel.castShadow = true; panel.receiveShadow = true; g.add(panel);
                    }
                    const topPanel = new THREE.Mesh(new THREE.BoxGeometry(openW, topH, wallD), sheetMat);
                    topPanel.position.set(0, wallH / 2 - topH / 2, 0);
                    topPanel.castShadow = true; topPanel.receiveShadow = true; g.add(topPanel);

                    // Frame channels
                    const frameOff = frameMat.clone();
                    frameOff.polygonOffset = true; frameOff.polygonOffsetFactor = -1; frameOff.polygonOffsetUnits = -1;
                    // Outer vertical posts
                    for (const x of [-wallW / 2, wallW / 2]) {
                        const post = new THREE.Mesh(new THREE.BoxGeometry(0.14, wallH + 0.1, 0.16), frameOff);
                        post.position.x = x; g.add(post);
                    }
                    // Top rail
                    const topRail = new THREE.Mesh(new THREE.BoxGeometry(wallW + 0.1, 0.12, 0.16), frameOff);
                    topRail.position.y = wallH / 2; g.add(topRail);
                    // Horizontal rails on narrow side panels
                    for (const y of [1.0, 0, -1.0]) {
                        for (const side of [-1, 1]) {
                            const px = side * (wallW / 2 - sideW / 2);
                            const rail = new THREE.Mesh(new THREE.BoxGeometry(sideW, 0.12, 0.16), frameOff);
                            rail.position.set(px, y, 0); g.add(rail);
                        }
                    }
                    // Door jamb channels
                    for (const x of [-(openW / 2), openW / 2]) {
                        const jamb = new THREE.Mesh(new THREE.BoxGeometry(0.14, openH, 0.2), frameOff);
                        jamb.position.set(x, -(wallH / 2 - openH / 2), 0); g.add(jamb);
                    }
                    const lintel = new THREE.Mesh(new THREE.BoxGeometry(openW + 0.14, 0.14, 0.2), frameOff);
                    lintel.position.set(0, wallH / 2 - topH - 0.07, 0); g.add(lintel);

                    // Corrugation ridges on side panels
                    const ridgeOff = (await createMetalMaterial(0xC5CBD2, 0.32)).clone();
                    ridgeOff.polygonOffset = true; ridgeOff.polygonOffsetFactor = -2; ridgeOff.polygonOffsetUnits = -2;
                    for (const side of [-1, 1]) {
                        const px = side * (wallW / 2 - sideW / 2);
                        for (let j = 0; j < 2; j++) {
                            const ridge = new THREE.Mesh(new THREE.BoxGeometry(0.03, wallH - 0.1, 0.04), ridgeOff);
                            ridge.position.set(px - sideW / 2 + 0.1 + j * (sideW / 2), 0, 0.07); g.add(ridge);
                        }
                    }

                    // Rivets
                    const rivetOff = rivetMat.clone();
                    rivetOff.polygonOffset = true; rivetOff.polygonOffsetFactor = -3; rivetOff.polygonOffsetUnits = -3;
                    for (const x of [-wallW / 2, wallW / 2]) {
                        for (const y of [wallH / 2, 0, -wallH / 2]) {
                            const rivet = new THREE.Mesh(new THREE.CylinderGeometry(0.035, 0.035, 0.06, 8), rivetOff);
                            rivet.rotation.x = Math.PI / 2; rivet.position.set(x, y, 0.14); g.add(rivet);
                        }
                    }

                    g.userData.isDoorFrame = true;
                    g.userData.frameType   = 'double';
                    g.userData.buildingType = 'metal_double_door_frame';
                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },
            door: {
                name: '🚪 Wooden Door',
                cost: { wood: 5 },
                create: async () => {
                    const g = new THREE.Group();
                    const plankMat = await createWoodMaterial(0x9C7A3C, 0.82);
                    const frameMat = await createWoodMaterial(0x5C3A1E, 0.75);

                    const frameOff = frameMat.clone();
                    frameOff.polygonOffset = true;
                    frameOff.polygonOffsetFactor = -1;
                    frameOff.polygonOffsetUnits  = -1;

                    // Hinge pivot at left inner edge of the frame opening (x = -0.82)
                    const doorGroup = new THREE.Group();
                    doorGroup.position.set(-0.82, 0, 0); // pivot at left jamb

                    // Door panel: 1.6 wide, left edge at pivot so right edge at pivot+1.6
                    const panel = new THREE.Mesh(new THREE.BoxGeometry(1.6, 2.8, 0.1), plankMat);
                    panel.position.set(0.8, 0, 0);
                    panel.castShadow = true; panel.receiveShadow = true;
                    doorGroup.add(panel);

                    // Door border edges
                    for (const x of [0, 1.6]) {
                        const edge = new THREE.Mesh(new THREE.BoxGeometry(0.08, 2.76, 0.12), frameOff);
                        edge.position.set(x, 0, 0);
                        doorGroup.add(edge);
                    }
                    for (const y of [1.38, -1.38]) {
                        const edge = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.08, 0.12), frameOff);
                        edge.position.set(0.8, y, 0);
                        doorGroup.add(edge);
                    }
                    // Cross brace
                    const brace = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.08, 0.12), frameOff);
                    brace.position.set(0.8, 0.2, 0);
                    doorGroup.add(brace);
                    // Handle — on the right side (near closing edge)
                    const handleMat = await createMetalMaterial(0x888888, 0.4);
                    const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.22, 8), handleMat);
                    handle.rotation.x = Math.PI / 2;
                    handle.position.set(1.5, 0, 0.1);
                    doorGroup.add(handle);

                    g.add(doorGroup);
                    g.userData.doorGroup = doorGroup;
                    g.userData.doorType  = 'single';
                    g.userData.isDoor    = true;
                    g.userData.isOpen    = false;
                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            double_door: {
                name: '🚪 Double Wooden Door',
                cost: { wood: 8 },
                create: async () => {
                    const g = new THREE.Group();
                    const plankMat = await createWoodMaterial(0x9C7A3C, 0.82);
                    const frameMat = await createWoodMaterial(0x5C3A1E, 0.75);

                    const frameOff = frameMat.clone();
                    frameOff.polygonOffset = true;
                    frameOff.polygonOffsetFactor = -1;
                    frameOff.polygonOffsetUnits  = -1;

                    const handleMat = await createMetalMaterial(0x888888, 0.4);

                    function makeDoorLeaf(hingeX, handleSide) {
                        const leaf = new THREE.Group();
                        leaf.position.set(hingeX, 0, 0);
                        const panelOX = hingeX < 0 ? 0.8 : -0.8; // panel offset from hinge

                        const panel = new THREE.Mesh(new THREE.BoxGeometry(1.6, 2.8, 0.1), plankMat);
                        panel.position.set(panelOX, 0, 0);
                        panel.castShadow = true; panel.receiveShadow = true;
                        leaf.add(panel);

                        for (const y of [1.37, -1.37]) {
                            const edge = new THREE.Mesh(new THREE.BoxGeometry(1.64, 0.1, 0.12), frameOff);
                            edge.position.set(panelOX, y, 0);
                            leaf.add(edge);
                        }
                        const brace = new THREE.Mesh(new THREE.BoxGeometry(1.64, 0.08, 0.12), frameOff);
                        brace.position.set(panelOX, 0.3, 0);
                        leaf.add(brace);

                        const hx = panelOX + (handleSide < 0 ? -0.65 : 0.65);
                        const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.22, 8), handleMat);
                        handle.rotation.x = Math.PI / 2;
                        handle.position.set(hx, 0, 0.1);
                        leaf.add(handle);

                        return leaf;
                    }

                    // Left leaf: hinge at x = -1.62 (left jamb inner edge), panel extends right
                    const leftDoorGroup  = makeDoorLeaf(-1.62,  1);
                    // Right leaf: hinge at x = +1.62 (right jamb inner edge), panel extends left
                    const rightDoorGroup = makeDoorLeaf( 1.62, -1);

                    g.add(leftDoorGroup);
                    g.add(rightDoorGroup);

                    g.userData.leftDoorGroup  = leftDoorGroup;
                    g.userData.rightDoorGroup = rightDoorGroup;
                    g.userData.doorType       = 'double';
                    g.userData.isDoor         = true;
                    g.userData.isOpen         = false;
                    g.userData.collisionBox   = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            // ═══════════════════════════════════════════════════════════════
            //  STONE DOOR — refined planks with a window cut-out
            // ═══════════════════════════════════════════════════════════════
            stone_door: {
                name: '🪨 Stone Door',
                cost: { wood: 8, stone: 12 },
                create: async () => {
                    const g = new THREE.Group();
                    const plankMat = await createWoodMaterial(0x7A5C2E, 0.78);
                    const frameMat = await createWoodMaterial(0x4A2E10, 0.72);
                    const frameOff = frameMat.clone();
                    frameOff.polygonOffset = true; frameOff.polygonOffsetFactor = -1; frameOff.polygonOffsetUnits = -1;
                    // Clear glass — see-through, both faces rendered
                    const glassMat = new THREE.MeshStandardMaterial({
                        color: 0xAADDEE, roughness: 0.05, metalness: 0.1,
                        transparent: true, opacity: 0.25, side: THREE.DoubleSide,
                        depthWrite: false
                    });

                    const doorGroup = new THREE.Group();
                    doorGroup.position.set(-0.82, 0, 0);

                    // Dimensions
                    const doorW = 1.6, doorH = 2.8;
                    const splitY  = -0.3;                        // where wood ends, glass starts
                    const woodH   = doorH / 2 + splitY;          // ~1.1 — solid bottom
                    const glassH  = doorH - woodH - 0.12;        // ~1.58 — glass opening height
                    const woodBotY   = -doorH / 2 + woodH / 2;
                    const glassTopY  = splitY + 0.12 / 2 + glassH / 2;
                    const innerW  = doorW - 0.26;                // glass opening width (inside frame)

                    // ── Bottom solid wood panel ────────────────────────────
                    const woodPanel = new THREE.Mesh(new THREE.BoxGeometry(doorW, woodH, 0.1), plankMat);
                    woodPanel.position.set(0.8, woodBotY, 0);
                    woodPanel.castShadow = true; woodPanel.receiveShadow = true;
                    doorGroup.add(woodPanel);
                    // Raised panel moulding both faces
                    for (const sz of [1, -1]) {
                        const mould = new THREE.Mesh(new THREE.BoxGeometry(innerW, woodH - 0.2, 0.04), frameOff);
                        mould.position.set(0.8, woodBotY, 0.07 * sz);
                        doorGroup.add(mould);
                    }

                    // ── Horizontal dividing rail ───────────────────────────
                    const divRail = new THREE.Mesh(new THREE.BoxGeometry(doorW, 0.12, 0.15), frameOff);
                    divRail.position.set(0.8, splitY, 0);
                    doorGroup.add(divRail);

                    // ── Glass section: frame border strips (NO solid backing) ──
                    // Left stile (inside the outer frame)
                    const lStile = new THREE.Mesh(new THREE.BoxGeometry(0.1, glassH, 0.12), frameOff);
                    lStile.position.set(0.8 - innerW / 2 + 0.05, glassTopY, 0);
                    doorGroup.add(lStile);
                    // Right stile
                    const rStile = new THREE.Mesh(new THREE.BoxGeometry(0.1, glassH, 0.12), frameOff);
                    rStile.position.set(0.8 + innerW / 2 - 0.05, glassTopY, 0);
                    doorGroup.add(rStile);
                    // Top rail of glass section
                    const tRail = new THREE.Mesh(new THREE.BoxGeometry(innerW, 0.1, 0.12), frameOff);
                    tRail.position.set(0.8, glassTopY + glassH / 2 - 0.05, 0);
                    doorGroup.add(tRail);
                    // Thin horizontal mid-bar in glass
                    const midBar = new THREE.Mesh(new THREE.BoxGeometry(innerW, 0.06, 0.1), frameOff);
                    midBar.position.set(0.8, glassTopY, 0);
                    doorGroup.add(midBar);

                    // ── Glass pane — fills the entire glass opening flush to the frame ──
                    const pane = new THREE.Mesh(new THREE.BoxGeometry(innerW, glassH, 0.04), glassMat);
                    pane.position.set(0.8, glassTopY, 0);
                    doorGroup.add(pane);

                    // ── Outer frame (left, right, top, bottom edges) ───────
                    for (const ex of [0, doorW]) {
                        const edge = new THREE.Mesh(new THREE.BoxGeometry(0.13, doorH, 0.16), frameOff);
                        edge.position.set(ex, 0, 0);
                        doorGroup.add(edge);
                    }
                    for (const ey of [doorH / 2, -doorH / 2]) {
                        const edge = new THREE.Mesh(new THREE.BoxGeometry(doorW, 0.13, 0.16), frameOff);
                        edge.position.set(0.8, ey, 0);
                        doorGroup.add(edge);
                    }

                    // ── Handle (brass) both faces ──────────────────────────
                    const handleMat = await createMetalMaterial(0xB08040, 0.35);
                    for (const sz of [1, -1]) {
                        const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.24, 8), handleMat);
                        handle.rotation.x = Math.PI / 2;
                        handle.position.set(1.47, splitY - 0.22, 0.13 * sz);
                        doorGroup.add(handle);
                        const bp = new THREE.Mesh(new THREE.BoxGeometry(0.09, 0.30, 0.04), handleMat);
                        bp.position.set(1.47, splitY - 0.22, 0.09 * sz);
                        doorGroup.add(bp);
                    }

                    g.add(doorGroup);
                    g.userData.doorGroup = doorGroup;
                    g.userData.doorType  = 'single';
                    g.userData.isDoor    = true;
                    g.userData.isOpen    = false;
                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            // ═══════════════════════════════════════════════════════════════
            //  STONE DOUBLE DOOR — wood panels bottom, large glass window top
            // ═══════════════════════════════════════════════════════════════
            stone_double_door: {
                name: '🪨 Stone Double Door',
                cost: { wood: 12, stone: 20 },
                create: async () => {
                    const g = new THREE.Group();
                    const plankMat = await createWoodMaterial(0x7A5C2E, 0.78);
                    const frameMat = await createWoodMaterial(0x4A2E10, 0.72);
                    const frameOff = frameMat.clone();
                    frameOff.polygonOffset = true; frameOff.polygonOffsetFactor = -1; frameOff.polygonOffsetUnits = -1;
                    const glassMat = new THREE.MeshStandardMaterial({
                        color: 0xAADDEE, roughness: 0.05, metalness: 0.1,
                        transparent: true, opacity: 0.25, side: THREE.DoubleSide,
                        depthWrite: false
                    });
                    const handleMat = await createMetalMaterial(0xB08040, 0.35);

                    const doorW = 1.6, doorH = 2.8;
                    const splitY   = -0.3;
                    const woodH    = doorH / 2 + splitY;
                    const glassH   = doorH - woodH - 0.12;
                    const woodBotY = -doorH / 2 + woodH / 2;
                    const glassTopY = splitY + 0.12 / 2 + glassH / 2;
                    const innerW   = doorW - 0.26;

                    function makeStoneLeaf(hingeX, handleSide) {
                        const leaf = new THREE.Group();
                        leaf.position.set(hingeX, 0, 0);
                        const ox = hingeX < 0 ? 0.8 : -0.8;

                        // Bottom solid wood panel
                        const woodPanel = new THREE.Mesh(new THREE.BoxGeometry(doorW, woodH, 0.1), plankMat);
                        woodPanel.position.set(ox, woodBotY, 0);
                        woodPanel.castShadow = true; woodPanel.receiveShadow = true;
                        leaf.add(woodPanel);
                        // Raised moulding both faces
                        for (const sz of [1, -1]) {
                            const mould = new THREE.Mesh(new THREE.BoxGeometry(innerW, woodH - 0.2, 0.04), frameOff);
                            mould.position.set(ox, woodBotY, 0.07 * sz);
                            leaf.add(mould);
                        }

                        // Dividing rail
                        const divRail = new THREE.Mesh(new THREE.BoxGeometry(doorW, 0.12, 0.15), frameOff);
                        divRail.position.set(ox, splitY, 0);
                        leaf.add(divRail);

                        // Glass section — open frame only, NO solid backing
                        const lStile = new THREE.Mesh(new THREE.BoxGeometry(0.1, glassH, 0.12), frameOff);
                        lStile.position.set(ox - innerW / 2 + 0.05, glassTopY, 0);
                        leaf.add(lStile);
                        const rStile = new THREE.Mesh(new THREE.BoxGeometry(0.1, glassH, 0.12), frameOff);
                        rStile.position.set(ox + innerW / 2 - 0.05, glassTopY, 0);
                        leaf.add(rStile);
                        const tRail = new THREE.Mesh(new THREE.BoxGeometry(innerW, 0.1, 0.12), frameOff);
                        tRail.position.set(ox, glassTopY + glassH / 2 - 0.05, 0);
                        leaf.add(tRail);
                        const midBar = new THREE.Mesh(new THREE.BoxGeometry(innerW, 0.06, 0.1), frameOff);
                        midBar.position.set(ox, glassTopY, 0);
                        leaf.add(midBar);

                        // Glass pane — fills the entire glass opening flush to the frame
                        const pane = new THREE.Mesh(new THREE.BoxGeometry(innerW, glassH, 0.04), glassMat);
                        pane.position.set(ox, glassTopY, 0);
                        leaf.add(pane);

                        // Outer frame edges
                        for (const ex of [ox - 0.8, ox + 0.8]) {
                            const edge = new THREE.Mesh(new THREE.BoxGeometry(0.13, doorH, 0.16), frameOff);
                            edge.position.set(ex, 0, 0); leaf.add(edge);
                        }
                        for (const ey of [doorH / 2, -doorH / 2]) {
                            const edge = new THREE.Mesh(new THREE.BoxGeometry(doorW, 0.13, 0.16), frameOff);
                            edge.position.set(ox, ey, 0); leaf.add(edge);
                        }

                        // Handle both faces
                        const hx = ox + (handleSide < 0 ? -0.50 : 0.50);
                        for (const sz of [1, -1]) {
                            const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.24, 8), handleMat);
                            handle.rotation.x = Math.PI / 2;
                            handle.position.set(hx, splitY - 0.22, 0.13 * sz);
                            leaf.add(handle);
                            const bp = new THREE.Mesh(new THREE.BoxGeometry(0.09, 0.30, 0.04), handleMat);
                            bp.position.set(hx, splitY - 0.22, 0.09 * sz);
                            leaf.add(bp);
                        }

                        return leaf;
                    }

                    const leftDoorGroup  = makeStoneLeaf(-1.62,  1);
                    const rightDoorGroup = makeStoneLeaf( 1.62, -1);
                    g.add(leftDoorGroup);
                    g.add(rightDoorGroup);

                    g.userData.leftDoorGroup  = leftDoorGroup;
                    g.userData.rightDoorGroup = rightDoorGroup;
                    g.userData.doorType       = 'double';
                    g.userData.isDoor         = true;
                    g.userData.isOpen         = false;
                    g.userData.collisionBox   = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            // ═══════════════════════════════════════════════════════════════
            //  METAL DOOR — clean layered geometry, no z-fighting
            // ═══════════════════════════════════════════════════════════════
            metal_door: {
                name: '⚙️ Metal Door',
                cost: { iron_ingot: 6, wood: 4 },
                create: async () => {
                    const g = new THREE.Group();

                    const matBase  = await createMetalMaterial(0x8A9098, 0.35);  // base grey
                    const matDark  = await createMetalMaterial(0x606870, 0.30);  // darker panel
                    const matLight = await createMetalMaterial(0xB8C0C8, 0.40);  // lighter panel
                    const matCorr  = await createMetalMaterial(0x9A9EA4, 0.32);  // corrugated bg
                    const matRidge = await createMetalMaterial(0xD0D8E0, 0.25);  // ridge highlights
                    const matWeld  = new THREE.MeshStandardMaterial({ color: 0x2A2018, roughness: 0.98, metalness: 0.1 });
                    const matRivet = await createMetalMaterial(0x484C54, 0.60);
                    const matChan  = await createMetalMaterial(0x505560, 0.55);
                    const matHandle= await createMetalMaterial(0x909AA4, 0.28);

                    const doorGroup = new THREE.Group();
                    doorGroup.position.set(-0.82, 0, 0);

                    // Helper: add same mesh mirrored on both faces
                    function addBothFaces(geom, mat, x, y, zFront) {
                        const mF = new THREE.Mesh(geom, mat);
                        mF.position.set(x, y,  zFront); doorGroup.add(mF);
                        const mB = new THREE.Mesh(geom, mat);
                        mB.position.set(x, y, -zFront); doorGroup.add(mB);
                    }

                    // ── Layer 0: solid backing panel (z ±0.04) — full door ──
                    // Two separate panels so each face has its own solid surface
                    const frontPanel = new THREE.Mesh(new THREE.BoxGeometry(1.6, 2.8, 0.04), matBase);
                    frontPanel.position.set(0.8, 0, 0.02);
                    frontPanel.castShadow = true; frontPanel.receiveShadow = true;
                    doorGroup.add(frontPanel);
                    const backPanel = new THREE.Mesh(new THREE.BoxGeometry(1.6, 2.8, 0.04), matBase);
                    backPanel.position.set(0.8, 0, -0.02);
                    backPanel.castShadow = true; backPanel.receiveShadow = true;
                    doorGroup.add(backPanel);

                    // ── Layer 1: large flat patches (z ±0.06) — no overlap ──
                    // Top-left lighter quad
                    const qTL = new THREE.BoxGeometry(0.78, 1.05, 0.04);
                    addBothFaces(qTL, matLight, 0.40, 0.88, 0.06);
                    // Bottom-right darker quad
                    const qBR = new THREE.BoxGeometry(0.86, 1.05, 0.04);
                    addBothFaces(qBR, matDark, 1.23, -0.88, 0.06);
                    // Top-right darker quad
                    const qTR = new THREE.BoxGeometry(0.64, 0.80, 0.04);
                    addBothFaces(qTR, matDark, 1.28, 0.98, 0.06);
                    // Bottom-left lighter quad
                    const qBL = new THREE.BoxGeometry(0.68, 0.78, 0.04);
                    addBothFaces(qBL, matLight, 0.35, -0.96, 0.06);

                    // ── Layer 2: corrugated strip (z ±0.08) ─────────────────
                    // Sits in the centre-left vertical band, non-overlapping with patches
                    const corrGeo = new THREE.BoxGeometry(0.52, 1.24, 0.04);
                    addBothFaces(corrGeo, matCorr, 0.56, -0.18, 0.08);
                    // Corrugation ridges (z ±0.115) — physically raised above the corr bg
                    for (let r = 0; r < 4; r++) {
                        const ridgeGeo = new THREE.BoxGeometry(0.055, 1.22, 0.04);
                        addBothFaces(ridgeGeo, matRidge, 0.31 + r * 0.12, -0.18, 0.115);
                    }

                    // ── Layer 3: weld seams (z ±0.07) ───────────────────────
                    // Vertical seam between corrugated strip and right patches
                    const wV = new THREE.BoxGeometry(0.04, 2.60, 0.04);
                    addBothFaces(wV, matWeld, 0.84, 0, 0.07);
                    // Horizontal seam across mid-door
                    const wH = new THREE.BoxGeometry(1.54, 0.04, 0.04);
                    addBothFaces(wH, matWeld, 0.80, 0.38, 0.07);

                    // ── Layer 4: rivets (z ±0.13) — proud of everything ─────
                    const rivetPositions = [
                        [0.84, 1.20], [0.84, 0.60], [0.84, 0.00], [0.84, -0.60], [0.84, -1.20],
                        [0.32, 0.38], [0.60, 0.38], [1.10, 0.38], [1.42, 0.38],
                        [0.14, 1.36], [0.14, -1.36], [1.54, 1.36], [1.54, -1.36],
                    ];
                    for (const [rx, ry] of rivetPositions) {
                        for (const sz of [1, -1]) {
                            const rv = new THREE.Mesh(new THREE.CylinderGeometry(0.030, 0.026, 0.06, 8), matRivet);
                            rv.rotation.x = Math.PI / 2;
                            rv.position.set(rx, ry, 0.13 * sz);
                            doorGroup.add(rv);
                        }
                    }

                    // ── Frame channels (proud of patches) ───────────────────
                    for (const ex of [0, 1.6]) {
                        const ch = new THREE.Mesh(new THREE.BoxGeometry(0.12, 2.84, 0.18), matChan);
                        ch.position.set(ex, 0, 0); doorGroup.add(ch);
                    }
                    for (const ey of [1.38, -1.38]) {
                        const ch = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.12, 0.18), matChan);
                        ch.position.set(0.8, ey, 0); doorGroup.add(ch);
                    }

                    // ── Handle — front & back ────────────────────────────────
                    for (const sz of [1, -1]) {
                        const bar = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.40, 0.07), matHandle);
                        bar.position.set(1.48, 0.05, 0.16 * sz); doorGroup.add(bar);
                        const bT = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.07, 0.16), matHandle);
                        bT.position.set(1.48, 0.25, 0.12 * sz); doorGroup.add(bT);
                        const bB = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.07, 0.16), matHandle);
                        bB.position.set(1.48, -0.15, 0.12 * sz); doorGroup.add(bB);
                    }

                    g.add(doorGroup);
                    g.userData.doorGroup = doorGroup;
                    g.userData.doorType  = 'single';
                    g.userData.isDoor    = true;
                    g.userData.isOpen    = false;
                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            // ═══════════════════════════════════════════════════════════════
            //  METAL DOUBLE DOOR — clean layered geometry, no z-fighting
            // ═══════════════════════════════════════════════════════════════
            metal_double_door: {
                name: '⚙️ Metal Double Door',
                cost: { iron_ingot: 10, wood: 6 },
                create: async () => {
                    const g = new THREE.Group();

                    const matBase  = await createMetalMaterial(0x8A9098, 0.35);
                    const matDark  = await createMetalMaterial(0x606870, 0.30);
                    const matLight = await createMetalMaterial(0xB8C0C8, 0.40);
                    const matCorr  = await createMetalMaterial(0x9A9EA4, 0.32);
                    const matRidge = await createMetalMaterial(0xD0D8E0, 0.25);
                    const matWeld  = new THREE.MeshStandardMaterial({ color: 0x2A2018, roughness: 0.98, metalness: 0.1 });
                    const matRivet = await createMetalMaterial(0x484C54, 0.60);
                    const matChan  = await createMetalMaterial(0x505560, 0.55);
                    const matHandle= await createMetalMaterial(0x909AA4, 0.28);

                    function makeMetalLeaf(hingeX, handleSide) {
                        const leaf = new THREE.Group();
                        leaf.position.set(hingeX, 0, 0);
                        const ox = hingeX < 0 ? 0.8 : -0.8;
                        // flip patch layout so each leaf mirrors nicely
                        const flip = hingeX < 0 ? 1 : -1;

                        // Helper: add geometry on both faces at ±z
                        function add2(geom, mat, lx, ly, zF) {
                            const mF = new THREE.Mesh(geom, mat);
                            mF.position.set(lx, ly,  zF); leaf.add(mF);
                            const mB = new THREE.Mesh(geom, mat);
                            mB.position.set(lx, ly, -zF); leaf.add(mB);
                        }

                        // Layer 0: two solid face panels (physically separate, no overlap)
                        const fPanel = new THREE.Mesh(new THREE.BoxGeometry(1.6, 2.8, 0.04), matBase);
                        fPanel.position.set(ox, 0, 0.02); fPanel.castShadow = true; fPanel.receiveShadow = true;
                        leaf.add(fPanel);
                        const bPanel = new THREE.Mesh(new THREE.BoxGeometry(1.6, 2.8, 0.04), matBase);
                        bPanel.position.set(ox, 0, -0.02); bPanel.castShadow = true;
                        leaf.add(bPanel);

                        // Layer 1: flat patches at z ±0.06 — sized to NOT overlap each other
                        // Top patch (hinge side, lighter)
                        add2(new THREE.BoxGeometry(0.95, 1.05, 0.04), matLight, ox + flip * 0.28, 0.85, 0.06);
                        // Lower patch (handle side, darker)
                        add2(new THREE.BoxGeometry(0.95, 0.88, 0.04), matDark,  ox - flip * 0.25, -0.98, 0.06);

                        // Layer 2: corrugated strip at z ±0.08 (vertical band, centre)
                        add2(new THREE.BoxGeometry(0.50, 1.30, 0.04), matCorr, ox, -0.15, 0.08);
                        // Ridges at z ±0.115 — raised above corr bg
                        for (let r = 0; r < 4; r++) {
                            add2(new THREE.BoxGeometry(0.055, 1.28, 0.04), matRidge, ox - 0.22 + r * 0.115, -0.15, 0.115);
                        }

                        // Layer 3: weld seams at z ±0.07
                        // Vertical seam
                        add2(new THREE.BoxGeometry(0.04, 2.60, 0.04), matWeld, ox + flip * 0.28, 0, 0.07);
                        // Horizontal seam
                        add2(new THREE.BoxGeometry(1.54, 0.04, 0.04), matWeld, ox, 0.35, 0.07);

                        // Layer 4: rivets at z ±0.13
                        const rivets = [
                            [ox + flip * 0.28, 1.20], [ox + flip * 0.28, 0.55],
                            [ox + flip * 0.28, -0.10], [ox + flip * 0.28, -0.75],
                            [ox - 0.55, 0.35], [ox, 0.35], [ox + 0.55, 0.35],
                            [ox - 0.70, 1.36], [ox + 0.70, 1.36],
                            [ox - 0.70, -1.36], [ox + 0.70, -1.36],
                        ];
                        for (const [rx, ry] of rivets) {
                            for (const sz of [1, -1]) {
                                const rv = new THREE.Mesh(new THREE.CylinderGeometry(0.030, 0.026, 0.06, 8), matRivet);
                                rv.rotation.x = Math.PI / 2;
                                rv.position.set(rx, ry, 0.13 * sz);
                                leaf.add(rv);
                            }
                        }

                        // Frame channels (proud of everything)
                        for (const ey of [1.38, -1.38]) {
                            const ch = new THREE.Mesh(new THREE.BoxGeometry(1.64, 0.12, 0.18), matChan);
                            ch.position.set(ox, ey, 0); leaf.add(ch);
                        }
                        for (const ex of [ox - 0.8, ox + 0.8]) {
                            const ch = new THREE.Mesh(new THREE.BoxGeometry(0.12, 2.84, 0.18), matChan);
                            ch.position.set(ex, 0, 0); leaf.add(ch);
                        }

                        // Handle front & back
                        const hx = ox + (handleSide < 0 ? -0.52 : 0.52);
                        for (const sz of [1, -1]) {
                            const bar = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.40, 0.07), matHandle);
                            bar.position.set(hx, 0.05, 0.16 * sz); leaf.add(bar);
                            const bT = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.07, 0.16), matHandle);
                            bT.position.set(hx, 0.25, 0.12 * sz); leaf.add(bT);
                            const bB = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.07, 0.16), matHandle);
                            bB.position.set(hx, -0.15, 0.12 * sz); leaf.add(bB);
                        }

                        return leaf;
                    }

                    const leftDoorGroup  = makeMetalLeaf(-1.62,  1);
                    const rightDoorGroup = makeMetalLeaf( 1.62, -1);
                    g.add(leftDoorGroup);
                    g.add(rightDoorGroup);

                    g.userData.leftDoorGroup  = leftDoorGroup;
                    g.userData.rightDoorGroup = rightDoorGroup;
                    g.userData.doorType       = 'double';
                    g.userData.isDoor         = true;
                    g.userData.isOpen         = false;
                    g.userData.collisionBox   = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },
            floor: {
                name: '🟫 Wooden Floor',
                cost: { wood: 4 },
                create: async () => {
                    const g = new THREE.Group();
                    const plankMat = await createWoodMaterial(0xA08040, 0.85);
                    const beamMat  = await createWoodMaterial(0x5C3A1E, 0.78);

                    // Single solid deck
                    const deck = new THREE.Mesh(new THREE.BoxGeometry(4, 0.2, 4), plankMat);
                    deck.receiveShadow = true;
                    deck.castShadow = true;
                    g.add(deck);

                    // Underside joists — sit below the deck, no z-fight
                    const joistMat = beamMat.clone();
                    for (const z of [-1.5, 0, 1.5]) {
                        const joist = new THREE.Mesh(new THREE.BoxGeometry(4, 0.16, 0.14), joistMat);
                        joist.position.set(0, -0.18, z);
                        joist.castShadow = true;
                        g.add(joist);
                    }

                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            stone_floor: {
                name: '⬜ Stone Floor',
                cost: { stone: 10 },
                create: async () => {
                    const g = new THREE.Group();
                    const stoneMat = await createStoneMaterial(0x808080, 0.9);
                    const mortarMat = new THREE.MeshStandardMaterial({ color: 0x4A4A4A, roughness: 0.98 });
                    const mortarOff = mortarMat.clone();
                    mortarOff.polygonOffset = true;
                    mortarOff.polygonOffsetFactor = -1;
                    mortarOff.polygonOffsetUnits  = -1;

                    // Solid slab
                    const slab = new THREE.Mesh(new THREE.BoxGeometry(4, 0.22, 4), stoneMat);
                    slab.receiveShadow = true;
                    slab.castShadow = true;
                    g.add(slab);

                    // 2×2 tile grout lines (proud of slab top)
                    for (const x of [-1, 0, 1]) {
                        const line = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.24, 4), mortarOff);
                        line.position.x = x;
                        g.add(line);
                    }
                    for (const z of [-1, 0, 1]) {
                        const line = new THREE.Mesh(new THREE.BoxGeometry(4, 0.24, 0.04), mortarOff);
                        line.position.z = z;
                        g.add(line);
                    }

                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            metal_floor: {
                name: '⬜ Metal Floor',
                cost: { iron_ingot: 5 },
                create: async () => {
                    const g = new THREE.Group();
                    const plateMat = await createMetalMaterial(0xB0B8C0, 0.3);
                    const beamMat  = await createMetalMaterial(0x888E96, 0.45);
                    const bumpMat  = await createMetalMaterial(0xC8CDD2, 0.35);

                    // Plate
                    const plate = new THREE.Mesh(new THREE.BoxGeometry(4, 0.15, 4), plateMat);
                    plate.receiveShadow = true;
                    plate.castShadow = true;
                    g.add(plate);

                    // Diamond bumps — proud of plate, polygonOffset
                    const bumpOff = bumpMat.clone();
                    bumpOff.polygonOffset = true;
                    bumpOff.polygonOffsetFactor = -1;
                    bumpOff.polygonOffsetUnits  = -1;
                    const bumpGeo = new THREE.BoxGeometry(0.18, 0.03, 0.18);
                    for (let xi = -3; xi <= 3; xi++) {
                        for (let zi = -3; zi <= 3; zi++) {
                            const bump = new THREE.Mesh(bumpGeo, bumpOff);
                            bump.rotation.y = Math.PI / 4;
                            bump.position.set(xi * 0.55 + (zi % 2 === 0 ? 0 : 0.275), 0.09, zi * 0.55);
                            g.add(bump);
                        }
                    }

                    // I-beam supports underneath
                    const beamOff = beamMat.clone();
                    for (const z of [-1.4, 0, 1.4]) {
                        const ib = new THREE.Mesh(new THREE.BoxGeometry(4, 0.18, 0.12), beamOff);
                        ib.position.set(0, -0.165, z);
                        ib.castShadow = true;
                        g.add(ib);
                    }

                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            // ═══════════════════════════════════════════════════════════════
            //  CEILINGS
            // ═══════════════════════════════════════════════════════════════
            ceiling: {
                name: '🟫 Wooden Ceiling',
                cost: { wood: 4 },
                create: async () => {
                    const g = new THREE.Group();
                    const plankMat = await createWoodMaterial(0xA08040, 0.85);
                    const beamMat  = await createWoodMaterial(0x5C3A1E, 0.78);

                    const deck = new THREE.Mesh(new THREE.BoxGeometry(4, 0.2, 4), plankMat);
                    deck.receiveShadow = true;
                    deck.castShadow = true;
                    g.add(deck);

                    // Exposed ceiling beams on the bottom (visible as joists when looking up)
                    for (const z of [-1.5, 0, 1.5]) {
                        const joist = new THREE.Mesh(new THREE.BoxGeometry(4, 0.16, 0.14), beamMat);
                        joist.position.set(0, -0.18, z);
                        joist.castShadow = true;
                        g.add(joist);
                    }

                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            stone_ceiling: {
                name: '⬜ Stone Ceiling',
                cost: { stone: 10 },
                create: async () => {
                    const g = new THREE.Group();
                    const stoneMat = await createStoneMaterial(0x808080, 0.9);
                    const mortarMat = new THREE.MeshStandardMaterial({ color: 0x4A4A4A, roughness: 0.98 });
                    const mortarOff = mortarMat.clone();
                    mortarOff.polygonOffset = true;
                    mortarOff.polygonOffsetFactor = -1;
                    mortarOff.polygonOffsetUnits  = -1;

                    const slab = new THREE.Mesh(new THREE.BoxGeometry(4, 0.25, 4), stoneMat);
                    slab.receiveShadow = true;
                    slab.castShadow = true;
                    g.add(slab);

                    for (const x of [-1, 0, 1]) {
                        const line = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.27, 4), mortarOff);
                        line.position.x = x;
                        g.add(line);
                    }
                    for (const z of [-1, 0, 1]) {
                        const line = new THREE.Mesh(new THREE.BoxGeometry(4, 0.27, 0.04), mortarOff);
                        line.position.z = z;
                        g.add(line);
                    }

                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            metal_ceiling: {
                name: '⬜ Metal Ceiling',
                cost: { iron_ingot: 5 },
                create: async () => {
                    const g = new THREE.Group();
                    const plateMat = await createMetalMaterial(0xB0B8C0, 0.3);
                    const beamMat  = await createMetalMaterial(0x888E96, 0.45);

                    const plate = new THREE.Mesh(new THREE.BoxGeometry(4, 0.15, 4), plateMat);
                    plate.receiveShadow = true;
                    plate.castShadow = true;
                    g.add(plate);

                    const beamOff = beamMat.clone();
                    beamOff.polygonOffset = true;
                    beamOff.polygonOffsetFactor = -1;
                    beamOff.polygonOffsetUnits  = -1;
                    for (const z of [-1.4, 0, 1.4]) {
                        const ib = new THREE.Mesh(new THREE.BoxGeometry(4, 0.18, 0.12), beamOff);
                        ib.position.set(0, 0.165, z);
                        ib.castShadow = true;
                        g.add(ib);
                    }

                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            // ═══════════════════════════════════════════════════════════════
            //  LADDER CEILING
            // ═══════════════════════════════════════════════════════════════
            ladder_ceiling: {
                name: '🪝 Ladder Ceiling',
                cost: { wood: 3 },
                create: async () => {
                    const g = new THREE.Group();
                    const plankMat = await createWoodMaterial(0xA08040, 0.85);
                    const beamMat  = await createWoodMaterial(0x5C3A1E, 0.78);

                    // Ceiling panel with hole cut — simulated by two half-panels
                    const leftPanel = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.2, 4), plankMat);
                    leftPanel.position.x = -1.3;
                    leftPanel.receiveShadow = true; leftPanel.castShadow = true;
                    g.add(leftPanel);
                    const rightPanel = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.2, 4), plankMat);
                    rightPanel.position.x = 1.3;
                    rightPanel.receiveShadow = true; rightPanel.castShadow = true;
                    g.add(rightPanel);
                    const frontPanel = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.2, 1.3), plankMat);
                    frontPanel.position.set(0, 0, -1.35);
                    frontPanel.receiveShadow = true; frontPanel.castShadow = true;
                    g.add(frontPanel);
                    const backPanel = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.2, 1.3), plankMat);
                    backPanel.position.set(0, 0, 1.35);
                    backPanel.receiveShadow = true; backPanel.castShadow = true;
                    g.add(backPanel);

                    // Frame around hatch opening
                    const hatchFrameMat = beamMat.clone();
                    hatchFrameMat.polygonOffset = true;
                    hatchFrameMat.polygonOffsetFactor = -1;
                    hatchFrameMat.polygonOffsetUnits  = -1;
                    for (const x of [-0.6, 0.6]) {
                        const rail = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.22, 1.4), hatchFrameMat);
                        rail.position.set(x, 0, 0);
                        g.add(rail);
                    }
                    for (const z of [-0.7, 0.7]) {
                        const rail = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.22, 0.08), hatchFrameMat);
                        rail.position.set(0, 0, z);
                        g.add(rail);
                    }

                    g.userData.isLadderCeiling = true;
                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            // ═══════════════════════════════════════════════════════════════
            //  STAIRS
            // ═══════════════════════════════════════════════════════════════
            stairs: {
                name: '🪜 Wooden Stairs',
                cost: { wood: 8, stone: 2 },
                create: async () => {
                    const g = new THREE.Group();
                    const plankMat = await createWoodMaterial(0x9C7A3C, 0.82);
                    const supportMat = await createWoodMaterial(0x5C3A1E, 0.78);

                    // Use polygonOffset on tread to prevent z-fighting with block top face
                    const treadMat = plankMat.clone();
                    treadMat.polygonOffset = true;
                    treadMat.polygonOffsetFactor = -2;
                    treadMat.polygonOffsetUnits = -2;

                    const numSteps = 10;
                    const stepH = 0.3;
                    const stepD = 4 / numSteps;
                    const stepW = 3.6;

                    for (let i = 0; i < numSteps; i++) {
                        // Block: slightly inset in X/Z so no coplanar edges between adjacent steps
                        const block = new THREE.Mesh(new THREE.BoxGeometry(stepW - 0.01, stepH - 0.002, stepD - 0.002), supportMat.clone());
                        block.position.set(0, (i + 0.5) * stepH, -2 + i * stepD + stepD * 0.5);
                        block.castShadow = true; block.receiveShadow = true; g.add(block);
                        // Tread: sits flush on top of block with polygonOffset to win depth test
                        const tread = new THREE.Mesh(new THREE.BoxGeometry(stepW - 0.01, 0.04, stepD - 0.002), treadMat.clone());
                        tread.position.set(0, (i + 1) * stepH - 0.02 + 0.001, -2 + i * stepD + stepD * 0.5);
                        tread.castShadow = true; tread.receiveShadow = true; g.add(tread);
                    }
                    // Side stringers — pulled inward slightly so they don't clip step sides
                    const stringerLen = Math.sqrt(16 + 9);
                    for (const x of [-(stepW / 2 - 0.02), stepW / 2 - 0.02]) {
                        const stringer = new THREE.Mesh(new THREE.BoxGeometry(0.08, stepH * 0.65, stringerLen), supportMat.clone());
                        stringer.rotation.x = Math.atan2(numSteps * stepH, 4);
                        stringer.position.set(x, numSteps * stepH * 0.5, 0);
                        stringer.castShadow = true; g.add(stringer);
                    }

                    g.userData.isStairs = true;
                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            stone_stairs: {
                name: '🪜 Stone Stairs',
                cost: { stone: 8 },
                create: async () => {
                    const g = new THREE.Group();
                    const stoneMat = await createStoneMaterial(0x808080, 0.9);

                    // Slightly darker top-face material with polygonOffset so step tops never z-fight with steps above
                    const stoneTopMat = stoneMat.clone();
                    stoneTopMat.polygonOffset = true;
                    stoneTopMat.polygonOffsetFactor = -2;
                    stoneTopMat.polygonOffsetUnits = -2;

                    const numSteps = 10;
                    const stepH = 0.3;
                    const stepD = 4 / numSteps;
                    const stepW = 3.6;

                    for (let i = 0; i < numSteps; i++) {
                        // One riser-height block per step — slightly inset to prevent coplanar edges
                        const step = new THREE.Mesh(
                            new THREE.BoxGeometry(stepW - 0.01, stepH - 0.002, stepD - 0.002),
                            i % 2 === 0 ? stoneMat.clone() : stoneTopMat.clone()
                        );
                        step.position.set(0, (i + 0.5) * stepH, -2 + i * stepD + stepD * 0.5);
                        step.castShadow = true; step.receiveShadow = true; g.add(step);
                    }

                    g.userData.isStairs = true;
                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            metal_stairs: {
                name: '🪜 Metal Stairs',
                cost: { iron_ingot: 4 },
                create: async () => {
                    const g = new THREE.Group();
                    const treadMat  = await createMetalMaterial(0xB0B8C0, 0.3);
                    const frameMat  = await createMetalMaterial(0x888E96, 0.5);

                    // Tread material with polygonOffset to prevent z-fighting with riser top face
                    const treadOffMat = treadMat.clone();
                    treadOffMat.polygonOffset = true;
                    treadOffMat.polygonOffsetFactor = -2;
                    treadOffMat.polygonOffsetUnits = -2;

                    const numSteps = 10;
                    const stepH = 0.3;
                    const stepD = 4 / numSteps;
                    const stepW = 3.6;

                    // Side stringers — pulled inward so they don't clip through step sides
                    const stringerLen = Math.sqrt(16 + 9);
                    for (const x of [-(stepW / 2 - 0.02), stepW / 2 - 0.02]) {
                        const stringer = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.18, stringerLen), frameMat.clone());
                        stringer.rotation.x = Math.atan2(numSteps * stepH, 4);
                        stringer.position.set(x, numSteps * stepH * 0.5, 0);
                        stringer.castShadow = true; g.add(stringer);
                    }

                    for (let i = 0; i < numSteps; i++) {
                        // Frame riser — inset slightly to prevent coplanar edges
                        const riser = new THREE.Mesh(new THREE.BoxGeometry(stepW - 0.01, stepH - 0.002, stepD - 0.004), frameMat.clone());
                        riser.position.set(0, (i + 0.5) * stepH, -2 + i * stepD + stepD * 0.5);
                        riser.castShadow = true; riser.receiveShadow = true; g.add(riser);
                        // Tread grating — flush on riser top, polygonOffset wins depth test
                        const tread = new THREE.Mesh(new THREE.BoxGeometry(stepW - 0.01, 0.04, stepD - 0.004), treadOffMat.clone());
                        tread.position.set(0, (i + 1) * stepH - 0.02 + 0.001, -2 + i * stepD + stepD * 0.5);
                        tread.castShadow = true; tread.receiveShadow = true; g.add(tread);
                    }

                    g.userData.isStairs = true;
                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            // ═══════════════════════════════════════════════════════════════
            //  CORNER STAIRS LEFT
            // ═══════════════════════════════════════════════════════════════
            corner_stairs_left: {
                name: '🪜 Corner Stairs (Left)',
                cost: { wood: 10, stone: 3 },
                create: async () => {
                    const g = new THREE.Group();
                    const plankMat   = await createWoodMaterial(0x9C7A3C, 0.82);
                    const supportMat = await createWoodMaterial(0x5C3A1E, 0.78);

                    const treadMat = plankMat.clone();
                    treadMat.polygonOffset = true;
                    treadMat.polygonOffsetFactor = -2;
                    treadMat.polygonOffsetUnits = -2;

                    const n=5, halfH=1.5, legD=2.0, stepW=1.9;
                    const stepH=halfH/n, stepD=legD/n;

                    // LEG 1: one riser-height block per step, no accumulating heights
                    for (let i=0;i<n;i++) {
                        const topY=(i+1)*stepH;
                        const block=new THREE.Mesh(new THREE.BoxGeometry(stepW-0.01,stepH-0.002,stepD-0.002),supportMat.clone());
                        block.position.set(1.0, topY-stepH*0.5, -2+i*stepD+stepD*0.5);
                        block.castShadow=true; block.receiveShadow=true; g.add(block);
                        const tread=new THREE.Mesh(new THREE.BoxGeometry(stepW-0.01,0.04,stepD-0.002),treadMat.clone());
                        tread.position.set(1.0, topY-0.02+0.001, -2+i*stepD+stepD*0.5);
                        tread.castShadow=true; tread.receiveShadow=true; g.add(tread);
                    }

                    // LANDING — slab + tread with polygonOffset
                    const slab=new THREE.Mesh(new THREE.BoxGeometry(2.0,halfH,2.0),supportMat.clone());
                    slab.position.set(1.0, halfH*0.5, 1.0);
                    slab.castShadow=true; slab.receiveShadow=true; g.add(slab);
                    const top=new THREE.Mesh(new THREE.BoxGeometry(2.0,0.04,2.0),treadMat.clone());
                    top.position.set(1.0, halfH+0.001, 1.0);
                    top.castShadow=true; top.receiveShadow=true; g.add(top);

                    // LEG 2: one riser per step, rising from halfH upward
                    for (let i=0;i<n;i++) {
                        const topY=halfH+(i+1)*stepH;
                        const block=new THREE.Mesh(new THREE.BoxGeometry(stepD-0.002,stepH-0.002,stepW-0.01),supportMat.clone());
                        block.position.set(-(i*stepD+stepD*0.5), topY-stepH*0.5, 1.0);
                        block.castShadow=true; block.receiveShadow=true; g.add(block);
                        const tread=new THREE.Mesh(new THREE.BoxGeometry(stepD-0.002,0.04,stepW-0.01),treadMat.clone());
                        tread.position.set(-(i*stepD+stepD*0.5), topY-0.02+0.001, 1.0);
                        tread.castShadow=true; tread.receiveShadow=true; g.add(tread);
                    }

                    g.userData.isStairs=true; g.userData.isCornerStairs=true; g.userData.cornerDir='left';
                    g.userData.collisionBox=new THREE.Box3().setFromObject(g); return g;
                }
            },

            stone_corner_stairs_left: {
                name: '🪜 Stone Corner Stairs (Left)',
                cost: { stone: 8 },
                create: async () => {
                    const g = new THREE.Group();
                    const stoneMat=await createStoneMaterial(0x808080,0.9);
                    const stoneOffMat=stoneMat.clone();
                    stoneOffMat.polygonOffset=true; stoneOffMat.polygonOffsetFactor=-2; stoneOffMat.polygonOffsetUnits=-2;
                    const n=5, halfH=1.5, legD=2.0, stepW=1.9;
                    const stepH=halfH/n, stepD=legD/n;

                    for (let i=0;i<n;i++) {
                        const topY=(i+1)*stepH;
                        const block=new THREE.Mesh(new THREE.BoxGeometry(stepW-0.01,stepH-0.002,stepD-0.002),i%2===0?stoneMat.clone():stoneOffMat.clone());
                        block.position.set(1.0,topY-stepH*0.5,-2+i*stepD+stepD*0.5);
                        block.castShadow=true; block.receiveShadow=true; g.add(block);
                    }
                    const slab=new THREE.Mesh(new THREE.BoxGeometry(2.0,halfH,2.0),stoneMat.clone());
                    slab.position.set(1.0,halfH*0.5,1.0); slab.castShadow=true; slab.receiveShadow=true; g.add(slab);
                    for (let i=0;i<n;i++) {
                        const topY=halfH+(i+1)*stepH;
                        const block=new THREE.Mesh(new THREE.BoxGeometry(stepD-0.002,stepH-0.002,stepW-0.01),i%2===0?stoneMat.clone():stoneOffMat.clone());
                        block.position.set(-(i*stepD+stepD*0.5),topY-stepH*0.5,1.0);
                        block.castShadow=true; block.receiveShadow=true; g.add(block);
                    }
                    g.userData.isStairs=true; g.userData.isCornerStairs=true; g.userData.cornerDir='left';
                    g.userData.collisionBox=new THREE.Box3().setFromObject(g); return g;
                }
            },

            metal_corner_stairs_left: {
                name: '🪜 Metal Corner Stairs (Left)',
                cost: { iron_ingot: 4 },
                create: async () => {
                    const g = new THREE.Group();
                    const treadMat=await createMetalMaterial(0xB0B8C0,0.3);
                    const frameMat=await createMetalMaterial(0x888E96,0.5);
                    const treadOffMat=treadMat.clone();
                    treadOffMat.polygonOffset=true; treadOffMat.polygonOffsetFactor=-2; treadOffMat.polygonOffsetUnits=-2;
                    const n=5, halfH=1.5, legD=2.0, stepW=1.9;
                    const stepH=halfH/n, stepD=legD/n;

                    for (let i=0;i<n;i++) {
                        const topY=(i+1)*stepH;
                        const block=new THREE.Mesh(new THREE.BoxGeometry(stepW-0.01,stepH-0.002,stepD-0.002),frameMat.clone());
                        block.position.set(1.0,topY-stepH*0.5,-2+i*stepD+stepD*0.5);
                        block.castShadow=true; block.receiveShadow=true; g.add(block);
                        const tread=new THREE.Mesh(new THREE.BoxGeometry(stepW-0.01,0.04,stepD-0.002),treadOffMat.clone());
                        tread.position.set(1.0,topY-0.02+0.001,block.position.z); g.add(tread);
                    }
                    const slab=new THREE.Mesh(new THREE.BoxGeometry(2.0,halfH,2.0),frameMat.clone());
                    slab.position.set(1.0,halfH*0.5,1.0); slab.castShadow=true; g.add(slab);
                    const top=new THREE.Mesh(new THREE.BoxGeometry(2.0,0.04,2.0),treadOffMat.clone());
                    top.position.set(1.0,halfH+0.001,1.0); g.add(top);
                    for (let i=0;i<n;i++) {
                        const topY=halfH+(i+1)*stepH;
                        const block=new THREE.Mesh(new THREE.BoxGeometry(stepD-0.002,stepH-0.002,stepW-0.01),frameMat.clone());
                        block.position.set(-(i*stepD+stepD*0.5),topY-stepH*0.5,1.0);
                        block.castShadow=true; block.receiveShadow=true; g.add(block);
                        const tread=new THREE.Mesh(new THREE.BoxGeometry(stepD-0.002,0.04,stepW-0.01),treadOffMat.clone());
                        tread.position.set(-(i*stepD+stepD*0.5),topY-0.02+0.001,1.0); g.add(tread);
                    }
                    g.userData.isStairs=true; g.userData.isCornerStairs=true; g.userData.cornerDir='left';
                    g.userData.collisionBox=new THREE.Box3().setFromObject(g); return g;
                }
            },

            // ═══════════════════════════════════════════════════════════════
            //  CORNER STAIRS RIGHT
            // ═══════════════════════════════════════════════════════════════
            corner_stairs_right: {
                name: '🪜 Corner Stairs (Right)',
                cost: { wood: 10, stone: 3 },
                create: async () => {
                    const g = new THREE.Group();
                    const plankMat   = await createWoodMaterial(0x9C7A3C, 0.82);
                    const supportMat = await createWoodMaterial(0x5C3A1E, 0.78);

                    const treadMat = plankMat.clone();
                    treadMat.polygonOffset = true;
                    treadMat.polygonOffsetFactor = -2;
                    treadMat.polygonOffsetUnits = -2;

                    const n=5, halfH=1.5, legD=2.0, stepW=1.9;
                    const stepH=halfH/n, stepD=legD/n;

                    // LEG 1: one riser-height block per step
                    for (let i=0;i<n;i++) {
                        const topY=(i+1)*stepH;
                        const block=new THREE.Mesh(new THREE.BoxGeometry(stepW-0.01,stepH-0.002,stepD-0.002),supportMat.clone());
                        block.position.set(-1.0,topY-stepH*0.5,-2+i*stepD+stepD*0.5);
                        block.castShadow=true; block.receiveShadow=true; g.add(block);
                        const tread=new THREE.Mesh(new THREE.BoxGeometry(stepW-0.01,0.04,stepD-0.002),treadMat.clone());
                        tread.position.set(-1.0,topY-0.02+0.001,-2+i*stepD+stepD*0.5);
                        tread.castShadow=true; tread.receiveShadow=true; g.add(tread);
                    }

                    // LANDING — tread with polygonOffset
                    const slab=new THREE.Mesh(new THREE.BoxGeometry(2.0,halfH,2.0),supportMat.clone());
                    slab.position.set(-1.0,halfH*0.5,1.0);
                    slab.castShadow=true; slab.receiveShadow=true; g.add(slab);
                    const top=new THREE.Mesh(new THREE.BoxGeometry(2.0,0.04,2.0),treadMat.clone());
                    top.position.set(-1.0,halfH+0.001,1.0);
                    top.castShadow=true; top.receiveShadow=true; g.add(top);

                    // LEG 2: one riser per step, rising from halfH upward
                    for (let i=0;i<n;i++) {
                        const topY=halfH+(i+1)*stepH;
                        const block=new THREE.Mesh(new THREE.BoxGeometry(stepD-0.002,stepH-0.002,stepW-0.01),supportMat.clone());
                        block.position.set(i*stepD+stepD*0.5,topY-stepH*0.5,1.0);
                        block.castShadow=true; block.receiveShadow=true; g.add(block);
                        const tread=new THREE.Mesh(new THREE.BoxGeometry(stepD-0.002,0.04,stepW-0.01),treadMat.clone());
                        tread.position.set(i*stepD+stepD*0.5,topY-0.02+0.001,1.0);
                        tread.castShadow=true; tread.receiveShadow=true; g.add(tread);
                    }

                    g.userData.isStairs=true; g.userData.isCornerStairs=true; g.userData.cornerDir='right';
                    g.userData.collisionBox=new THREE.Box3().setFromObject(g); return g;
                }
            },

            stone_corner_stairs_right: {
                name: '🪜 Stone Corner Stairs (Right)',
                cost: { stone: 8 },
                create: async () => {
                    const g = new THREE.Group();
                    const stoneMat=await createStoneMaterial(0x808080,0.9);
                    const stoneOffMat=stoneMat.clone();
                    stoneOffMat.polygonOffset=true; stoneOffMat.polygonOffsetFactor=-2; stoneOffMat.polygonOffsetUnits=-2;
                    const n=5, halfH=1.5, legD=2.0, stepW=1.9;
                    const stepH=halfH/n, stepD=legD/n;

                    for (let i=0;i<n;i++) {
                        const topY=(i+1)*stepH;
                        const block=new THREE.Mesh(new THREE.BoxGeometry(stepW-0.01,stepH-0.002,stepD-0.002),i%2===0?stoneMat.clone():stoneOffMat.clone());
                        block.position.set(-1.0,topY-stepH*0.5,-2+i*stepD+stepD*0.5);
                        block.castShadow=true; block.receiveShadow=true; g.add(block);
                    }
                    const slab=new THREE.Mesh(new THREE.BoxGeometry(2.0,halfH,2.0),stoneMat.clone());
                    slab.position.set(-1.0,halfH*0.5,1.0); slab.castShadow=true; slab.receiveShadow=true; g.add(slab);
                    for (let i=0;i<n;i++) {
                        const topY=halfH+(i+1)*stepH;
                        const block=new THREE.Mesh(new THREE.BoxGeometry(stepD-0.002,stepH-0.002,stepW-0.01),i%2===0?stoneMat.clone():stoneOffMat.clone());
                        block.position.set(i*stepD+stepD*0.5,topY-stepH*0.5,1.0);
                        block.castShadow=true; block.receiveShadow=true; g.add(block);
                    }
                    g.userData.isStairs=true; g.userData.isCornerStairs=true; g.userData.cornerDir='right';
                    g.userData.collisionBox=new THREE.Box3().setFromObject(g); return g;
                }
            },

            metal_corner_stairs_right: {
                name: '🪜 Metal Corner Stairs (Right)',
                cost: { iron_ingot: 4 },
                create: async () => {
                    const g = new THREE.Group();
                    const treadMat=await createMetalMaterial(0xB0B8C0,0.3);
                    const frameMat=await createMetalMaterial(0x888E96,0.5);
                    const treadOffMat=treadMat.clone();
                    treadOffMat.polygonOffset=true; treadOffMat.polygonOffsetFactor=-2; treadOffMat.polygonOffsetUnits=-2;
                    const n=5, halfH=1.5, legD=2.0, stepW=1.9;
                    const stepH=halfH/n, stepD=legD/n;

                    for (let i=0;i<n;i++) {
                        const topY=(i+1)*stepH;
                        const block=new THREE.Mesh(new THREE.BoxGeometry(stepW-0.01,stepH-0.002,stepD-0.002),frameMat.clone());
                        block.position.set(-1.0,topY-stepH*0.5,-2+i*stepD+stepD*0.5);
                        block.castShadow=true; block.receiveShadow=true; g.add(block);
                        const tread=new THREE.Mesh(new THREE.BoxGeometry(stepW-0.01,0.04,stepD-0.002),treadOffMat.clone());
                        tread.position.set(-1.0,topY-0.02+0.001,block.position.z); g.add(tread);
                    }
                    const slab=new THREE.Mesh(new THREE.BoxGeometry(2.0,halfH,2.0),frameMat.clone());
                    slab.position.set(-1.0,halfH*0.5,1.0); slab.castShadow=true; g.add(slab);
                    const top=new THREE.Mesh(new THREE.BoxGeometry(2.0,0.04,2.0),treadOffMat.clone());
                    top.position.set(-1.0,halfH+0.001,1.0); g.add(top);
                    for (let i=0;i<n;i++) {
                        const topY=halfH+(i+1)*stepH;
                        const block=new THREE.Mesh(new THREE.BoxGeometry(stepD-0.002,stepH-0.002,stepW-0.01),frameMat.clone());
                        block.position.set(i*stepD+stepD*0.5,topY-stepH*0.5,1.0);
                        block.castShadow=true; block.receiveShadow=true; g.add(block);
                        const tread=new THREE.Mesh(new THREE.BoxGeometry(stepD-0.002,0.04,stepW-0.01),treadOffMat.clone());
                        tread.position.set(i*stepD+stepD*0.5,topY-0.02+0.001,1.0); g.add(tread);
                    }
                    g.userData.isStairs=true; g.userData.isCornerStairs=true; g.userData.cornerDir='right';
                    g.userData.collisionBox=new THREE.Box3().setFromObject(g); return g;
                }
            },

            // ═══════════════════════════════════════════════════════════════
            //  LADDER
            // ═══════════════════════════════════════════════════════════════
            ladder: {
                name: '🪜 Ladder',
                cost: { wood: 3 },
                create: async () => {
                    const g = new THREE.Group();
                    const railMat = await createWoodMaterial(0x5C3A1E, 0.78);
                    const rungMat = await createWoodMaterial(0x9C7A3C, 0.82);

                    // Side rails
                    for (const x of [-0.38, 0.38]) {
                        const rail = new THREE.Mesh(new THREE.BoxGeometry(0.1, 3, 0.1), railMat);
                        rail.position.set(x, 1.5, 0);
                        rail.castShadow = true; rail.receiveShadow = true;
                        g.add(rail);
                    }
                    // Rungs
                    const rungGeo = new THREE.BoxGeometry(0.76, 0.08, 0.08);
                    for (let i = 0; i < 9; i++) {
                        const rung = new THREE.Mesh(rungGeo, rungMat);
                        rung.position.set(0, 0.25 + i * 0.35, 0);
                        rung.castShadow = true;
                        g.add(rung);
                    }

                    g.userData.isLadder = true;
                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            workbench: {
                name: '\ud83d\udd27 Workbench',
                cost: { wood: 10, stone: 5 },
                create: async () => {
                    const workbench = new THREE.Group();

                    // Load GLB model from repo
                    await _loadAssetGLB('Workbench.glb');
                    const _glbInst = _instantiateGLB('Workbench.glb', 3.0);
                    if (_glbInst) workbench.add(_glbInst);

                    workbench.userData.isWorkbench = true;
                    return workbench;
                }
            },
            campfire: {
                name: '\ud83d\udd25 Campfire',
                cost: { wood: 5, stone: 3 },
                create: async () => {
                    const campfire = new THREE.Group();

                    // Load GLB model from repo
                    await _loadAssetGLB('camp fire.glb');
                    const _glbInst = _instantiateGLB('camp fire.glb', 1.0);
                    if (_glbInst) campfire.add(_glbInst);

                    campfire.userData.fireLight = null;
                    campfire.userData.fireGlow = null;
                    campfire.userData.particleTimer = 0;
                    campfire.userData.smokeTimer = 0;
                    campfire.userData.isCampfire = true;
                    campfire.userData.smeltingState = createSmeltingState(3000);
                    campfire.userData._smeltMs = 3000;
                    return campfire;
                }
            },
            cooking_station: {
                name: '\ud83c\udf73 Cooking Station',
                cost: { stone: 12, iron_ingot: 4, wood: 6 },
                create: async () => {
                    const oven = new THREE.Group();

                    // Load GLB model from repo
                    await _loadAssetGLB('cooking station.glb');
                    const _glbInst = _instantiateGLB('cooking station.glb', 3.0);
                    if (_glbInst) oven.add(_glbInst);

                    oven.userData.ovenDoor = null;
                    oven.userData.ovenGlow = null;
                    oven.userData.fireLight = null;
                    oven.userData.isCookingStation = true;
                    oven.userData.cookingState = createCookingStationState();
                    oven.userData.smokeTimer = 0;
                    return oven;
                }
            },
            sleeping_bag: {
                name: '\ud83d\udecf\ufe0f Sleeping Bag',
                cost: { fiber: 10, wood: 2 },
                create: async () => {
                    const bag = new THREE.Group();

                    // Try GLB first
                    await _loadAssetGLB('Bedroll.glb');
                    const glbInst = _instantiateGLB('Bedroll.glb', 2.8);
                    if (glbInst) {
                        // Only recolour meshes that are green — change them to red
                        glbInst.traverse(c => {
                            if (!c.isMesh) return;
                            const applyRed = (m) => {
                                if (!m || !m.color) return m;
                                const col = m.color;
                                if (col.g > col.r * 1.2 && col.g > col.b * 1.2) {
                                    const nm = m.clone();
                                    nm.color = new THREE.Color(0xcc2200);
                                    nm.needsUpdate = true;
                                    return nm;
                                }
                                return m;
                            };
                            if (Array.isArray(c.material)) {
                                c.material = c.material.map(applyRed);
                            } else {
                                c.material = applyRed(c.material);
                            }
                        });
                        bag.add(glbInst);
                    } else {
                        // Procedural fallback — simple tan bedroll
                        const tanMat = new THREE.MeshStandardMaterial({ color: 0xc8a86a, roughness: 0.9 });
                        const darkMat = new THREE.MeshStandardMaterial({ color: 0x8b6914, roughness: 0.95 });
                        const roll = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.18, 1.8, 12), tanMat);
                        roll.rotation.z = Math.PI / 2;
                        roll.position.set(0, 0.18, 0);
                        roll.castShadow = true;
                        bag.add(roll);
                        const strap1 = new THREE.Mesh(new THREE.CylinderGeometry(0.19, 0.19, 0.06, 12), darkMat);
                        strap1.rotation.z = Math.PI / 2; strap1.position.set(-0.55, 0.18, 0); bag.add(strap1);
                        const strap2 = strap1.clone(); strap2.position.set(0.55, 0.18, 0); bag.add(strap2);
                    }

                    bag.userData.isSleepingBag = true;
                    bag.userData.collisionBox = new THREE.Box3().setFromObject(bag);
                    return bag;
                }
            },
            building_bench: {
                name: '\ud83e\ude9a Building Bench',
                create: async () => {
                    const bench = new THREE.Group();

                    // Load GLB model from repo
                    await _loadAssetGLB('Buillding table.glb');
                    const _glbInst = _instantiateGLB('Buillding table.glb', 3.0);
                    if (_glbInst) { _glbInst.rotation.y = Math.PI / 2; bench.add(_glbInst); }

                    bench.userData.isBuildingBench = true;
                    return bench;
                }
            },
            furnace: {
                name: '\ud83d\udd25 Furnace',
                create: async () => {
                    const furnace = new THREE.Group();

                    // Load GLB model from repo
                    await _loadAssetGLB('Furnace.glb');
                    const _glbInst = _instantiateGLB('Furnace.glb', 3.0);
                    if (_glbInst) furnace.add(_glbInst);

                    // ── Interior fire glow ──────────────────────────────────
                    // Canvas radial gradient: bright yellow-white core → orange → deep red → black
                    const _gc = document.createElement('canvas');
                    _gc.width = 128; _gc.height = 128;
                    const _gctx = _gc.getContext('2d');
                    const _grad = _gctx.createRadialGradient(64, 64, 2, 64, 64, 64);
                    _grad.addColorStop(0.00, 'rgba(255,255,220,1.0)');
                    _grad.addColorStop(0.18, 'rgba(255,200,60,1.0)');
                    _grad.addColorStop(0.40, 'rgba(255,90,10,0.95)');
                    _grad.addColorStop(0.65, 'rgba(180,20,0,0.75)');
                    _grad.addColorStop(0.85, 'rgba(60,5,0,0.4)');
                    _grad.addColorStop(1.00, 'rgba(0,0,0,0.0)');
                    _gctx.fillStyle = _grad;
                    _gctx.fillRect(0, 0, 128, 128);
                    const _glowTex = new THREE.CanvasTexture(_gc);

                    // Back plate — sits just inside the arch, faces outward (+Z)
                    const _glowMat = new THREE.MeshBasicMaterial({
                        map: _glowTex, transparent: true, opacity: 0.18,
                        depthWrite: false, blending: THREE.AdditiveBlending,
                        side: THREE.DoubleSide,
                    });
                    const _glowMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.62, 0.62), _glowMat);
                    // Position: arch centre is ~1.35 world-units up, ~0.15 behind the face
                    _glowMesh.position.set(0, 1.35, 0.18);
                    _glowMesh.visible = true;
                    furnace.add(_glowMesh);
                    furnace.userData._glowMesh = _glowMesh;

                    // Second slightly larger, dimmer layer for depth/bloom feel
                    const _glowMat2 = new THREE.MeshBasicMaterial({
                        map: _glowTex, transparent: true, opacity: 0.10,
                        depthWrite: false, blending: THREE.AdditiveBlending,
                        side: THREE.DoubleSide,
                    });
                    const _glowMesh2 = new THREE.Mesh(new THREE.PlaneGeometry(0.90, 0.90), _glowMat2);
                    _glowMesh2.position.set(0, 1.35, 0.10);
                    _glowMesh2.visible = true;
                    furnace.add(_glowMesh2);
                    furnace.userData._glowMesh2 = _glowMesh2;
                    // ────────────────────────────────────────────────────────

                    furnace.userData.doorOpening = null;
                    furnace.userData.fireGlow = null;
                    furnace.userData.fireLight = null;
                    furnace.userData.particleTimer = 0;
                    furnace.userData.smokeTimer = 0;
                    furnace.userData.isFurnace = true;
                    furnace.userData.smeltingState = createSmeltingState(5000);
                    furnace.userData._smeltMs = 5000;
                    return furnace;
                }
            },
            storage_box: {
                name: '\ud83d\udce6 Large Storage',
                cost: { wood: 8, stone: 2 },
                create: async () => {
                    const box = new THREE.Group();

                    await _loadAssetGLB('Large Storage.glb');
                    const _glbInst = _instantiateGLB('Large Storage.glb', 2.0);
                    if (_glbInst) box.add(_glbInst);

                    box.userData.isStorageBox = true;
                    box.userData.storageInventory = new Array(26).fill(null);
                    return box;
                }
            },
            small_storage_box: {
                name: '\ud83d\udce6 Small Storage',
                cost: { wood: 4, stone: 1 },
                create: async () => {
                    const box = new THREE.Group();

                    await _loadAssetGLB('small storage.glb');
                    const _glbInst = _instantiateGLB('small storage.glb', 0.75);
                    if (_glbInst) box.add(_glbInst);

                    box.userData.isStorageBox = true;
                    box.userData.isSmallStorage = true;
                    box.userData.storageInventory = new Array(14).fill(null);
                    return box;
                }
            },
            storage_shelf: {
                name: '\ud83d\udce6 Storage Shelf',
                cost: { iron_ingot: 4 },
                create: async () => {
                    const shelf = new THREE.Group();
                    
                    // Vertical supports (4 corners)
                    const supportGeo = new THREE.BoxGeometry(0.1, 2.0, 0.1);
                    const supportMat = new THREE.MeshStandardMaterial({ 
                        color: 0x888888,
                        metalness: 0.7,
                        roughness: 0.3
                    });
                    
                    [[-0.7, -0.7], [-0.7, 0.7], [0.7, -0.7], [0.7, 0.7]].forEach(([x, z]) => {
                        const support = new THREE.Mesh(supportGeo, supportMat);
                        support.position.set(x, 1.0, z);
                        support.castShadow = true;
                        shelf.add(support);
                    });
                    
                    // Two shelves
                    const shelfGeo = new THREE.BoxGeometry(1.6, 0.05, 1.6);
                    const shelfMat = new THREE.MeshStandardMaterial({ 
                        color: 0x666666,
                        metalness: 0.6,
                        roughness: 0.4
                    });
                    
                    [0.7, 1.4].forEach(y => {
                        const shelfPlate = new THREE.Mesh(shelfGeo, shelfMat);
                        shelfPlate.position.y = y;
                        shelfPlate.castShadow = true;
                        shelfPlate.receiveShadow = true;
                        shelf.add(shelfPlate);
                    });
                    
                    shelf.userData.isShelf = true;
                    
                    return shelf;
                }
            },
            wall_shelf: {
                name: '\ud83d\udce6 Wall Shelf',
                cost: { wood: 6, iron_ingot: 2 },
                create: async () => {
                    const ws = new THREE.Group();

                    await _loadAssetGLB('Wall Shelf.glb');
                    const _glbInst = _instantiateGLB('Wall Shelf.glb', 1.5);
                    if (_glbInst) ws.add(_glbInst);

                    ws.userData.isWallShelf = true;
                    return ws;
                }
            },
            planter_box: {
                name: '\ud83c\udf31 Planter Box (4 Slot)',
                cost: { wood: 12, stone: 4 },
                create: async () => {
                    return _buildPlanterMesh(2.2, 0.9, 4, [-0.75,-0.25,0.25,0.75], [0]);
                }
            },
            large_planter: {
                name: '\ud83c\udf31 Large Planter (12 Slot)',
                cost: { wood: 28, stone: 10 },
                create: async () => {
                    // 3 rows × 4 columns, square box
                    const cols = 4, rows = 3;
                    const xPositions = [-0.82,-0.27,0.27,0.82];
                    const zPositions = [-0.42,0,0.42];
                    const slots = [];
                    for (let r=0; r<rows; r++) for (let c=0; c<cols; c++) slots.push({x:xPositions[c],z:zPositions[r]});
                    return _buildPlanterMesh(2.4, 1.4, 12, slots.map(s=>s.x), slots.map(s=>s.z));
                }
            },
            sewing_table: {
                name: '\ud83e\uddf5 Sewing Table',
                cost: { wood: 8, iron_ingot: 3 },
                create: async () => {
                    const table = new THREE.Group();

                    // Load GLB model from repo
                    await _loadAssetGLB('Sewing bench.glb');
                    const _glbInst = _instantiateGLB('Sewing bench.glb', 1.0);
                    if (_glbInst) table.add(_glbInst);

                    table.userData.isSewingTable = true;
                    return table;
                }
            },
            recycler: {
                name: '\u267b\ufe0f Recycler',
                cost: { iron_ingot: 15, wood: 5 },
                create: async () => {
                    const recycler = new THREE.Group();
                    
                    // Legs (4 corners)
                    const legGeo = new THREE.BoxGeometry(0.12, 1.0, 0.12);
                    const legMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.7 });
                    [[-0.9, -0.7], [0.9, -0.7], [-0.9, 0.7], [0.9, 0.7]].forEach(([x, z]) => {
                        const leg = new THREE.Mesh(legGeo, legMat);
                        leg.position.set(x, 0.5, z);
                        leg.castShadow = true;
                        recycler.add(leg);
                    });
                    
                    // Frame connecting legs (to prevent gaps)
                    const frameGeo = new THREE.BoxGeometry(2.0, 0.08, 1.6);
                    const frameMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.7 });
                    const lowerFrame = new THREE.Mesh(frameGeo, frameMat);
                    lowerFrame.position.y = 1.0;
                    lowerFrame.castShadow = true;
                    lowerFrame.receiveShadow = true;
                    recycler.add(lowerFrame);
                    
                    // Main body (green metal box)
                    const body = new THREE.Mesh(
                        new THREE.BoxGeometry(2.0, 0.6, 1.6),
                        new THREE.MeshStandardMaterial({ color: 0x4A6B3A, roughness: 0.6, metalness: 0.4 })
                    );
                    body.position.y = 1.3;
                    body.castShadow = true;
                    body.receiveShadow = true;
                    recycler.add(body);
                    
                    // Control panel (front side)
                    const panel = new THREE.Mesh(
                        new THREE.BoxGeometry(0.6, 0.4, 0.05),
                        new THREE.MeshStandardMaterial({ color: 0xBBBBBB, roughness: 0.4, metalness: 0.6 })
                    );
                    panel.position.set(0.3, 1.2, 0.82);
                    panel.castShadow = true;
                    recycler.add(panel);
                    
                    // Green indicator light on panel (will be used to show running state)
                    const light = new THREE.Mesh(
                        new THREE.CircleGeometry(0.05, 16),
                        new THREE.MeshBasicMaterial({ 
                            color: 0x00FF00,
                            side: THREE.DoubleSide
                        })
                    );
                    light.position.set(0.3, 1.3, 0.85);
                    light.visible = false; // Hidden by default, shown when running
                    recycler.add(light);
                    recycler.userData.statusLight = light; // Store reference
                    
                    // Hopper/funnel on top (yellow/gold)
                    const hopperBottom = new THREE.Mesh(
                        new THREE.BoxGeometry(1.8, 0.2, 1.4),
                        new THREE.MeshStandardMaterial({ color: 0xDAA520, roughness: 0.5 })
                    );
                    hopperBottom.position.y = 1.7;
                    hopperBottom.castShadow = true;
                    recycler.add(hopperBottom);
                    
                    // Hopper top (angled sides)
                    const hopperGeo = new THREE.CylinderGeometry(1.0, 0.9, 0.4, 4);
                    const hopperTop = new THREE.Mesh(
                        hopperGeo,
                        new THREE.MeshStandardMaterial({ color: 0xDAA520, roughness: 0.5 })
                    );
                    hopperTop.rotation.y = Math.PI / 4;
                    hopperTop.position.y = 2.0;
                    hopperTop.castShadow = true;
                    recycler.add(hopperTop);
                    
                    // Hopper opening cover (to prevent seeing inside body)
                    const hopperCover = new THREE.Mesh(
                        new THREE.BoxGeometry(1.7, 0.1, 1.3),
                        new THREE.MeshStandardMaterial({ color: 0x4A6B3A, roughness: 0.6 })
                    );
                    hopperCover.position.y = 1.65;
                    hopperCover.receiveShadow = true;
                    recycler.add(hopperCover);
                    
                    // Hopper grate/bars on top
                    const barMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8 });
                    for (let i = -0.6; i <= 0.6; i += 0.2) {
                        const bar = new THREE.Mesh(
                            new THREE.BoxGeometry(0.04, 0.02, 1.4),
                            barMat
                        );
                        bar.position.set(i, 2.21, 0);
                        recycler.add(bar);
                    }
                    
                    // Large wheel/drum on left side
                    const drum = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.35, 0.35, 0.3, 16),
                        new THREE.MeshStandardMaterial({ color: 0x5A6B4A, roughness: 0.5, metalness: 0.5 })
                    );
                    drum.rotation.z = Math.PI / 2;
                    drum.position.set(-1.1, 1.3, 0);
                    drum.castShadow = true;
                    recycler.add(drum);
                    
                    // Drum details
                    const drumDetail = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.3, 0.32, 16),
                        new THREE.MeshStandardMaterial({ color: 0x3A4A2A, roughness: 0.6 })
                    );
                    drumDetail.rotation.z = Math.PI / 2;
                    drumDetail.position.set(-1.1, 1.3, 0);
                    recycler.add(drumDetail);
                    
                    // Red valve/handle on drum
                    const valve = new THREE.Mesh(
                        new THREE.TorusGeometry(0.12, 0.03, 8, 16),
                        new THREE.MeshStandardMaterial({ color: 0xCC0000, roughness: 0.4, metalness: 0.7 })
                    );
                    valve.position.set(-1.25, 1.3, 0);
                    valve.castShadow = true;
                    recycler.add(valve);
                    
                    // Recycling symbol on side
                    const symbolBg = new THREE.Mesh(
                        new THREE.CircleGeometry(0.2, 16),
                        new THREE.MeshStandardMaterial({ 
                            color: 0xFFFFFF, 
                            roughness: 0.3,
                            side: THREE.DoubleSide
                        })
                    );
                    symbolBg.rotation.y = -Math.PI / 2; // Face outward
                    symbolBg.position.set(-0.3, 1.3, 0.81);
                    recycler.add(symbolBg);
                    
                    // Create recycling arrows (simplified triangles)
                    const arrowGeo = new THREE.ConeGeometry(0.08, 0.15, 3);
                    const arrowMat = new THREE.MeshStandardMaterial({ color: 0x2E7D32 });
                    for (let i = 0; i < 3; i++) {
                        const arrow = new THREE.Mesh(arrowGeo, arrowMat);
                        arrow.rotation.z = (i * Math.PI * 2 / 3) + Math.PI / 2;
                        arrow.position.set(-0.3 + Math.cos(i * Math.PI * 2 / 3) * 0.12, 1.3 + Math.sin(i * Math.PI * 2 / 3) * 0.12, 0.82);
                        recycler.add(arrow);
                    }
                    
                    // Outlet chute (bottom right)
                    const chute = new THREE.Mesh(
                        new THREE.BoxGeometry(0.3, 0.2, 0.3),
                        new THREE.MeshStandardMaterial({ color: 0x4A4A4A, roughness: 0.6, metalness: 0.5 })
                    );
                    chute.position.set(0.85, 0.9, 0.7);
                    chute.castShadow = true;
                    recycler.add(chute);
                    
                    recycler.userData.isRecycler = true;
                    recycler.userData.isProcessing = false;
                    recycler.userData.drum = drum; // Store reference for rotation animation
                    recycler.userData.hopper = hopperBottom; // Store reference for vibration
                    
                    return recycler;
                }
            },
            water_catcher: {
                name: '🪣 Well',
                cost: { wood: 8, stone: 4, fiber: 6 },
                create: async () => {
                    const wcGroup = new THREE.Group();

                    // Load GLB model
                    await _loadAssetGLB('Well.glb');
                    const _glbInst = _instantiateGLB('Well.glb', 3.0);
                    if (_glbInst) {
                        // Fix overly dark materials — GLB has baked AO/vertex colours that
                        // make it appear almost black. Brighten each mesh material to match
                        // other placed objects in the scene.
                        _glbInst.traverse(c => {
                            if (!c.isMesh || !c.material) return;
                            const mats = Array.isArray(c.material) ? c.material : [c.material];
                            mats.forEach(mat => {
                                if (!mat) return;
                                // Lift the base colour towards a visible range
                                if (mat.color) {
                                    const hsl = {};
                                    mat.color.getHSL(hsl);
                                    // If lightness is below 0.25 the model will look black in scene lighting
                                    if (hsl.l < 0.25) mat.color.setHSL(hsl.h, hsl.s, Math.max(hsl.l * 3.5, 0.28));
                                }
                                // Kill baked AO that darkens everything
                                mat.aoMapIntensity = 0;
                                // Ensure roughness isn't absorbing all light
                                if (mat.roughness > 0.95) mat.roughness = 0.82;
                                mat.needsUpdate = true;
                            });
                        });
                        wcGroup.add(_glbInst);
                    }

                    wcGroup.userData.isWaterCatcher = true;
                    return wcGroup;
                }
            },
            floor_rug_red: {
                name: '\ud83d\udfe5 Red Floor Rug',
                cost: { fiber: 8 },
                create: async () => {
                    const group = new THREE.Group();
                    
                    // Main rug body with fabric texture
                    const rugMat = await createFabricMaterial(0xCC0000, 0.9);
                    const rug = new THREE.Mesh(
                        new THREE.PlaneGeometry(2, 3, 10, 15),
                        rugMat
                    );
                    rug.rotation.x = -Math.PI / 2;
                    rug.position.y = 0.01;
                    rug.receiveShadow = true;
                    
                    // Add slight bumps/waves to rug surface for realism
                    const positions = rug.geometry.attributes.position;
                    for (let i = 0; i < positions.count; i++) {
                        const x = positions.getX(i);
                        const y = positions.getY(i);
                        const wave = Math.sin(x * 3) * Math.sin(y * 2) * 0.015;
                        positions.setZ(i, wave);
                    }
                    rug.geometry.computeVertexNormals();
                    group.add(rug);
                    
                    // Braided/woven border
                    const borderThickness = 0.12;
                    const borderHeight = 0.02;
                    const borderMat = new THREE.MeshStandardMaterial({ 
                        color: 0x880000,
                        roughness: 0.85
                    });
                    
                    const borders = [
                        { w: 2, h: borderThickness, x: 0, z: -1.5 + borderThickness/2 },
                        { w: 2, h: borderThickness, x: 0, z: 1.5 - borderThickness/2 },
                        { w: borderThickness, h: 3, x: -1 + borderThickness/2, z: 0 },
                        { w: borderThickness, h: 3, x: 1 - borderThickness/2, z: 0 }
                    ];
                    
                    borders.forEach(b => {
                        const border = new THREE.Mesh(
                            new THREE.BoxGeometry(b.w, borderHeight, b.h),
                            borderMat.clone()
                        );
                        border.position.set(b.x, 0.025, b.z);
                        border.receiveShadow = true;
                        group.add(border);
                        
                        // Braided detail on border
                        const braidGeo = new THREE.BoxGeometry(b.w * 0.95, 0.01, b.h * 0.5);
                        const braid = new THREE.Mesh(braidGeo, borderMat.clone());
                        braid.position.set(b.x, 0.035, b.z);
                        group.add(braid);
                    });
                    
                    // Corner tassels
                    const tasselMat = new THREE.MeshStandardMaterial({ 
                        color: 0xFFD700,
                        roughness: 0.8
                    });
                    
                    const corners = [
                        [-1, -1.5], [1, -1.5], [-1, 1.5], [1, 1.5]
                    ];
                    
                    corners.forEach(([x, z]) => {
                        // Tassel bundle
                        for (let i = 0; i < 5; i++) {
                            const tasselGeo = new THREE.CylinderGeometry(0.008, 0.005, 0.12, 4);
                            const tassel = new THREE.Mesh(tasselGeo, tasselMat);
                            tassel.position.set(
                                x + (Math.random() - 0.5) * 0.03,
                                0.06,
                                z + (Math.random() - 0.5) * 0.03
                            );
                            tassel.rotation.x = Math.PI / 2;
                            tassel.rotation.z = Math.random() * 0.2 - 0.1;
                            group.add(tassel);
                        }
                        
                        // Knot at base of tassels
                        const knot = new THREE.Mesh(
                            new THREE.SphereGeometry(0.02, 6, 6),
                            tasselMat.clone()
                        );
                        knot.position.set(x, 0.015, z);
                        group.add(knot);
                    });
                    
                    // Decorative pattern - central medallion
                    const patternMat = new THREE.MeshStandardMaterial({ 
                        color: 0xFFD700,
                        roughness: 0.7,
                        metalness: 0.1
                    });
                    
                    // Center circle
                    const centerCircle = new THREE.Mesh(
                        new THREE.CircleGeometry(0.3, 16),
                        patternMat
                    );
                    centerCircle.rotation.x = -Math.PI / 2;
                    centerCircle.position.y = 0.03;
                    group.add(centerCircle);
                    
                    // Radiating diamond pattern around center
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const distance = 0.5;
                        const diamond = new THREE.Mesh(
                            new THREE.PlaneGeometry(0.15, 0.15),
                            patternMat.clone()
                        );
                        diamond.rotation.x = -Math.PI / 2;
                        diamond.rotation.z = Math.PI / 4;
                        diamond.position.set(
                            Math.cos(angle) * distance,
                            0.03,
                            Math.sin(angle) * distance
                        );
                        group.add(diamond);
                    }
                    
                    // Small decorative dots
                    for (let i = -1; i <= 1; i++) {
                        for (let j = -2; j <= 2; j++) {
                            if (Math.abs(i) + Math.abs(j) > 1 && Math.abs(i) + Math.abs(j) <= 2) {
                                const dot = new THREE.Mesh(
                                    new THREE.CircleGeometry(0.05, 8),
                                    patternMat.clone()
                                );
                                dot.rotation.x = -Math.PI / 2;
                                dot.position.set(i * 0.6, 0.03, j * 0.7);
                                group.add(dot);
                            }
                        }
                    }
                    
                    // Mark as non-collidable
                    group.userData.isWalkable = true;
                    group.userData.noCollision = true;
                    
                    return group;
                }
            },
            floor_rug_blue: {
                name: '\ud83d\udfe6 Blue Floor Rug',
                cost: { fiber: 8 },
                create: async () => {
                    const group = new THREE.Group();
                    
                    // Main rug body - blue
                    const rug = new THREE.Mesh(
                        new THREE.PlaneGeometry(2, 3),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x0066CC,
                            roughness: 0.9,
                            side: THREE.DoubleSide
                        })
                    );
                    rug.rotation.x = -Math.PI / 2;
                    rug.position.y = 0.01;
                    rug.receiveShadow = true;
                    group.add(rug);
                    
                    // Navy border
                    const borderThickness = 0.15;
                    const borders = [
                        { w: 2, h: borderThickness, x: 0, z: -1.5 + borderThickness/2 },
                        { w: 2, h: borderThickness, x: 0, z: 1.5 - borderThickness/2 },
                        { w: borderThickness, h: 3, x: -1 + borderThickness/2, z: 0 },
                        { w: borderThickness, h: 3, x: 1 - borderThickness/2, z: 0 }
                    ];
                    
                    borders.forEach(b => {
                        const border = new THREE.Mesh(
                            new THREE.PlaneGeometry(b.w, b.h),
                            new THREE.MeshStandardMaterial({ 
                                color: 0x003388,
                                roughness: 0.85,
                                side: THREE.DoubleSide
                            })
                        );
                        border.rotation.x = -Math.PI / 2;
                        border.position.set(b.x, 0.02, b.z);
                        border.receiveShadow = true;
                        group.add(border);
                    });
                    
                    // Decorative pattern - white stripes
                    const stripeGeo = new THREE.PlaneGeometry(1.5, 0.15);
                    const stripeMat = new THREE.MeshStandardMaterial({ 
                        color: 0xFFFFFF,
                        roughness: 0.8,
                        side: THREE.DoubleSide
                    });
                    
                    // Horizontal stripes
                    [-1, 0, 1].forEach(z => {
                        const stripe = new THREE.Mesh(stripeGeo, stripeMat);
                        stripe.rotation.x = -Math.PI / 2;
                        stripe.position.set(0, 0.03, z * 0.7);
                        stripe.receiveShadow = true;
                        group.add(stripe);
                    });
                    
                    group.userData.isWalkable = true;
                    group.userData.noCollision = true;
                    
                    return group;
                }
            },
            floor_rug_green: {
                name: '\ud83d\udfe9 Green Floor Rug',
                cost: { fiber: 8 },
                create: async () => {
                    const group = new THREE.Group();
                    
                    // Main rug body - green
                    const rug = new THREE.Mesh(
                        new THREE.PlaneGeometry(2, 3),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x00AA00,
                            roughness: 0.9,
                            side: THREE.DoubleSide
                        })
                    );
                    rug.rotation.x = -Math.PI / 2;
                    rug.position.y = 0.01;
                    rug.receiveShadow = true;
                    group.add(rug);
                    
                    // Dark green border
                    const borderThickness = 0.15;
                    const borders = [
                        { w: 2, h: borderThickness, x: 0, z: -1.5 + borderThickness/2 },
                        { w: 2, h: borderThickness, x: 0, z: 1.5 - borderThickness/2 },
                        { w: borderThickness, h: 3, x: -1 + borderThickness/2, z: 0 },
                        { w: borderThickness, h: 3, x: 1 - borderThickness/2, z: 0 }
                    ];
                    
                    borders.forEach(b => {
                        const border = new THREE.Mesh(
                            new THREE.PlaneGeometry(b.w, b.h),
                            new THREE.MeshStandardMaterial({ 
                                color: 0x006600,
                                roughness: 0.85,
                                side: THREE.DoubleSide
                            })
                        );
                        border.rotation.x = -Math.PI / 2;
                        border.position.set(b.x, 0.02, b.z);
                        border.receiveShadow = true;
                        group.add(border);
                    });
                    
                    // Decorative pattern - brown/tan circular pattern
                    const circleGeo = new THREE.CircleGeometry(0.2, 16);
                    const circleMat = new THREE.MeshStandardMaterial({ 
                        color: 0xD2691E,
                        roughness: 0.8,
                        side: THREE.DoubleSide
                    });
                    
                    // Grid of circles
                    for (let x = -0.6; x <= 0.6; x += 0.6) {
                        for (let z = -1.2; z <= 1.2; z += 0.6) {
                            const circle = new THREE.Mesh(circleGeo, circleMat);
                            circle.rotation.x = -Math.PI / 2;
                            circle.position.set(x, 0.03, z);
                            circle.receiveShadow = true;
                            group.add(circle);
                        }
                    }
                    
                    group.userData.isWalkable = true;
                    group.userData.noCollision = true;
                    
                    return group;
                }
            },
            curtain_red: {
                name: '\ud83d\udd34 Red Curtain',
                cost: { cloth: 2 },
                create: async () => {
                    const curtainGroup = new THREE.Group();
                    
                    // Fabric material with texture
                    const fabricMat = await createFabricMaterial(0xCC0000, 0.85);
                    
                    // Create left curtain panel with folds
                    const leftPanelGroup = new THREE.Group();
                    const numFolds = 5;
                    const foldWidth = 0.7 / numFolds;
                    
                    for (let i = 0; i < numFolds; i++) {
                        // Create curved fold segments
                        const foldGeo = new THREE.PlaneGeometry(foldWidth, 1.5, 1, 8);
                        const positions = foldGeo.attributes.position;
                        
                        // Apply wave/fold effect to vertices
                        for (let j = 0; j < positions.count; j++) {
                            const y = positions.getY(j);
                            const waveOffset = Math.sin((i + j * 0.1) * Math.PI) * 0.08;
                            positions.setZ(j, waveOffset);
                            
                            // Slight taper at bottom for draping effect
                            if (y < 0) {
                                const tapering = (y + 0.75) / 0.75;
                                positions.setX(j, positions.getX(j) * (0.9 + tapering * 0.1));
                            }
                        }
                        foldGeo.computeVertexNormals();
                        
                        const fold = new THREE.Mesh(foldGeo, fabricMat.clone());
                        fold.position.x = -0.35 + (i * foldWidth);
                        fold.castShadow = true;
                        fold.receiveShadow = true;
                        leftPanelGroup.add(fold);
                    }
                    
                    leftPanelGroup.position.set(-1.45, 0, 0);
                    curtainGroup.add(leftPanelGroup);
                    
                    // Create right curtain panel with folds (mirrored)
                    const rightPanelGroup = new THREE.Group();
                    for (let i = 0; i < numFolds; i++) {
                        const foldGeo = new THREE.PlaneGeometry(foldWidth, 1.5, 1, 8);
                        const positions = foldGeo.attributes.position;
                        
                        for (let j = 0; j < positions.count; j++) {
                            const y = positions.getY(j);
                            const waveOffset = Math.sin((i + j * 0.1) * Math.PI) * 0.08;
                            positions.setZ(j, -waveOffset); // Mirrored
                            
                            if (y < 0) {
                                const tapering = (y + 0.75) / 0.75;
                                positions.setX(j, positions.getX(j) * (0.9 + tapering * 0.1));
                            }
                        }
                        foldGeo.computeVertexNormals();
                        
                        const fold = new THREE.Mesh(foldGeo, fabricMat.clone());
                        fold.position.x = -0.35 + (i * foldWidth);
                        fold.castShadow = true;
                        fold.receiveShadow = true;
                        rightPanelGroup.add(fold);
                    }
                    
                    rightPanelGroup.position.set(1.45, 0, 0);
                    curtainGroup.add(rightPanelGroup);
                    
                    // Decorative hem at bottom
                    const hemMat = new THREE.MeshStandardMaterial({ 
                        color: 0x880000,
                        roughness: 0.7,
                        metalness: 0.1
                    });
                    
                    const leftHem = new THREE.Mesh(
                        new THREE.BoxGeometry(0.7, 0.05, 0.02),
                        hemMat
                    );
                    leftHem.position.set(-1.45, -0.77, 0);
                    curtainGroup.add(leftHem);
                    
                    const rightHem = new THREE.Mesh(
                        new THREE.BoxGeometry(0.7, 0.05, 0.02),
                        hemMat.clone()
                    );
                    rightHem.position.set(1.45, -0.77, 0);
                    curtainGroup.add(rightHem);
                    
                    // Curtain rod with decorative ends
                    const rodMat = await createMetalMaterial(0x7A7A7A, 0.3);
                    const rod = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.03, 0.03, 3.6, 12),
                        rodMat
                    );
                    rod.rotation.z = Math.PI / 2;
                    rod.position.y = 0.85;
                    curtainGroup.add(rod);
                    
                    // Decorative finials on rod ends
                    for (let x of [-1.9, 1.9]) {
                        const finial = new THREE.Mesh(
                            new THREE.SphereGeometry(0.06, 12, 12),
                            rodMat.clone()
                        );
                        finial.position.set(x, 0.85, 0);
                        curtainGroup.add(finial);
                    }
                    
                    // Curtain rings
                    const ringMat = await createMetalMaterial(0x555555, 0.4);
                    for (let i = 0; i < 7; i++) {
                        const ring = new THREE.Mesh(
                            new THREE.TorusGeometry(0.04, 0.01, 8, 12),
                            ringMat.clone()
                        );
                        ring.rotation.x = Math.PI / 2;
                        ring.position.set(-1.5 + i * 0.5, 0.85, 0);
                        curtainGroup.add(ring);
                    }
                    
                    return curtainGroup;
                }
            },
            curtain_blue: {
                name: '\ud83d\udd35 Blue Curtain',
                cost: { cloth: 2 },
                create: async () => {
                    const curtainGroup = new THREE.Group();
                    
                    const leftPanel = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.7, 1.5),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x0066CC,
                            roughness: 0.8,
                            side: THREE.DoubleSide
                        })
                    );
                    leftPanel.position.set(-1.45, 0, 0);
                    leftPanel.castShadow = true;
                    leftPanel.receiveShadow = true;
                    curtainGroup.add(leftPanel);
                    
                    const rightPanel = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.7, 1.5),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x0066CC,
                            roughness: 0.8,
                            side: THREE.DoubleSide
                        })
                    );
                    rightPanel.position.set(1.45, 0, 0);
                    rightPanel.castShadow = true;
                    rightPanel.receiveShadow = true;
                    curtainGroup.add(rightPanel);
                    
                    const rod = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.03, 0.03, 3.6, 8),
                        new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.7 })
                    );
                    rod.rotation.z = Math.PI / 2;
                    rod.position.y = 0.85;
                    curtainGroup.add(rod);
                    
                    return curtainGroup;
                }
            },
            curtain_green: {
                name: '\ud83d\udfe2 Green Curtain',
                cost: { cloth: 2 },
                create: async () => {
                    const curtainGroup = new THREE.Group();
                    
                    const leftPanel = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.7, 1.5),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x00AA00,
                            roughness: 0.8,
                            side: THREE.DoubleSide
                        })
                    );
                    leftPanel.position.set(-1.45, 0, 0);
                    leftPanel.castShadow = true;
                    leftPanel.receiveShadow = true;
                    curtainGroup.add(leftPanel);
                    
                    const rightPanel = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.7, 1.5),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x00AA00,
                            roughness: 0.8,
                            side: THREE.DoubleSide
                        })
                    );
                    rightPanel.position.set(1.45, 0, 0);
                    rightPanel.castShadow = true;
                    rightPanel.receiveShadow = true;
                    curtainGroup.add(rightPanel);
                    
                    const rod = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.03, 0.03, 3.6, 8),
                        new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.7 })
                    );
                    rod.rotation.z = Math.PI / 2;
                    rod.position.y = 0.85;
                    curtainGroup.add(rod);
                    
                    return curtainGroup;
                }
            },
            curtain_white: {
                name: '\u2b1c White Curtain',
                cost: { cloth: 2 },
                create: async () => {
                    const curtainGroup = new THREE.Group();
                    
                    const leftPanel = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.7, 1.5),
                        new THREE.MeshStandardMaterial({ 
                            color: 0xF5F5F5,
                            roughness: 0.8,
                            side: THREE.DoubleSide
                        })
                    );
                    leftPanel.position.set(-1.45, 0, 0);
                    leftPanel.castShadow = true;
                    leftPanel.receiveShadow = true;
                    curtainGroup.add(leftPanel);
                    
                    const rightPanel = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.7, 1.5),
                        new THREE.MeshStandardMaterial({ 
                            color: 0xF5F5F5,
                            roughness: 0.8,
                            side: THREE.DoubleSide
                        })
                    );
                    rightPanel.position.set(1.45, 0, 0);
                    rightPanel.castShadow = true;
                    rightPanel.receiveShadow = true;
                    curtainGroup.add(rightPanel);
                    
                    const rod = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.03, 0.03, 3.6, 8),
                        new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.7 })
                    );
                    rod.rotation.z = Math.PI / 2;
                    rod.position.y = 0.85;
                    curtainGroup.add(rod);
                    
                    return curtainGroup;
                }
            },
            curtain_beige: {
                name: '\ud83d\udfe4 Beige Curtain',
                cost: { cloth: 2 },
                create: async () => {
                    const curtainGroup = new THREE.Group();
                    
                    const leftPanel = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.7, 1.5),
                        new THREE.MeshStandardMaterial({ 
                            color: 0xD2B48C,
                            roughness: 0.8,
                            side: THREE.DoubleSide
                        })
                    );
                    leftPanel.position.set(-1.45, 0, 0);
                    leftPanel.castShadow = true;
                    leftPanel.receiveShadow = true;
                    curtainGroup.add(leftPanel);
                    
                    const rightPanel = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.7, 1.5),
                        new THREE.MeshStandardMaterial({ 
                            color: 0xD2B48C,
                            roughness: 0.8,
                            side: THREE.DoubleSide
                        })
                    );
                    rightPanel.position.set(1.45, 0, 0);
                    rightPanel.castShadow = true;
                    rightPanel.receiveShadow = true;
                    curtainGroup.add(rightPanel);
                    
                    const rod = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.03, 0.03, 3.6, 8),
                        new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.7 })
                    );
                    rod.rotation.z = Math.PI / 2;
                    rod.position.y = 0.85;
                    curtainGroup.add(rod);
                    
                    return curtainGroup;
                }
            },

            // ═══════════════════════════════════════════════════════════════
            //  NEW FURNITURE & SPECIAL BUILDINGS
            // ═══════════════════════════════════════════════════════════════

            sofa: {
                name: '🛋️ Sofa',
                cost: { wood: 6, cloth: 4, fiber: 3 },
                create: async () => {
                    const g = new THREE.Group();
                    const woodMat = new THREE.MeshStandardMaterial({ color: 0x5C3A1E, roughness: 0.8 });
                    const fabricMat = new THREE.MeshStandardMaterial({ color: 0x8B6F47, roughness: 0.9 });
                    const cushionMat = new THREE.MeshStandardMaterial({ color: 0xA0785A, roughness: 0.85 });

                    // Base frame
                    const base = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.35, 0.85), woodMat);
                    base.position.set(0, 0.175, 0);
                    base.castShadow = true; base.receiveShadow = true;
                    g.add(base);

                    // Seat cushions (3x)
                    for (let i = -1; i <= 1; i++) {
                        const seat = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.2, 0.75), cushionMat);
                        seat.position.set(i * 0.64, 0.45, 0);
                        seat.castShadow = true; seat.receiveShadow = true;
                        g.add(seat);
                    }

                    // Back rest
                    const back = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.7, 0.2), fabricMat);
                    back.position.set(0, 0.65, -0.32);
                    back.castShadow = true; back.receiveShadow = true;
                    g.add(back);

                    // Back cushions (3x)
                    for (let i = -1; i <= 1; i++) {
                        const bc = new THREE.Mesh(new THREE.BoxGeometry(0.58, 0.58, 0.12), cushionMat);
                        bc.position.set(i * 0.64, 0.62, -0.24);
                        bc.castShadow = true;
                        g.add(bc);
                    }

                    // Arms (left & right)
                    for (const x of [-1.1, 1.1]) {
                        const arm = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.55, 0.85), woodMat);
                        arm.position.set(x, 0.45, 0);
                        arm.castShadow = true;
                        g.add(arm);
                    }

                    // Legs
                    for (const [lx, lz] of [[-0.9,-0.38],[0.9,-0.38],[-0.9,0.38],[0.9,0.38]]) {
                        const leg = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.18, 0.08), woodMat);
                        leg.position.set(lx, 0.09, lz);
                        leg.castShadow = true;
                        g.add(leg);
                    }

                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            bookcase: {
                name: '📚 Bookcase',
                cost: { wood: 10, iron_ingot: 2 },
                create: async () => {
                    const g = new THREE.Group();
                    await _loadAssetGLB('Bookshelf.glb');
                    const _glbInst = _instantiateGLB('Bookshelf.glb', 2.2);
                    if (_glbInst) g.add(_glbInst);
                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            table: {
                name: '🪑 Table',
                cost: { wood: 6, iron_ingot: 1 },
                create: async () => {
                    const g = new THREE.Group();
                    await _loadAssetGLB('Table.glb');
                    const _glbInst = _instantiateGLB('Table.glb', 1.5);
                    if (_glbInst) g.add(_glbInst);
                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            chair: {
                name: '🪑 Chair',
                cost: { wood: 4, cloth: 2 },
                create: async () => {
                    const g = new THREE.Group();
                    await _loadAssetGLB('Chair.glb');
                    const _glbInst = _instantiateGLB('Chair.glb', 1.2);
                    if (_glbInst) g.add(_glbInst);
                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            wall_shelf_b: {
                name: '🪵 Wall Shelf B',
                cost: { wood: 5, iron_ingot: 1 },
                create: async () => {
                    const g = new THREE.Group();
                    await _loadAssetGLB('CubeShelf.glb');
                    const _glbInst = _instantiateGLB('CubeShelf.glb', 1.4);
                    if (_glbInst) g.add(_glbInst);
                    g.userData.isWallShelf = true;
                    return g;
                }
            },

            candle: {
                name: '🕯️ Candle',
                cost: { cloth: 1, stone: 1 },
                create: async () => {
                    const g = new THREE.Group();
                    await _loadAssetGLB('Candle.glb');
                    const _glbInst = _instantiateGLB('Candle.glb', 0.6);
                    if (_glbInst) g.add(_glbInst);
                    // Keep warm point light even with GLB model
                    const candleLight = new THREE.PointLight(0xFFAA33, 0.8, 3.5);
                    candleLight.position.set(0, 0.44, 0);
                    g.add(candleLight);
                    g.userData.candleLight = candleLight;
                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            wall_light: {
                name: '💡 Wall Light',
                cost: { iron_ingot: 3, cloth: 1 },
                create: async () => {
                    const g = new THREE.Group();
                    const ironMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.8, roughness: 0.35 });
                    const glassMat = new THREE.MeshStandardMaterial({ color: 0xFFFFCC, transparent: true, opacity: 0.55, roughness: 0.1, metalness: 0.0, emissive: 0xFFEE88, emissiveIntensity: 0.6 });

                    // Wall backplate
                    const plate = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.3, 0.04), ironMat);
                    plate.position.set(0, 0, -0.08);
                    plate.castShadow = true;
                    g.add(plate);

                    // Arm extending from wall
                    const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 0.3, 8), ironMat);
                    arm.rotation.x = Math.PI / 2;
                    arm.position.set(0, 0.02, 0.07);
                    g.add(arm);

                    // Shade (cone)
                    const shade = new THREE.Mesh(new THREE.ConeGeometry(0.14, 0.2, 10, 1, true), ironMat);
                    shade.rotation.x = Math.PI;
                    shade.position.set(0, -0.1, 0.22);
                    shade.castShadow = true;
                    g.add(shade);

                    // Glass bulb inside shade
                    const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.07, 10, 8), glassMat);
                    bulb.position.set(0, 0.02, 0.22);
                    g.add(bulb);

                    // Iron ring at shade opening
                    const ring = new THREE.Mesh(new THREE.TorusGeometry(0.14, 0.015, 6, 16), ironMat);
                    ring.position.set(0, -0.2, 0.22);
                    g.add(ring);

                    // Point light
                    const wallLightPL = new THREE.PointLight(0xFFEE88, 1.2, 6.0);
                    wallLightPL.position.set(0, -0.2, 0.22);
                    g.add(wallLightPL);

                    g.userData.wallLight = wallLightPL;
                    g.userData.isWallShelf = true; // uses same wall-placement logic
                    return g;
                }
            },

            bee_hive: {
                name: '🐝 Bee Hive',
                cost: { wood: 12, fiber: 6, sticks: 4 },
                create: async () => {
                    const g = new THREE.Group();
                    await _loadAssetGLB('Hive.glb');
                    const _glbInst = _instantiateGLB('Hive.glb', 1.8);
                    if (_glbInst) {
                        // GLB has a baked-in Y rotation — zero it out to align with world
                        _glbInst.rotation.set(0, 0, 0);
                        // GLB has no UVs — paint vertex colours per mesh so each part looks distinct.
                        // Palette per mesh index: roof → dark shingles, slats → warm oak grain,
                        // legs/frame → dark walnut, landing board → pale pine.
                        const _hivePalettes = [
                            // Mesh 0 — roof: dark charcoal shingles with blue-grey tint
                            [ new THREE.Color(0x4A4035), new THREE.Color(0x3A3028),
                              new THREE.Color(0x524840), new THREE.Color(0x302820) ],
                            // Mesh 1 — top super/body: warm honey-oak slats
                            [ new THREE.Color(0xD4A050), new THREE.Color(0xC08030),
                              new THREE.Color(0xE0B060), new THREE.Color(0xB07020) ],
                            // Mesh 2 — middle super: slightly cooler tan
                            [ new THREE.Color(0xC8955A), new THREE.Color(0xB07838),
                              new THREE.Color(0xD8A868), new THREE.Color(0xA06828) ],
                            // Mesh 3 — bottom super: deeper amber
                            [ new THREE.Color(0xB8803A), new THREE.Color(0xA06A20),
                              new THREE.Color(0xC89050), new THREE.Color(0x8A5818) ],
                            // Mesh 4 — legs/stand: dark walnut
                            [ new THREE.Color(0x5C3A1E), new THREE.Color(0x4A2E10),
                              new THREE.Color(0x6A4428), new THREE.Color(0x3A2208) ],
                            // Mesh 5+ — base/landing board: pale pine
                            [ new THREE.Color(0xE8C878), new THREE.Color(0xD4B058),
                              new THREE.Color(0xF0D888), new THREE.Color(0xC4A048) ],
                        ];

                        // Helper: paint a geometry with a palette, face-alternating with grain jitter
                        function _paintHiveMesh(geo, palette) {
                            const pos   = geo.attributes.position;
                            const count = pos.count;
                            const colArr = new Float32Array(count * 3);
                            for (let vi = 0; vi < count; vi++) {
                                const faceIdx  = Math.floor(vi / 3);
                                const ci       = faceIdx % palette.length;
                                const col      = palette[ci];
                                // Multi-frequency grain jitter — gives wood-ring feel
                                const jitter   = Math.sin(vi * 5.7) * 0.035
                                               + Math.sin(vi * 13.1) * 0.018
                                               + Math.sin(vi * 31.3) * 0.008;
                                colArr[vi*3]   = Math.max(0, Math.min(1, col.r + jitter));
                                colArr[vi*3+1] = Math.max(0, Math.min(1, col.g + jitter * 0.7));
                                colArr[vi*3+2] = Math.max(0, Math.min(1, col.b + jitter * 0.3));
                            }
                            geo.setAttribute('color', new THREE.BufferAttribute(colArr, 3));
                        }

                        let _hiveMeshIdx = 0;
                        _glbInst.traverse(c => {
                            if (!c.isMesh) return;
                            const palette = _hivePalettes[Math.min(_hiveMeshIdx, _hivePalettes.length - 1)];
                            _hiveMeshIdx++;
                            _paintHiveMesh(c.geometry, palette);
                            c.material = new THREE.MeshBasicMaterial({
                                vertexColors: true,
                                side: THREE.DoubleSide,
                            });
                            c.castShadow = false;
                            c.receiveShadow = false;
                        });
                        g.add(_glbInst);
                    }
                    g.userData.isBeeHive = true;
                    g.userData.beeHiveData = { honey: 0, lastCollect: Date.now(), isReady: false };
                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            chicken_coop: {
                name: '🐔 Chicken Coop',
                cost: { wood: 16, fiber: 8, iron_ingot: 2 },
                create: async () => {
                    const g = new THREE.Group();
                    await _loadAssetGLB('ChickenCoop.glb');
                    const _glbInst = _instantiateGLB('ChickenCoop.glb', 2.5);
                    if (_glbInst) g.add(_glbInst);
                    g.userData.isChickenCoop = true;
                    g.userData.chickenCoopData = { eggs: 0, lastCollect: Date.now(), isReady: false };
                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            },

            oil_smelter: {
                name: '🛢️ Oil Smelter',
                cost: { iron_ingot: 12, stone: 8, coal: 4 },
                create: async () => {
                    const g = new THREE.Group();
                    const ironMat = new THREE.MeshStandardMaterial({ color: 0x444A50, metalness: 0.75, roughness: 0.45 });
                    const darkIronMat = new THREE.MeshStandardMaterial({ color: 0x2A2E32, metalness: 0.8, roughness: 0.5 });
                    const copperMat = new THREE.MeshStandardMaterial({ color: 0xB87333, metalness: 0.7, roughness: 0.4 });
                    const rivetMat = new THREE.MeshStandardMaterial({ color: 0x333840, metalness: 0.85, roughness: 0.35 });
                    const glassMat = new THREE.MeshStandardMaterial({ color: 0x88BB88, transparent: true, opacity: 0.45, roughness: 0.1 });
                    const fireMat = new THREE.MeshBasicMaterial({ color: 0xFF6600, transparent: true, opacity: 0.7 });

                    // Base / foundation
                    const base = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.12, 1.1), darkIronMat);
                    base.position.set(0, 0.06, 0);
                    base.castShadow = true; base.receiveShadow = true;
                    g.add(base);

                    // Main boiler tank (horizontal cylinder)
                    const tank = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 1.1, 16), ironMat);
                    tank.rotation.x = Math.PI / 2;
                    tank.position.set(0, 0.78, 0);
                    tank.castShadow = true;
                    g.add(tank);

                    // Tank end caps
                    for (const z of [-0.56, 0.56]) {
                        const cap = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.05, 16), darkIronMat);
                        cap.rotation.x = Math.PI / 2;
                        cap.position.set(0, 0.78, z);
                        g.add(cap);
                    }

                    // Horizontal bands on tank
                    for (let i = 0; i < 3; i++) {
                        const band = new THREE.Mesh(new THREE.TorusGeometry(0.405, 0.02, 6, 16), darkIronMat);
                        band.rotation.x = Math.PI / 2;
                        band.position.set(0, 0.78, -0.36 + i * 0.36);
                        g.add(band);
                    }

                    // Support legs / saddles
                    for (const x of [-0.4, 0.4]) {
                        const saddle = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.38, 0.85), darkIronMat);
                        saddle.position.set(x, 0.37, 0);
                        saddle.castShadow = true;
                        g.add(saddle);
                    }

                    // Furnace box (firebox beneath tank)
                    const firebox = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.22, 0.8), darkIronMat);
                    firebox.position.set(0, 0.17, 0);
                    firebox.castShadow = true;
                    g.add(firebox);

                    // Firebox door
                    const fireboxDoor = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.18, 0.04), ironMat);
                    fireboxDoor.position.set(0, 0.17, 0.42);
                    g.add(fireboxDoor);
                    const fireGlow = new THREE.Mesh(new THREE.PlaneGeometry(0.22, 0.14), fireMat);
                    fireGlow.position.set(0, 0.17, 0.44);
                    g.add(fireGlow);

                    // Chimney stack
                    const chimney = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.75, 8), darkIronMat);
                    chimney.position.set(-0.4, 1.36, -0.2);
                    chimney.castShadow = true;
                    g.add(chimney);
                    const chimneyTop = new THREE.Mesh(new THREE.CylinderGeometry(0.11, 0.09, 0.06, 8), darkIronMat);
                    chimneyTop.position.set(-0.4, 1.74, -0.2);
                    g.add(chimneyTop);

                    // Output pipe + valve
                    const pipe = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, 0.45, 8), copperMat);
                    pipe.rotation.x = Math.PI / 2;
                    pipe.position.set(0.45, 0.52, 0.32);
                    g.add(pipe);
                    const valve = new THREE.Mesh(new THREE.TorusGeometry(0.055, 0.018, 6, 10), copperMat);
                    valve.position.set(0.45, 0.52, 0.55);
                    g.add(valve);

                    // Pressure gauge
                    const gaugeBase = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.04, 10), ironMat);
                    gaugeBase.rotation.x = Math.PI / 2;
                    gaugeBase.position.set(-0.2, 1.14, 0.42);
                    g.add(gaugeBase);
                    const gaugeGlass = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.02, 10), glassMat);
                    gaugeGlass.rotation.x = Math.PI / 2;
                    gaugeGlass.position.set(-0.2, 1.14, 0.45);
                    g.add(gaugeGlass);

                    // Rivets on tank
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const rivet = new THREE.Mesh(new THREE.SphereGeometry(0.018, 5, 5), rivetMat);
                        rivet.position.set(Math.cos(angle) * 0.41, 0.78 + Math.sin(angle) * 0.41, -0.56);
                        g.add(rivet);
                    }

                    g.userData.isOilSmelter = true;
                    g.userData.oilSmelterData = { active: false, fuel: 0, output: 0 };
                    g.userData.collisionBox = new THREE.Box3().setFromObject(g);
                    return g;
                }
            }
        };
        
        function updateBuildingMenu() {
            const list = document.getElementById('building-list');
            list.innerHTML = '';
            
            // Group buildings by category
            const categories = {
                'Structure': [],
                'Doors & Frames': [],
                'Stairs & Ladders': [],
                'Crafting Stations': [],
                'Storage & Furniture': [],
                'Decorations': []
            };
            
            for (let id in buildingTypes) {
                const building = buildingTypes[id];
                
                let categoryName = 'Structure';
                if (id.includes('door') || id.includes('frame') || id.includes('window')) {
                    categoryName = 'Doors & Frames';
                } else if (id.includes('stairs') || id.includes('ladder')) {
                    categoryName = 'Stairs & Ladders';
                } else if (id === 'campfire' || id === 'workbench' || id === 'building_bench' || 
                           id === 'furnace' || id === 'sewing_table' || id === 'recycler') {
                    categoryName = 'Crafting Stations';
                } else if (id.includes('storage') || id === 'sleeping_bag' || id.includes('shelf')) {
                    categoryName = 'Storage & Furniture';
                } else if (id === 'sofa' || id === 'bookcase' || id === 'table' || id === 'chair' || id === 'wall_shelf_b') {
                    categoryName = 'Storage & Furniture';
                } else if (id === 'bee_hive' || id === 'chicken_coop' || id === 'oil_smelter') {
                    categoryName = 'Crafting Stations';
                } else if (id.includes('rug') || id.includes('curtain') || id === 'candle' || id === 'wall_light') {
                    categoryName = 'Decorations';
                }
                
                categories[categoryName].push({ id, building });
            }
            
            // Create grid for each category
            for (let categoryName in categories) {
                if (categories[categoryName].length === 0) continue;
                
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'menu-category';
                
                const titleDiv = document.createElement('div');
                titleDiv.className = 'category-title';
                titleDiv.textContent = categoryName;
                categoryDiv.appendChild(titleDiv);
                
                const gridDiv = document.createElement('div');
                gridDiv.className = 'category-grid';
                
                categories[categoryName].forEach(({ id, building }) => {
                    const canBuild = Object.entries(building.cost).every(
                        ([resource, amount]) => inventory[resource] >= amount
                    );
                    
                    const item = document.createElement('div');
                    item.className = 'grid-item' + (canBuild ? '' : ' disabled');
                    
                    const icon = itemIcons[id] || '\u2753';
                    const costText = Object.entries(building.cost)
                        .map(([r, a]) => `${a} ${r}`)
                        .join(', ');
                    
                    item.innerHTML = `
                        <div class="grid-item-icon">${icon}</div>
                        <div class="grid-item-name">${building.name.replace(/^[^\s]+\s/, '')}</div>
                        <div class="grid-item-cost">${costText}</div>
                    `;
                    
                    if (canBuild) {
                        item.onclick = () => startBuilding(id);
                    }
                    
                    gridDiv.appendChild(item);
                });
                
                categoryDiv.appendChild(gridDiv);
                list.appendChild(categoryDiv);
            }
        }
        
        // Shared preview materials reused for every placement ghost
        const _previewMat = new THREE.MeshStandardMaterial({
            color: 0x00ff00, emissive: new THREE.Color(0x00ff00), emissiveIntensity: 0.3,
            transparent: true, opacity: 0.6, roughness: 0.7, metalness: 0.1, side: THREE.DoubleSide
        });
        const _previewMatStairs = new THREE.MeshStandardMaterial({
            color: 0x00ff00, emissive: new THREE.Color(0x00ff00), emissiveIntensity: 0.6,
            transparent: true, opacity: 0.8, roughness: 0.7, metalness: 0.1,
            side: THREE.DoubleSide, depthWrite: false
        });
        // Cached raycaster/vector — never allocate inside updateBuildPreview (60fps)
        const _buildRaycaster = new THREE.Raycaster();
        const _buildCenter    = new THREE.Vector2(0, 0);
        let   _buildFloorCache = null;
        let   _buildFloorLen   = -1;

        async function startBuilding(type) {
            buildMode = type;
            document.getElementById('build-info').style.display = 'block';
            document.getElementById('build-info').textContent = 'Left click to place, Right click/ESC to cancel, R to rotate';
            
            if (buildPreview) scene.remove(buildPreview);
            buildPreview = await buildAndPlaceModel(type);
            buildPreview.traverse((child) => {
                if (child.isMesh) {
                    child.userData.originalMaterial = child.material;
                    child.material = _previewMat;
                    child.renderOrder = 999;
                }
            });

            // Add inside-face direction indicator for walls and door frames
            const _wallTypes = ['wall', 'window_wall', 'door_frame', 'double_door_frame',
                'stone_door_frame', 'metal_door_frame', 'stone_double_door_frame', 'metal_double_door_frame'];
            if (_wallTypes.includes(type)) {
                // Arrow pointing toward the INSIDE face (+Z in local space)
                const arrowMat = new THREE.MeshBasicMaterial({ color: 0xffff00, depthTest: false });
                const arrowGroup = new THREE.Group();
                arrowGroup.name = '_faceIndicator';
                // Arrow shaft
                const shaft = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.55), arrowMat);
                shaft.position.set(0, 0.3, 0.35);
                arrowGroup.add(shaft);
                // Arrowhead (cone pointing +Z)
                const head = new THREE.Mesh(new THREE.ConeGeometry(0.18, 0.35, 8), arrowMat);
                head.rotation.x = Math.PI / 2;
                head.position.set(0, 0.3, 0.75);
                arrowGroup.add(head);
                // Label plane with "INSIDE" text using a small canvas texture
                const _canvas = document.createElement('canvas');
                _canvas.width = 256; _canvas.height = 64;
                const _ctx = _canvas.getContext('2d');
                _ctx.fillStyle = 'rgba(0,0,0,0)';
                _ctx.fillRect(0, 0, 256, 64);
                _ctx.fillStyle = '#ffff00';
                _ctx.font = 'bold 42px Arial';
                _ctx.textAlign = 'center';
                _ctx.textBaseline = 'middle';
                _ctx.fillText('INSIDE', 128, 32);
                const _tex = new THREE.CanvasTexture(_canvas);
                const labelMat = new THREE.MeshBasicMaterial({ map: _tex, transparent: true, depthTest: false, side: THREE.DoubleSide });
                const label = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 0.3), labelMat);
                label.position.set(0, 0.7, 0.2);
                arrowGroup.add(label);
                buildPreview.add(arrowGroup);
            }
            buildPreview.visible = true;
            scene.add(buildPreview);
        }
        
        function updateBuildPreview() {
            if (!buildMode || !buildPreview) return;
            
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(camera.quaternion);
            const distance = 5;
            
            let targetPos = camera.position.clone().add(forward.multiplyScalar(distance));
            let stairsHitSurface = null; // STAIRS ONLY: Track what surface was hit
            
            // For stairs and floor-placeable items, use raycast to find actual surface position
            if (buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right' || 
                buildMode === 'floor' || buildMode === 'ceiling' || 
                buildMode === 'wall' || buildMode === 'window_wall' || buildMode === 'door_frame' || buildMode === 'double_door_frame' ||
                buildMode === 'campfire' || buildMode === 'workbench' || buildMode === 'furnace' || buildMode === 'cooking_station' ||
                buildMode === 'water_catcher' ||
                buildMode === 'storage_box' || buildMode === 'small_storage_box' || buildMode === 'sleeping_bag' || buildMode === 'building_bench' || buildMode === 'sewing_table' || buildMode === 'wall_shelf') {
                const raycaster = _buildRaycaster;
                raycaster.setFromCamera(_buildCenter, camera);
                if (!_buildFloorCache || _buildFloorLen !== buildings.length) {
                    _buildFloorCache = buildings.filter(b => isFloorOrCeiling(b.userData.buildingType));
                    _buildFloorLen = buildings.length;
                }
                const isBoxMode = buildMode === 'storage_box' || buildMode === 'small_storage_box';
                const shelfTargets = isBoxMode ? buildings.filter(b => b.userData.isShelf) : [];
                const buildingsToCheck = shelfTargets.length ? [..._buildFloorCache, ...shelfTargets] : _buildFloorCache;
                
                const intersects = raycaster.intersectObjects(buildingsToCheck, true);
                
                if (intersects.length > 0 && intersects[0].distance < 15) {
                    // Found a surface, use that position
                    targetPos = intersects[0].point.clone();
                    
                    // STAIRS ONLY: Track what was hit
                    if (buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') {
                        let hitObject = intersects[0].object;
                        while (hitObject.parent && !hitObject.userData.buildingType) {
                            hitObject = hitObject.parent;
                        }
                        stairsHitSurface = hitObject.userData.buildingType;
                    }
                } else {
                    // No building surface, check ground plane intersection
                    const groundY = 0;
                    if (forward.y < 0) { // Only if looking downward
                        const t = (groundY - camera.position.y) / forward.y;
                        if (t > 0 && t < 20) { // Within reasonable distance
                            targetPos = camera.position.clone().add(forward.clone().multiplyScalar(t));
                            targetPos.y = groundY;
                            if (buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') {
                                stairsHitSurface = 'ground';
                            }
                        }
                    }
                }
            }
            
            // Ensure preview is visible and in front of camera
            buildPreview.visible = true;
            
            // Rust-like snapping system
            let bestSnap = null; // hoisted so wall placement code can read isStackSnap outside snapToGrid block
            if (snapToGrid) {
                const gridSize = 4; // 4-unit grid for walls/foundations
                
                // Find nearest building to snap to
                let bestSnapDist = Infinity;
                
                for (let building of buildings) {
                    const buildingType = building.userData.buildingType;
                    const buildingRot = building.rotation.y;
                    
                    // Snap walls to walls, floors to floors
                    if (buildMode === 'wall' || buildMode === 'window_wall' || buildMode === 'door_frame' || buildMode === 'double_door_frame' ||
                        buildMode === 'stone_wall' || buildMode === 'metal_wall' ||
                        buildMode === 'stone_window_wall' || buildMode === 'metal_window_wall' ||
                        buildMode === 'stone_door_frame' || buildMode === 'metal_door_frame' ||
                        buildMode === 'stone_double_door_frame' || buildMode === 'metal_double_door_frame') {
                        // Wall-to-wall snapping (walls are 4 units wide) — includes all wall variants so door frames snap next to walls, window walls, and each other
                        if (buildingType === 'wall' || buildingType === 'window_wall' || buildingType === 'door_frame' || buildingType === 'double_door_frame' ||
                            buildingType === 'stone_wall' || buildingType === 'metal_wall' || buildingType === 'stone_window_wall' || buildingType === 'metal_window_wall' ||
                            buildingType === 'stone_door_frame' || buildingType === 'metal_door_frame' || buildingType === 'stone_double_door_frame' || buildingType === 'metal_double_door_frame') {
                            // Calculate direction based on rotation
                            const rotNormalized = buildingRot % (Math.PI * 2);
                            
                            let snapPositions = [];
                            
                            // If wall is horizontal (facing N/S)
                            if (Math.abs(Math.sin(rotNormalized)) < 0.5) {
                                snapPositions = [
                                    { x: building.position.x + 4, z: building.position.z, rot: buildingRot },     // Right
                                    { x: building.position.x - 4, z: building.position.z, rot: buildingRot },     // Left
                                    // Perpendicular snaps
                                    { x: building.position.x + 2, z: building.position.z + 2, rot: buildingRot + Math.PI / 2 },
                                    { x: building.position.x - 2, z: building.position.z + 2, rot: buildingRot + Math.PI / 2 },
                                    { x: building.position.x + 2, z: building.position.z - 2, rot: buildingRot + Math.PI / 2 },
                                    { x: building.position.x - 2, z: building.position.z - 2, rot: buildingRot + Math.PI / 2 }
                                ];
                            } else {
                                // Wall is vertical (facing E/W)
                                snapPositions = [
                                    { x: building.position.x, z: building.position.z + 4, rot: buildingRot },     // Front
                                    { x: building.position.x, z: building.position.z - 4, rot: buildingRot },     // Back
                                    // Perpendicular snaps
                                    { x: building.position.x + 2, z: building.position.z + 2, rot: buildingRot - Math.PI / 2 },
                                    { x: building.position.x + 2, z: building.position.z - 2, rot: buildingRot - Math.PI / 2 },
                                    { x: building.position.x - 2, z: building.position.z + 2, rot: buildingRot - Math.PI / 2 },
                                    { x: building.position.x - 2, z: building.position.z - 2, rot: buildingRot - Math.PI / 2 }
                                ];
                            }
                            
                            for (let snap of snapPositions) {
                                const dist = Math.sqrt(Math.pow(targetPos.x - snap.x, 2) + Math.pow(targetPos.z - snap.z, 2));
                                if (dist < bestSnapDist && dist < 6) {
                                    bestSnapDist = dist;
                                    bestSnap = {
                                        x: snap.x,
                                        z: snap.z,
                                        y: building.position.y,
                                        rotation: snap.rot
                                    };
                                }
                            }
                            
                            // Vertical wall stacking - walls can stack directly above other walls with ceiling in between
                            const horizDist = Math.sqrt(
                                Math.pow(targetPos.x - building.position.x, 2) + 
                                Math.pow(targetPos.z - building.position.z, 2)
                            );
                            // If placing directly above this wall (same X/Z position)
                            if (horizDist < 2.0) {
                                // Look for any ceiling above this wall
                                let ceilingAbove = null;
                                let closestCeilingDist = Infinity;
                                
                                for (let otherBuilding of buildings) {
                                    const _obt = otherBuilding.userData.buildingType;
                                    if (_obt === 'ceiling' || _obt === 'stone_ceiling' || _obt === 'metal_ceiling') {
                                        // Check if ceiling is above this wall
                                        if (otherBuilding.position.y > building.position.y + 1.0) {
                                            // Check if ceiling is near this wall's X/Z position
                                            const ceilingHorizDist = Math.sqrt(
                                                Math.pow(building.position.x - otherBuilding.position.x, 2) + 
                                                Math.pow(building.position.z - otherBuilding.position.z, 2)
                                            );
                                            if (ceilingHorizDist < 3) {
                                                const vertDist = otherBuilding.position.y - building.position.y;
                                                if (vertDist < closestCeilingDist) {
                                                    closestCeilingDist = vertDist;
                                                    ceilingAbove = otherBuilding;
                                                }
                                            }
                                        }
                                    }
                                }
                                
                                // If found ceiling above, snap new wall to sit on it
                                // Give stacking priority over side-snaps by forcing bestSnapDist very low
                                if (ceilingAbove) {
                                    const stackSnapDist = horizDist * 0.1; // always beats side-snaps
                                    bestSnapDist = stackSnapDist;
                                    bestSnap = {
                                        x: building.position.x,
                                        z: building.position.z,
                                        y: ceilingAbove.position.y + 0.1 + 1.5, // Ceiling Y + thickness + half wall height
                                        rotation: building.rotation.y,
                                        isStackSnap: true // flag: Y is already correct, skip recalculation
                                    };
                                }
                            }
                        }
                        
                        // Wall-to-floor/ceiling edge snapping (floors/ceilings are 4x4)
                        if (isFloorOrCeiling(buildingType)) {
                            // Snap to floor/ceiling edges - walls sit exactly at edge
                            const edgePositions = [
                                { x: building.position.x + 2, z: building.position.z, rot: Math.PI / 2 },      // East edge
                                { x: building.position.x - 2, z: building.position.z, rot: Math.PI / 2 },      // West edge
                                { x: building.position.x, z: building.position.z + 2, rot: 0 },                // South edge
                                { x: building.position.x, z: building.position.z - 2, rot: 0 }                 // North edge
                            ];
                            
                            for (let snap of edgePositions) {
                                const dist = Math.sqrt(Math.pow(targetPos.x - snap.x, 2) + Math.pow(targetPos.z - snap.z, 2));
                                if (dist < bestSnapDist && dist < 6) {
                                    bestSnapDist = dist;
                                    let wallY;
                                    if (buildingType === 'ceiling') {
                                        // For ceilings, walls sit on top (ceiling is the floor of upper level)
                                        wallY = building.position.y + 0.1 + 1.5; // Ceiling Y + ceiling thickness + half wall height
                                    } else {
                                        // For floors, walls sit on top
                                        wallY = building.position.y + 0.1 + 1.5; // Floor Y + floor thickness + half wall height
                                    }
                                    bestSnap = {
                                        x: snap.x,
                                        z: snap.z,
                                        y: wallY,
                                        rotation: snap.rot
                                    };
                                }
                            }
                        }
                    } else if (buildMode === 'floor') {
                        // Floor-to-floor and floor-to-ceiling snapping (4x4 floors)
                        if (isFloorOrCeiling(buildingType)) {
                            // Horizontal snapping (same level)
                            const snapPositions = [
                                { x: building.position.x + 4, z: building.position.z, y: building.position.y },
                                { x: building.position.x - 4, z: building.position.z, y: building.position.y },
                                { x: building.position.x, z: building.position.z + 4, y: building.position.y },
                                { x: building.position.x, z: building.position.z - 4, y: building.position.y }
                            ];
                            
                            // Add vertical stacking - floor directly above ceiling (for multi-story)
                            if (buildingType.includes('ceiling')) {
                                snapPositions.push(
                                    { x: building.position.x, z: building.position.z, y: building.position.y + 3.2 } // Place floor above ceiling
                                );
                            }
                            
                            for (let snap of snapPositions) {
                                const dist = Math.sqrt(
                                    Math.pow(targetPos.x - snap.x, 2) + 
                                    Math.pow(targetPos.z - snap.z, 2) +
                                    Math.pow(targetPos.y - snap.y, 2) * 0.5 // Vertical distance matters less
                                );
                                if (dist < bestSnapDist && dist < 6) {
                                    bestSnapDist = dist;
                                    bestSnap = {
                                        x: snap.x,
                                        z: snap.z,
                                        y: snap.y,
                                        rotation: building.rotation.y
                                    };
                                }
                            }
                        }
                    } else if (buildMode === 'ceiling') {
                        // Ceiling-to-ceiling horizontal snapping (same height level)
                        if (buildingType === 'ceiling') {
                            const snapPositions = [
                                { x: building.position.x + 4, z: building.position.z },
                                { x: building.position.x - 4, z: building.position.z },
                                { x: building.position.x, z: building.position.z + 4 },
                                { x: building.position.x, z: building.position.z - 4 }
                            ];
                            
                            for (let snap of snapPositions) {
                                const dist = Math.sqrt(Math.pow(targetPos.x - snap.x, 2) + Math.pow(targetPos.z - snap.z, 2));
                                if (dist < bestSnapDist && dist < 6) {
                                    bestSnapDist = dist;
                                    bestSnap = {
                                        x: snap.x,
                                        z: snap.z,
                                        y: building.position.y, // Keep same height as existing ceiling
                                        rotation: 0
                                    };
                                }
                            }
                        }
                        // Ceiling snaps to wall tops — ceiling panel centre sits directly above the wall centre
                        if (buildingType === 'wall' || buildingType === 'window_wall' ||
                            buildingType === 'door_frame' || buildingType === 'double_door_frame' ||
                            buildingType === 'stone_wall' || buildingType === 'metal_wall' ||
                            buildingType === 'stone_window_wall' || buildingType === 'metal_window_wall' ||
                            buildingType === 'stone_door_frame' || buildingType === 'metal_door_frame' ||
                            buildingType === 'stone_double_door_frame' || buildingType === 'metal_double_door_frame') {
                            const wallRot = building.rotation.y;
                            const rotNorm = wallRot % (Math.PI * 2);
                            // Ceiling snaps centred on the wall position (wall edge = ceiling edge)
                            // Offer two ceiling panel centres: one on each side of the wall
                            let offX, offZ;
                            if (Math.abs(Math.sin(rotNorm)) < 0.5) {
                                // Wall faces N/S → offset along Z
                                offX = 0; offZ = 2;
                            } else {
                                // Wall faces E/W → offset along X
                                offX = 2; offZ = 0;
                            }
                            const ceilY = building.position.y + 1.6;
                            const snapPositions = [
                                { x: building.position.x + offX, z: building.position.z + offZ, y: ceilY },
                                { x: building.position.x - offX, z: building.position.z - offZ, y: ceilY }
                            ];
                            for (let snap of snapPositions) {
                                const dist = Math.sqrt(Math.pow(targetPos.x - snap.x, 2) + Math.pow(targetPos.z - snap.z, 2));
                                if (dist < bestSnapDist && dist < 4) {
                                    bestSnapDist = dist;
                                    bestSnap = { x: snap.x, z: snap.z, y: snap.y, rotation: 0 };
                                }
                            }
                        }
                    } else if (buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') {
                        // STAIRS: Snap to 2-unit grid for clean alignment
                        if (isFloorOrCeiling(buildingType)) {
                            const dist = Math.sqrt(
                                Math.pow(targetPos.x - building.position.x, 2) + 
                                Math.pow(targetPos.z - building.position.z, 2)
                            );
                            if (dist < 5) {
                                // Snap to 2-unit grid
                                const stairGrid = 2;
                                const snappedX = Math.round(targetPos.x / stairGrid) * stairGrid;
                                const snappedZ = Math.round(targetPos.z / stairGrid) * stairGrid;
                                
                                bestSnap = {
                                    x: snappedX,
                                    z: snappedZ,
                                    y: building.position.y,
                                    rotation: buildRotation,
                                    snapToCeiling: buildingType === 'ceiling',
                                    ceilingRef: buildingType === 'ceiling' ? building : null
                                };
                            }
                        }
                    }
                }
                
                // Apply best snap if found
                if (bestSnap) {
                    targetPos.x = bestSnap.x;
                    targetPos.z = bestSnap.z;
                    targetPos.y = bestSnap.y;
                    buildRotation = bestSnap.rotation;
                } else if (buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') {
                    // STAIRS: Always snap to grid
                    const stairGrid = 2;
                    targetPos.x = Math.round(targetPos.x / stairGrid) * stairGrid;
                    targetPos.z = Math.round(targetPos.z / stairGrid) * stairGrid;
                } else if (buildMode === 'storage_box' || buildMode === 'small_storage_box') {
                    // Storage boxes: shelf snap handles positioning — skip grid snap
                } else if (buildMode === 'ceiling' || buildMode === 'ladder_ceiling') {
                    // Ceiling centres sit at half-grid offset (wall grid is 0,4,8 → ceiling centres at 2,6,10)
                    targetPos.x = Math.round((targetPos.x - 2) / gridSize) * gridSize + 2;
                    targetPos.z = Math.round((targetPos.z - 2) / gridSize) * gridSize + 2;
                } else {
                    // No snap point found, use grid snapping
                    targetPos.x = Math.round(targetPos.x / gridSize) * gridSize;
                    targetPos.z = Math.round(targetPos.z / gridSize) * gridSize;
                }
            }
            
            buildPreview.position.copy(targetPos);
            
            // Check if there's a floor underneath to snap to
            let floorHeight = 0;
            let onFloor = false;
            
            // STAIRS: Use raycast hit surface
            if ((buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') && stairsHitSurface === 'floor') {
                onFloor = true;
                for (let building of buildings) {
                    if (building.userData.buildingType && building.userData.buildingType.includes('floor')) {
                        const floorBox = new THREE.Box3().setFromObject(building);
                        if (targetPos.x >= floorBox.min.x && targetPos.x <= floorBox.max.x &&
                            targetPos.z >= floorBox.min.z && targetPos.z <= floorBox.max.z) {
                            floorHeight = floorBox.max.y;
                            break;
                        }
                    }
                }
            } else if (buildMode !== 'stairs' && buildMode !== 'corner_stairs_left' && buildMode !== 'corner_stairs_right') {
                // Non-stairs: Original detection
                for (let building of buildings) {
                    if (building.userData.buildingType && building.userData.buildingType.includes('floor')) {
                        const floorBox = new THREE.Box3().setFromObject(building);
                        // Check if preview is above this floor
                        if (targetPos.x >= floorBox.min.x && targetPos.x <= floorBox.max.x &&
                            targetPos.z >= floorBox.min.z && targetPos.z <= floorBox.max.z) {
                            floorHeight = floorBox.max.y;
                            onFloor = true;
                        }
                    }
                }
            }
            
            // Universal ceiling detection - check if there's a ceiling below target position
            let ceilingBelow = null;
            
            // STAIRS: Use raycast hit surface
            if ((buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') && stairsHitSurface === 'ceiling') {
                for (let building of buildings) {
                    if (building.userData.buildingType === 'ceiling') {
                        const ceilingBox = new THREE.Box3().setFromObject(building);
                        if (targetPos.x >= ceilingBox.min.x && targetPos.x <= ceilingBox.max.x &&
                            targetPos.z >= ceilingBox.min.z && targetPos.z <= ceilingBox.max.z) {
                            ceilingBelow = building;
                            break;
                        }
                    }
                }
            } else if (buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') {
                // STAIRS but didn't hit ceiling - no ceiling
                ceilingBelow = null;
            } else {
                // Non-stairs: Original detection
                // STAIRS FIX: Skip ceiling detection if raycast already hit a floor
                const stairsHitFloor = ((buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') && onFloor);
                
                // First check if stairs snapped to a ceiling edge
                if ((buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') && bestSnap && bestSnap.snapToCeiling && bestSnap.ceilingRef) {
                    ceilingBelow = bestSnap.ceilingRef;
                } else if (!stairsHitFloor) {
                    // Regular ceiling detection (skip for stairs that hit floor)
                    const isWallMode = (buildMode === 'wall' || buildMode === 'window_wall' || buildMode === 'door_frame' || buildMode === 'double_door_frame' ||
                        buildMode === 'stone_wall' || buildMode === 'metal_wall' ||
                        buildMode === 'stone_window_wall' || buildMode === 'metal_window_wall' ||
                        buildMode === 'stone_door_frame' || buildMode === 'metal_door_frame' ||
                        buildMode === 'stone_double_door_frame' || buildMode === 'metal_double_door_frame');
                    const ceilingLookDist = isWallMode ? 5 : 2; // wider tolerance for walls placing on 2nd floor ceilings
                    for (let building of buildings) {
                        const _cbt = building.userData.buildingType;
                        if (_cbt === 'ceiling' || _cbt === 'stone_ceiling' || _cbt === 'metal_ceiling') {
                            const ceilingBox = new THREE.Box3().setFromObject(building);
                            // Check if target position is within or near this ceiling (horizontally aligned)
                            const horizMargin = isWallMode ? 3 : 0;
                            if (targetPos.x >= ceilingBox.min.x - horizMargin && targetPos.x <= ceilingBox.max.x + horizMargin &&
                                targetPos.z >= ceilingBox.min.z - horizMargin && targetPos.z <= ceilingBox.max.z + horizMargin &&
                                targetPos.y >= ceilingBox.min.y - ceilingLookDist) {
                                // Found a ceiling at/below target - use the highest one
                                if (!ceilingBelow || building.position.y > ceilingBelow.position.y) {
                                    ceilingBelow = building;
                                }
                            }
                        }
                    }
                }
            }
            const ceilingHeight = ceilingBelow ? ceilingBelow.position.y + 0.1 : 0;
            const onCeiling = ceilingBelow !== null;
            
            // Set height based on building type and whether on floor or ceiling
            if (buildMode === 'floor') {
                // Floors can clip into terrain, stay at ground level
                buildPreview.position.y = 0.1;
            } else if (buildMode === 'ceiling' || buildMode === 'ladder_ceiling') {
                // Ceilings and ladder_ceilings place based on surrounding structures - check for highest relevant level
                // First check if already on a ceiling (for stacking multiple stories)
                if (onCeiling) {
                    // Already on a ceiling, check for walls at this level
                    let wallAtThisLevel = null;
                    let highestWallY = 0;
                    
                    for (let building of buildings) {
                        const _bbt = building.userData.buildingType;
                        if (_bbt === 'wall' || _bbt === 'window_wall' || _bbt === 'door_frame' || _bbt === 'double_door_frame' ||
                            _bbt === 'stone_wall' || _bbt === 'metal_wall' ||
                            _bbt === 'stone_window_wall' || _bbt === 'metal_window_wall' ||
                            _bbt === 'stone_door_frame' || _bbt === 'metal_door_frame' ||
                            _bbt === 'stone_double_door_frame' || _bbt === 'metal_double_door_frame') {
                            const dist = Math.sqrt(
                                Math.pow(targetPos.x - building.position.x, 2) + 
                                Math.pow(targetPos.z - building.position.z, 2)
                            );
                            // Look for walls near this position and at the ceiling level or above
                            if (dist < 4 && building.position.y >= ceilingHeight) {
                                if (building.position.y > highestWallY) {
                                    highestWallY = building.position.y;
                                    wallAtThisLevel = building;
                                }
                            }
                        }
                    }
                    
                    if (wallAtThisLevel) {
                        // Place ceiling at top of these upper-level walls
                        buildPreview.position.y = wallAtThisLevel.position.y + 1.6;
                    } else {
                        // No walls at this level, place 3 units above the existing ceiling
                        buildPreview.position.y = ceilingHeight + 3.0;
                    }
                } else if (onFloor) {
                    // On a floor, place 3 units above
                    buildPreview.position.y = floorHeight + 3.0;
                } else {
                    // No floor/ceiling detected, check for walls nearby
                    let wallFound = false;
                    for (let building of buildings) {
                        const _bbt2 = building.userData.buildingType;
                        if (_bbt2 === 'wall' || _bbt2 === 'window_wall' || _bbt2 === 'door_frame' || _bbt2 === 'double_door_frame' ||
                            _bbt2 === 'stone_wall' || _bbt2 === 'metal_wall' ||
                            _bbt2 === 'stone_window_wall' || _bbt2 === 'metal_window_wall' ||
                            _bbt2 === 'stone_door_frame' || _bbt2 === 'metal_door_frame' ||
                            _bbt2 === 'stone_double_door_frame' || _bbt2 === 'metal_double_door_frame') {
                            const dist = Math.sqrt(
                                Math.pow(targetPos.x - building.position.x, 2) + 
                                Math.pow(targetPos.z - building.position.z, 2)
                            );
                            if (dist < 4) {
                                buildPreview.position.y = building.position.y + 1.6;
                                wallFound = true;
                                break;
                            }
                        }
                    }
                    if (!wallFound) {
                        // No structures nearby, use default ceiling height
                        buildPreview.position.y = 3.1;
                    }
                }
            } else if (buildMode === 'door' || buildMode === 'double_door' || buildMode === 'stone_door' || buildMode === 'stone_double_door' || buildMode === 'metal_door' || buildMode === 'metal_double_door') {
                // Doors ONLY snap to door frames — find closest frame to camera within reach
                let closestFrame = null;
                let closestDist = Infinity;

                for (let building of buildings) {
                    if (building.userData.isDoorFrame) {
                        const dist = camera.position.distanceTo(building.position);
                        if (dist < 8 && dist < closestDist) {
                            closestDist = dist;
                            closestFrame = building;
                        }
                    }
                }

                if (closestFrame) {
                    buildPreview.position.x = closestFrame.position.x;
                    buildPreview.position.z = closestFrame.position.z;
                    buildPreview.position.y = closestFrame.position.y - 0.1;
                    buildPreview.rotation.y = closestFrame.rotation.y;
                } else {
                    // No frame nearby — park preview off-screen so it's clearly unplaceable
                    buildPreview.position.y = -999;
                }
            } else if (buildMode === 'door_frame' || buildMode === 'double_door_frame' ||
                       buildMode === 'stone_door_frame' || buildMode === 'metal_door_frame' ||
                       buildMode === 'stone_double_door_frame' || buildMode === 'metal_double_door_frame') {
                // Door frames sit on floor OR on ceiling (for multi-story)
                if (bestSnap && bestSnap.isStackSnap) {
                    buildPreview.position.y = bestSnap.y;
                } else if (onCeiling) {
                    buildPreview.position.y = ceilingHeight + 1.5;
                } else if (onFloor) {
                    buildPreview.position.y = floorHeight + 1.5;
                } else {
                    buildPreview.position.y = 1.5;
                }
            } else if (buildMode === 'wall' || buildMode === 'window_wall' ||
                       buildMode === 'stone_wall' || buildMode === 'metal_wall' ||
                       buildMode === 'stone_window_wall' || buildMode === 'metal_window_wall') {
                // Walls and window walls (all tiers) sit on floor OR on ceiling (for multi-story)
                if (bestSnap && bestSnap.isStackSnap) {
                    buildPreview.position.y = bestSnap.y; // stacking snap already computed the correct Y
                } else if (onCeiling) {
                    buildPreview.position.y = ceilingHeight + 1.5;
                } else if (onFloor) {
                    buildPreview.position.y = floorHeight + 1.5;
                } else {
                    buildPreview.position.y = 1.5;
                }
            } else if (buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') {
                // Stairs should sit ON TOP of floors/ceilings, not inside them
                // Bottom of stairs should be at the floor surface
                if (onCeiling) {
                    // Sitting on ceiling - bottom of stairs at ceiling top
                    buildPreview.position.y = ceilingHeight + 0.15; // Ceiling thickness + small offset
                } else if (onFloor) {
                    // Sitting on floor - bottom of stairs at floor top
                    buildPreview.position.y = floorHeight + 0.15; // Floor thickness + small offset
                } else {
                    // Ground level - bottom at ground
                    buildPreview.position.y = 0.15;
                }
            } else if (buildMode === 'ladder') {
                // Ladders snap to walls and can stack vertically
                let closestWall = null;
                let minDist = Infinity;
                
                // Find closest wall at any height
                for (let building of buildings) {
                    if (building.userData.buildingType === 'wall' || 
                        building.userData.buildingType === 'window_wall' ||
                        building.userData.isDoorFrame) {
                        const dist = Math.sqrt(
                            Math.pow(targetPos.x - building.position.x, 2) + 
                            Math.pow(targetPos.z - building.position.z, 2)
                        );
                        // Check if wall is at a relevant height (within 10 units of target)
                        const heightDiff = Math.abs(targetPos.y - building.position.y);
                        if (dist < minDist && dist < 5 && heightDiff < 10) {
                            minDist = dist;
                            closestWall = building;
                        }
                    }
                }
                
                if (closestWall) {
                    // Snap to wall position and rotation
                    buildPreview.rotation.y = closestWall.rotation.y;
                    
                    // Position ladder flush against wall (0.3 units offset from wall center)
                    const wallAngle = closestWall.rotation.y;
                    const offsetX = Math.sin(wallAngle) * 0.3;
                    const offsetZ = Math.cos(wallAngle) * 0.3;
                    
                    buildPreview.position.x = closestWall.position.x + offsetX;
                    buildPreview.position.z = closestWall.position.z + offsetZ;
                    
                    // Check for existing ladders at this wall position to allow stacking
                    // Find the highest ladder that's below our target position
                    let stackOnLadder = null;
                    let highestLadderBelow = -Infinity;
                    
                    for (let building of buildings) {
                        if (building.userData.isLadder) {
                            const distToLadder = Math.sqrt(
                                Math.pow(buildPreview.position.x - building.position.x, 2) + 
                                Math.pow(buildPreview.position.z - building.position.z, 2)
                            );
                            // Check if this ladder is at the same wall position
                            if (distToLadder < 0.5) {
                                const ladderTop = building.position.y + 1.5; // Top of this ladder
                                // If this ladder is below where we're trying to place and is the highest so far
                                if (ladderTop <= targetPos.y && ladderTop > highestLadderBelow) {
                                    highestLadderBelow = ladderTop;
                                    stackOnLadder = building;
                                }
                            }
                        }
                    }
                    
                    // Determine placement height
                    if (stackOnLadder) {
                        // Stack directly on top of existing ladder
                        buildPreview.position.y = stackOnLadder.position.y + 3; // 3 units is ladder height
                    } else if (onCeiling && !onFloor && Math.abs(targetPos.y - ceilingHeight) < 2) {
                        // Place on ceiling if looking near a ceiling
                        buildPreview.position.y = ceilingHeight;
                    } else if (onFloor) {
                        buildPreview.position.y = floorHeight;
                    } else {
                        buildPreview.position.y = 0;
                    }
                } else {
                    // No wall nearby, place on floor/ground like normal object
                    if (onCeiling) {
                        buildPreview.position.y = ceilingHeight;
                    } else if (onFloor) {
                        buildPreview.position.y = floorHeight;
                    } else {
                        buildPreview.position.y = 0;
                    }
                }
            } else if (buildMode === 'curtain_red' || buildMode === 'curtain_blue' || buildMode === 'curtain_green' || buildMode === 'curtain_white' || buildMode === 'curtain_beige') {
                // Curtains snap to window walls - placed on inside wall facing player
                let closestWindow = null;
                let minDist = Infinity;
                
                // Find closest window wall
                for (let building of buildings) {
                    if (building.userData.buildingType === 'window_wall') {
                        const dist = Math.sqrt(
                            Math.pow(targetPos.x - building.position.x, 2) + 
                            Math.pow(targetPos.z - building.position.z, 2)
                        );
                        if (dist < minDist && dist < 5) {
                            minDist = dist;
                            closestWindow = building;
                        }
                    }
                }
                
                if (closestWindow) {
                    // Get wall rotation
                    const wallAngle = closestWindow.rotation.y;
                    
                    // Determine which side of the wall the player is on
                    const wallX = closestWindow.position.x;
                    const wallZ = closestWindow.position.z;
                    const playerX = camera.position.x;
                    const playerZ = camera.position.z;
                    
                    // Calculate vector from wall to player
                    const toPlayerX = playerX - wallX;
                    const toPlayerZ = playerZ - wallZ;
                    
                    // Wall normal direction
                    const wallNormalX = Math.sin(wallAngle);
                    const wallNormalZ = Math.cos(wallAngle);
                    
                    // Dot product to determine which side player is on
                    const dotProduct = toPlayerX * wallNormalX + toPlayerZ * wallNormalZ;
                    
                    // Place curtain on the side facing the player (inside)
                    // Offset by -0.2 units on the side facing player
                    const offsetMultiplier = dotProduct > 0 ? -0.2 : 0.2;
                    const offsetX = Math.sin(wallAngle) * offsetMultiplier;
                    const offsetZ = Math.cos(wallAngle) * offsetMultiplier;
                    
                    buildPreview.position.x = closestWindow.position.x + offsetX;
                    buildPreview.position.z = closestWindow.position.z + offsetZ;
                    buildPreview.position.y = closestWindow.position.y;
                    
                    // Rotate to face same direction as wall
                    buildPreview.rotation.y = closestWindow.rotation.y;
                } else {
                    // No window nearby, place like normal object
                    if (onCeiling) {
                        buildPreview.position.y = ceilingHeight;
                    } else if (onFloor) {
                        buildPreview.position.y = floorHeight;
                    } else {
                        buildPreview.position.y = 0;
                    }
                }
            } else if (buildMode === 'floor_rug_red' || buildMode === 'floor_rug_blue' || buildMode === 'floor_rug_green') {
                // Floor rugs sit flat on floors or ground
                if (onFloor) {
                    buildPreview.position.y = floorHeight + 0.01; // Slightly above floor to prevent z-fighting
                } else {
                    buildPreview.position.y = 0.01; // Ground level
                }
            } else if (buildMode === 'wall_shelf') {
                // Wall shelf: raycast against wall faces for precise flush placement
                const _wsRay = _buildRaycaster;
                _wsRay.setFromCamera(_buildCenter, camera);
                const _wsWalls = buildings.filter(b => {
                    const bt = b.userData.buildingType;
                    return bt === 'wall' || bt === 'window_wall';
                });
                const _wsHits = _wsRay.intersectObjects(_wsWalls, true);
                let _wsSnapped = false;
                if (_wsHits.length > 0 && _wsHits[0].distance < 10) {
                    const hit = _wsHits[0];
                    const normal = hit.face ? hit.face.normal.clone() : new THREE.Vector3(0, 0, 1);
                    const normalMatrix = new THREE.Matrix3().getNormalMatrix(hit.object.matrixWorld);
                    normal.applyMatrix3(normalMatrix).normalize();
                    if (Math.abs(normal.y) < 0.5) {
                        // Offset along the face normal so the shelf back sits on the wall surface
                        const shelfDepth = 0.22;
                        buildPreview.position.copy(hit.point).addScaledVector(normal, shelfDepth);
                        const wallParent = hit.object.parent || hit.object;
                        buildPreview.position.y = Math.max(0.4, Math.min(hit.point.y, wallParent.position.y + 2.5));
                        buildPreview.rotation.y = Math.atan2(normal.x, normal.z);
                        _wsSnapped = true;
                    }
                }
                if (!_wsSnapped) {
                    // Fallback: nearest wall, offset to face surface
                    let closestWall = null, minWallDist = Infinity;
                    for (const building of buildings) {
                        const bt = building.userData.buildingType;
                        if (bt === 'wall' || bt === 'window_wall') {
                            const dx = targetPos.x - building.position.x;
                            const dz = targetPos.z - building.position.z;
                            const dist = Math.sqrt(dx*dx + dz*dz);
                            if (dist < minWallDist && dist < 5) { minWallDist = dist; closestWall = building; }
                        }
                    }
                    if (closestWall) {
                        const wallAngle = closestWall.rotation.y;
                        // wall half-thickness (~0.07) + shelf model back depth (~0.22)
                        const faceOffset = 0.29;
                        buildPreview.position.x = closestWall.position.x + Math.sin(wallAngle) * faceOffset;
                        buildPreview.position.z = closestWall.position.z + Math.cos(wallAngle) * faceOffset;
                        const shelfY = Math.max(0.5, Math.min(targetPos.y, closestWall.position.y + 2.5));
                        buildPreview.position.y = shelfY;
                        buildPreview.rotation.y = wallAngle;
                    } else {
                        if (onFloor) buildPreview.position.y = floorHeight + 1.2;
                        else buildPreview.position.y = 1.2;
                    }
                }
            } else if (buildMode === 'wall_shelf_b') {
                // Wall shelf B: same wall-snap logic as wall_shelf
                const _wsbRay = _buildRaycaster;
                _wsbRay.setFromCamera(_buildCenter, camera);
                const _wsbWalls = buildings.filter(b => {
                    const bt = b.userData.buildingType;
                    return bt === 'wall' || bt === 'window_wall';
                });
                const _wsbHits = _wsbRay.intersectObjects(_wsbWalls, true);
                let _wsbSnapped = false;
                if (_wsbHits.length > 0 && _wsbHits[0].distance < 10) {
                    const hit = _wsbHits[0];
                    const normal = hit.face ? hit.face.normal.clone() : new THREE.Vector3(0, 0, 1);
                    const normalMatrix = new THREE.Matrix3().getNormalMatrix(hit.object.matrixWorld);
                    normal.applyMatrix3(normalMatrix).normalize();
                    if (Math.abs(normal.y) < 0.5) {
                        const shelfDepth = 0.3;
                        buildPreview.position.copy(hit.point).addScaledVector(normal, shelfDepth);
                        const wallParent = hit.object.parent || hit.object;
                        buildPreview.position.y = Math.max(0.4, Math.min(hit.point.y, wallParent.position.y + 2.5));
                        buildPreview.rotation.y = Math.atan2(normal.x, normal.z);
                        _wsbSnapped = true;
                    }
                }
                if (!_wsbSnapped) {
                    // Fallback: nearest wall
                    let closestWall = null, minWallDist = Infinity;
                    for (const building of buildings) {
                        const bt = building.userData.buildingType;
                        if (bt === 'wall' || bt === 'window_wall') {
                            const dx = targetPos.x - building.position.x;
                            const dz = targetPos.z - building.position.z;
                            const dist = Math.sqrt(dx*dx + dz*dz);
                            if (dist < minWallDist && dist < 5) { minWallDist = dist; closestWall = building; }
                        }
                    }
                    if (closestWall) {
                        const wallAngle = closestWall.rotation.y;
                        const faceOffset = 0.3;
                        buildPreview.position.x = closestWall.position.x + Math.sin(wallAngle) * faceOffset;
                        buildPreview.position.z = closestWall.position.z + Math.cos(wallAngle) * faceOffset;
                        buildPreview.position.y = Math.max(0.5, Math.min(targetPos.y, closestWall.position.y + 2.5));
                        buildPreview.rotation.y = wallAngle;
                    } else {
                        if (onFloor) buildPreview.position.y = floorHeight + 1.2;
                        else buildPreview.position.y = 1.2;
                    }
                }
            } else if (buildMode === 'sewing_table' || buildMode === 'candle') {
                // Sewing table / candle clips to any surface: floor, ceiling, or wall
                const _stRay = _buildRaycaster;
                _stRay.setFromCamera(_buildCenter, camera);
                // Raycast against all buildings (floors, walls, ceilings) and ground
                const _stTargets = [...buildings];
                const _stHits = _stRay.intersectObjects(_stTargets, true);
                if (_stHits.length > 0 && _stHits[0].distance < 12) {
                    const hit = _stHits[0];
                    const normal = hit.face ? hit.face.normal.clone() : new THREE.Vector3(0,1,0);
                    // Transform normal to world space
                    const normalMatrix = new THREE.Matrix3().getNormalMatrix(hit.object.matrixWorld);
                    normal.applyMatrix3(normalMatrix).normalize();
                    // Place on hit point, offset slightly along normal so it sits flush
                    buildPreview.position.copy(hit.point).addScaledVector(normal, 0.05);
                    // Rotate to face along wall/surface normal (yaw only for vertical surfaces)
                    if (Math.abs(normal.y) < 0.5) {
                        // Wall or ceiling-like surface — align rotation to face outward
                        buildPreview.rotation.y = Math.atan2(normal.x, normal.z);
                    }
                    // For floor/ceiling surfaces keep existing buildRotation
                } else if (onCeiling) {
                    buildPreview.position.y = ceilingHeight;
                } else if (onFloor) {
                    buildPreview.position.y = floorHeight;
                } else {
                    buildPreview.position.y = 0;
                }
            } else {
                // Other objects sit on floor/ceiling/ground — storage boxes also snap to shelves
                if (buildMode === 'storage_box' || buildMode === 'small_storage_box') {
                    const boxFootprint = buildMode === 'storage_box' ? 1.2 : 0.6;
                    const shelfLevels  = [0.725, 1.425];
                    let bestShelfSnap = null;
                    let bestShelfDist = Infinity;
                    for (const building of buildings) {
                        if (!building.userData.isShelf) continue;
                        const dx = targetPos.x - building.position.x;
                        const dz = targetPos.z - building.position.z;
                        const horizDist = Math.sqrt(dx*dx + dz*dz);
                        if (horizDist > 2.0) continue;
                        const shelfRot = building.rotation.y;
                        const localX = dx * Math.cos(-shelfRot) - dz * Math.sin(-shelfRot);
                        const localZ = dx * Math.sin(-shelfRot) + dz * Math.cos(-shelfRot);
                        const halfShelf = 0.8 - boxFootprint / 2;
                        const clampedX = Math.max(-halfShelf, Math.min(halfShelf, localX));
                        const clampedZ = Math.max(-halfShelf, Math.min(halfShelf, localZ));
                        let bestLevel = shelfLevels[0]; let bestLevelDiff = Infinity;
                        for (const lvl of shelfLevels) {
                            const diff = Math.abs(targetPos.y - (building.position.y + lvl));
                            if (diff < bestLevelDiff) { bestLevelDiff = diff; bestLevel = lvl; }
                        }
                        const wx = building.position.x + clampedX * Math.cos(shelfRot) - clampedZ * Math.sin(shelfRot);
                        const wz = building.position.z + clampedX * Math.sin(shelfRot) + clampedZ * Math.cos(shelfRot);
                        if (horizDist < bestShelfDist) {
                            bestShelfDist = horizDist;
                            bestShelfSnap = { x: wx, y: building.position.y + bestLevel, z: wz };
                        }
                    }
                    if (bestShelfSnap) {
                        buildPreview.position.set(bestShelfSnap.x, bestShelfSnap.y, bestShelfSnap.z);
                    } else if (onCeiling) {
                        buildPreview.position.y = ceilingHeight;
                    } else if (onFloor) {
                        buildPreview.position.y = floorHeight;
                    } else {
                        buildPreview.position.y = 0;
                    }
                } else if (onCeiling) {
                    buildPreview.position.y = ceilingHeight;
                } else if (onFloor) {
                    buildPreview.position.y = floorHeight;
                } else {
                    buildPreview.position.y = 0;
                }
            }
            
            // Apply rotation
            buildPreview.rotation.y = buildRotation;
            
            // Update preview color based on validity
            const canPlace = !checkBuildingCollision(buildPreview);
            const previewColor = canPlace ? 0x00ff00 : 0xff0000;
            const emissiveColor = new THREE.Color(previewColor);
            
            buildPreview.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material.color.setHex(previewColor);
                    if (child.material.emissive) {
                        child.material.emissive.copy(emissiveColor);
                    }
                    // STAIRS: Force visibility
                    child.visible = true;
                    if (buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') {
                        child.material.transparent = true;
                        child.material.opacity = 0.8;
                        child.material.needsUpdate = true;
                    }
                }
            });
            
            // Ensure the whole preview is visible
            buildPreview.visible = true;
            
            // STAIRS: Extra visibility enforcement
            if (buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') {
                buildPreview.renderOrder = 1000;
                buildPreview.frustumCulled = false;
            }
        }
        
        function checkBuildingCollision(testBuilding) {
            // ── Type helpers ──────────────────────────────────────────────
            const _isWall = t => t === 'wall' || t === 'stone_wall' || t === 'metal_wall' ||
                                  t === 'window_wall' || t === 'stone_window_wall' || t === 'metal_window_wall';
            const _isFrame = t => t === 'door_frame' || t === 'stone_door_frame' || t === 'metal_door_frame' ||
                                   t === 'double_door_frame' || t === 'stone_double_door_frame' || t === 'metal_double_door_frame';
            const _isWallOrFrame = t => _isWall(t) || _isFrame(t);
            const _isCeiling = t => t === 'ceiling' || t === 'stone_ceiling' || t === 'metal_ceiling' || t === 'ladder_ceiling';
            const _isFloor = t => t === 'floor' || t === 'stone_floor' || t === 'metal_floor';
            const _isFloorOrCeiling = t => _isFloor(t) || _isCeiling(t);
            const _isDoor = t => t === 'door' || t === 'double_door' ||
                                  t === 'stone_door' || t === 'stone_double_door' ||
                                  t === 'metal_door' || t === 'metal_double_door';

            const bm = buildMode;

            // ── Never-collide modes ───────────────────────────────────────
            if (bm === 'stairs' || bm === 'corner_stairs_left' || bm === 'corner_stairs_right') return false;
            if (bm === 'floor_rug_red' || bm === 'floor_rug_blue' || bm === 'floor_rug_green') return false;
            if (bm === 'sewing_table' || bm === 'wall_shelf' || bm === 'wall_shelf_b' || bm === 'candle' || bm === 'wall_light') return false;

            // ── Curtains: only block other curtains ───────────────────────
            if (bm.startsWith('curtain_')) {
                for (const b of buildings) {
                    if (b.userData.buildingType && b.userData.buildingType.startsWith('curtain_')) {
                        const d2 = Math.pow(testBuilding.position.x - b.position.x, 2) +
                                   Math.pow(testBuilding.position.z - b.position.z, 2);
                        if (d2 < 1.0) return true;
                    }
                }
                return false;
            }

            // ── Ceilings: only block exact-overlap with other ceilings ────
            if (_isCeiling(bm)) {
                for (const b of buildings) {
                    if (_isCeiling(b.userData.buildingType)) {
                        const heightDiff = Math.abs(testBuilding.position.y - b.position.y);
                        const horizDist  = Math.sqrt(Math.pow(testBuilding.position.x - b.position.x, 2) +
                                                     Math.pow(testBuilding.position.z - b.position.z, 2));
                        if (heightDiff < 0.5 && horizDist < 1.0) return true;
                    }
                }
                return false;
            }

            // ── Doors: only block other placed doors ──────────────────────
            // Doors snap into frames; frames, walls, floors etc. must never block them
            if (_isDoor(bm)) {
                const testBox = new THREE.Box3().setFromObject(testBuilding);
                for (const b of buildings) {
                    if (!_isDoor(b.userData.buildingType)) continue;
                    const bBox = new THREE.Box3().setFromObject(b);
                    if (testBox.intersectsBox(bBox)) return true;
                }
                return false;
            }

            // ── All other building pieces ─────────────────────────────────
            // Building parts never block other building parts.
            return false;
        }
        
        async function placeBuilding() {
            if (!buildMode) return;
            
            // Check distance from player (max 8 meters)
            const distanceToBuilding = camera.position.distanceTo(buildPreview.position);
            if (distanceToBuilding > 8) {
                showMessage('\u26a0\ufe0f Too far away! Must be within 8 meters.');
                return;
            }
            
            // Check if we have the item
            if (!inventory[buildMode] || inventory[buildMode] <= 0) {
                showMessage('\u274c You don\'t have this item!');
                cancelBuilding();
                return;
            }
            
            // Check for collision
            if (checkBuildingCollision(buildPreview)) {
                showMessage('\u274c Cannot place here - collision detected!');
                return;
            }
            
            // Consume one item from inventory
            inventory[buildMode]--;
            
            const building = await buildAndPlaceModel(buildMode);
            building.position.copy(buildPreview.position);
            building.rotation.copy(buildPreview.rotation);
            building.userData.type = 'building';
            building.userData.buildingType = buildMode;
            
            // Set specific userData flags based on building type
            if (buildMode === 'campfire') {
                building.userData.isCampfire = true;
            } else if (buildMode === 'furnace') {
                building.userData.isFurnace = true;
            } else if (buildMode === 'cooking_station') {
                building.userData.isCookingStation = true;
            } else if (buildMode === 'workbench') {
                building.userData.isWorkbench = true;
            } else if (buildMode === 'building_bench') {
                building.userData.isBuildingBench = true;
            } else if (buildMode === 'sewing_table') {
                building.userData.isSewingTable = true;
            } else if (buildMode === 'recycler') {
                building.userData.isRecycler = true;
            } else if (buildMode === 'water_catcher') {
                building.userData.isWaterCatcher = true;
            } else if (buildMode === 'storage_box') {
                building.userData.isStorageBox = true;
            } else if (buildMode === 'small_storage_box') {
                building.userData.isStorageBox = true;
                building.userData.isSmallStorage = true;
                if (!building.userData.storageInventory) {
                    building.userData.storageInventory = new Array(14).fill(null);
                }
            } else if (buildMode === 'ladder') {
                building.userData.isLadder = true;
            } else if (buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') {
                building.userData.isStairs = true;
                if (buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') {
                    building.userData.isCornerStairs = true;
                }
            } else if (buildMode === 'ladder_ceiling') {
                building.userData.isLadderCeiling = true;
            } else if (buildMode === 'door' || buildMode === 'stone_door' || buildMode === 'metal_door') {
                building.userData.isDoor = true;
                building.userData.isOpen = false;
                building.userData.initialRotation = buildPreview.rotation.y;
                if (!building.userData.doorType) building.userData.doorType = 'single';
            } else if (buildMode === 'double_door' || buildMode === 'stone_double_door' || buildMode === 'metal_double_door') {
                building.userData.isDoor = true;
                building.userData.isOpen = false;
                building.userData.doorType = 'double';
            } else if (buildMode === 'door_frame' || buildMode === 'double_door_frame') {
                building.userData.isDoorFrame = true;
            } else if (buildMode === 'sleeping_bag') {
                building.userData.isSleepingBag = true;
            } else if (buildMode === 'storage_shelf') {
                building.userData.isShelf = true;
            } else if (buildMode === 'wall_shelf') {
                building.userData.isWallShelf = true;
            } else if (buildMode === 'planter_box') {
                building.userData.isPlanterBox = true;
                building.userData.seeds = [null, null, null, null];
                const _pxArr = [-0.75,-0.25,0.25,0.75];
                building.userData.slotPositions = _pxArr;
                building.userData.slotZPositions = [0,0,0,0];
                building.userData.slotDefs = _pxArr.map(x=>({x,z:0}));
                building.userData.wateredThisRain = false;
                building.traverse(child => { if (child.name === 'plantContainer') building.userData.plantContainer = child; });
            } else if (buildMode === 'large_planter') {
                building.userData.isPlanterBox = true;
                const _lpX = [-0.82,-0.27,0.27,0.82], _lpZ = [-0.42,0,0.42];
                const _lpDefs = [];
                for (let r=0;r<3;r++) for (let c=0;c<4;c++) _lpDefs.push({x:_lpX[c],z:_lpZ[r]});
                building.userData.slotDefs = _lpDefs;
                building.userData.slotPositions = _lpDefs.map(d=>d.x);
                building.userData.slotZPositions = _lpDefs.map(d=>d.z);
                building.userData.seeds = new Array(12).fill(null);
                building.userData.wateredThisRain = false;
                building.traverse(child => { if (child.name === 'plantContainer') building.userData.plantContainer = child; });
            } else if (buildMode === 'floor_rug_red' || buildMode === 'floor_rug_blue' || buildMode === 'floor_rug_green') {
                building.userData.isRug = true;
            } else if (buildMode === 'curtain_red' || buildMode === 'curtain_blue' || buildMode === 'curtain_green' || 
                       buildMode === 'curtain_white' || buildMode === 'curtain_beige') {
                building.userData.isCurtain = true;
            } else if (buildMode === 'sofa' || buildMode === 'bookcase' || buildMode === 'table' || buildMode === 'chair') {
                building.userData.isFurniture = true;
            } else if (buildMode === 'wall_shelf_b') {
                building.userData.isWallShelf = true;
            } else if (buildMode === 'candle') {
                building.userData.isCandle = true;
            } else if (buildMode === 'wall_light') {
                building.userData.isWallLight = true;
            } else if (buildMode === 'bee_hive') {
                building.userData.isBeeHive = true;
                building.userData.beeHiveData = { honey: 0, lastCollect: Date.now(), isReady: false };
            } else if (buildMode === 'chicken_coop') {
                building.userData.isChickenCoop = true;
                building.userData.chickenCoopData = { eggs: 0, lastCollect: Date.now(), isReady: false };
            } else if (buildMode === 'oil_smelter') {
                building.userData.isOilSmelter = true;
                building.userData.oilSmelterData = { active: false, fuel: 0, output: 0 };
            }
            
            // Add collision box
            building.userData.collisionBox = new THREE.Box3().setFromObject(building);

            // Attach dynamic fire light to heat-source buildings
            _attachFireLight(building);
            
            buildings.push(building);
            scene.add(building);
            
            playCollectSound();
            showMessage(`Built ${buildingTypes[buildMode].name}!`);
            
            scene.remove(buildPreview);
            buildPreview = null;
            buildMode = null;
            buildRotation = 0;
            document.getElementById('build-info').style.display = 'none';
            updateUI();
        }
        
        function cancelBuilding() {
            if (buildPreview) {
                scene.remove(buildPreview);
                buildPreview = null;
            }
            buildMode = null;
            document.getElementById('build-info').style.display = 'none';
        }
        
        // ===== CONTROLS =====
        const keys = {};
        const mouse = { x: 0, y: 0, locked: false };

        // ── Mobile Touch Controls ─────────────────────────────────────────────
        let mobileControlsEnabled = false;

        function setMobileControls(enabled) {
            mobileControlsEnabled = enabled;
            const overlay = document.getElementById('mobile-controls');
            const fab     = document.getElementById('mobile-toggle-fab');
            const pauseBtn = document.getElementById('mobile-controls-toggle-btn');
            overlay.style.display = enabled ? 'block' : 'none';
            fab.style.display = 'block'; // always show FAB once initialised
            if (pauseBtn) pauseBtn.textContent = '📱 Mobile Controls: ' + (enabled ? 'ON' : 'OFF');
        }

        // FAB (always-on-screen toggle)
        document.getElementById('mobile-toggle-fab').addEventListener('click', () => {
            setMobileControls(!mobileControlsEnabled);
        });

        // Pause menu button
        document.getElementById('mobile-controls-toggle-btn').addEventListener('click', () => {
            setMobileControls(!mobileControlsEnabled);
        });

        // ── Joystick ──────────────────────────────────────────────────────────
        const joyZone  = document.getElementById('joy-zone');
        const joyThumb = document.getElementById('joy-thumb');
        const JOY_RADIUS = 50; // max thumb travel
        let joyActive = false, joyId = null, joyOriginX = 0, joyOriginY = 0;

        function joyMove(cx, cy) {
            const rect = joyZone.getBoundingClientRect();
            const ox = rect.left + rect.width  / 2;
            const oy = rect.top  + rect.height / 2;
            let dx = cx - ox, dy = cy - oy;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > JOY_RADIUS) { dx *= JOY_RADIUS/dist; dy *= JOY_RADIUS/dist; }
            const nx = dx / JOY_RADIUS, ny = dy / JOY_RADIUS;
            joyThumb.style.left = (50 + dx) + 'px';
            joyThumb.style.top  = (50 + dy) + 'px';
            keys['w'] = ny < -0.3;
            keys['s'] = ny >  0.3;
            keys['a'] = nx < -0.3;
            keys['d'] = nx >  0.3;
        }

        function joyReset() {
            joyThumb.style.left = '50px';
            joyThumb.style.top  = '50px';
            keys['w'] = false; keys['s'] = false;
            keys['a'] = false; keys['d'] = false;
        }

        joyZone.addEventListener('touchstart', e => {
            if (!mobileControlsEnabled) return;
            e.preventDefault();
            const t = e.changedTouches[0];
            joyId = t.identifier; joyActive = true;
            joyMove(t.clientX, t.clientY);
        }, { passive: false });

        joyZone.addEventListener('touchmove', e => {
            if (!mobileControlsEnabled) return;
            e.preventDefault();
            for (const t of e.changedTouches) {
                if (t.identifier === joyId) joyMove(t.clientX, t.clientY);
            }
        }, { passive: false });

        joyZone.addEventListener('touchend', e => {
            e.preventDefault();
            joyActive = false; joyId = null; joyReset();
        }, { passive: false });

        // ── Look zone (right-side swipe = camera rotation) ────────────────────
        const lookZone = document.getElementById('look-zone');
        let lookId = null, lookLastX = 0, lookLastY = 0;
        const LOOK_SENSITIVITY = 0.005;

        lookZone.addEventListener('touchstart', e => {
            if (!mobileControlsEnabled) return;
            e.preventDefault();
            const t = e.changedTouches[0];
            lookId = t.identifier;
            lookLastX = t.clientX; lookLastY = t.clientY;
        }, { passive: false });

        lookZone.addEventListener('touchmove', e => {
            if (!mobileControlsEnabled) return;
            e.preventDefault();
            for (const t of e.changedTouches) {
                if (t.identifier !== lookId) continue;
                const dx = t.clientX - lookLastX;
                const dy = t.clientY - lookLastY;
                lookLastX = t.clientX; lookLastY = t.clientY;
                if (isThirdPerson) {
                    tp_orbitYaw   -= dx * LOOK_SENSITIVITY * 2;
                    tp_orbitPitch -= dy * LOOK_SENSITIVITY * 2;
                    tp_orbitPitch  = Math.max(-0.4, Math.min(0.8, tp_orbitPitch));
                } else {
                    camera.rotation.y -= dx * LOOK_SENSITIVITY;
                    camera.rotation.x -= dy * LOOK_SENSITIVITY;
                    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                    camera.rotation.z = 0;
                    camera.rotation.order = 'YXZ';
                }
            }
        }, { passive: false });

        lookZone.addEventListener('touchend', e => {
            for (const t of e.changedTouches) {
                if (t.identifier === lookId) lookId = null;
            }
        }, { passive: false });

        // ── Action buttons ────────────────────────────────────────────────────
        function btnPress(el, onDown, onUp) {
            el.addEventListener('touchstart', e => {
                if (!mobileControlsEnabled) return;
                e.preventDefault(); el.style.opacity = '0.6'; onDown();
            }, { passive: false });
            el.addEventListener('touchend', e => {
                e.preventDefault(); el.style.opacity = '1'; if (onUp) onUp();
            }, { passive: false });
        }

        // Jump
        btnPress(document.getElementById('btn-jump'), () => {
            if (!isJumping && !isDead && !onLadder) {
                isJumping = true;
                jumpVelocity = jumpStrength;
            }
        });

        // Attack — simulate left mousedown/mouseup on canvas
        btnPress(document.getElementById('btn-attack'), () => {
            renderer.domElement.dispatchEvent(new MouseEvent('mousedown', { bubbles: true, button: 0 }));
        }, () => {
            renderer.domElement.dispatchEvent(new MouseEvent('mouseup', { bubbles: true, button: 0 }));
        });

        // Inventory
        btnPress(document.getElementById('btn-inventory'), () => {
            const inv = document.getElementById('inventory-panel');
            if (inv.style.display === 'block') {
                inv.style.display = 'none';
            } else {
                inv.style.display = 'block';
            }
        });

        // Interact (E key)
        btnPress(document.getElementById('btn-interact'), () => {
            keys['e'] = true;
        }, () => {
            keys['e'] = false;
        });

        // Sprint toggle
        let mobileSprinting = false;
        const btnSprint = document.getElementById('btn-sprint');
        btnSprint.addEventListener('click', () => {
            if (!mobileControlsEnabled) return;
            mobileSprinting = !mobileSprinting;
            keys['shift'] = mobileSprinting;
            btnSprint.style.background = mobileSprinting
                ? 'rgba(255,165,0,0.6)' : 'rgba(255,165,0,0.25)';
            btnSprint.textContent = mobileSprinting ? '🏃 ON' : '🏃 RUN';
        });
        // ── End Mobile Touch Controls ─────────────────────────────────────────
        const moveSpeed = 0.045; // Reduced to 30% of original
        const sprintSpeed = 0.1313; // 30% faster than previous sprint (was 0.101)
        const sensitivity = 0.002;
        let isJumping = false;
        let onLadder = false; // Track if player is currently on a ladder
        let jumpVelocity = 0;
        const jumpStrength = 0.1875; // Quarter of original jump height
        const gravity = 0.015;
        let playerY = 1.7; // Player eye height from ground
        let stamina = 100;
        const maxStamina = 100;
        // Time-based rates (per second) — independent of frame rate
        const staminaDrainPerSec = 10;       // empties in ~10s of continuous sprinting
        const staminaRegenPerSec = 7;        // refills in ~14s while walking
        const staminaRegenFastPerSec = 20;   // refills in ~5s while standing still
        let staminaExhausted = false;        // true once stamina hits 0, clears after 5s
        const exhaustedDuration = 5.0;       // seconds player cannot sprint after hitting 0
        let staminaExhaustedAt = 0;          // performance.now() timestamp when exhaustion started
        const exhaustedSpeed = 0.018;        // very slow crawl when exhausted
        let _staminaLastTime = 0;            // timestamp for delta-time stamina math
        let staminaDepletedTime = 0;
        const staminaRegenDelay = 0;

        // ── BUFF SYSTEM ─────────────────────────────────────────────────
        // Each buff: { endTime: ms timestamp }
        const activeBuffs = {
            veggi_stew:    null,  // stamina drain -80%
            meat_stew:     null,  // +30% max health
            hearty:        null,  // double gathering resources
            well_fed:      null,  // hunger drains 40% slower
            hydrated:      null,  // thirst drains 35% slower
            warmth:        null,  // cold temp effect slowed 60%
            sugar_rush:    null,  // +15% move speed, short duration
            fortified_gut: null,  // hunger & thirst paused 2 mins
        };
        const BUFF_DURATION = 600000; // 10 real-time minutes in ms

        const BUFF_DURATIONS = {
            veggi_stew:    600000,  // 10 min
            meat_stew:     600000,  // 10 min
            hearty:        600000,  // 10 min
            well_fed:      180000,  // 3 min
            hydrated:      240000,  // 4 min
            warmth:        300000,  // 5 min
            sugar_rush:     90000,  // 90 sec
            fortified_gut: 120000,  // 2 min
        };
        function applyBuff(id) {
            const dur = BUFF_DURATIONS[id] || BUFF_DURATION;
            activeBuffs[id] = { endTime: Date.now() + dur };
            updateBuffHUD();
        }

        function tickBuffs() {
            const now = Date.now();
            let changed = false;
            for (const id in activeBuffs) {
                if (activeBuffs[id] && now >= activeBuffs[id].endTime) {
                    activeBuffs[id] = null;
                    changed = true;
                    if (id === 'meat_stew') {
                        // Clamp health back to 100 if it was inflated
                        health = Math.min(100, health);
                        updateUI();
                    }
                    const _buffNames = {
                        veggi_stew: 'Stamina Saver', meat_stew: 'Fortified', hearty: 'Double Gathering',
                        well_fed: 'Well Fed', hydrated: 'Hydrated', warmth: 'Warmth', cold_resist: 'Warmth',
                        sugar_rush: 'Sugar Rush', fortified_gut: 'Fortified Gut'
                    };
                    showMessage(`⏱ ${_buffNames[id] || id} buff has worn off.`);
                }
            }
            if (changed) updateBuffHUD();
        }

        function updateBuffHUD() {
            const hud = document.getElementById('buff-hud');
            if (!hud) return;
            hud.innerHTML = '';
            const now = Date.now();
            const defs = {
                veggi_stew:    { icon: '🥬', label: 'Stamina Saver (-80% drain)' },
                meat_stew:     { icon: '❤️', label: 'Fortified (+30% max health)' },
                hearty:        { icon: '⚒️', label: 'Double Gathering' },
                well_fed:      { icon: '🍰', label: 'Well Fed (hunger -40% drain)' },
                hydrated:      { icon: '💧', label: 'Hydrated (thirst -35% drain)' },
                warmth:        { icon: '🔥', label: 'Warmth (cold resist +60%)' },
                sugar_rush:    { icon: '⚡', label: 'Sugar Rush (+15% speed)' },
                fortified_gut: { icon: '🛡️', label: 'Fortified Gut (hunger/thirst paused)' },
            };
            for (const [id, buff] of Object.entries(activeBuffs)) {
                if (!buff) continue;
                const secsLeft = Math.max(0, Math.ceil((buff.endTime - now) / 1000));
                const mins = Math.floor(secsLeft / 60);
                const secs = secsLeft % 60;
                const timeStr = mins > 0 ? `${mins}m ${secs}s` : `${secs}s`;
                const el = document.createElement('div');
                el.className = 'buff-indicator';
                el.innerHTML = `${defs[id].icon} ${defs[id].label} <span class="buff-indicator-timer">${timeStr}</span>`;
                hud.appendChild(el);
            }
        }
        
        // ═══════════════════════════════════════════════════════════

        document.addEventListener('keydown', async (e) => {
            keys[e.key.toLowerCase()] = true;
            
            if (e.key === ' ' && !isDead && !fishingState.active) {
                if (!isJumping && !onLadder) { isJumping = true; jumpVelocity = jumpStrength; }
            }
            
            if (e.key === 'Escape') {
                e.preventDefault();
                
                // Check if any menus are open first
                const craftingOpen = document.getElementById('crafting-menu').style.display === 'block';
                const workbenchOpen = document.getElementById('workbench-menu').style.display === 'block';
                const furnaceOpen = document.getElementById('furnace-menu').style.display === 'block';
                const campfireOpen = document.getElementById('campfire-menu').style.display === 'block';
                const recyclerOpen = document.getElementById('recycler-menu').style.display === 'block';
                const waterCatcherOpen = document.getElementById('water-catcher-menu').style.display === 'block';
                const cookingStationOpen = document.getElementById('cooking-station-menu').style.display === 'block';
                const inventoryOpen = document.getElementById('inventory-panel').style.display === 'block';
                const storageOpen = document.getElementById('storage-panel').style.display === 'block';
                const planterOpen = document.getElementById('planter-panel').style.display === 'block';
                const backpackOpen = document.getElementById('backpack-panel').style.display === 'block';
                const adminOpen = document.getElementById('admin-menu').style.display === 'block';
                
                // Check if save/load modal is open and close it
                const saveModalOpen = document.getElementById('save-slot-modal').classList.contains('open');
                if (saveModalOpen) {
                    closeSaveSlotModal();
                    return;
                }

                // Close everything and re-lock pointer — works for any open menu
                const anyOpen = craftingOpen || workbenchOpen || furnaceOpen || campfireOpen ||
                    recyclerOpen || waterCatcherOpen || cookingStationOpen || inventoryOpen ||
                    storageOpen || planterOpen || backpackOpen || adminOpen || buildMode;
                if (anyOpen) {
                    closeAllUI();
                } else {
                    // No menus open, toggle pause menu
                    togglePause();
                }
            } else if (e.key === 'p' || e.key === 'P') {
                // Toggle third-person camera
                toggleThirdPerson();
            } else if (e.key === '`' || e.key === '~') {
                // Toggle admin menu
                if (document.getElementById('admin-menu').style.display === 'block') {
                    closeAdminMenu();
                } else {
                    openAdminMenu();
                }
            } else if (e.key === 'Tab') {
                e.preventDefault();
                toggleInventory();
            } else if (e.key === 'c' || e.key === 'C') {
                toggleCraftingMenu();
            } else if (e.key === 'f' || e.key === 'F') {
                toggleFlashlight();
            } else if (e.key === 'r' || e.key === 'R') {
                // Check if holding pistol or machine gun - reload it
                const heldItem = hotbar[selectedHotbarSlot].item;
                if (heldItem === 'pistol') {
                    reloadPistol();
                } else if (heldItem === 'machine_gun') {
                    reloadMachineGun();
                } else if (buildPreview) {
                    // Rotate building preview
                    buildRotation += Math.PI / 2;
                    if (buildRotation >= Math.PI * 2) buildRotation = 0;
                    showMessage('\ud83d\udd04 Rotated building');
                }
            } else if (e.key === 'm' || e.key === 'M') {
                if (_fmOpen) { closeFullMap(); } else { openFullMap(); }
            } else if (e.key === 'g' || e.key === 'G') {
                if (buildMode) {
                    snapToGrid = !snapToGrid;
                    showMessage(snapToGrid ? '\ud83d\udd27 Snapping: ON' : '\ud83d\udd27 Snapping: OFF');
                }
            } else if (e.key === 'e' || e.key === 'E') {
                // ── FISHING: if active, handle bite/cancel and return ──
                if (fishingState.active) {
                    onFishingEPress();
                    return;
                }
                // ── FISHING: try to start fishing if rod equipped near river ──
                {
                    const held = hotbar[selectedHotbarSlot]?.item;
                    if (held === 'fishing_rod' && _isNearRiver()) {
                        startFishing();
                        _playCastSound();
                        return;
                    }
                    // Check if rod is anywhere in hotbar (not just selected slot) near river
                    if (_isNearRiver()) {
                        const rodHotbarIdx = hotbar.findIndex(s => s.item === 'fishing_rod');
                        if (rodHotbarIdx !== -1) {
                            selectedHotbarSlot = rodHotbarIdx;
                            updateHotbar();
                            updateHeldItem();
                            startFishing();
                            _playCastSound();
                            return;
                        }
                        // Rod is in inventory but not hotbar — auto-assign to first empty hotbar slot
                        if ((inventory['fishing_rod'] || 0) > 0) {
                            const emptySlot = hotbar.findIndex(s => !s.item);
                            if (emptySlot !== -1) {
                                hotbar[emptySlot].item = 'fishing_rod';
                                selectedHotbarSlot = emptySlot;
                                updateHotbar();
                                updateHeldItem();
                                startFishing();
                                _playCastSound();
                                return;
                            } else {
                                showMessage('🎣 Drag the Fishing Rod to your hotbar to fish!');
                                return;
                            }
                        }
                    }
                }
                // Try to interact with buildings (doors, crafting stations, etc.)
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);


                // Check death backpacks first (they live outside the buildings array)
                if (deathBackpacks.length > 0) {
                    const bpHits = raycaster.intersectObjects(deathBackpacks, true);
                    if (bpHits.length > 0 && bpHits[0].distance < 4) {
                        let t = bpHits[0].object;
                        while (t.parent && !t.userData.isDeathBackpack) t = t.parent;
                        if (t.userData.isDeathBackpack) { openBackpack(t); return; }
                    }
                }

                const intersects = raycaster.intersectObjects([...buildings, ...junkPiles], true);

                if (intersects.length > 0 && intersects[0].distance < 8) {
                    let target = intersects[0].object;
                    // Walk up to the root group — stop at any recognised flag OR when we reach scene level
                    while (target.parent && target.parent.type !== 'Scene' &&
                           !target.userData.buildingType && !target.userData.isDoor &&
                           !target.userData.isStorageBox && !target.userData.isWorkbench &&
                           !target.userData.isBuildingBench && !target.userData.isSewingTable &&
                           !target.userData.isRecycler && !target.userData.isWaterCatcher &&
                           !target.userData.isFurnace && !target.userData.isCampfire &&
                           !target.userData.isDoorFrame && !target.userData.isSleepingBag &&
                           !target.userData.isPlanterBox && !target.userData.isJunkPile &&
                           !target.userData.isBeeHive && !target.userData.isChickenCoop &&
                           !target.userData.isOilSmelter) {
                        target = target.parent;
                    }
                    
                    // Check for building upgrade with building hammer equipped FIRST
                    const heldItem = hotbar[selectedHotbarSlot].item;
                    if (heldItem === 'building_hammer' && target.userData.buildingType) {
                        const upgradeInfo = getUpgradeInfo(target.userData.buildingType);
                        
                        if (upgradeInfo.canUpgrade) {
                            // Check if player has resources
                            if (hasResources(upgradeInfo.cost)) {
                                // Deduct resources
                                deductResources(upgradeInfo.cost);
                                updateUI();
                                
                                // Store position, rotation, and special data
                                const pos = target.position.clone();
                                const rot = target.rotation.clone();
                                const wasOpen = target.userData.isOpen;
                                const smeltingState = target.userData.smeltingState;
                                const storageInventory = target.userData.storageInventory;
                                const hasCodeLock = target.userData.hasCodeLock;
                                const codeLock = target.userData.codeLock;

                                // Build the new model FIRST before removing the old one
                                // so if anything fails the original building is preserved
                                let newBuilding;
                                try {
                                    newBuilding = await buildAndPlaceModel(upgradeInfo.nextTier);
                                } catch(e) {
                                    console.error('Upgrade model build failed:', e);
                                    // Refund resources since upgrade failed
                                    for (const resource in upgradeInfo.cost) {
                                        inventory[resource] = (inventory[resource] || 0) + upgradeInfo.cost[resource];
                                    }
                                    updateUI();
                                    showMessage('❌ Upgrade failed - resources refunded');
                                    return;
                                }

                                // New model is ready — now safely swap out the old building
                                scene.remove(target);
                                const index = buildings.indexOf(target);
                                if (index > -1) {
                                    buildings.splice(index, 1);
                                }

                                // Reset any preview tint left on materials
                                newBuilding.traverse(child => {
                                    if (child.isMesh && child.material) {
                                        const mats = Array.isArray(child.material) ? child.material : [child.material];
                                        mats.forEach(mat => {
                                            if (mat) {
                                                mat.color.setHex(mat.userData._origColor !== undefined ? mat.userData._origColor : 0xffffff);
                                                if (mat.emissive) mat.emissive.setHex(0x000000);
                                                mat.transparent = mat.userData._origTransparent !== undefined ? mat.userData._origTransparent : false;
                                                mat.opacity = mat.userData._origOpacity !== undefined ? mat.userData._origOpacity : 1.0;
                                                mat.needsUpdate = true;
                                            }
                                        });
                                        child.visible = true;
                                    }
                                });
                                newBuilding.visible = true;
                                newBuilding.position.copy(pos);
                                newBuilding.rotation.copy(rot);
                                newBuilding.userData.type = 'building';
                                newBuilding.userData.buildingType = upgradeInfo.nextTier;
                                newBuilding.userData.collisionBox = new THREE.Box3().setFromObject(newBuilding);
                                
                                // Set specific flags based on building type
                                const buildType = upgradeInfo.nextTier;
                                if (buildType.includes('stairs')) {
                                    newBuilding.userData.isStairs = true;
                                    if (buildType.includes('corner')) {
                                        newBuilding.userData.isCornerStairs = true;
                                    }
                                } else if (buildType.includes('door_wall')) {
                                    newBuilding.userData.isDoor = true;
                                    if (buildType.includes('single')) {
                                        newBuilding.userData.doorType = 'single';
                                    } else if (buildType.includes('double')) {
                                        newBuilding.userData.doorType = 'double';
                                    }
                                } else if (buildType === 'ladder') {
                                    newBuilding.userData.isLadder = true;
                                } else if (buildType === 'ladder_ceiling') {
                                    newBuilding.userData.isLadderCeiling = true;
                                }
                                
                                // Restore special properties
                                if (wasOpen !== undefined) {
                                    newBuilding.userData.isOpen = wasOpen;
                                }
                                if (smeltingState) {
                                    Object.assign(newBuilding.userData.smeltingState, smeltingState);
                                }
                                if (storageInventory) {
                                    newBuilding.userData.storageInventory = [...storageInventory];
                                }
                                
                                // Restore code lock if door had one
                                if (hasCodeLock && codeLock) {
                                    newBuilding.userData.hasCodeLock = true;
                                    newBuilding.userData.codeLock = codeLock;
                                    createCodeLockModel(newBuilding);
                                }
                                
                                buildings.push(newBuilding);
                                scene.add(newBuilding);
                                _attachFireLight(newBuilding);
                                
                                const tierName = upgradeInfo.currentTier === 1 ? 'Stone' : 'Metal';
                                showMessage(`\u2b06\ufe0f Upgraded to ${tierName}! (Tier ${upgradeInfo.currentTier + 1}/${upgradeInfo.maxTier})`);
                                playCollectSound();
                                return;
                            } else {
                                // Show what's needed
                                let needed = [];
                                for (const resource in upgradeInfo.cost) {
                                    const has = inventory[resource] || 0;
                                    const need = upgradeInfo.cost[resource];
                                    if (has < need) {
                                        needed.push(`${need - has} ${resource}`);
                                    }
                                }
                                showMessage(`\u26a0\ufe0f Need: ${needed.join(', ')}`);
                                return;
                            }
                        } else if (upgradeInfo.maxed) {
                            showMessage('\u2b06\ufe0f Already max tier!');
                            return;
                        }
                    }
                    
                    // Open/close door (only if not upgrading)
                    if (target.userData.isDoor) {
                        // Check if player is holding a code lock to install it
                        const heldItem = hotbar[selectedHotbarSlot].item;
                        if (heldItem === 'code_lock' && inventory.code_lock > 0) {
                            // Check if door is closed
                            if (target.userData.isOpen) {
                                showMessage('\ud83d\udeaa Close the door first!');
                                return;
                            }
                            
                            // Check if door already has a code lock
                            if (target.userData.hasCodeLock) {
                                showMessage('\ud83d\udd12 Door already has a code lock!');
                                return;
                            }
                            
                            // Install code lock
                            inventory.code_lock--;
                            updateUI();
                            openCodeLockSetUI(target);
                            return;
                        }
                        
                        // Check if door has a code lock
                        if (target.userData.hasCodeLock) {
                            // Check if trying to open
                            if (!target.userData.isOpen) {
                                // Door is closed and locked - need code
                                openCodeLockEnterUI(target);
                                return;
                            } else {
                                // Door is open - just close it
                                target.userData.isOpen = false;
                                
                                if (target.userData.doorType === 'single') {
                                    target.userData.doorTargetY = 0;
                                } else if (target.userData.doorType === 'double') {
                                    target.userData.leftTargetY  = 0;
                                    target.userData.rightTargetY = 0;
                                } else {
                                    const initialRotation = target.userData.initialRotation || 0;
                                    target.userData.rotation.y = initialRotation;
                                }
                                
                                showMessage('\ud83d\udd12 Door closed and locked');
                                return;
                            }
                        }
                        
                        // Normal door operation (no code lock)
                        const wasOpen = target.userData.isOpen;
                        target.userData.isOpen = !target.userData.isOpen;
                        
                        if (target.userData.doorType === 'single') {
                            // Single door - animate smoothly via target
                            target.userData.doorTargetY = target.userData.isOpen ? -Math.PI / 2 : 0;
                        } else if (target.userData.doorType === 'double') {
                            // Double doors - left leaf swings left, right leaf swings right (outward from centre)
                            target.userData.leftTargetY  = target.userData.isOpen ?  Math.PI / 2 : 0;
                            target.userData.rightTargetY = target.userData.isOpen ? -Math.PI / 2 : 0;
                        } else {
                            // Old style rotating door
                            const initialRotation = target.userData.initialRotation || 0;
                            if (target.userData.isOpen) {
                                target.rotation.y = initialRotation + Math.PI / 2;
                            } else {
                                target.rotation.y = initialRotation;
                            }
                        }
                        
                        // Play appropriate door sound
                        if (target.userData.isOpen) {
                            playDoorOpenSound();
                            showMessage('\ud83d\udd13 Door opened');
                        } else {
                            showMessage('\ud83d\udd12 Door closed');
                        }
                        return;
                    }
                    
                    if (target.userData.isJunkPile) {
                        openJunkPile(target);
                        return;
                    }

                    if (target.userData.isStorageBox) {
                        openStorageBox(target);
                        return;
                    } else if (target.userData.isWorkbench) {
                        openWorkbenchMenu(target);
                        return;
                    } else if (target.userData.isBuildingBench) {
                        if (document.getElementById('workbench-menu').style.display !== 'block') openBuildingBenchMenu(target);
                        return;
                    } else if (target.userData.isSewingTable) {
                        if (document.getElementById('workbench-menu').style.display !== 'block') openSewingTableMenu(target);
                        return;
                    } else if (target.userData.isRecycler) {
                        openRecyclerMenu(target);
                        return;
                    } else if (target.userData.isWaterCatcher) {
                        openWaterCatcherMenu(target);
                        return;
                    } else if (target.userData.isFurnace) {
                        openFurnaceMenu(target);
                        return;
                    } else if (target.userData.isCookingStation) {
                        openCookingStationMenu(target);
                        return;
                    } else if (target.userData.isCampfire) {
                        openCampfireMenu(target);
                        return;
                    } else if (target.userData.isSleepingBag) {
                        // Set spawn point
                        spawnPoint = {
                            x: target.position.x,
                            y: target.position.y + 1.7,
                            z: target.position.z
                        };
                        showMessage('\ud83d\udecf\ufe0f Spawn point set!');
                        playCollectSound();
                        return;
                    } else if (target.userData.isBeeHive) {
                        openBeeHiveMenu(target);
                        return;
                    } else if (target.userData.isChickenCoop) {
                        openChickenCoopMenu(target);
                        return;
                    } else if (target.userData.isOilSmelter) {
                        showMessage('🛢️ Oil Smelter — Coming Soon!');
                        return;
                    } else if (target.userData.isPlanterBox) {
                        // Check if player is looking at a specific grown plant slot
                        // by finding which slot the raycast hit is closest to
                        const hitPoint = intersects[0].point;
                        const planterWorldPos = target.position;
                        const planterRot = target.rotation.y;
                        // Transform hit point to planter local space
                        const dx = hitPoint.x - planterWorldPos.x;
                        const dz = hitPoint.z - planterWorldPos.z;
                        const localHitX = dx * Math.cos(-planterRot) - dz * Math.sin(-planterRot);
                        // Find closest slot
                        const slots = target.userData.slotPositions || [-0.75,-0.25,0.25,0.75];
                        let closestSlot = -1, closestDist = Infinity;
                        slots.forEach((sx, si) => {
                            const d = Math.abs(localHitX - sx);
                            if (d < closestDist) { closestDist = d; closestSlot = si; }
                        });
                        const seed = closestSlot >= 0 ? target.userData.seeds[closestSlot] : null;
                        if (seed && seed.grown) {
                            harvestPlant(target, closestSlot);
                        } else if (seed && !seed.grown) {
                            showMessage(`\u23f3 Growing... ${Math.round((seed.waterCount/4)*100)}% — needs more rain`);
                        } else {
                            openPlanterBox(target);
                        }
                        return;
                    }
                }
            } else if (e.key >= '1' && e.key <= '6') {
                selectedHotbarSlot = parseInt(e.key) - 1;
                updateHotbar();
                updateHeldItem();
                
                // Show tooltip for newly selected item
                const selectedSlot = hotbar[selectedHotbarSlot];
                if (selectedSlot.item && inventory[selectedSlot.item] > 0) {
                    showHotbarTooltip(selectedSlot.item);
                    // Auto-hide after 2 seconds
                    setTimeout(() => {
                        hideHotbarTooltip();
                    }, 2000);
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });
        
        // ===== CENTRAL UI POINTER-LOCK MANAGER =====
        // Every menu open/close goes through these two helpers.
        // ── GLOBAL UI MANAGER ──
        // Simple: uiOpen() frees the mouse. closeAllUI() hides every menu and re-locks.
        // No counters — ESC or any close button calls closeAllUI() and it always works.

        // Helper: position inventory panel on the right side when a container is open
        function positionInventoryRight(panel) {
            panel.style.left = 'auto';
            panel.style.right = '20px';
            // Centre in the viewport above the hotbar (~130px tall incl. bottom gap)
            panel.style.top = 'calc(50% - 65px)';
            panel.style.transform = 'translateY(-50%)';
        }

        // Helper: reset inventory panel to centered (standalone open)
        function resetInventoryCenter(panel) {
            panel.style.left = '50%';
            panel.style.right = '';
            // Centre in the viewport above the hotbar (~130px tall incl. bottom gap)
            panel.style.top = 'calc(50% - 65px)';
            panel.style.transform = 'translate(-50%, -50%)';
        }

        function _setCrosshairVisible(v) {
            const ch  = document.getElementById('crosshair');
            const pch = document.getElementById('pistol-crosshair');
            if (ch)  ch.style.display  = v ? '' : 'none';
            // pistol crosshair only shows when gun is held — don't force it on
            if (pch && !v) pch.style.display = 'none';
        }

        function uiOpen() {
            // Release pointer lock so cursor is free
            if (document.pointerLockElement) document.exitPointerLock();
            // Hide crosshair while any menu is open
            _setCrosshairVisible(false);
        }

        let _hasUserGesture = false;

        function _tryLock() {
            if (!_hasUserGesture || isPaused) return;
            if (!document.pointerLockElement) {
                try {
                    const req = renderer.domElement.requestPointerLock();
                    if (req && typeof req.catch === 'function') req.catch(() => {});
                } catch(e) {}
            }
        }

        // Close every menu panel and re-acquire pointer lock.
        // Call this from ALL close buttons, ESC, and anywhere a menu is dismissed.
        function closeAllUI() {
            // Stop fishing if active
            if (typeof fishingState !== 'undefined' && fishingState.active) {
                stopFishing();
            }
            // Hide every menu/panel
            const _ids = ['crafting-menu','workbench-menu','furnace-menu','campfire-menu',
                          'recycler-menu','water-catcher-menu','cooking-station-menu',
                          'storage-panel','planter-panel','backpack-panel','admin-menu',
                          'code-lock-menu','settings-menu','junkpile-panel','fullmap-overlay',
                          'bee-hive-menu','chicken-coop-menu'];
            _ids.forEach(id => { const el = document.getElementById(id); if (el) el.style.display = 'none'; });
            _fmOpen = false;
            // Inventory panel — also reset positioning
            const _inv = document.getElementById('inventory-panel');
            if (_inv) { _inv.style.display = 'none'; _inv.style.left = ''; _inv.style.right = ''; _inv.style.top = ''; _inv.style.transform = ''; }
            // Reset menu positioning overrides
            ['furnace-menu','campfire-menu'].forEach(id => {
                const el = document.getElementById(id); if (el) { el.style.left = ''; el.style.transform = ''; }
            });
            // Clear all station/object references
            currentWorkbench = null; currentBuildingBench = null; currentSewingTable = null;
            currentFurnace = null; currentCampfire = null;
            currentStorageBox = null; currentPlanterBox = null; currentBackpack = null;
            currentCookingStation = null; currentWaterCatcher = null; currentJunkPile = null;
            currentBeeHive = null; currentChickenCoop = null;
            if (typeof waterCatcherState !== 'undefined') waterCatcherState.isOpen = false;
            // Cancel any active build mode
            if (typeof cancelBuilding === 'function') cancelBuilding();
            // Re-acquire pointer lock after a short delay
            setTimeout(_tryLock, 80);
            // Restore crosshair now menus are closed
            _setCrosshairVisible(true);
        }

        // Legacy aliases so existing open/close functions still compile
        function uiClose() { closeAllUI(); }
        function uiForceCloseAll() { closeAllUI(); }

        // Global ESC safety net — fires before anything else, guaranteed to close all UI
        document.addEventListener('keydown', function _globalEscHandler(e) {
            if (e.key !== 'Escape') return;
            // Check if any game menu is visible
            const _menuIds = ['crafting-menu','workbench-menu','furnace-menu','campfire-menu',
                              'recycler-menu','water-catcher-menu','cooking-station-menu',
                              'inventory-panel','storage-panel','planter-panel','backpack-panel','bee-hive-menu','chicken-coop-menu',
                              'admin-menu','code-lock-menu','settings-menu'];
            const anyVisible = _menuIds.some(id => {
                const el = document.getElementById(id);
                return el && el.style.display === 'block';
            });
            if (anyVisible) {
                e.stopImmediatePropagation();
                closeAllUI();
            }
        }, true); // capture phase — runs before game keydown handlers

        // Also call uiClose whenever the browser releases the lock externally
        // (e.g. user presses Escape while a menu is already open \ufffd don't re-lock)

        document.addEventListener('pointerlockchange', () => {
            mouse.locked = document.pointerLockElement === renderer.domElement;
        });
        
        renderer.domElement.addEventListener('click', () => {
            _hasUserGesture = true;
            // Re-acquire pointer lock on canvas click if no menus are open
            if (!mouse.locked && !isPaused) {
                const _menuIds = ['crafting-menu','workbench-menu','furnace-menu','campfire-menu',
                    'recycler-menu','water-catcher-menu','cooking-station-menu','inventory-panel',
                    'storage-panel','planter-panel','backpack-panel','admin-menu','settings-menu',
                    'junkpile-panel','fullmap-overlay','bee-hive-menu','chicken-coop-menu'];
                const anyOpen = _menuIds.some(id => {
                    const el = document.getElementById(id);
                    return el && el.style.display !== 'none' && el.style.display !== '';
                });
                if (!anyOpen) {
                    try { renderer.domElement.requestPointerLock(); } catch(e) {}
                }
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!mouse.locked) return;

            if (isThirdPerson) {
                // In 3rd-person: mouse drives the orbit angles directly.
                // camera.rotation is set by lookAt() each frame — don't touch it here.
                tp_orbitYaw   -= e.movementX * sensitivity;
                tp_orbitPitch -= e.movementY * sensitivity;
                tp_orbitPitch  = Math.max(-0.4, Math.min(0.8, tp_orbitPitch));
            } else {
                // 1st-person: mouse drives camera rotation directly
                camera.rotation.y -= e.movementX * sensitivity;
                camera.rotation.x -= e.movementY * sensitivity;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                camera.rotation.z = 0;
                camera.rotation.order = 'YXZ';
            }
        });
        
        document.addEventListener('mousedown', async (e) => {
            if (!mouse.locked) return;
            
            if (e.button === 0) { // Left click
                const heldItem = hotbar[selectedHotbarSlot].item;
                
                // Check if holding food/consumable item - consume it instead of attacking
                // Use the _foodItems Set (source of truth) so this never drifts out of sync
                if (_foodItems.has(heldItem) && inventory[heldItem] > 0) {
                    consumeItem(heldItem);
                    return; // Don't attack when consuming
                }
                
                if (buildMode) {
                    placeBuilding();
                } else if (heldItem === 'pistol') {
                    // Shoot pistol
                    shootPistol();
                } else if (heldItem === 'machine_gun') {
                    // Start auto-fire
                    machineGunState.isFiring = true;
                    shootMachineGun();
                } else if (heldItem === 'bow' && inventory.arrows > 0) {
                    // Shoot arrow
                    shootArrow();
                } else {
                    // Check if trying to place a building/crafting station from hotbar
                    const placeables = ['wall', 'window_wall', 'floor', 'ceiling', 'ladder_ceiling', 'stairs', 'corner_stairs_left', 'corner_stairs_right', 'ladder', 'door_frame', 'door', 'double_door', 'stone_door', 'stone_double_door', 'metal_door', 'metal_double_door', 'double_door_frame', 'campfire', 'workbench', 'building_bench', 'furnace', 'storage_box', 'sleeping_bag', 'small_storage_box', 'storage_shelf', 'wall_shelf', 'sewing_table', 'recycler', 'water_catcher', 'floor_rug_red', 'floor_rug_blue', 'floor_rug_green', 'curtain_red', 'curtain_blue', 'curtain_green', 'curtain_white', 'curtain_beige', 'planter_box', 'large_planter', 'cooking_station', 'sofa', 'bookcase', 'table', 'chair', 'wall_shelf_b', 'candle', 'wall_light', 'bee_hive', 'chicken_coop', 'oil_smelter'];
                    
                    if (placeables.includes(heldItem) && inventory[heldItem] > 0) {
                        handleBuildingPlacement();
                    } else {
                        handleAttack();
                    }
                }
            } else if (e.button === 2) { // Right click
                if (buildMode) {
                    cancelBuilding();
                } else {
                    // Check if holding building hammer - remove buildings
                    const heldItem = hotbar[selectedHotbarSlot].item;
                    if (heldItem === 'building_hammer') {
                        // Raycast to find building to remove
                        const raycaster = new THREE.Raycaster();
                        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                        const intersects = raycaster.intersectObjects(buildings, true);
                        
                        if (intersects.length > 0) {
                            // Check distance first
                            if (intersects[0].distance > 8) {
                                showMessage('\u26a0\ufe0f Too far away! Must be within 8 meters.');
                                return;
                            }
                            
                            let target = intersects[0].object;
                            // Find the root building object
                            while (target.parent && !buildings.includes(target)) {
                                target = target.parent;
                            }
                            
                            // Check if it's a placed building
                            const buildingIndex = buildings.indexOf(target);
                            if (buildingIndex !== -1) {
                                const buildingType = target.userData.buildingType;
                                
                                // If removing a ceiling, check for wall gap and auto-fill
                                if (buildingType === 'ceiling') {
                                    const ceilingPos = target.position;
                                    const ceilingY = ceilingPos.y;
                                    
                                    // Find all walls at approximately the same height
                                    let wallsNearby = [];
                                    for (let building of buildings) {
                                        if (building.userData.buildingType === 'wall' || 
                                            building.userData.buildingType === 'window_wall' ||
                                            building.userData.isDoorFrame) {
                                            const heightMatch = Math.abs(building.position.y - ceilingY) < 0.5;
                                            if (heightMatch) {
                                                const dist = Math.sqrt(
                                                    Math.pow(building.position.x - ceilingPos.x, 2) + 
                                                    Math.pow(building.position.z - ceilingPos.z, 2)
                                                );
                                                // Check if wall is adjacent (within reasonable distance)
                                                if (dist < 6 && dist > 2) {
                                                    wallsNearby.push(building);
                                                }
                                            }
                                        }
                                    }
                                    
                                    // If there are 2 or more walls nearby, likely a gap that needs filling
                                    if (wallsNearby.length >= 2) {
                                        // Determine which wall type to use (most common)
                                        const wallType = wallsNearby[0].userData.buildingType;
                                        
                                        // Determine rotation based on nearby walls
                                        // Try to match the rotation of walls that are in line with the ceiling
                                        let bestRotation = wallsNearby[0].rotation.y;
                                        
                                        // Create replacement wall at ceiling position
                                        const replacementWall = await buildingTypes[wallType].create();
                                        replacementWall.position.set(ceilingPos.x, ceilingY, ceilingPos.z);
                                        replacementWall.rotation.y = bestRotation;
                                        
                                        replacementWall.userData.type = 'building';
                                        replacementWall.userData.buildingType = wallType;
                                        replacementWall.userData.collisionBox = new THREE.Box3().setFromObject(replacementWall);
                                        
                                        buildings.push(replacementWall);
                                        scene.add(replacementWall);
                                        
                                        showMessage(`\u2705 Gap filled with ${wallType}!`);
                                    }
                                }
                                
                                // Remove from scene and array
                                scene.remove(target);
                                buildings.splice(buildingIndex, 1);
                                // Clean up any spatial audio sources for this building
                                if (_hiveSources.has(target)) _stopSpatialSource(target, _hiveSources);
                                if (_coopSources.has(target)) _stopSpatialSource(target, _coopSources);
                                // Clean up bee particles if this was a hive
                                if (target.userData.isBeeHive) _removeHiveBees(target);
                                
                                showMessage(`\ud83d\uddd1\ufe0f Removed ${buildingType}!`);
                                playHitSound();
                                
                                // Refund half materials (optional)
                                if (buildingTypes[buildingType] && buildingTypes[buildingType].cost) {
                                    const costs = buildingTypes[buildingType].cost;
                                    Object.keys(costs).forEach(resource => {
                                        const refund = Math.floor(costs[resource] / 2);
                                        inventory[resource] = (inventory[resource] || 0) + refund;
                                    });
                                    updateUI();
                                }
                            }
                        }
                    }
                }
            }
        });
        
        // Mouse wheel for hotbar scrolling
        document.addEventListener('wheel', (e) => {
            if (!mouse.locked) return;
            
            e.preventDefault();
            
            if (e.deltaY > 0) {
                // Scroll down - next slot
                selectedHotbarSlot = (selectedHotbarSlot + 1) % hotbar.length;
            } else {
                // Scroll up - previous slot
                selectedHotbarSlot = (selectedHotbarSlot - 1 + hotbar.length) % hotbar.length;
            }
            
            updateHotbar();
            updateHeldItem();
            
            // Show tooltip for newly selected item
            const selectedSlot = hotbar[selectedHotbarSlot];
            if (selectedSlot.item && inventory[selectedSlot.item] > 0) {
                showHotbarTooltip(selectedSlot.item);
                // Auto-hide after 2 seconds
                setTimeout(() => {
                    hideHotbarTooltip();
                }, 2000);
            }
        }, { passive: false });
        
        document.addEventListener('contextmenu', (e) => e.preventDefault());
        
        function toggleCraftingMenu() {
            const menu = document.getElementById('crafting-menu');
            const isVisible = menu.style.display === 'block';
            
            if (isVisible) {
                menu.style.display = 'none';
                uiClose();
            } else {
                menu.style.display = 'block';
                uiOpen();
                updateCraftingMenu();
            }
        }
        
        // ===== ARROW SHOOTING SYSTEM =====
        const arrows = [];
        
        function shootArrow() {
            if (inventory.arrows <= 0) {
                showMessage('\u26a0\ufe0f No arrows!');
                return;
            }
            
            inventory.arrows--;
            animateTool();
            updateUI();
            
            // Hide the nocked arrow on the bow temporarily
            const bowModel = heldItemGroup.children[0];
            if (bowModel && bowModel.userData.arrow) {
                bowModel.userData.arrow.visible = false;
                // Show it again after animation
                setTimeout(() => {
                    if (bowModel.userData.arrow) {
                        bowModel.userData.arrow.visible = true;
                    }
                }, 500);
            }
            
            // Create arrow projectile
            const arrow = new THREE.Group();
            
            // Arrow shaft - built along Z axis (forward)
            const shaftGeo = new THREE.CylinderGeometry(0.01, 0.01, 0.6, 6);
            const shaftMat = new THREE.MeshStandardMaterial({ 
                color: 0x8B6914,
                roughness: 0.7
            });
            const shaft = new THREE.Mesh(shaftGeo, shaftMat);
            shaft.rotation.x = Math.PI / 2; // Point along Z axis
            arrow.add(shaft);
            
            // Arrow tip (sharp point)
            const tipGeo = new THREE.ConeGeometry(0.015, 0.05, 6);
            const tipMat = new THREE.MeshStandardMaterial({ 
                color: 0x666666,
                metalness: 0.7,
                roughness: 0.3
            });
            const tip = new THREE.Mesh(tipGeo, tipMat);
            tip.rotation.x = -Math.PI / 2; // Point forward along Z
            tip.position.z = -0.325; // Tip at front
            arrow.add(tip);
            
            // Fletching
            for (let i = 0; i < 3; i++) {
                const fletchGeo = new THREE.PlaneGeometry(0.025, 0.06);
                const fletchMat = new THREE.MeshStandardMaterial({
                    color: 0xff3300,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7
                });
                const fletch = new THREE.Mesh(fletchGeo, fletchMat);
                fletch.position.z = 0.28; // Fletching at back
                fletch.rotation.y = (i * Math.PI * 2 / 3);
                arrow.add(fletch);
            }
            
            // Get bow position in world space
            const bowWorldPos = new THREE.Vector3();
            if (bowModel) {
                bowModel.getWorldPosition(bowWorldPos);
            } else {
                bowWorldPos.copy(camera.position);
            }
            
            // Get direction from camera
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);
            
            // Position arrow at bow location, slightly forward
            arrow.position.copy(bowWorldPos);
            arrow.position.add(direction.clone().multiplyScalar(0.3));
            
            // Offset to right side where bow is held
            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(camera.quaternion);
            arrow.position.add(right.multiplyScalar(0.15));
            arrow.position.y -= 0.15;
            
            // Rotate arrow to face direction
            arrow.lookAt(arrow.position.clone().add(direction));
            
            arrow.userData.velocity = direction.multiplyScalar(1.2); // Fast arrow speed
            arrow.userData.gravity = -0.01; // Arrow drops over distance
            arrow.userData.life = 300; // Arrow lifespan in frames
            arrow.userData.type = 'arrow';
            
            arrows.push(arrow);
            scene.add(arrow);
            
            // Bow shooting sound
            playBowShootSound();
        }
        
        function updateArrows() {
            for (let i = arrows.length - 1; i >= 0; i--) {
                const arrow = arrows[i];
                
                // Move arrow
                arrow.position.add(arrow.userData.velocity);
                
                // Apply gravity
                arrow.userData.velocity.y -= 0.015;
                
                // Update arrow rotation to face velocity
                const lookTarget = arrow.position.clone().add(arrow.userData.velocity);
                arrow.lookAt(lookTarget);
                
                // Check collisions
                const raycaster = new THREE.Raycaster(
                    arrow.position,
                    arrow.userData.velocity.clone().normalize(),
                    0,
                    arrow.userData.velocity.length() + 0.5
                );
                
                const targets = [...enemies, ...scorpions, ...coyotes, ...window.animals, ...window.squirrels];
                const intersects = raycaster.intersectObjects(targets, true);
                
                if (intersects.length > 0) {
                    let target = intersects[0].object;
                    while (target.parent && !target.userData.type) {
                        target = target.parent;
                    }
                    
                    // Deal damage
                    if (target.userData.type === 'enemy') {
                        target.userData.health -= 50;
                        if (target.userData.health <= 0) {
                            _killEnemy(target, '👻 Ghost defeated!');
                        }
                    } else if (target.userData.type === 'scorpion') {
                        target.userData.health -= 25;
                        if (target.userData.health <= 0) {
                            scene.remove(target);
                            scorpions.splice(scorpions.indexOf(target), 1);
                            showMessage('🦂 Scorpion killed!');
                        }
                    } else if (target.userData.type === 'coyote') {
                        target.userData.health -= 30;
                        if (target.userData.health <= 0) {
                            scene.remove(target);
                            coyotes.splice(coyotes.indexOf(target), 1);
                            inventory.meat += 2; updateUI();
                            showMessage('🐺 Coyote killed! +2 Meat');
                        } else {
                            target.userData.state = 'chase'; // Arrow makes it aggro
                        }
                    } else if (target.userData.type === 'animal') {
                        target.userData.health -= 50;
                        if (target.userData.health <= 0) {
                            inventory.meat += 2;
                            scene.remove(target);
                            window.animals.splice(window.animals.indexOf(target), 1);
                            showMessage('+ 2 Meat');
                            updateUI();
                        }
                    } else if (target.userData.type === 'squirrel') {
                        target.userData.health -= 50;
                        if (target.userData.health <= 0) {
                            inventory.meat += 1;
                            scene.remove(target);
                            window.squirrels.splice(window.squirrels.indexOf(target), 1);
                            showMessage('+ 1 Meat');
                            updateUI();
                        }
                    }
                    
                    // Remove arrow
                    scene.remove(arrow);
                    arrows.splice(i, 1);
                    continue;
                }
                
                // Remove arrow if too old or hit ground
                arrow.userData.life--;
                if (arrow.userData.life <= 0 || arrow.position.y < 0) {
                    scene.remove(arrow);
                    arrows.splice(i, 1);
                }
            }
        }
        
        // ===== PISTOL SYSTEM =====
        const bullets = [];
        const particles = []; // For muzzle flash and bullet trail particles
        
        function shootPistol() {
            // Check if reloading
            if (pistolState.isReloading) {
                return;
            }
            
            // Check if clip is empty
            if (pistolState.currentClip <= 0) {
                playPistolClickSound();
                showMessage('\u26a0\ufe0f No ammo in clip! Press R to reload');
                return;
            }
            
            // Fire bullet
            pistolState.currentClip--;
            updateAmmoDisplay();
            
            // Recoil animation
            animatePistolRecoil();
            
            // Muzzle flash
            createMuzzleFlash();
            
            // Gun sound
            playPistolSound();
            
            // Create bullet
            const bullet = new THREE.Group();
            
            // Bullet core (bright)
            const bulletGeo = new THREE.SphereGeometry(0.025, 6, 6);
            const bulletMat = new THREE.MeshBasicMaterial({ 
                color: 0xffff00,
                emissive: 0xffff00,
                emissiveIntensity: 3,
                transparent: true,
                opacity: 1
            });
            const bulletMesh = new THREE.Mesh(bulletGeo, bulletMat);
            bullet.add(bulletMesh);
            
            // Bullet glow halo
            const haloGeo = new THREE.SphereGeometry(0.04, 8, 8);
            const haloMat = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                transparent: true,
                opacity: 0.5,
                depthWrite: false
            });
            const halo = new THREE.Mesh(haloGeo, haloMat);
            bullet.add(halo);
            
            // Get direction from camera (very accurate - no spread)
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);
            
            // Position bullet at gun barrel end (in front of camera)
            bullet.position.copy(camera.position);
            bullet.position.add(direction.clone().multiplyScalar(0.6));
            
            // Offset slightly right and down to match gun position
            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(camera.quaternion);
            bullet.position.add(right.multiplyScalar(0.15));
            bullet.position.y -= 0.1;
            
            bullet.userData.velocity = direction.multiplyScalar(2.5); // Very fast bullet
            bullet.userData.life = 120;
            bullet.userData.type = 'bullet';
            bullet.userData.lastPosition = bullet.position.clone();
            bullet.userData.direction = direction.clone();
            
            bullets.push(bullet);
            scene.add(bullet);
            
            // Create particle trail behind bullet
            bullet.userData.createTrailParticle = function() {
                if (Math.random() > 0.3) return; // Don't create every frame
                
                const trailGeo = new THREE.SphereGeometry(0.015, 4, 4);
                const trailMat = new THREE.MeshBasicMaterial({
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 0.8,
                    depthWrite: false
                });
                const trail = new THREE.Mesh(trailGeo, trailMat);
                trail.position.copy(this.lastPosition);
                
                trail.userData.life = 0;
                trail.userData.maxLife = 8;
                trail.userData.startSize = trail.scale.x;
                
                scene.add(trail);
                particles.push(trail);
            };
        }
        
        function reloadPistol() {
            // Check if already reloading
            if (pistolState.isReloading) {
                return;
            }
            
            // Check if clip is full
            if (pistolState.currentClip >= pistolState.clipSize) {
                showMessage('\ud83d\udd2b Clip is full!');
                return;
            }
            
            // Check if have ammo
            if (inventory.pistol_ammo <= 0) {
                showMessage('\u26a0\ufe0f No ammo available!');
                return;
            }
            
            // Start reload
            pistolState.isReloading = true;
            pistolState.reloadStartTime = Date.now();
            showMessage('\ud83d\udd04 Reloading...');
            
            // Play reload sound
            playReloadSound();
            
            // Animate reload
            animatePistolReload();
        }
        
        function updatePistolReload() {
            if (!pistolState.isReloading) return;
            
            const elapsed = Date.now() - pistolState.reloadStartTime;
            
            if (elapsed >= pistolState.reloadDuration) {
                // Reload complete
                const ammoNeeded = pistolState.clipSize - pistolState.currentClip;
                const ammoToAdd = Math.min(ammoNeeded, inventory.pistol_ammo);
                
                pistolState.currentClip += ammoToAdd;
                inventory.pistol_ammo -= ammoToAdd;
                
                pistolState.isReloading = false;
                updateAmmoDisplay();
                updateUI();
                showMessage('\u2705 Reload complete!');
            }
        }
        
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // Create trail particles
                if (bullet.userData.createTrailParticle) {
                    bullet.userData.createTrailParticle();
                }
                
                // Move bullet
                bullet.userData.lastPosition = bullet.position.clone();
                bullet.position.add(bullet.userData.velocity);
                
                // Check collisions with enemies/animals
                const raycaster = new THREE.Raycaster(
                    bullet.position,
                    bullet.userData.velocity.clone().normalize(),
                    0,
                    bullet.userData.velocity.length() + 0.5
                );
                
                const targets = [...enemies, ...scorpions, ...coyotes, ...window.animals, ...window.squirrels];
                const intersects = raycaster.intersectObjects(targets, true);
                
                if (intersects.length > 0) {
                    let target = intersects[0].object;
                    while (target.parent && !target.userData.type) {
                        target = target.parent;
                    }
                    
                    // Deal heavy damage (more than sword/arrow)
                    if (target.userData.type === 'enemy') {
                        const dmg = bullet.userData.isMGBullet ? 30 : 80; // SMG does less damage per shot
                        target.userData.health -= dmg;
                        if (target.userData.health <= 0) {
                            _killEnemy(target, '☠️ Ghost eliminated!');
                        }
                    } else if (target.userData.type === 'scorpion') {
                        const dmg = bullet.userData.isMGBullet ? 10 : 25;
                        target.userData.health -= dmg;
                        if (target.userData.health <= 0) {
                            scene.remove(target);
                            scorpions.splice(scorpions.indexOf(target), 1);
                            showMessage('🦂 Scorpion eliminated!');
                        }
                    } else if (target.userData.type === 'coyote') {
                        const dmg = bullet.userData.isMGBullet ? 20 : 50;
                        target.userData.health -= dmg;
                        if (target.userData.health <= 0) {
                            scene.remove(target);
                            coyotes.splice(coyotes.indexOf(target), 1);
                            inventory.meat += 2; updateUI();
                            showMessage('🐺 Coyote eliminated! +2 Meat');
                        } else {
                            target.userData.state = 'chase';
                        }
                    } else if (target.userData.type === 'animal') {
                        const dmg = bullet.userData.isMGBullet ? 40 : 100;
                        target.userData.health -= dmg;
                        if (target.userData.health <= 0) {
                            inventory.meat += 2;
                            scene.remove(target);
                            window.animals.splice(window.animals.indexOf(target), 1);
                            showMessage('+ 2 Meat');
                            updateUI();
                        }
                    } else if (target.userData.type === 'squirrel') {
                        const dmg = bullet.userData.isMGBullet ? 40 : 100;
                        target.userData.health -= dmg;
                        if (target.userData.health <= 0) {
                            inventory.meat += 1;
                            scene.remove(target);
                            window.squirrels.splice(window.squirrels.indexOf(target), 1);
                            showMessage('+ 1 Meat');
                            updateUI();
                        }
                    }
                    
                    // Remove bullet
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                    continue;
                }
                
                // Check collision with buildings/walls
                const buildingIntersects = raycaster.intersectObjects(buildings, true);
                if (buildingIntersects.length > 0 && buildingIntersects[0].distance < 0.5) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                    continue;
                }
                
                // Remove bullet if too old or hit ground
                bullet.userData.life--;
                if (bullet.userData.life <= 0 || bullet.position.y < 0) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                }
            }
        }
        
        function createMuzzleFlash() {
            // Get gun barrel position
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);
            
            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(camera.quaternion);
            
            const flashPosition = camera.position.clone();
            flashPosition.add(direction.clone().multiplyScalar(0.7));
            flashPosition.add(right.multiplyScalar(0.15));
            flashPosition.y -= 0.1;
            
            // PARTICLE-BASED MUZZLE FLASH
            
            // Main flash burst (expanding sphere of particles)
            for (let i = 0; i < 20; i++) {
                const angle1 = Math.random() * Math.PI * 2;
                const angle2 = Math.random() * Math.PI;
                
                const particleGeo = new THREE.SphereGeometry(0.02 + Math.random() * 0.02, 4, 4);
                const particleMat = new THREE.MeshBasicMaterial({
                    color: i < 10 ? 0xffff00 : 0xff8800,
                    transparent: true,
                    opacity: 0.9,
                    depthWrite: false
                });
                const particle = new THREE.Mesh(particleGeo, particleMat);
                
                particle.position.copy(flashPosition);
                
                // Radial velocity
                const vel = new THREE.Vector3(
                    Math.sin(angle2) * Math.cos(angle1),
                    Math.sin(angle2) * Math.sin(angle1),
                    Math.cos(angle2)
                );
                vel.normalize().multiplyScalar(0.15 + Math.random() * 0.1);
                
                // Bias forward
                vel.add(direction.clone().multiplyScalar(0.3));
                
                particle.userData.velocity = vel;
                particle.userData.life = 0;
                particle.userData.maxLife = 8 + Math.floor(Math.random() * 5);
                particle.userData.startSize = particle.scale.x;
                
                scene.add(particle);
                particles.push(particle);
            }
            
            // Hot gas particles (faster, smaller)
            for (let i = 0; i < 15; i++) {
                const particleGeo = new THREE.SphereGeometry(0.01, 3, 3);
                const particleMat = new THREE.MeshBasicMaterial({
                    color: i < 7 ? 0xffffff : 0xffaa00,
                    transparent: true,
                    opacity: 0.8,
                    depthWrite: false
                });
                const particle = new THREE.Mesh(particleGeo, particleMat);
                
                particle.position.copy(flashPosition);
                
                // Forward cone
                const spread = 0.3;
                const vel = direction.clone();
                vel.x += (Math.random() - 0.5) * spread;
                vel.y += (Math.random() - 0.5) * spread;
                vel.z += (Math.random() - 0.5) * spread * 0.5;
                vel.normalize().multiplyScalar(0.4 + Math.random() * 0.2);
                
                particle.userData.velocity = vel;
                particle.userData.life = 0;
                particle.userData.maxLife = 12 + Math.floor(Math.random() * 6);
                particle.userData.startSize = particle.scale.x;
                
                scene.add(particle);
                particles.push(particle);
            }
            
            // Smoke puff (slower, larger, grey)
            for (let i = 0; i < 8; i++) {
                const particleGeo = new THREE.SphereGeometry(0.04 + Math.random() * 0.03, 4, 4);
                const grey = 0.3 + Math.random() * 0.4;
                const particleMat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(grey, grey, grey),
                    transparent: true,
                    opacity: 0.6,
                    depthWrite: false
                });
                const particle = new THREE.Mesh(particleGeo, particleMat);
                
                particle.position.copy(flashPosition);
                particle.position.add(direction.clone().multiplyScalar(0.1));
                
                const vel = direction.clone();
                vel.x += (Math.random() - 0.5) * 0.4;
                vel.y += (Math.random() - 0.5) * 0.4 + 0.1; // Slight upward drift
                vel.z += (Math.random() - 0.5) * 0.2;
                vel.normalize().multiplyScalar(0.08 + Math.random() * 0.05);
                
                particle.userData.velocity = vel;
                particle.userData.life = 0;
                particle.userData.maxLife = 30 + Math.floor(Math.random() * 15);
                particle.userData.startSize = particle.scale.x;
                
                scene.add(particle);
                particles.push(particle);
            }
            
            // Bright core flash (instant, fades fast)
            const coreGeo = new THREE.SphereGeometry(0.08, 8, 8);
            const coreMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 1,
                depthWrite: false
            });
            const core = new THREE.Mesh(coreGeo, coreMat);
            core.position.copy(flashPosition);
            scene.add(core);
            
            let coreFrame = 0;
            const animateCore = () => {
                coreFrame++;
                if (coreFrame >= 4) {
                    scene.remove(core);
                    return;
                }
                core.material.opacity = 1 - (coreFrame / 4);
                core.scale.set(1 + coreFrame * 0.3, 1 + coreFrame * 0.3, 1 + coreFrame * 0.3);
                requestAnimationFrame(animateCore);
            };
            animateCore();
            
            // Smoke puff
            const smokeGeo = new THREE.SphereGeometry(0.08, 8, 8);
            const smokeMat = new THREE.MeshBasicMaterial({
                color: 0x555555,
                transparent: true,
                opacity: 0.3,
                depthWrite: false
            });
            const smoke = new THREE.Mesh(smokeGeo, smokeMat);
            smoke.position.copy(flashPosition);
            scene.add(smoke);
            
            // Animate smoke
            let smokeFrame = 0;
            const animateSmoke = () => {
                smokeFrame++;
                if (smokeFrame >= 25) {
                    scene.remove(smoke);
                    return;
                }
                smoke.position.add(direction.clone().multiplyScalar(0.015));
                smoke.scale.multiplyScalar(1.06);
                smoke.material.opacity = 0.3 * (1 - smokeFrame / 25);
                requestAnimationFrame(animateSmoke);
            };
            animateSmoke();
        }
        
        function animatePistolRecoil() {
            if (!heldItemGroup.children[0]) return;
            
            const recoilDuration = 100; // ms
            const startPos = heldItemGroup.position.clone();
            const startRot = heldItemGroup.rotation.clone();
            const startTime = Date.now();
            
            const animate = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / recoilDuration, 1);
                
                if (progress < 0.3) {
                    // Recoil back
                    const kick = (progress / 0.3);
                    heldItemGroup.position.z = startPos.z + kick * 0.1;
                    heldItemGroup.rotation.x = startRot.x - kick * 0.3;
                } else {
                    // Return to normal
                    const recovery = (progress - 0.3) / 0.7;
                    heldItemGroup.position.z = startPos.z + (1 - recovery) * 0.1;
                    heldItemGroup.rotation.x = startRot.x - (1 - recovery) * 0.3;
                }
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    heldItemGroup.position.copy(startPos);
                    heldItemGroup.rotation.copy(startRot);
                }
            };
            
            animate();
        }
        
        function animatePistolReload() {
            if (!heldItemGroup.children[0]) return;
            
            const model = heldItemGroup.children[0];
            const magazine = model.userData.magazine;
            if (!magazine) return;
            
            const reloadDuration = pistolState.reloadDuration;
            const startTime = Date.now();
            const startMagPos = magazine.position.clone();
            
            const animate = () => {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / reloadDuration;
                
                if (progress < 0.3) {
                    // Drop mag
                    magazine.position.y = startMagPos.y - (progress / 0.3) * 0.3;
                } else if (progress < 0.6) {
                    // Mag out of view
                    magazine.position.y = startMagPos.y - 0.5;
                } else {
                    // New mag in
                    const insertProgress = (progress - 0.6) / 0.4;
                    magazine.position.y = startMagPos.y - 0.3 + (insertProgress * 0.3);
                }
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    magazine.position.copy(startMagPos);
                }
            };
            
            animate();
        }
        
        function updateAmmoDisplay() {
            const ammoCounter = document.getElementById('ammo-counter');
            if (!ammoCounter) return;
            if (currentHeldItem === 'pistol') {
                ammoCounter.textContent = `${pistolState.currentClip} / ${inventory.pistol_ammo}`;
            } else if (currentHeldItem === 'machine_gun') {
                ammoCounter.textContent = `${machineGunState.currentClip} / ${inventory.mg_ammo}`;
            }
        }

        // ===== MACHINE GUN SYSTEM =====
        function shootMachineGun() {
            if (machineGunState.isReloading) return;
            if (machineGunState.currentClip <= 0) {
                playPistolClickSound();
                showMessage('⚠️ Mag empty! Press R to reload');
                machineGunState.isFiring = false;
                return;
            }

            machineGunState.currentClip--;
            machineGunState.lastShotTime = Date.now();
            machineGunState.shotsFired++;
            updateAmmoDisplay();

            animateMachineGunRecoil();
            createMachineGunMuzzleFlash();
            playMachineGunSound();

            // Create bullet (slightly more spread than pistol)
            const bullet = new THREE.Group();
            const bulletGeo = new THREE.SphereGeometry(0.025, 6, 6);
            const bulletMat = new THREE.MeshBasicMaterial({
                color: 0xff4400, emissive: 0xff4400, emissiveIntensity: 3,
                transparent: true, opacity: 1
            });
            bullet.add(new THREE.Mesh(bulletGeo, bulletMat));

            const haloGeo = new THREE.SphereGeometry(0.04, 8, 8);
            const haloMat = new THREE.MeshBasicMaterial({
                color: 0xff6600, transparent: true, opacity: 0.5, depthWrite: false
            });
            bullet.add(new THREE.Mesh(haloGeo, haloMat));

            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);
            // Slight random spread for automatic fire
            direction.x += (Math.random() - 0.5) * 0.018;
            direction.y += (Math.random() - 0.5) * 0.018;
            direction.normalize();

            bullet.position.copy(camera.position);
            bullet.position.add(direction.clone().multiplyScalar(0.6));
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
            bullet.position.add(right.multiplyScalar(0.15));
            bullet.position.y -= 0.1;

            bullet.userData.velocity = direction.multiplyScalar(2.5);
            bullet.userData.life = 120;
            bullet.userData.type = 'bullet';
            bullet.userData.isMGBullet = true;   // lower damage — fires faster but hits softer
            bullet.userData.lastPosition = bullet.position.clone();
            bullet.userData.direction = direction.clone();
            bullet.userData.createTrailParticle = function() {
                if (Math.random() > 0.4) return;
                const trailGeo = new THREE.SphereGeometry(0.015, 4, 4);
                const trailMat = new THREE.MeshBasicMaterial({
                    color: 0xff6600, transparent: true, opacity: 0.8, depthWrite: false
                });
                const trail = new THREE.Mesh(trailGeo, trailMat);
                trail.position.copy(this.lastPosition);
                trail.userData.life = 0;
                trail.userData.maxLife = 8;
                trail.userData.startSize = trail.scale.x;
                scene.add(trail);
                particles.push(trail);
            };

            bullets.push(bullet);
            scene.add(bullet);
        }

        function reloadMachineGun() {
            if (machineGunState.isReloading) return;
            if (machineGunState.currentClip >= machineGunState.clipSize) {
                showMessage('🔫 Magazine is full!');
                return;
            }
            if (inventory.mg_ammo <= 0) {
                showMessage('⚠️ No MG ammo available!');
                return;
            }
            machineGunState.isFiring = false;
            machineGunState.isReloading = true;
            machineGunState.reloadStartTime = Date.now();
            showMessage('🔄 Reloading machine gun...');
            playReloadSound();
            animateMachineGunReload();
        }

        function updateMachineGunReload() {
            if (!machineGunState.isReloading) return;
            const elapsed = Date.now() - machineGunState.reloadStartTime;
            if (elapsed >= machineGunState.reloadDuration) {
                const ammoNeeded = machineGunState.clipSize - machineGunState.currentClip;
                const ammoToAdd  = Math.min(ammoNeeded, inventory.mg_ammo);
                machineGunState.currentClip += ammoToAdd;
                inventory.mg_ammo -= ammoToAdd;
                machineGunState.isReloading = false;
                updateAmmoDisplay();
                updateUI();
                showMessage('✅ Machine gun reloaded!');
            }
        }

        function updateMachineGunFire() {
            if (!machineGunState.isFiring) return;
            if (machineGunState.isReloading) return;
            if (currentHeldItem !== 'machine_gun') { machineGunState.isFiring = false; return; }
            const now = Date.now();
            if (now - machineGunState.lastShotTime >= machineGunState.fireRate) {
                shootMachineGun();
            }
        }

        function animateMachineGunRecoil() {
            if (!heldItemGroup.children[0]) return;
            const recoilDuration = 60;
            const startPos = heldItemGroup.position.clone();
            const startRot = heldItemGroup.rotation.clone();
            const startTime = Date.now();
            const animate = () => {
                const progress = Math.min((Date.now() - startTime) / recoilDuration, 1);
                if (progress < 0.3) {
                    const kick = progress / 0.3;
                    heldItemGroup.position.z = startPos.z + kick * 0.07;
                    heldItemGroup.rotation.x = startRot.x - kick * 0.18;
                } else {
                    const recovery = (progress - 0.3) / 0.7;
                    heldItemGroup.position.z = startPos.z + (1 - recovery) * 0.07;
                    heldItemGroup.rotation.x = startRot.x - (1 - recovery) * 0.18;
                }
                if (progress < 1) requestAnimationFrame(animate);
                else { heldItemGroup.position.copy(startPos); heldItemGroup.rotation.copy(startRot); }
            };
            animate();
        }

        function animateMachineGunReload() {
            if (!heldItemGroup.children[0]) return;
            const model = heldItemGroup.children[0];
            const magazine = model.userData.magazine;
            if (!magazine) return;
            const startMagPos = magazine.position.clone();
            const startTime = Date.now();
            const animate = () => {
                const progress = (Date.now() - startTime) / machineGunState.reloadDuration;
                if (progress < 0.25) {
                    magazine.position.y = startMagPos.y - (progress / 0.25) * 0.35;
                } else if (progress < 0.65) {
                    magazine.position.y = startMagPos.y - 0.5;
                } else {
                    magazine.position.y = startMagPos.y - 0.35 + ((progress - 0.65) / 0.35) * 0.35;
                }
                if (progress < 1) requestAnimationFrame(animate);
                else magazine.position.copy(startMagPos);
            };
            animate();
        }

        function createMachineGunMuzzleFlash() {
            const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const right     = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
            const flashPos  = camera.position.clone()
                .add(direction.clone().multiplyScalar(0.75))
                .add(right.multiplyScalar(0.15));
            flashPos.y -= 0.1;

            // Burst particles — orange/red tint (distinguishes from pistol's yellow)
            for (let i = 0; i < 18; i++) {
                const a1 = Math.random() * Math.PI * 2, a2 = Math.random() * Math.PI;
                const geo  = new THREE.SphereGeometry(0.018 + Math.random() * 0.018, 4, 4);
                const mat  = new THREE.MeshBasicMaterial({
                    color: i < 9 ? 0xff6600 : 0xff2200,
                    transparent: true, opacity: 0.9, depthWrite: false
                });
                const p = new THREE.Mesh(geo, mat);
                p.position.copy(flashPos);
                const vel = new THREE.Vector3(
                    Math.sin(a2) * Math.cos(a1), Math.sin(a2) * Math.sin(a1), Math.cos(a2)
                ).normalize().multiplyScalar(0.12 + Math.random() * 0.09);
                vel.add(direction.clone().multiplyScalar(0.25));
                p.userData.velocity = vel;
                p.userData.life = 0;
                p.userData.maxLife = 7 + Math.floor(Math.random() * 4);
                p.userData.startSize = p.scale.x;
                scene.add(p); particles.push(p);
            }
            // Quick ring flash
            const ringGeo = new THREE.TorusGeometry(0.04, 0.012, 6, 12);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.85, depthWrite: false });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.position.copy(flashPos);
            ring.lookAt(flashPos.clone().add(direction));
            scene.add(ring);
            let rf = 0;
            const animRing = () => {
                rf++;
                if (rf >= 6) { scene.remove(ring); return; }
                ring.scale.multiplyScalar(1.4);
                ring.material.opacity *= 0.5;
                requestAnimationFrame(animRing);
            };
            animRing();
        }

        function playMachineGunSound() {
            // Pistol base pitch: ~0.95–1.05. SMG is 40% higher: 1.33–1.47
            // After the first shot in a burst, volume drops 30%
            const vol = machineGunState.shotsFired > 1 ? 0.3 * 0.7 : 0.3;
            if (_pistolBuffer) {
                const source = audioContext.createBufferSource();
                source.buffer = _pistolBuffer;
                source.playbackRate.value = 1.33 + Math.random() * 0.14; // 40% higher pitch than pistol
                const gain = audioContext.createGain();
                gain.gain.setValueAtTime(vol, audioContext.currentTime);
                source.connect(gain);
                gain.connect(audioContext.destination);
                source.start();
                return;
            }
            // Synthesised fallback
            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const g   = audioContext.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(220, now);
            osc.frequency.exponentialRampToValueAtTime(80, now + 0.07);
            g.gain.setValueAtTime(vol, now);
            g.gain.exponentialRampToValueAtTime(0.01, now + 0.09);
            osc.connect(g); g.connect(audioContext.destination);
            osc.start(now); osc.stop(now + 0.09);
        }
        
        function playBowShootSound() {
            const now = audioContext.currentTime;
            
            // String release - fast snap
            const snap = audioContext.createOscillator();
            const snapGain = audioContext.createGain();
            
            snap.type = 'square';
            snap.frequency.setValueAtTime(600, now);
            snap.frequency.exponentialRampToValueAtTime(200, now + 0.05);
            
            snapGain.gain.setValueAtTime(0.25, now);
            snapGain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
            
            snap.connect(snapGain);
            snapGain.connect(audioContext.destination);
            
            snap.start(now);
            snap.stop(now + 0.08);
            
            // Bow limb vibration
            const vib = audioContext.createOscillator();
            const vibGain = audioContext.createGain();
            
            vib.type = 'sine';
            vib.frequency.setValueAtTime(120, now + 0.02);
            vib.frequency.exponentialRampToValueAtTime(80, now + 0.2);
            
            vibGain.gain.setValueAtTime(0.15, now + 0.02);
            vibGain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
            
            vib.connect(vibGain);
            vibGain.connect(audioContext.destination);
            
            vib.start(now + 0.02);
            vib.stop(now + 0.25);
            
            // Arrow whoosh
            const whoosh = audioContext.createOscillator();
            const whooshGain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            whoosh.type = 'sawtooth';
            whoosh.frequency.setValueAtTime(400, now);
            whoosh.frequency.exponentialRampToValueAtTime(150, now + 0.15);
            
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(800, now);
            
            whooshGain.gain.setValueAtTime(0.12, now);
            whooshGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
            
            whoosh.connect(filter);
            filter.connect(whooshGain);
            whooshGain.connect(audioContext.destination);
            
            whoosh.start(now);
            whoosh.stop(now + 0.15);
        }
        

        
        // ===== TOOL SOUNDS =====
        function playAxeSwingSound() { /* synth removed — add MP3 here */ }
        
        function playPickaxeSwingSound() { /* synth removed — add MP3 here */ }
        
        function playSwordSwingSound() {
            const now = audioContext.currentTime;
            
            // Fast blade whoosh
            const whoosh = audioContext.createOscillator();
            const whooshGain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            whoosh.type = 'sawtooth';
            whoosh.frequency.setValueAtTime(800, now);
            whoosh.frequency.exponentialRampToValueAtTime(300, now + 0.2);
            
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(1000, now);
            filter.Q.setValueAtTime(2, now);
            
            whooshGain.gain.setValueAtTime(0.18, now);
            whooshGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
            
            whoosh.connect(filter);
            filter.connect(whooshGain);
            whooshGain.connect(audioContext.destination);
            
            whoosh.start(now);
            whoosh.stop(now + 0.2);
        }
        
        function playHammerSwingSound() {
            const now = audioContext.currentTime;
            
            // Heavy whoosh
            const whoosh = audioContext.createOscillator();
            const whooshGain = audioContext.createGain();
            
            whoosh.type = 'sine';
            whoosh.frequency.setValueAtTime(250, now);
            whoosh.frequency.exponentialRampToValueAtTime(100, now + 0.18);
            
            whooshGain.gain.setValueAtTime(0.2, now);
            whooshGain.gain.exponentialRampToValueAtTime(0.01, now + 0.18);
            
            whoosh.connect(whooshGain);
            whooshGain.connect(audioContext.destination);
            
            whoosh.start(now);
            whoosh.stop(now + 0.18);
        }
        
        function playAxeHitSound() { /* replaced by wood chop MP3 */ }
        
        function playPickaxeHitSound() { /* replaced by stonemine MP3 */ }
        
        function playSwordHitSound() {
            const now = audioContext.currentTime;
            
            // Sharp metallic hit
            const hit = audioContext.createOscillator();
            const hitGain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            hit.type = 'square';
            hit.frequency.setValueAtTime(800, now);
            hit.frequency.exponentialRampToValueAtTime(400, now + 0.06);
            
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(500, now);
            
            hitGain.gain.setValueAtTime(0.22, now);
            hitGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            
            hit.connect(filter);
            filter.connect(hitGain);
            hitGain.connect(audioContext.destination);
            
            hit.start(now);
            hit.stop(now + 0.1);
        }
        
        function playHammerHitSound() {
            const now = audioContext.currentTime;
            
            // Heavy metallic clang
            const clang = audioContext.createOscillator();
            const clangGain = audioContext.createGain();
            
            clang.type = 'square';
            clang.frequency.setValueAtTime(350, now);
            clang.frequency.exponentialRampToValueAtTime(180, now + 0.15);
            
            clangGain.gain.setValueAtTime(0.35, now);
            clangGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
            
            clang.connect(clangGain);
            clangGain.connect(audioContext.destination);
            
            clang.start(now);
            clang.stop(now + 0.2);
        }
        
        // Sound functions for pistol
        // Preload pistol shot sound
        let _pistolBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/PistolShot.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _pistolBuffer = buf; console.log('Pistol sound loaded OK'); })
            .catch(e => { console.error('Pistol sound fetch error:', e); });

        function playPistolSound() {
            if (!_pistolBuffer) return;
            const source = audioContext.createBufferSource();
            source.buffer = _pistolBuffer;
            source.playbackRate.value = 0.95 + Math.random() * 0.1; // slight pitch variation
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0.4, audioContext.currentTime); // 60% quieter
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);
            source.start();
        }

        let _gunClickBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/Gun Click.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _gunClickBuffer = buf; console.log('Gun click sound loaded OK'); })
            .catch(e => { console.error('Gun click sound fetch error:', e); });

        function playPistolClickSound() {
            if (_gunClickBuffer) {
                const source = audioContext.createBufferSource();
                source.buffer = _gunClickBuffer;
                const gain = audioContext.createGain();
                gain.gain.setValueAtTime(0.7, audioContext.currentTime); // 30% quieter
                source.connect(gain);
                gain.connect(audioContext.destination);
                source.start();
                return;
            }
            // Synthesised fallback
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const now = audioCtx.currentTime;
            const click = audioCtx.createOscillator();
            const clickGain = audioCtx.createGain();
            click.connect(clickGain);
            clickGain.connect(audioCtx.destination);
            click.type = 'square';
            click.frequency.setValueAtTime(1200, now);
            click.frequency.exponentialRampToValueAtTime(800, now + 0.01);
            clickGain.gain.setValueAtTime(0.15, now);
            clickGain.gain.exponentialRampToValueAtTime(0.01, now + 0.02);
            click.start(now);
            click.stop(now + 0.02);
        }
        
        // Preload pistol reload sound
        let _reloadBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/pistolreload.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _reloadBuffer = buf; console.log('Pistol reload sound loaded OK'); })
            .catch(e => { console.error('Pistol reload sound fetch error:', e); });

        function playReloadSound() {
            if (!_reloadBuffer) return;
            const source = audioContext.createBufferSource();
            source.buffer = _reloadBuffer;
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(1.105, audioContext.currentTime); // 15% quieter than before
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);
            source.start();
        }

        function toggleFlashlight() {
            flashlightOn = !flashlightOn;
            flashlight.intensity = flashlightOn ? 1.5 : 0;
            showMessage(flashlightOn ? '\ud83d\udd26 Flashlight ON' : '\ud83d\udd26 Flashlight OFF');
            // Click sound
            if (audioContext) {
                const buf = audioContext.createBuffer(1, audioContext.sampleRate * 0.04, audioContext.sampleRate);
                const d = buf.getChannelData(0);
                for (let i = 0; i < d.length; i++) {
                    // Sharp transient click: loud at start, instant decay
                    d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / d.length, 18);
                }
                const src = audioContext.createBufferSource();
                src.buffer = buf;
                const gain = audioContext.createGain();
                gain.gain.value = flashlightOn ? 0.6 : 0.4;
                src.connect(gain);
                gain.connect(audioContext.destination);
                src.start();
            }
        }
        
        function checkPlayerCollision(newPos) {
            const playerRadius = 0.4;

            // ?? Nature obstacles: fast radius check in XZ ??
            const allNature = [
                ...treePositions.map(p => ({ ...p, r: (p.radius || 2) * 0.55 })),
                ...rockPositions.map(p => ({ ...p, r: (p.radius || 1.5) * 0.7 })),
                ...orePositions.map(p => ({ ...p, r: 0.9 })),
                ...sulfurPositions.map(p => ({ ...p, r: 0.9 })),
                ...bushPositions.map(p => ({ ...p, r: 0.8 })),
                ...desertFormationColliders,
                ...cactiPositions.map(p => ({ x: p.x, z: p.z, r: p.radius })),
            ];
            for (const ob of allNature) {
                const dx = newPos.x - ob.x, dz = newPos.z - ob.z;
                if (dx*dx + dz*dz < (playerRadius + ob.r) * (playerRadius + ob.r)) return true;
            }

            const playerBox = new THREE.Box3(
                new THREE.Vector3(newPos.x - playerRadius, newPos.y - 1.7, newPos.z - playerRadius),
                new THREE.Vector3(newPos.x + playerRadius, newPos.y, newPos.z + playerRadius)
            );
            
            for (let building of buildings) {
                // Don't collide with open doors
                if (building.userData.isDoor && building.userData.isOpen) continue;
                
                // Don't collide with door frames (walkable)
                if (building.userData.isDoorFrame) continue;
                
                // Don't collide with sleeping bags (walkable)
                if (building.userData.isSleepingBag) continue;
                
                // Don't collide with rugs (walkable decorations)
                if (building.userData.isRug || building.userData.noCollision) continue;
                
                // Don't collide with curtains (just decorative)
                if (building.userData.isCurtain) continue;
                
                // Don't collide with floors, ceilings, or ladder_ceilings (can walk on/under them)
                if (isFloorOrCeiling(building.userData.buildingType) || 
                    building.userData.isLadderCeiling) continue;
                
                // Don't collide with stairs (handle separately)
                if (building.userData.isStairs) continue;
                
                _reusableBox.setFromObject(building); // reuse ? no allocation
                if (playerBox.intersectsBox(_reusableBox)) {
                    return true; // Collision detected
                }
            }
            return false; // No collision
        }
        
        // Shared obstacle check for enemies/animals (XZ radius only, no buildings)
        function collidesWithNature(pos, radius) {
            // Rebuild flat cache if world has changed (tree felled, rock mined, etc.)
            if (_natureCollidersStale) _rebuildNatureColliders();
            const px = pos.x, pz = pos.z;
            for (let i = 0; i < _natureColliders.length; i++) {
                const ob = _natureColliders[i];
                const dx = px - ob.x, dz = pz - ob.z;
                const minDist = radius + ob.r;
                if (dx*dx + dz*dz < minDist * minDist) return true;
            }
            return false;
        }
        // Mark collider cache stale whenever world objects are removed (called from harvest/destroy code)
        function _markNatureCollidersStale() { _natureCollidersStale = true; }

        function checkStairsHeight() {
            let onStairs = false;
            for (let building of buildings) {
                if (building.userData.isStairs) {
                    _reusableBox.setFromObject(building);
                    if (camera.position.x >= _reusableBox.min.x - 0.5 && camera.position.x <= _reusableBox.max.x + 0.5 &&
                        camera.position.z >= _reusableBox.min.z - 0.5 && camera.position.z <= _reusableBox.max.z + 0.5) {

                        const _worldPos = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);
                        const _local = building.worldToLocal(_worldPos.clone());
                        const rotatedX = _local.x;
                        const rotatedZ = _local.z;

                        let progress = 0;

                        if (building.userData.isCornerStairs) {
                            const dir = building.userData.cornerDir || 'left';
                            const halfH = 1.5;
                            const totalH = 3.0;

                            if (dir === 'right') {
                                const onLanding = rotatedZ >= 0 && rotatedZ <= 2.0 &&
                                                  rotatedX >= -2.0 && rotatedX <= 0.2;
                                const onLeg2 = rotatedZ >= 0 && rotatedZ <= 2.0 && rotatedX > 0.2;

                                if (onLeg2) {
                                    const legProgress = Math.max(0, Math.min(1, rotatedX / 2.0));
                                    progress = (halfH / totalH) + legProgress * (halfH / totalH);
                                } else if (onLanding) {
                                    progress = halfH / totalH;
                                } else {
                                    const legProgress = Math.max(0, Math.min(1, (rotatedZ + 2) / 4));
                                    progress = legProgress * (halfH / totalH);
                                }
                            } else {
                                const onLanding = rotatedZ >= 0 && rotatedZ <= 2.0 &&
                                                  rotatedX >= -0.2 && rotatedX <= 2.0;
                                const onLeg2 = rotatedZ >= 0 && rotatedZ <= 2.0 && rotatedX < -0.2;

                                if (onLeg2) {
                                    const legProgress = Math.max(0, Math.min(1, -rotatedX / 2.0));
                                    progress = (halfH / totalH) + legProgress * (halfH / totalH);
                                } else if (onLanding) {
                                    progress = halfH / totalH;
                                } else {
                                    const legProgress = Math.max(0, Math.min(1, (rotatedZ + 2) / 4));
                                    progress = legProgress * (halfH / totalH);
                                }
                            }
                        } else {
                            // Straight stairs: progress along Z
                            progress = Math.max(0, Math.min(1, (rotatedZ + 2) / 4));
                        }

                        const stairHeight = progress * 3;
                        const targetHeight = building.position.y + stairHeight + 1.7;

                        if (Math.abs(playerY - targetHeight) < 2) {
                            playerY = targetHeight;
                            camera.position.y = playerY;
                            isJumping = false;
                            jumpVelocity = 0;
                            onStairs = true;
                        }
                        break;
                    }
                }
            }
            return onStairs;
        }
        
        // ===== MOVEMENT =====
        // ===== FOOTSTEP SOUND SYSTEM =====
        let footstepTimer = 0;
        // Player movement direction — updated each frame by updateMovement()
        // Used by local snow layer to blow particles opposite to travel direction
        const _playerVelDir = new THREE.Vector3(0, 0, 0); // normalised XZ direction
        let _playerIsMoving = false;
        let lastFootstepSurface = 'grass';

        // Detect which surface the player is standing on
        function detectSurface() {
            const px = camera.position.x, pz = camera.position.z;
            const py = playerY; // from jump/movement scope — approximate via camera

            // Snow biome ground — check before buildings so snow crunch plays outdoors
            if (typeof _getSnowBiomeBlend === 'function' && _getSnowBiomeBlend() > 0.5) return 'snow';

            // River biome — trigger when player is touching the water mesh.
            // WATER_LEVEL = -(RIVER_DEPTH * 0.46). We compute it here since the
            // const WATER_LEVEL is block-scoped inside the mesh builder and not
            // visible from this function.
            if (typeof rbTerrainY === 'function' && typeof RIVER_DEPTH !== 'undefined') {
                const _waterLevel = -(RIVER_DEPTH * 0.46);
                const _ry = rbTerrainY(px, pz);
                if (_ry <= _waterLevel + 0.05) return 'river';
            }

            // Check if standing on a placed floor
            for (let building of buildings) {
                const bt = building.userData.buildingType;
                if (!isFloorOrCeiling(bt)) continue;
                const box = new THREE.Box3().setFromObject(building);
                if (px >= box.min.x && px <= box.max.x && pz >= box.min.z && pz <= box.max.z) {
                    const floorTop = box.max.y;
                    if (Math.abs(camera.position.y - 1.7 - floorTop) < 0.5) {
                        if (bt === 'metal_floor') return 'metal';
                        if (bt === 'stone_floor') return 'stone';
                        return 'wood'; // default floor = wood
                    }
                }
            }

            // Check if standing near a rock or ore (dirt patch)
            for (let rp of rockPositions) {
                const d = Math.sqrt((px - rp.x) ** 2 + (pz - rp.z) ** 2);
                // Check if on dirt patch (larger radius) or on rock itself (smaller radius)
                if (d < rp.radius * 1.7) return 'dirt'; // Dirt patch around rock
                if (d < rp.radius * 0.9) return 'stone'; // On the rock itself
            }
            for (let op of orePositions) {
                const d = Math.sqrt((px - op.x) ** 2 + (pz - op.z) ** 2);
                // Check if on dirt patch (larger radius) or on ore itself (smaller radius)
                if (d < op.radius * 1.7) return 'dirt'; // Dirt patch around ore
                if (d < op.radius * 0.9) return 'stone'; // On the ore itself
            }

            return 'grass';
        }

        // Play a footstep for the given surface
        function playFootstep(surface) {
            const now = audioContext.currentTime;
            const vol = volumeSettings.footsteps;
            if (vol <= 0) return;
            // ±15% volume variation per step so no two footsteps sound identical
            const vv = 0.85 + Math.random() * 0.30;

            if (surface === 'grass') {
                // Deep thud — sub-bass noise burst
                const bufSize = audioContext.sampleRate * 0.14;
                const buf = audioContext.createBuffer(1, bufSize, audioContext.sampleRate);
                const d = buf.getChannelData(0);
                for (let i = 0; i < bufSize; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufSize * 0.38));
                const src = audioContext.createBufferSource();
                src.buffer = buf;
                const lp = audioContext.createBiquadFilter();
                lp.type = 'lowpass'; lp.frequency.value = 220;
                lp.Q.value = 2.0;
                const g = audioContext.createGain();
                g.gain.setValueAtTime(vol * 0.7 * vv, now);
                g.gain.exponentialRampToValueAtTime(0.001, now + 0.16);
                src.connect(lp); lp.connect(g); g.connect(audioContext.destination);
                src.start(now); src.stop(now + 0.18);

            } else if (surface === 'dirt') {
                // Soft low rustle — filtered to low-mid band
                const bufSize = audioContext.sampleRate * 0.1;
                const buf = audioContext.createBuffer(1, bufSize, audioContext.sampleRate);
                const d = buf.getChannelData(0);
                for (let i = 0; i < bufSize; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufSize * 0.45));
                const src = audioContext.createBufferSource();
                src.buffer = buf;
                const hp = audioContext.createBiquadFilter();
                hp.type = 'highpass'; hp.frequency.value = 120;
                const lp = audioContext.createBiquadFilter();
                lp.type = 'lowpass'; lp.frequency.value = 700;
                const g = audioContext.createGain();
                g.gain.setValueAtTime(vol * 0.6 * vv, now);
                g.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
                src.connect(hp); hp.connect(lp); lp.connect(g); g.connect(audioContext.destination);
                src.start(now); src.stop(now + 0.14);

            } else if (surface === 'wood') {
                // Hollow low knock — deeper sine thud
                const osc = audioContext.createOscillator();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(60 + Math.random() * 20, now);
                osc.frequency.exponentialRampToValueAtTime(32, now + 0.12);
                const g = audioContext.createGain();
                g.gain.setValueAtTime(vol * 0.55 * vv, now);
                g.gain.exponentialRampToValueAtTime(0.001, now + 0.14);
                osc.connect(g); g.connect(audioContext.destination);
                osc.start(now); osc.stop(now + 0.16);
                // low-mid click layer
                const bufSize = audioContext.sampleRate * 0.04;
                const buf = audioContext.createBuffer(1, bufSize, audioContext.sampleRate);
                const dd = buf.getChannelData(0);
                for (let i = 0; i < bufSize; i++) dd[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufSize * 0.18));
                const src = audioContext.createBufferSource();
                src.buffer = buf;
                const bp = audioContext.createBiquadFilter();
                bp.type = 'bandpass'; bp.frequency.value = 350;
                bp.Q.value = 1.5;
                const g2 = audioContext.createGain();
                g2.gain.setValueAtTime(vol * 0.3 * vv, now);
                src.connect(bp); bp.connect(g2); g2.connect(audioContext.destination);
                src.start(now); src.stop(now + 0.05);

            } else if (surface === 'stone') {
                // Hard low clack — lower bandpass
                const bufSize = audioContext.sampleRate * 0.08;
                const buf = audioContext.createBuffer(1, bufSize, audioContext.sampleRate);
                const d = buf.getChannelData(0);
                for (let i = 0; i < bufSize; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufSize * 0.14));
                const src = audioContext.createBufferSource();
                src.buffer = buf;
                const bp = audioContext.createBiquadFilter();
                bp.type = 'bandpass'; bp.frequency.value = 320;
                bp.Q.value = 2.5;
                const g = audioContext.createGain();
                g.gain.setValueAtTime(vol * 0.7 * vv, now);
                g.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                src.connect(bp); bp.connect(g); g.connect(audioContext.destination);
                src.start(now); src.stop(now + 0.12);

            } else if (surface === 'metal') {
                // Lower metallic clang — deeper resonance
                [90, 96].forEach(freq => {
                    const osc = audioContext.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.value = freq + Math.random() * 6;
                    const g = audioContext.createGain();
                    g.gain.setValueAtTime(vol * 0.4 * vv, now);
                    g.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
                    osc.connect(g); g.connect(audioContext.destination);
                    osc.start(now); osc.stop(now + 0.28);
                });
                // mid-body thud layer
                const bufSize = audioContext.sampleRate * 0.04;
                const buf = audioContext.createBuffer(1, bufSize, audioContext.sampleRate);
                const dd = buf.getChannelData(0);
                for (let i = 0; i < bufSize; i++) dd[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufSize * 0.12));
                const src = audioContext.createBufferSource();
                src.buffer = buf;
                const bp = audioContext.createBiquadFilter();
                bp.type = 'bandpass'; bp.frequency.value = 500;
                bp.Q.value = 2;
                const g = audioContext.createGain();
                g.gain.setValueAtTime(vol * 0.45 * vv, now);
                src.connect(bp); bp.connect(g); g.connect(audioContext.destination);
                src.start(now); src.stop(now + 0.05);

            } else if (surface === 'snow') {
                // SnowFeet.mp3 — slice a random chunk, modulate pitch and volume per step
                if (!_snowFeetBuffer) return;
                const clipDuration = 0.35;
                const maxOffset = Math.max(0, _snowFeetBuffer.duration - clipDuration);
                const offset = Math.random() * maxOffset;
                const src = audioContext.createBufferSource();
                src.buffer = _snowFeetBuffer;
                src.playbackRate.value = 0.82 + Math.random() * 0.36;
                const gain = audioContext.createGain();
                gain.gain.setValueAtTime(vol * 1.5 * vv, now);
                gain.gain.linearRampToValueAtTime(0, now + clipDuration);
                src.connect(gain);
                gain.connect(audioContext.destination);
                src.start(now, offset, clipDuration);

            } else if (surface === 'river') {
                // RiverWalk.mp3 — slice a random chunk per step for variation
                if (!window._riverWalkBuffer) return;
                const clipDuration = 0.4;
                const maxOffset = Math.max(0, window._riverWalkBuffer.duration - clipDuration);
                const offset = Math.random() * maxOffset;
                const src = audioContext.createBufferSource();
                src.buffer = window._riverWalkBuffer;
                src.playbackRate.value = 0.9 + Math.random() * 0.2;
                const gain = audioContext.createGain();
                gain.gain.setValueAtTime(vol * 1.2 * vv, now);
                gain.gain.linearRampToValueAtTime(0, now + clipDuration);
                src.connect(gain);
                gain.connect(audioContext.destination);
                src.start(now, offset, clipDuration);
            }
        }

        // Play a single random footstep slice from the Snowwalk.mp3 buffer.
        // Picks a random start offset so every step sounds different.
        function playSnowFootstep() {
            if (!_snowWalkBuffer) return;
            const vol = volumeSettings.footsteps;
            if (vol <= 0) return;

            const clipDuration = 0.38; // length of one "crunch" slice in seconds
            const maxOffset = Math.max(0, _snowWalkBuffer.duration - clipDuration);
            const offset = Math.random() * maxOffset;

            const src = audioContext.createBufferSource();
            src.buffer = _snowWalkBuffer;

            // Slight random pitch shift per step for natural variation
            src.playbackRate.value = 0.88 + Math.random() * 0.24;

            const gain = audioContext.createGain();
            const now = audioContext.currentTime;
            gain.gain.setValueAtTime(vol * 0.75, now);
            // Short fade-out tail so the clip doesn't click at the end
            gain.gain.linearRampToValueAtTime(0, now + clipDuration);

            src.connect(gain);
            gain.connect(audioContext.destination);
            src.start(now, offset, clipDuration);
        }

        function updateMovement() {
            if (isDead) return;
            // 3rd-person: movement and camera are handled entirely in updateThirdPerson().
            // We still run gravity/jump/ladder below so physics works in both modes.
            if (isThirdPerson) return;

            const forward = new THREE.Vector3(0, 0, -1);
            const right = new THREE.Vector3(1, 0, 0);
            forward.applyQuaternion(camera.quaternion);
            right.applyQuaternion(camera.quaternion);
            forward.y = 0; right.y = 0;
            forward.normalize(); right.normalize();

            // --- Time-based stamina ---
            const _nowSec = performance.now() * 0.001;
            const _dt = _staminaLastTime ? Math.min(_nowSec - _staminaLastTime, 0.1) : 0;
            _staminaLastTime = _nowSec;

            if (stamina <= 0 && !staminaExhausted) { staminaExhausted = true; staminaExhaustedAt = performance.now(); }
            if (staminaExhausted && (performance.now() - staminaExhaustedAt) >= exhaustedDuration * 1000) staminaExhausted = false;

            const fpIsMoving = keys['w'] || keys['s'] || keys['a'] || keys['d'];
            const isSprinting = keys['shift'] && !staminaExhausted && stamina > 0 && fpIsMoving;
            const _sugarMult = activeBuffs.sugar_rush ? 1.15 : 1.0;
            const currentSpeed = staminaExhausted ? exhaustedSpeed : (isSprinting ? sprintSpeed * _sugarMult : moveSpeed * _sugarMult);

            if (isSprinting) {
                const drainMult = activeBuffs.veggi_stew ? 0.2 : 1.0;
                stamina = Math.max(0, stamina - staminaDrainPerSec * drainMult * _dt);
            } else if (!fpIsMoving) {
                stamina = Math.min(maxStamina, stamina + staminaRegenFastPerSec * _dt);
            } else {
                stamina = Math.min(maxStamina, stamina + staminaRegenPerSec * _dt);
            }
            // Update stamina bar directly every frame
            _updateStaminaBar();

            // River terrain step helper: returns the world-Y the player's feet
            // should be at for a given XZ position (0 on flat ground, negative in channel).
            // Max step-up per move = 0.35 units — slopes walkable, walls blocked.
            const _RB_MAX_STEP = 0.55;
            function _getTerrainY(wx, wz) {
                // Combine river terrain (negative offsets) + snow terrain + snow drifts (walkable mounds)
                const river = (typeof rbTerrainY    === 'function') ? rbTerrainY(wx, wz)    : 0;
                const snow  = (typeof snowTerrainY  === 'function') ? snowTerrainY(wx, wz)  : 0;
                const drift = (typeof driftTerrainY === 'function') ? driftTerrainY(wx, wz) : 0;
                return river + Math.max(snow, drift);
            }

            function _rbMoveWithTerrain(newPos) {
                if (checkPlayerCollision(newPos)) return; // building collision — skip

                // Island boundary — stop at ocean edge
                newPos.x = Math.max(_ISLAND_XMIN, Math.min(_ISLAND_XMAX, newPos.x));
                newPos.z = Math.max(_ISLAND_ZMIN, Math.min(_ISLAND_ZMAX, newPos.z));

                const terrY = _getTerrainY(newPos.x, newPos.z);
                const targetCamY = 1.7 + terrY;
                const deltaY = targetCamY - camera.position.y;

                // Hard vertical cliffs (> 3 units rise per step) are impassable.
                if (deltaY > 3.0) return;

                // If the player is elevated above ground (e.g. on stairs/floor),
                // don't snap them back down to terrain level while moving.
                if (camera.position.y > targetCamY + 0.4) {
                    // Just move XZ, keep current Y — gravity/stairs will handle Y
                    newPos.y = camera.position.y;
                } else if (deltaY > _RB_MAX_STEP) {
                    newPos.y = camera.position.y + _RB_MAX_STEP;
                } else {
                    newPos.y = targetCamY;
                }

                camera.position.copy(newPos);
                playerY = newPos.y;
            }

            if (keys['w']) { _rbMoveWithTerrain(camera.position.clone().addScaledVector(forward,  currentSpeed)); }
            if (keys['s']) { _rbMoveWithTerrain(camera.position.clone().addScaledVector(forward, -currentSpeed)); }
            if (keys['a']) { _rbMoveWithTerrain(camera.position.clone().addScaledVector(right,   -currentSpeed)); }
            if (keys['d']) { _rbMoveWithTerrain(camera.position.clone().addScaledVector(right,    currentSpeed)); }

            // Track movement direction for local snow layer
            const isMovingNow = keys['w'] || keys['s'] || keys['a'] || keys['d'];
            _playerIsMoving = isMovingNow;
            if (isMovingNow) {
                _playerVelDir.set(0, 0, 0);
                if (keys['w']) _playerVelDir.addScaledVector(forward,  1);
                if (keys['s']) _playerVelDir.addScaledVector(forward, -1);
                if (keys['a']) _playerVelDir.addScaledVector(right,   -1);
                if (keys['d']) _playerVelDir.addScaledVector(right,    1);
                if (_playerVelDir.lengthSq() > 0) _playerVelDir.normalize();
            }
            if (isMovingNow && !isJumping && !onLadder) {
                const stepInterval = isSprinting ? 0.32 : 0.52; // s between steps
                footstepTimer += 0.016; // ~60fps delta
                if (footstepTimer >= stepInterval) {
                    footstepTimer = 0;
                    const surface = detectSurface();
                    playFootstep(surface);
                }
            } else {
                footstepTimer = 0;
            }
            
            // Check if on stairs and adjust Y position
            const onStairs = checkStairsHeight();
            
            // Check if near a ladder and allow climbing - treat stacked ladders as one continuous ladder
            onLadder = false; // Reset each frame
            let ladderTop = -Infinity;
            let ladderBottom = Infinity;
            let ladderPosition = null;
            
            // First, find all ladders at the same position (stacked ladders)
            const nearbyLadders = [];
            for (let building of buildings) {
                if (building.userData.isLadder) {
                    const distToLadder = Math.sqrt(
                        Math.pow(camera.position.x - building.position.x, 2) + 
                        Math.pow(camera.position.z - building.position.z, 2)
                    );
                    
                    // Closer range - must be within 0.8 units (was 1.5)
                    if (distToLadder <= 0.8) {
                        nearbyLadders.push(building);
                    }
                }
            }
            
            // If we found nearby ladders, treat them as one continuous ladder system
            if (nearbyLadders.length > 0) {
                // Find the combined top and bottom of all stacked ladders at this position
                for (let ladder of nearbyLadders) {
                    const ladderBox = new THREE.Box3().setFromObject(ladder);
                    ladderTop = Math.max(ladderTop, ladderBox.max.y);
                    ladderBottom = Math.min(ladderBottom, ladderBox.min.y);
                    if (!ladderPosition) {
                        ladderPosition = { x: ladder.position.x, z: ladder.position.z };
                    }
                }
                
                // Check if player is within the combined ladder's vertical range (with larger buffer)
                if (camera.position.y >= ladderBottom - 1.0 && camera.position.y <= ladderTop + 2.0) {
                    onLadder = true;
                    
                    // Use E key to climb up
                    if (keys['e']) {
                        // Smooth climbing animation - fixed speed regardless of framerate
                        const climbSpeed = 0.08;
                        camera.position.y += climbSpeed;
                        
                        // Check for ladder_ceiling exit point near the ladder top
                        let ladderCeilingExit = null;
                        for (let building of buildings) {
                            if (building.userData.isLadderCeiling) {
                                // Check if this ladder ceiling is near the ladder horizontally
                                const distToCeiling = Math.sqrt(
                                    Math.pow(building.position.x - ladderPosition.x, 2) + 
                                    Math.pow(building.position.z - ladderPosition.z, 2)
                                );
                                // Check if ceiling is near the ladder top vertically
                                const heightDiff = Math.abs(building.position.y - ladderTop);
                                
                                if (distToCeiling < 2.5 && heightDiff < 2.0) {
                                    ladderCeilingExit = building;
                                    break;
                                }
                            }
                        }
                        
                        // Auto-detach when reaching the top
                        if (camera.position.y >= ladderTop - 1.5) {
                            if (ladderCeilingExit) {
                                // Exit onto ladder ceiling - treat its Y position as the floor surface
                                // Place player standing on it (camera at floor + eye height)
                                camera.position.y = ladderCeilingExit.position.y + 1.7;
                            } else {
                                // No ladder ceiling - calculate from ladder top
                                // ladderTop is the top of the ladder mesh
                                // Player feet should be at ladderTop, camera at ladderTop + 1.7
                                camera.position.y = ladderTop + 1.7;
                            }
                            onLadder = false;
                        }
                    }
                    // Use S key to climb down
                    if (keys['s']) {
                        const climbDownSpeed = 0.06;
                        camera.position.y -= climbDownSpeed;
                    }
                    
                    // Cancel jumping/falling when on ladder
                    isJumping = false;
                    jumpVelocity = 0;
                }
            }
            
            // Apply gravity if not on stairs, not on ladder, and not jumping
            if (!onStairs && !onLadder && !isJumping) {
                // Check if there's a floor/ceiling under the player
                // Combined terrain offset: river (negative) + snow (positive)
                const _rbOffset = _getTerrainY(camera.position.x, camera.position.z);
                let groundLevel = 1.7 + _rbOffset;
                let onGround = false;
                
                for (let building of buildings) {
                    if (isFloorOrCeiling(building.userData.buildingType)) {
                        const box = new THREE.Box3().setFromObject(building);
                        // Check if player is standing on this floor/ceiling
                        if (camera.position.x >= box.min.x && camera.position.x <= box.max.x &&
                            camera.position.z >= box.min.z && camera.position.z <= box.max.z) {
                            const floorTop = box.max.y + 1.7;
                            if (Math.abs(playerY - floorTop) < 0.8) {
                                groundLevel = floorTop;
                                onGround = true;
                                break;
                            }
                        }
                    }
                }
                
                // If player is above ground level, either snap down gently (terrain slope)
                // or start fall physics for a real drop (jumped off a cliff etc.)
                if (playerY > groundLevel + 0.05) {
                    const drop = playerY - groundLevel;
                    if (drop <= 0.5 && !onGround) {
                        playerY = groundLevel;
                        camera.position.y = playerY;
                    } else if (!onGround) {
                        // Only fall if not supported by a stair surface
                        let supportedByStairs = false;
                        for (let building of buildings) {
                            if (!building.userData.isStairs) continue;
                            _reusableBox.setFromObject(building);
                            if (camera.position.x >= _reusableBox.min.x - 0.5 &&
                                camera.position.x <= _reusableBox.max.x + 0.5 &&
                                camera.position.z >= _reusableBox.min.z - 0.5 &&
                                camera.position.z <= _reusableBox.max.z + 0.5 &&
                                playerY > _reusableBox.min.y && playerY < _reusableBox.max.y + 2.0) {
                                supportedByStairs = true;
                                break;
                            }
                        }
                        if (!supportedByStairs) {
                            isJumping = true;
                            jumpVelocity = -0.1;
                        }
                    }
                } else if (playerY < groundLevel - 0.05 && !onGround) {
                    playerY = groundLevel;
                    camera.position.y = playerY;
                }
            }
            
            // Jump physics
            if (isJumping) {
                playerY += jumpVelocity;
                jumpVelocity -= gravity;
                
                // Land on ground or on floor/ceiling
                // Include river terrain displacement so player lands inside the channel
                const _rbOffsetJ = _getTerrainY(camera.position.x, camera.position.z);
                let groundLevel = 1.7 + _rbOffsetJ;
                for (let building of buildings) {
                    if (isFloorOrCeiling(building.userData.buildingType)) {
                        const box = new THREE.Box3().setFromObject(building);
                        const playerBox = new THREE.Box3(
                            new THREE.Vector3(camera.position.x - 0.3, playerY - 1.7, camera.position.z - 0.3),
                            new THREE.Vector3(camera.position.x + 0.3, playerY, camera.position.z + 0.3)
                        );
                        if (box.intersectsBox(playerBox) && playerY > box.max.y) {
                            groundLevel = Math.max(groundLevel, box.max.y + 1.7);
                        }
                    }
                }
                
                if (playerY <= groundLevel) {
                    playerY = groundLevel;
                    isJumping = false;
                    jumpVelocity = 0;
                }
            }
            
            // Keep player at correct height
            camera.position.y = playerY;
            
            // Update flashlight position
            if (flashlightOn) {
                flashlight.position.copy(camera.position);
                const target = new THREE.Vector3(0, 0, -1);
                target.applyQuaternion(camera.quaternion);
                target.add(camera.position);
                flashlight.target.position.copy(target);
            }
        }
        
        // ===== ATTACK AND GATHER SYSTEM =====
        function handleAttack() {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            const allObjects = [...trees, ...rocks, ...metalOres, ...sulfurOres, ...window.animals, ...window.squirrels, ...enemies, ...scorpions, ...coyotes, ...berryBushes, ...foliageBushes, ...crystalNodes, ...grassBlades, ...desertGrassTufts, ...cacti, ...groundCollectibles, ...wildPlants, ...buildings];
            const intersects = raycaster.intersectObjects(allObjects, true);
            
            if (intersects.length > 0) {
                const distance = intersects[0].distance;
                
                // Check if within reach (5 units = about 1 meter in game scale)
                if (distance > 5) {
                    showMessage('\u26a0\ufe0f Too far away!');
                    return;
                }
                
                let target = intersects[0].object;
                while (target.parent && !target.userData.type && !target.userData.isWildPlant && !target.userData.buildingType && !target.userData.isDoor && !target.userData.isStorageBox && !target.userData.isWorkbench && !target.userData.isBuildingBench && !target.userData.isSewingTable && !target.userData.isRecycler && !target.userData.isWaterCatcher && !target.userData.isFurnace && !target.userData.isCampfire && !target.userData.isDoorFrame && !target.userData.isSleepingBag && !target.userData.isPlanterBox) {
                    target = target.parent;
                }
                
                const heldItem = hotbar[selectedHotbarSlot].item;
                
                // Animate tool
                animateTool();


                // Wild plant harvest
                if (target.userData.isWildPlant) {
                    if (!target.userData.harvestable) {
                        const minsLeft = Math.ceil((target.userData.respawnAt - Date.now()) / 60000);
                        showMessage(`⏳ Regrowth in ~${minsLeft} min`);
                        return;
                    }
                    const map = _harvestMap[target.userData.seedType];
                    if (map) {
                        inventory[map.produce] = (inventory[map.produce]||0) + map.count;
                        inventory[target.userData.seedType] = (inventory[target.userData.seedType]||0) + map.seedReturn;
                        const pName = itemDisplayNames[map.produce]||map.produce;
                        showMessage(`🌿 Harvested wild ${pName}! +${map.count} ${pName} +${map.seedReturn} seed(s)`);
                    }
                    playPlantSound();

                    // Remove from scene and wildPlants array entirely
                    scene.remove(target);
                    const wi = wildPlants.indexOf(target);
                    if (wi !== -1) wildPlants.splice(wi, 1);

                    // Schedule a respawn at a new random location after 15 real minutes
                    const seedType = target.userData.seedType;
                    setTimeout(() => {
                        // Find a valid new position (same logic as initial spawn)
                        let nx, nz, valid = false, attempts = 0;
                        do {
                            nx = (Math.random() - 0.5) * 160;
                            nz = 10 + Math.random() * 70;
                            if (Math.sqrt(nx*nx + nz*nz) < 18) { attempts++; continue; }
                            valid = true;
                            for (const pos of [...treePositions, ...rockPositions, ...bushPositions]) {
                                if (Math.sqrt((nx-pos.x)**2+(nz-pos.z)**2) < 4) { valid = false; break; }
                            }
                            // Also avoid other wild plants
                            for (const wp of wildPlants) {
                                if (Math.sqrt((nx-wp.position.x)**2+(nz-wp.position.z)**2) < 3) { valid = false; break; }
                            }
                            attempts++;
                        } while (!valid && attempts < 120);
                        if (!valid) return; // couldn't find spot, skip this respawn

                        const _wsc = {wheat_seed:7.5,corn_seed:6.8,hemp_seed:6.5,red_berry_seed:1.2,black_berry_seed:1.2,tomato_seed:0.625,pumpkin_seed:5.0,cucumber_seed:2.5,potato_seed:2.5,carrot_seed:2.5,cabbage_seed:2.5,mushroom_seed:2.5,strawberry_seed:2.5};
                        const fresh = buildPlantModel(seedType, 4, _wsc[seedType] || 2.5);
                        const _rSink = ({carrot_seed:0.18, potato_seed:0.10, strawberry_seed:0.04})[seedType] || 0;
                        fresh.position.set(nx, fresh.position.y - _rSink, nz);
                        fresh.rotation.y = Math.random() * Math.PI * 2;
                        fresh.userData.isWildPlant = true;
                        fresh.userData.seedType    = seedType;
                        fresh.userData.harvestable = true;
                        fresh.userData.respawnAt   = 0;
                        scene.add(fresh);
                        wildPlants.push(fresh);
                    }, 15 * 60 * 1000); // 15 real minutes

                    updateUI();
                    return;
                }
                
                // Ground collectibles - no tool needed
                if (target.userData.type === 'stick_pickup' || target.userData.type === 'mushroom_pickup' || target.userData.type === 'rock_pickup') {
                    const collectible = target.userData.collectible;
                    const amount = target.userData.amount;
                    
                    _addToInventory(collectible, amount);
                    if (target.userData.type === 'mushroom_pickup') playPlantSound(); else playCollectSound();
                    showMessage(`+ ${amount} ${collectible}`);
                    scene.remove(target);
                    groundCollectibles.splice(groundCollectibles.indexOf(target), 1);
                    updateUI();
                    return;
                }
                
                if (target.userData.type === 'tree') {
                    // Sharp stone OR axe can harvest trees
                    if (heldItem !== 'axe' && heldItem !== 'sharp_stone' && heldItem !== 'stone_axe') {
                        showMessage('\ud83e\ude93 Need an axe or sharp stone to chop trees!');
                        return;
                    }
                    
                    target.userData.health--;
                    playTreeChopSound(); // Custom tree chop sound
                    playAxeHitSound(); // Tool impact sound
                    
                    // Shake tree on hit
                    const originalRotation = target.rotation.z;
                    target.rotation.z = originalRotation + (Math.random() - 0.5) * 0.1;
                    setTimeout(() => {
                        if (target.parent) target.rotation.z = originalRotation;
                    }, 100);
                    
                    if (target.userData.health <= 0) {
                        // Axe gives 2x resources compared to sharp stone
                        const heartyMult = activeBuffs.hearty ? 2 : 1;
                        const woodAmount = ((heldItem === 'axe' || heldItem === 'stone_axe') ? 4 : 2) * heartyMult;
                        const sticksAmount = ((heldItem === 'axe' || heldItem === 'stone_axe') ? 2 : 1) * heartyMult;
                        
                        inventory.wood += woodAmount;
                        inventory.sticks += sticksAmount;
                        
                        // Animate tree falling
                        const treePos = target.position.clone();
                        // Use userData.trunkHeight (set on both GLB and procedural trees at spawn).
                        // GLB trees have no CylinderGeometry so geometry.parameters.height throws.
                        const trunkHeight = target.userData.trunkHeight
                            || (target.children[0]?.geometry?.parameters?.height)
                            || 5;
                        
                        playTreeFallSound(); // Tree falling sound
                        
                        // Fall animation
                        let fallProgress = 0;
                        const fallDuration = 80; // frames (~1.3 seconds at 60fps)
                        const fallDirection = Math.random() * Math.PI * 2; // Random direction
                        
                        target.userData.falling = true;
                        target.userData.fallProgress = 0;
                        target.userData.fallDuration = fallDuration;
                        target.userData.fallDirection = fallDirection;
                        target.userData.onFallComplete = async () => {
                            // Remove fallen tree from collision immediately
                            if (target.userData._posEntry && target.userData._posArray) {
                                const idx = target.userData._posArray.indexOf(target.userData._posEntry);
                                if (idx !== -1) target.userData._posArray.splice(idx, 1);
                            }
                            _markNatureCollidersStale();

                            // Remove fallen tree
                            scene.remove(target);
                            trees.splice(trees.indexOf(target), 1);
                            
                            // Create stump
                            const stump = await createTreeStump(treePos.x, treePos.z, trunkHeight);
                            
                            // Add to respawn queue (5 minutes = 300000ms)
                            stumpRespawnQueue.push({
                                stump: stump,
                                respawnTime: Date.now() + 300000,
                                position: { x: treePos.x, z: treePos.z }
                            });
                        };
                        
                        showMessage(`+ ${woodAmount} Wood, + ${sticksAmount} Sticks`);
                    }
                } else if (target.userData.type === 'rock') {
                    // Sharp stone or pickaxe for rocks
                    if (heldItem !== 'pickaxe' && heldItem !== 'sharp_stone' && heldItem !== 'stone_pickaxe') {
                        showMessage('\u26cf\ufe0f Need a pickaxe or sharp stone to mine rocks!');
                        return;
                    }
                    
                    target.userData.health--;
                    playRockMineSound(); // Custom rock mining sound
                    playPickaxeHitSound(); // Tool impact sound
                    
                    // Shrink rock with each hit
                    const healthPercent = target.userData.health / target.userData.maxHealth;
                    const scale = 0.5 + (healthPercent * 0.5); // Shrinks from 100% to 50% size
                    target.scale.set(scale, scale, scale);
                    
                    // Shake effect
                    const originalY = target.position.y;
                    target.position.y = originalY + 0.05;
                    setTimeout(() => {
                        if (target.parent) target.position.y = originalY;
                    }, 50);
                    
                    if (target.userData.health <= 0) {
                        // Pickaxe gives 2x resources
                        const heartyMult = activeBuffs.hearty ? 2 : 1;
                        const stoneAmount = ((heldItem === 'pickaxe' || heldItem === 'stone_pickaxe') ? 4 : 2) * heartyMult;
                        inventory.stone += stoneAmount;
                        
                        // Store position before removal
                        const rockPos = target.position.clone();
                        
                        // Remove from collision arrays immediately
                        if (target.userData._posEntry && target.userData._posArray) {
                            const idx = target.userData._posArray.indexOf(target.userData._posEntry);
                            if (idx !== -1) target.userData._posArray.splice(idx, 1);
                        }
                        _markNatureCollidersStale();

                        // Poof effect as it disappears
                        target.scale.set(0.1, 0.1, 0.1);
                        setTimeout(() => {
                            scene.remove(target);
                            rocks.splice(rocks.indexOf(target), 1);
                            
                            // Add to respawn queue (5 minutes)
                            rockRespawnQueue.push({
                                respawnTime: Date.now() + 300000,
                                originalPosition: rockPos
                            });
                        }, 100);
                        
                        showMessage(`+ ${stoneAmount} Stone`);
                    }
                } else if (target.userData.type === 'metal_ore') {
                    // Need pickaxe for metal ore
                    if (heldItem !== 'pickaxe' && heldItem !== 'stone_pickaxe') {
                        showMessage('\u26cf\ufe0f Need a pickaxe to mine metal ore!');
                        return;
                    }
                    
                    target.userData.health--;
                    playOreMineSound(); // Custom ore mining sound
                    playPickaxeHitSound(); // Tool impact sound
                    
                    // Shrink ore with each hit
                    const healthPercent = target.userData.health / target.userData.maxHealth;
                    const scale = 0.4 + (healthPercent * 0.6); // Shrinks from 100% to 40% size
                    target.scale.set(scale, scale, scale);
                    
                    // Metallic flash effect
                    target.children.forEach(child => {
                        if (child.material) {
                            const originalEmissive = child.material.emissive ? child.material.emissive.getHex() : 0;
                            child.material.emissive = new THREE.Color(0x888888);
                            child.material.emissiveIntensity = 0.5;
                            setTimeout(() => {
                                if (child.material) {
                                    child.material.emissive = new THREE.Color(originalEmissive);
                                    child.material.emissiveIntensity = 0;
                                }
                            }, 100);
                        }
                    });
                    
                    if (target.userData.health <= 0) {
                        // Pickaxe gives full yield
                        const heartyMult = activeBuffs.hearty ? 2 : 1;
                        inventory.iron_ore += 3 * heartyMult;
                        
                        // Store position before removal
                        const orePos = target.position.clone();

                        // Remove from collision arrays immediately
                        if (target.userData._posEntry && target.userData._posArray) {
                            const idx = target.userData._posArray.indexOf(target.userData._posEntry);
                            if (idx !== -1) target.userData._posArray.splice(idx, 1);
                        }
                        _markNatureCollidersStale();
                        
                        // Sparkle effect as it disappears
                        target.scale.set(0.1, 0.1, 0.1);
                        setTimeout(() => {
                            scene.remove(target);
                            metalOres.splice(metalOres.indexOf(target), 1);
                            
                            // Add to respawn queue (5 minutes)
                            oreRespawnQueue.push({
                                respawnTime: Date.now() + 300000,
                                originalPosition: orePos,
                                type: 'metal'
                            });
                        }, 150);
                        
                        showMessage('+ 3 Iron Ore');
                    }
                } else if (target.userData.type === 'sulfur_ore') {
                    // Need pickaxe or stone pickaxe for sulfur ore
                    if (heldItem !== 'pickaxe' && heldItem !== 'stone_pickaxe') {
                        showMessage('\u26cf\ufe0f Need a pickaxe to mine sulfur!');
                        return;
                    }

                    target.userData.health--;
                    playOreMineSound();
                    playPickaxeHitSound();

                    // Shrink with each hit
                    const healthPercent = target.userData.health / target.userData.maxHealth;
                    const scale = 0.4 + (healthPercent * 0.6);
                    target.scale.set(scale, scale, scale);

                    // Green flash on hit
                    target.children.forEach(child => {
                        if (child.material) {
                            const origEmissive = child.material.emissive ? child.material.emissive.getHex() : 0;
                            const origIntensity = child.material.emissiveIntensity || 0;
                            child.material.emissive = new THREE.Color(0x44cc00);
                            child.material.emissiveIntensity = 0.6;
                            setTimeout(() => {
                                if (child.material) {
                                    child.material.emissive = new THREE.Color(origEmissive);
                                    child.material.emissiveIntensity = origIntensity;
                                }
                            }, 100);
                        }
                    });

                    if (target.userData.health <= 0) {
                        const heartyMult = activeBuffs.hearty ? 2 : 1;
                        const sulfurAmount = ((heldItem === 'pickaxe') ? 4 : 2) * heartyMult;
                        inventory.sulfur_ore += sulfurAmount;

                        const orePos = target.position.clone();

                        // Remove from collision arrays immediately
                        if (target.userData._posEntry && target.userData._posArray) {
                            const idx = target.userData._posArray.indexOf(target.userData._posEntry);
                            if (idx !== -1) target.userData._posArray.splice(idx, 1);
                        }
                        _markNatureCollidersStale();

                        target.scale.set(0.1, 0.1, 0.1);
                        setTimeout(() => {
                            scene.remove(target);
                            sulfurOres.splice(sulfurOres.indexOf(target), 1);
                            oreRespawnQueue.push({
                                respawnTime: Date.now() + 300000,
                                originalPosition: orePos,
                                type: 'sulfur'
                            });
                        }, 150);

                        showMessage(`\u26cf\ufe0f + ${sulfurAmount} Sulfur Ore`);
                        updateUI();
                    }
                } else if (target.userData.type === 'crystal_node') {
                    // Only pickaxe can mine crystal nodes
                    if (heldItem !== 'pickaxe' && heldItem !== 'stone_pickaxe') {
                        showMessage('⛏️ Need a pickaxe to mine crystal nodes!');
                        return;
                    }

                    target.userData.health--;
                    playOreMineSound();
                    playPickaxeHitSound();

                    // White-violet flash on hit (matches crystal colour palette)
                    target.traverse(child => {
                        if (child.isMesh && child.material) {
                            const origEmissive = child.material.emissive ? child.material.emissive.getHex() : 0;
                            const origIntensity = child.material.emissiveIntensity || 0;
                            child.material.emissive = new THREE.Color(0xffffff);
                            child.material.emissiveIntensity = 1.5;
                            setTimeout(() => {
                                if (child.material) {
                                    child.material.emissive = new THREE.Color(origEmissive);
                                    child.material.emissiveIntensity = origIntensity;
                                }
                            }, 110);
                        }
                    });

                    // Shrink per hit
                    const hpFrac = target.userData.health / target.userData.maxHealth;
                    const sc = 0.4 + hpFrac * 0.6;
                    target.scale.set(sc, sc, sc);

                    if (target.userData.health <= 0) {
                        const heartyMult = activeBuffs.hearty ? 2 : 1;
                        const shardAmt = (heldItem === 'pickaxe' ? 3 : 2) * heartyMult;
                        inventory.crystal_shard += shardAmt;

                        const nodePos = target.position.clone();
                        if (target.userData._posEntry && target.userData._posArray) {
                            const idx = target.userData._posArray.indexOf(target.userData._posEntry);
                            if (idx !== -1) target.userData._posArray.splice(idx, 1);
                        }
                        _markNatureCollidersStale();
                        target.scale.set(0.1, 0.1, 0.1);
                        setTimeout(() => {
                            scene.remove(target);
                            const ni = crystalNodes.indexOf(target);
                            if (ni !== -1) crystalNodes.splice(ni, 1);
                            oreRespawnQueue.push({
                                respawnTime: Date.now() + 420000,
                                originalPosition: nodePos,
                                type: 'crystal_node'
                            });
                        }, 150);
                        showMessage(`💎 + ${shardAmt} Crystal Shard`);
                        updateUI();
                    }
                } else if (target.userData.type === 'animal') {
                    // Any weapon can hunt
                    if (!['sword', 'spear', 'axe', 'pickaxe', 'sharp_stone'].includes(heldItem)) {
                        showMessage('\u2694\ufe0f Need a weapon or tool to hunt!');
                        return;
                    }
                    
                    // Damage: Sword > Spear > Tools > Sharp Stone
                    let damageAmount = 10;
                    if (heldItem === 'sword') damageAmount = 60;
                    else if (heldItem === 'spear') damageAmount = 50;
                    else if (heldItem === 'axe' || heldItem === 'pickaxe') damageAmount = 25;
                    else if (heldItem === 'sharp_stone') damageAmount = 15;
                    
                    target.userData.health -= damageAmount;
                    playHitSound();
                    
                    if (target.userData.health <= 0) {
                        const heartyMult = activeBuffs.hearty ? 2 : 1;
                        inventory.meat += 2 * heartyMult;
                        scene.remove(target);
                        window.animals.splice(window.animals.indexOf(target), 1);
                        showMessage(`+ ${2 * heartyMult} Meat`);
                    }
                } else if (target.userData.type === 'enemy') {
                    // Any weapon or tool can fight
                    if (!['sword', 'spear', 'axe', 'pickaxe', 'sharp_stone'].includes(heldItem)) {
                        showMessage('\u2694\ufe0f Need a weapon or tool to fight!');
                        return;
                    }
                    
                    // Damage: Sword > Spear > Tools > Sharp Stone
                    let damageAmount = 5;
                    if (heldItem === 'sword') damageAmount = 50;
                    else if (heldItem === 'spear') damageAmount = 40;
                    else if (heldItem === 'axe' || heldItem === 'pickaxe') damageAmount = 20;
                    else if (heldItem === 'sharp_stone') damageAmount = 10;
                    
                    target.userData.health -= damageAmount;
                    playHitSound();
                    
                    if (heldItem === 'axe' || heldItem === 'pickaxe' || heldItem === 'sharp_stone') {
                        showMessage(`\u26a0\ufe0f ${heldItem} is not very effective against enemies!`);
                    }
                    
                    if (target.userData.health <= 0) {
                        _killEnemy(target, '✅ Ghost defeated!');
                    }
                } else if (target.userData.type === 'scorpion') {
                    // Scorpions can be killed with any weapon or tool (they're small)
                    if (!['sword', 'spear', 'axe', 'pickaxe', 'sharp_stone'].includes(heldItem)) {
                        showMessage('⚔️ Use a weapon or tool to kill the scorpion!');
                        return;
                    }
                    let scorpDmg = 5;
                    if (heldItem === 'sword') scorpDmg = 25;
                    else if (heldItem === 'spear') scorpDmg = 20;
                    else if (heldItem === 'axe' || heldItem === 'pickaxe') scorpDmg = 15;
                    else if (heldItem === 'sharp_stone') scorpDmg = 8;
                    target.userData.health -= scorpDmg;
                    playHitSound();
                    if (target.userData.health <= 0) {
                        scene.remove(target);
                        scorpions.splice(scorpions.indexOf(target), 1);
                        showMessage('🦂 Scorpion killed!');
                    } else {
                        showMessage(`🦂 Hit scorpion! (${Math.max(0, target.userData.health)}/${target.userData.maxHealth} HP)`);
                    }
                } else if (target.userData.type === 'coyote') {
                    if (!['sword', 'spear', 'axe', 'pickaxe', 'sharp_stone'].includes(heldItem)) {
                        showMessage('⚔️ Use a weapon to fight the coyote!');
                        return;
                    }
                    let coyDmg = 8;
                    if (heldItem === 'sword') coyDmg = 30;
                    else if (heldItem === 'spear') coyDmg = 25;
                    else if (heldItem === 'axe' || heldItem === 'pickaxe') coyDmg = 18;
                    else if (heldItem === 'sharp_stone') coyDmg = 10;
                    target.userData.health -= coyDmg;
                    target.userData.state = 'chase';
                    playHitSound();
                    if (target.userData.health <= 0) {
                        scene.remove(target);
                        coyotes.splice(coyotes.indexOf(target), 1);
                        inventory.meat += 2; updateUI();
                        showMessage('🐺 Coyote killed! +2 Meat');
                    } else {
                        showMessage(`🐺 Hit coyote! (${Math.max(0, target.userData.health)}/${target.userData.maxHealth} HP)`);
                    }
                } else if (target.userData.type === 'squirrel') {
                    if (!['sword', 'spear', 'axe', 'pickaxe', 'sharp_stone'].includes(heldItem)) {
                        showMessage('⚔️ Use a weapon or tool to hunt!');
                        return;
                    }
                    let sqDmg = 8;
                    if (heldItem === 'sword') sqDmg = 30;
                    else if (heldItem === 'spear') sqDmg = 25;
                    else if (heldItem === 'axe' || heldItem === 'pickaxe') sqDmg = 20;
                    else if (heldItem === 'sharp_stone') sqDmg = 10;
                    target.userData.health -= sqDmg;
                    playHitSound();
                    if (target.userData.health <= 0) {
                        const heartyMult = activeBuffs.hearty ? 2 : 1;
                        inventory.meat += 1 * heartyMult;
                        scene.remove(target);
                        window.squirrels.splice(window.squirrels.indexOf(target), 1);
                        showMessage(`🐿️ Squirrel killed! +${1 * heartyMult} Meat`);
                        updateUI();
                    } else {
                        showMessage(`🐿️ Hit squirrel! (${Math.max(0, target.userData.health)}/${target.userData.maxHealth} HP)`);
                    }
                } else if (target.userData.type === 'berryBush') {
                    // Berry bushes give berries + small fiber
                    const bush = target;
                    let collected = 0;
                    bush.userData.berries.forEach(berry => {
                        if (berry.userData.isVisible) {
                            berry.visible = false;
                            berry.userData.isVisible = false;
                            berry.userData.respawnTime = 3600;
                            collected++;
                        }
                    });
                    
                    if (collected > 0) {
                        const heartyMult = activeBuffs.hearty ? 2 : 1;
                        inventory.berries += collected * heartyMult;
                        // Berry bushes give 1 fiber (less than regular grass which gives 2)
                        inventory.fiber += 1 * heartyMult;
                        // 35% chance to find worms while digging around bush roots
                        if (Math.random() < 0.35) {
                            const wormCount = 1 + Math.floor(Math.random() * 2);
                            inventory.worms = (inventory.worms || 0) + wormCount;
                            showMessage(`+ ${collected * heartyMult} Berries, + ${heartyMult} Fiber, + ${wormCount} 🪱 Worm${wormCount > 1 ? 's' : ''}!`);
                        } else {
                            showMessage(`+ ${collected * heartyMult} Berries, + ${heartyMult} Fiber`);
                        }
                        playPlantSound(); // Custom berry picking sound
                    }
                } else if (target.userData.type === 'foliageBush') {
                    // Foliage bushes give fibre — respawn after 5 minutes
                    if (!target.userData.harvestable) {
                        const minsLeft = Math.ceil((target.userData.respawnAt - Date.now()) / 60000);
                        showMessage(`⏳ Regrowth in ~${minsLeft} min`);
                        return;
                    }
                    const heartyMult = activeBuffs.hearty ? 2 : 1;
                    const fiberAmount = (2 + Math.floor(Math.random() * 3)) * heartyMult;
                    inventory.fiber = (inventory.fiber || 0) + fiberAmount;
                    playPlantSound();
                    // 35% chance to find worms under foliage bush roots
                    if (Math.random() < 0.35) {
                        const wormCount = 1 + Math.floor(Math.random() * 2);
                        inventory.worms = (inventory.worms || 0) + wormCount;
                        showMessage(`🌿 +${fiberAmount} Fiber, + ${wormCount} 🪱 Worm${wormCount > 1 ? 's' : ''}!`);
                    } else {
                        showMessage(`🌿 +${fiberAmount} Fiber`);
                    }
                    updateUI();

                    // Mark as harvested — shrink it visually
                    target.userData.harvestable = false;
                    target.userData.respawnAt   = Date.now() + 5 * 60 * 1000;
                    target.scale.set(0.4, 0.3, 0.4);
                    target.traverse(c => { if (c.isMesh && c.material) { const mats = Array.isArray(c.material) ? c.material : [c.material]; mats.forEach(m => { if (m) { m.color.multiplyScalar(0.55); m.needsUpdate = true; } }); } });

                    // Re-grow after 5 minutes
                    setTimeout(() => {
                        target.userData.harvestable = true;
                        target.userData.respawnAt   = 0;
                        target.scale.set(1, 1, 1);
                        target.traverse(c => { if (c.isMesh && c.material) { const mats = Array.isArray(c.material) ? c.material : [c.material]; mats.forEach(m => { if (m) { m.color.multiplyScalar(1 / 0.55); m.needsUpdate = true; } }); } });
                    }, 5 * 60 * 1000);
                } else if (grassBlades.includes(target)) {
                    // Grass gives good fiber
                    const heartyMult = activeBuffs.hearty ? 2 : 1;
                    inventory.fiber += 2 * heartyMult;
                    playPlantSound();
                    showMessage(`+ ${2 * heartyMult} Fiber`);
                    scene.remove(target);
                    grassBlades.splice(grassBlades.indexOf(target), 1);
                } else if (desertGrassTufts.includes(target)) {
                    // Desert grass tufts give 1-2 fiber
                    const heartyMult = activeBuffs.hearty ? 2 : 1;
                    const fiberAmount = (1 + Math.floor(Math.random() * 2)) * heartyMult;
                    inventory.fiber += fiberAmount;
                    playPlantSound();
                    showMessage('\ud83c\udf3f +' + fiberAmount + ' Fiber');
                    scene.remove(target);
                    desertGrassTufts.splice(desertGrassTufts.indexOf(target), 1);
                } else if (cacti.includes(target)) {
                    // Cacti give cloth when harvested — then disappear and respawn elsewhere
                    if (!target.userData.hasCloth) {
                        showMessage('🌵 Already harvested — come back later');
                        return;
                    }
                    const heartyMult = activeBuffs.hearty ? 2 : 1;
                    const clothAmount = (1 + Math.floor(Math.random() * 2)) * heartyMult;
                    inventory.cloth = (inventory.cloth || 0) + clothAmount;
                    playPlantSound();
                    showMessage('🌵 +' + clothAmount + ' Cloth');

                    // Remove from scene, cacti array, and cactiPositions collision
                    scene.remove(target);
                    const ci = cacti.indexOf(target);
                    if (ci !== -1) cacti.splice(ci, 1);
                    // Remove matching position entry
                    const cpIdx = cactiPositions.findIndex(p => Math.abs(p.x - target.position.x) < 0.1 && Math.abs(p.z - target.position.z) < 0.1);
                    if (cpIdx !== -1) cactiPositions.splice(cpIdx, 1);
                    _markNatureCollidersStale();

                    // Respawn a new cactus at a different desert location after ~5 real minutes
                    setTimeout(() => {
                        const dcMargin  = 8;
                        const dcCenterZ = -desertOffset + 0.5;
                        const dcHalf    = groundSize / 2 - dcMargin;
                        const dcXMin    = -groundSize / 2 + dcMargin;
                        const dcXMax    =  groundSize / 2 - dcMargin;
                        const dcZMin    = dcCenterZ - dcHalf;
                        const dcZMax    = dcCenterZ + dcHalf - 18;
                        let fx, fz, valid = false, attempts = 0;
                        do {
                            fx = dcXMin + Math.random() * (dcXMax - dcXMin);
                            fz = dcZMin + Math.random() * (dcZMax - dcZMin);
                            valid = true;
                            for (const ob of desertFormationColliders) {
                                if (Math.sqrt((fx-ob.x)**2+(fz-ob.z)**2) < ob.r + 1.5) { valid=false; break; }
                            }
                            if (valid) {
                                for (const p of [...rockPositions, ...orePositions, ...sulfurPositions, ...cactiPositions]) {
                                    if (Math.sqrt((fx-p.x)**2+(fz-p.z)**2) < 4) { valid=false; break; }
                                }
                            }
                            attempts++;
                        } while (!valid && attempts < 80);
                        if (valid) createCactus(fx, fz);
                    }, 5 * 60 * 1000); // 5 real minutes
                } // end else if (cacti)
                
                updateUI();
            }
        }
        
        // Handle building placement from hotbar
        async function handleBuildingPlacement() {
            const heldItem = hotbar[selectedHotbarSlot].item;
            
            // Check if held item is a buildable/placeable
            const placeables = ['wall', 'window_wall', 'floor', 'ceiling', 'ladder_ceiling', 'stairs', 'corner_stairs_left', 'corner_stairs_right', 'ladder', 'door_frame', 'door', 'double_door', 'stone_door', 'stone_double_door', 'metal_door', 'metal_double_door', 'double_door_frame', 'campfire', 'workbench', 'building_bench', 'furnace', 'storage_box', 'sleeping_bag', 'small_storage_box', 'storage_shelf', 'wall_shelf', 'sewing_table', 'recycler', 'water_catcher', 'floor_rug_red', 'floor_rug_blue', 'floor_rug_green', 'curtain_red', 'curtain_blue', 'curtain_green', 'curtain_white', 'curtain_beige', 'planter_box', 'large_planter', 'cooking_station', 'sofa', 'bookcase', 'table', 'chair', 'wall_shelf_b', 'candle', 'wall_light', 'bee_hive', 'chicken_coop', 'oil_smelter'];
            
            if (placeables.includes(heldItem) && inventory[heldItem] > 0) {
                // Check if this item has a create function in buildingTypes
                if (!buildingTypes[heldItem]) {
                    showMessage(`\u274c Cannot place ${heldItem}!`);
                    return;
                }
                
                // Enter build mode with this item
                buildMode = heldItem;
                
                if (buildPreview) scene.remove(buildPreview);
                buildPreview = await buildAndPlaceModel(heldItem);
                buildPreview.traverse((child) => {
                    if (child.isMesh) {
                        child.userData.originalMaterial = child.material;
                        const isStairs = (heldItem === 'stairs' || heldItem === 'corner_stairs_left' || heldItem === 'corner_stairs_right');
                        child.material = isStairs ? _previewMatStairs : _previewMat;
                        child.renderOrder = isStairs ? 1000 : 999;
                        if (isStairs) { child.castShadow = false; child.receiveShadow = false; }
                    }
                });
                
                // Ensure the preview is visible
                buildPreview.visible = true;
                if (heldItem === 'stairs' || heldItem === 'corner_stairs_left' || heldItem === 'corner_stairs_right') {
                    buildPreview.renderOrder = 1000;
                }
                
                scene.add(buildPreview);
                document.getElementById('build-info').style.display = 'block';
                document.getElementById('build-info').textContent = 'Left click to place, R to rotate, ESC to cancel';
            }
        }
        
        // ===== DAY/NIGHT CYCLE =====
        function updateDayNight() {
            gameTime++;
            // Update time of day (if not paused by admin)
            if (!timeIsPaused) {
                time += 0.0005; // ~24 hours = 40 minutes real time
                
                if (time >= 24) {
                    time = 0;
                    day++;
                }
            }
            
            // Update sun position (light)
            const sunAngle = (time / 24) * Math.PI * 2 - Math.PI / 2;
            sun.position.x = Math.cos(sunAngle) * 100;
            sun.position.y = Math.sin(sunAngle) * 100 + 20;
            sun.position.z = 50;

            // Only update shadows during daytime — saves significant GPU at night/horizon
            // Dawn starts ~5, dusk ends ~19; add small buffer (5.5–18.5) to avoid snapping
            sun.shadow.autoUpdate = (time >= 5.5 && time <= 18.5);
            
            // Smooth day/night blend using a 0?1 curve
            // Dawn: 5?7, Day: 7?17, Dusk: 17?19, Night: 19?5
            let dayBlend; // 1 = full day, 0 = full night
            if (time >= 7 && time < 17) {
                dayBlend = 1;
            } else if (time >= 5 && time < 7) {
                dayBlend = (time - 5) / 2; // dawn ramp
            } else if (time >= 17 && time < 19) {
                dayBlend = 1 - (time - 17) / 2; // dusk ramp
            } else {
                dayBlend = 0;
            }

            const daySkyTop    = _skyDayTop;
            const daySkyBot    = _skyDayBot;
            const nightSkyTop  = _skyNightTop;
            const nightSkyBot  = _skyNightBot;

            // Calculate normal sky colors based on time of day
            const normalTop = _skyNormalTop.lerpColors(nightSkyTop, daySkyTop, dayBlend);
            const normalBot = _skyNormalBot.lerpColors(nightSkyBot, daySkyBot, dayBlend);
            
            // Storm sky colors that adapt to time of day
            // Day storm: lighter grey, Night storm: very dark grey
            const stormDaySkyTop = _skyStormDayTop;
            const stormDaySkyBot = _skyStormDayBot;
            const stormNightSkyTop = _skyStormNightTop;
            const stormNightSkyBot = _skyStormNightBot;
            
            // Lerp storm colors based on day/night
            const stormSkyTop = _skyStormTop.lerpColors(stormNightSkyTop, stormDaySkyTop, dayBlend);
            const stormSkyBot = _skyStormBot.lerpColors(stormNightSkyBot, stormDaySkyBot, dayBlend);
            
            // Initialize rain transition progress if not exists
            if (typeof window.rainTransitionProgress === 'undefined') {
                window.rainTransitionProgress = 0;
            }
            
            // Smoothly transition rain progress (0 = clear, 1 = storm)
            const transitionSpeed = 0.008; // Adjust for faster/slower transition
            if (isRaining) {
                window.rainTransitionProgress = Math.min(1, window.rainTransitionProgress + transitionSpeed);
            } else {
                window.rainTransitionProgress = Math.max(0, window.rainTransitionProgress - transitionSpeed);
            }
            
            // Lerp between normal and storm colors based on transition progress
            const curTop = _skyCurTop.lerpColors(normalTop, stormSkyTop, window.rainTransitionProgress);
            const curBot = _skyCurBot.lerpColors(normalBot, stormSkyBot, window.rainTransitionProgress);

            sky.material.uniforms.topColor.value.copy(curTop);
            sky.material.uniforms.bottomColor.value.copy(curBot);

            // Lighting ? Balanced brightness
            const lightIntensity   = 0.05 + dayBlend * (1.2 + Math.sin(Math.max(0, dayBlend) * Math.PI) * 0.5);
            const ambientIntensity = 0.02 + dayBlend * (0.35 + Math.sin(Math.max(0, dayBlend) * Math.PI) * 0.15);
            sun.intensity = lightIntensity;
            ambientLight.intensity = ambientIntensity;
            hemiLight.intensity = 0.005 + dayBlend * 0.545;
            hemiLight.color.copy(curTop);
            hemiLight.groundColor.copy(curBot);

            // Fog colour matches sky bottom
            const fogHex = curBot.getHex();
            scene.fog.color.setHex(fogHex);
            renderer.setClearColor(fogHex);

            // Drive sky shader uniforms for stars + aurora + sun + moon
            const nightBlend = 1 - dayBlend;
            sky.material.uniforms.uNight.value      = nightBlend;
            sky.material.uniforms.uDayBlend.value   = dayBlend;
            sky.material.uniforms.uTime.value       = (sky.material.uniforms.uTime.value + 0.016) % 100.0;
            sky.material.uniforms.uAuroraTime.value = (sky.material.uniforms.uAuroraTime.value + 0.022) % 100.0;

            // Sun: rises east (+x), arcs through south (+z offset), sets west (-x)
            const sunA = (time / 24) * Math.PI * 2 - Math.PI / 2;
            const sunDirRaw = sky.material.uniforms.uSunDir.value;
            sunDirRaw.set(Math.cos(sunA), Math.sin(sunA), 0.15).normalize();
            // Moon: opposite the sun
            const moonDirX = -Math.cos(sunA), moonDirY = -Math.sin(sunA), moonDirZ = -0.15;
            const moonDirLen = Math.sqrt(moonDirX*moonDirX + moonDirY*moonDirY + moonDirZ*moonDirZ);
            sky.material.uniforms.uMoonDir.value.set(
                moonDirX/moonDirLen, moonDirY/moonDirLen, moonDirZ/moonDirLen
            );

            // Move sun sprite to match sun direction (only visible above horizon)
            if (window._sunSprite) {
                const sx = sunDirRaw.x, sy = sunDirRaw.y, sz = sunDirRaw.z;
                const sunElevation = Math.max(sy, 0.25); // clamp so it doesn't dip below camera
                const sLen = Math.sqrt(sx*sx + sunElevation*sunElevation + sz*sz);
                const sd = window._sunDist;
                window._sunSprite.position.set(
                    camera.position.x + (sx/sLen) * sd,
                    camera.position.y + (sunElevation/sLen) * sd,
                    camera.position.z + (sz/sLen) * sd
                );
                // Fade out at/below horizon, fade in with dayBlend
                window._sunSprite.material.opacity = dayBlend * (1.0 - window.rainTransitionProgress);
                // Shift disc colour toward orange/red at horizon (limb reddening)
                const redness = Math.max(0, 1 - sunDirRaw.y / 0.15);
                window._sunSpriteMat.color.setRGB(1.0, Math.max(0.55, 1.0 - redness * 0.45), Math.max(0.1, 1.0 - redness * 0.9));
            }

            // Move moon sprite to match moon direction
            if (window._moonSprite) {
                const nx = moonDirX/moonDirLen;
                const ny = moonDirY/moonDirLen;
                const nz = moonDirZ/moonDirLen;
                const moonElevation = Math.max(ny, 0.25);
                const mLen2 = Math.sqrt(nx*nx + moonElevation*moonElevation + nz*nz);
                const md = window._moonDist;
                window._moonSprite.position.set(
                    camera.position.x + (nx/mLen2) * md,
                    camera.position.y + (moonElevation/mLen2) * md,
                    camera.position.z + (nz/mLen2) * md
                );
                window._moonSprite.material.opacity = nightBlend;
            }

            _updateShootingStars(nightBlend);

            // Night enemy spawning
            if (dayBlend === 0 && gameTime % 300 === 0) {
                spawnEnemies();
            }
            
            // Keep shadow frustum centred on player so quality is always tight around them
            sun.target.position.set(camera.position.x, 0, camera.position.z);
            sun.target.updateMatrixWorld();
            sun.shadow.camera.updateProjectionMatrix();

            // Update time display
            const hours = Math.floor(time);
            const minutes = Math.floor((time % 1) * 60);
            const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            const icon = dayBlend > 0.5 ? '\u2600\ufe0f' : dayBlend > 0 ? '\ud83c\udf05' : '\ud83c\udf19';
            if (!_cachedTimeEl) _cachedTimeEl = document.getElementById('time');
            if (_cachedTimeEl) _cachedTimeEl.textContent = `${icon} ${timeString}`;
            
            // Update stats - constant drain rate, food faster than water
            // Hunger drains every 1000 frames (~16.7 seconds at 60fps)
            // Thirst drains every 1400 frames (~23.3 seconds at 60fps)
            if (gameTime % 1000 === 0) {
                if (!activeBuffs.fortified_gut) {
                    const hungerMult = activeBuffs.well_fed ? 0.6 : 1.0;
                    // Apply as fractional drain using a counter
                    if (hungerMult === 1.0 || (gameTime % Math.round(1000 / hungerMult) === 0)) {
                        hunger = Math.max(0, hunger - 1);
                    }
                }
                updateUI();
            }
            
            if (gameTime % 1400 === 0) {
                if (!activeBuffs.fortified_gut) {
                    const thirstMult = activeBuffs.hydrated ? 0.65 : 1.0;
                    if (thirstMult === 1.0 || (gameTime % Math.round(1400 / thirstMult) === 0)) {
                        thirst = Math.max(0, thirst - 1);
                    }
                }
                updateUI();
            }
            
            // Health damage when stats are empty
            if (gameTime % 240 === 0) {
                if (hunger === 0) health = Math.max(0, health - 2);
                if (thirst === 0) health = Math.max(0, health - 3);
                
                if (health <= 0) {
                    die();
                }
                
                updateUI();
            }
        }

        // Helper — triggers death animation then removes from scene/array after it finishes
        function _killEnemy(target, message) {
            if (target.userData._dying) return;
            target.userData._dying = true;
            target.userData._deathTimer = 0;
            showMessage(message);
            if (target.userData.ghostPlayAnim) {
                target.userData.ghostPlayAnim('death', false, 1.0);
            }
        }

        // ===== ENEMY AI (Slower movement with eye animation) =====
        function updateEnemies() {
            const now = Date.now();
            const FULL_DIST  = 30;   // full 60fps AI within 30 units
            const HALF_DIST  = 60;   // half-rate (every other frame) 30–60 units
            // Beyond 60 units enemies already despawn (see distance > 80 check below)
            enemies.forEach((enemy, index) => {

                // ── Distance throttle ──────────────────────────────────────────
                // Enemies far from the player don't need full-rate AI. Skip on odd
                // frames for mid-range, skip entirely for very far (they'll despawn anyway).
                const _dx = enemy.position.x - camera.position.x;
                const _dz = enemy.position.z - camera.position.z;
                const _dSq = _dx*_dx + _dz*_dz;
                if (_dSq > HALF_DIST * HALF_DIST) {
                    // Only update every other frame for distant enemies
                    enemy.userData._throttleFrame = (enemy.userData._throttleFrame || 0) + 1;
                    if (enemy.userData._throttleFrame % 2 !== 0) return;
                }

                // ── Mixer tick ──
                if (enemy.userData.ghostMixer) {
                    if (!enemy.userData._mixerLast) enemy.userData._mixerLast = now;
                    const dt = Math.min((now - enemy.userData._mixerLast) / 1000, 0.1);
                    enemy.userData._mixerLast = now;
                    enemy.userData.ghostMixer.update(dt);
                }

                // ── Death sequence — wait for anim then remove ──
                if (enemy.userData._dying) {
                    enemy.userData._deathTimer += 0.016;
                    if (enemy.userData._deathTimer > 1.8) {
                        scene.remove(enemy);
                        enemies.splice(index, 1);
                    }
                    return; // no further AI while dying
                }

                // ── Hover bob ──
                enemy.userData._hoverPhase = (enemy.userData._hoverPhase || 0) + 0.025;
                enemy.position.y = enemy.userData._hoverBase + Math.sin(enemy.userData._hoverPhase) * 0.18;

                const distance = camera.position.distanceTo(enemy.position);

                // Initialize persistent state
                if (!enemy.userData.stuckTimer)        enemy.userData.stuckTimer = 0;
                if (!enemy.userData.lastPosition)      enemy.userData.lastPosition = enemy.position.clone();
                if (!enemy.userData.wanderTarget)      enemy.userData.wanderTarget = null;
                if (!enemy.userData.positionCheckTimer) enemy.userData.positionCheckTimer = 0;

                // Stuck detection
                enemy.userData.positionCheckTimer++;
                if (enemy.userData.positionCheckTimer >= 60) {
                    const moveDistance = enemy.position.distanceTo(enemy.userData.lastPosition);
                    if (moveDistance < 0.5 && distance < 30) enemy.userData.stuckTimer++;
                    else enemy.userData.stuckTimer = 0;
                    enemy.userData.lastPosition = enemy.position.clone();
                    enemy.userData.positionCheckTimer = 0;
                }
                if (enemy.userData.stuckTimer >= 20 && !enemy.userData.wanderTarget) {
                    const randomAngle = Math.random() * Math.PI * 2;
                    const randomDistance = 20 + Math.random() * 30;
                    enemy.userData.wanderTarget = new THREE.Vector3(
                        enemy.position.x + Math.cos(randomAngle) * randomDistance,
                        enemy.userData._hoverBase,
                        enemy.position.z + Math.sin(randomAngle) * randomDistance
                    );
                    showMessage('👻 Ghost is wandering...');
                }

                // ── Sound ──
                if (!enemy.userData.soundTimer) enemy.userData.soundTimer = 0;
                enemy.userData.soundTimer += 0.016;
                const timeSinceAttack = now - (enemy.userData.lastAttackTime || 0);
                if (enemy.userData.soundTimer > 2 + Math.random() * 3 && timeSinceAttack > 2000) {
                    enemy.userData.soundTimer = 0;
                    const maxHear = 15;
                    if (distance < maxHear) {
                        let vol = distance <= 1 ? 0.5 : distance <= 5
                            ? 0.5 * (1 - ((distance - 1) / 4) * 0.6)
                            : 0.2 * (1 - (distance - 5) / (maxHear - 5));
                        if (vol > 0.02) playEnemySound(vol);
                    }
                }

                // ── Movement (wander or chase) ──
                const enemyRadius = 0.5;
                let moveDir = null;

                if (enemy.userData.wanderTarget) {
                    const distToTarget = enemy.position.distanceTo(enemy.userData.wanderTarget);
                    if (distToTarget < 2) {
                        enemy.userData.wanderTarget = null;
                        enemy.userData.stuckTimer = 0;
                    } else {
                        _scratchV3a.subVectors(enemy.userData.wanderTarget, enemy.position).normalize();
                        moveDir = _scratchV3a;
                        moveDir.y = 0;
                    }
                } else if (distance < 30) {
                    _scratchV3b.subVectors(camera.position, enemy.position).normalize();
                    _scratchRaycaster.set(enemy.position, _scratchV3b);
                    const wallHits = _scratchRaycaster.intersectObjects(buildings, true);
                    const hasLOS = wallHits.length === 0 || wallHits[0].distance >= distance;
                    if (hasLOS) {
                        _scratchV3a.subVectors(camera.position, enemy.position).normalize();
                        moveDir = _scratchV3a;
                        moveDir.y = 0;
                    }
                }

                if (moveDir && !enemy.userData._attackAnim) {
                    moveDir.normalize();
                    const newPos = _scratchV3c.copy(enemy.position).addScaledVector(moveDir, 0.025);
                    newPos.y = enemy.position.y; // preserve hover Y
                    _scratchBox.set(
                        _scratchV3a.set(newPos.x - enemyRadius, newPos.y - 1, newPos.z - enemyRadius),
                        _scratchV3b.set(newPos.x + enemyRadius, newPos.y + 1, newPos.z + enemyRadius)
                    );
                    let canMove = !collidesWithNature(newPos, enemyRadius);
                    if (canMove) for (const building of buildings) {
                        if (building.userData.isDoor && building.userData.isOpen) continue;
                        if (_scratchBox.intersectsBox(_scratchBox2.setFromObject(building))) { canMove = false; break; }
                    }
                    if (canMove) enemy.position.copy(newPos);
                    // Face direction
                    enemy.rotation.y = Math.atan2(moveDir.x, moveDir.z);
                }

                // ── Fly animation when moving, idle when stopped ──
                if (!enemy.userData._attackAnim && enemy.userData.ghostPlayAnim) {
                    if (moveDir && distance > 2) {
                        enemy.userData.ghostPlayAnim('fly', true, 1.0);
                    } else if (!moveDir) {
                        enemy.userData.ghostPlayAnim('fly', true, 0.5); // slow hover in place
                    }
                }

                // ── Attack — headbutt when in range ──
                if (distance < 2 && !enemy.userData._attackAnim) {
                    const currentTime = now;
                    if (currentTime - enemy.userData.lastAttackTime > 1500) {
                        enemy.userData.lastAttackTime = currentTime;
                        enemy.userData._attackAnim = true;

                        // Play headbutt
                        if (enemy.userData.ghostPlayAnim) {
                            enemy.userData.ghostPlayAnim('headbutt', false, 1.0, () => {
                                enemy.userData._attackAnim = false;
                                if (enemy.userData.ghostPlayAnim) enemy.userData.ghostPlayAnim('fly', true, 1.0);
                            });
                        } else {
                            setTimeout(() => { enemy.userData._attackAnim = false; }, 800);
                        }

                        // Deal damage
                        health = Math.max(0, health - 10);
                        const attackVol = Math.max(0, (1 - distance / 20)) * (volumeSettings.enemies || 1) * 0.95;
                        if (attackVol > 0.01) playEnemyAttackSound(attackVol);
                        showMessage('💥 Ghost headbutted you! -10 health');
                        updateUI();
                        if (health <= 0) die();
                    }
                }

                // ── Despawn at dawn or too far ──
                // Despawn at dawn or if too far
                if (distance > 80 || (time >= 6 && time < 18)) {
                    scene.remove(enemy);
                    enemies.splice(index, 1);
                }
            });
        }
        
        // ===== ANIMAL AI (Original behavior with fixed ground positioning) =====
        function updateAnimals() {
            if (!window.animals) return;
            const FULL_DIST = 25;   // full rate within 25 units
            const SKIP_DIST = 60;   // skip entirely beyond 60 units (invisible anyway)
            
            window.animals.forEach(animal => {
                // ── Distance throttle ──────────────────────────────────────────
                const _dx = animal.position.x - camera.position.x;
                const _dz = animal.position.z - camera.position.z;
                const _dSq = _dx*_dx + _dz*_dz;
                if (_dSq > SKIP_DIST * SKIP_DIST) return; // too far — skip entirely
                if (_dSq > FULL_DIST * FULL_DIST) {
                    animal.userData._throttleFrame = (animal.userData._throttleFrame || 0) + 1;
                    if (animal.userData._throttleFrame % 3 !== 0) return; // ~20fps for mid-range
                }

                // Sound effect - each animal has its own random interval
                if (!animal.userData.soundTimer) animal.userData.soundTimer = 0;
                if (!animal.userData.soundInterval) {
                    // Each animal gets a random interval between 20-60 seconds
                    animal.userData.soundInterval = 20 + Math.random() * 40;
                }
                
                animal.userData.soundTimer += 0.016;
                
                if (animal.userData.soundTimer > animal.userData.soundInterval) {
                    animal.userData.soundTimer = 0;
                    // Set new random interval for next sound
                    animal.userData.soundInterval = 20 + Math.random() * 40;
                    
                    const distance = camera.position.distanceTo(animal.position);
                    const maxHearDistance = 5; // Can barely hear up to 5 units away
                    const optimalDistance = 1; // Full volume within 1 meter
                    
                    if (distance < maxHearDistance) {
                        let volume = 0;
                        
                        if (distance <= optimalDistance) {
                            // Within 1 meter - full volume (0.15)
                            volume = 0.15;
                        } else {
                            // Beyond 1 meter - very rapid falloff, almost silent
                            const falloffFactor = (distance - optimalDistance) / (maxHearDistance - optimalDistance);
                            // Exponential falloff for very faint sound
                            volume = 0.15 * Math.pow(1 - falloffFactor, 4); // Power of 4 for steep falloff
                        }
                        
                        if (volume > 0.01) { // Only play if volume is audible
                            playAnimalSound(volume);
                        }
                    }
                }
                
                // Movement
                const animalNextPos = _scratchV3a.copy(animal.position).add(animal.userData.velocity);
                if (collidesWithNature(animalNextPos, 0.4)) {
                    // Bounce off obstacle – pick a new random direction
                    animal.userData.velocity.set(
                        (Math.random() - 0.5) * 0.02,
                        0,
                        (Math.random() - 0.5) * 0.02
                    );
                    // Stuck detection: count consecutive blocked frames
                    animal.userData.stuckFrames = (animal.userData.stuckFrames || 0) + 1;
                    if (animal.userData.stuckFrames > 60) {
                        // Try up to 16 escape directions at increasing radii
                        let freed = false;
                        for (let attempt = 0; attempt < 16 && !freed; attempt++) {
                            const angle = Math.random() * Math.PI * 2;
                            const radius = 0.5 + (attempt * 0.25);
                            const escapePos = _scratchV3a.set(
                                animal.position.x + Math.cos(angle) * radius,
                                animal.position.y,
                                animal.position.z + Math.sin(angle) * radius
                            );
                            if (!collidesWithNature(escapePos, 0.4)) {
                                animal.position.copy(escapePos);
                                animal.userData.velocity.set(
                                    Math.cos(angle) * 0.015,
                                    0,
                                    Math.sin(angle) * 0.015
                                );
                                freed = true;
                            }
                        }
                        animal.userData.stuckFrames = 0;
                    }
                } else {
                    animal.position.copy(animalNextPos);
                    animal.userData.stuckFrames = 0;
                }
                
                if (Math.random() < 0.01) {
                    animal.userData.velocity.set(
                        (Math.random() - 0.5) * 0.02,
                        0,
                        (Math.random() - 0.5) * 0.02
                    );
                }
                
                if (Math.abs(animal.position.x) > 80 || Math.abs(animal.position.z) > 80) {
                    animal.userData.velocity.multiplyScalar(-1);
                }
                
                // Keep at ground level - fixed height
                animal.position.y = 0.3;

                // Gentle head bob when moving
                animal.userData.animTime += 0.04;
                const at = animal.userData.animTime;
                const moving = animal.userData.velocity.length() > 0.001;
                if (animal.userData.head) {
                    animal.userData.head.rotation.x = moving ? Math.sin(at * 6.5) * 0.07 : 0;
                }
                
                // Face movement direction
                if (animal.userData.velocity.length() > 0.001) {
                    const yawAngle = Math.atan2(animal.userData.velocity.x, animal.userData.velocity.z);
                    animal.rotation.y = yawAngle;
                }
            });
        }
        
        // ===== SQUIRREL AI (Original behavior with fixed ground positioning) =====
        function updateSquirrels() {
            if (!window.squirrels) return;
            
            const now = Date.now();
            const FULL_DIST = 20;   // full rate within 20 units
            const SKIP_DIST = 50;   // skip entirely beyond 50 units
            window.squirrels.forEach(squirrel => {
                // ── Distance throttle ──────────────────────────────────────────
                const _dx = squirrel.position.x - camera.position.x;
                const _dz = squirrel.position.z - camera.position.z;
                const _dSq = _dx*_dx + _dz*_dz;
                if (_dSq > SKIP_DIST * SKIP_DIST) return; // too far — skip entirely
                if (_dSq > FULL_DIST * FULL_DIST) {
                    squirrel.userData._throttleFrame = (squirrel.userData._throttleFrame || 0) + 1;
                    if (squirrel.userData._throttleFrame % 3 !== 0) return; // ~20fps for mid-range
                }

                // ── Mixer tick ──
                if (squirrel.userData.sqMixer) {
                    if (!squirrel.userData._mixerLast) squirrel.userData._mixerLast = now;
                    const dt = Math.min((now - squirrel.userData._mixerLast) / 1000, 0.1);
                    squirrel.userData._mixerLast = now;
                    squirrel.userData.sqMixer.update(dt);
                }

                // ── Sound effect ──
                if (!squirrel.userData.soundTimer) squirrel.userData.soundTimer = 0;
                if (!squirrel.userData.soundInterval) squirrel.userData.soundInterval = 30 + Math.random() * 60;
                squirrel.userData.soundTimer += 0.016;
                if (squirrel.userData.soundTimer > squirrel.userData.soundInterval) {
                    squirrel.userData.soundTimer = 0;
                    squirrel.userData.soundInterval = 30 + Math.random() * 60;
                    const distance = camera.position.distanceTo(squirrel.position);
                    if (distance < 5) {
                        const falloff = Math.max(0, 1 - distance / 5);
                        const vol = 0.15 * Math.pow(falloff, 4);
                        if (vol > 0.01) playSquirrelSound(vol);
                    }
                }

                // ── Flee from player ──
                const FLEE_RADIUS   = 6.0;  // start running when player is within 6 units
                const ALERT_RADIUS  = 10.0; // stop and look around when within 10 units
                const FLEE_SPEED    = 0.07;
                const WANDER_SPEED  = 0.018;

                const flatDist = Math.sqrt(
                    Math.pow(camera.position.x - squirrel.position.x, 2) +
                    Math.pow(camera.position.z - squirrel.position.z, 2)
                );

                if (flatDist < FLEE_RADIUS) {
                    // Sprint directly away from player
                    squirrel.userData.state = 'flee';
                    const awayX = squirrel.position.x - camera.position.x;
                    const awayZ = squirrel.position.z - camera.position.z;
                    const len   = Math.sqrt(awayX * awayX + awayZ * awayZ) || 1;
                    squirrel.userData.velocity.set(
                        (awayX / len) * FLEE_SPEED,
                        0,
                        (awayZ / len) * FLEE_SPEED
                    );
                } else if (flatDist < ALERT_RADIUS) {
                    // Alert — freeze and face player
                    squirrel.userData.state = 'alert';
                    squirrel.userData.velocity.set(0, 0, 0);
                    const toPlayerAngle = Math.atan2(
                        camera.position.x - squirrel.position.x,
                        camera.position.z - squirrel.position.z
                    );
                    squirrel.rotation.y = toPlayerAngle;
                } else {
                    // Normal wander / sit behaviour when player is far away
                    squirrel.userData.wanderTimer -= 0.016;
                    if (squirrel.userData.state === 'flee' || squirrel.userData.state === 'alert') {
                        // Just escaped — reset to wander
                        squirrel.userData.state = 'wander';
                        squirrel.userData.wanderTimer = 1.5 + Math.random() * 3;
                    }
                    if (squirrel.userData.state === 'wander') {
                        if (squirrel.userData.wanderTimer <= 0) {
                            if (Math.random() < 0.4) {
                                squirrel.userData.state       = 'sit';
                                squirrel.userData.sitDuration = 2 + Math.random() * 4;
                                squirrel.userData.sitTimer    = 0;
                                squirrel.userData.velocity.set(0, 0, 0);
                                if (squirrel.userData.sqPlayAnim) squirrel.userData.sqPlayAnim('sit', true, 1.0);
                            } else {
                                squirrel.userData.wanderTimer = 1.5 + Math.random() * 3;
                            }
                        }
                    } else if (squirrel.userData.state === 'sit') {
                        squirrel.userData.sitTimer += 0.016;
                        if (squirrel.userData.sitTimer >= squirrel.userData.sitDuration) {
                            squirrel.userData.state = 'wander';
                            squirrel.userData.wanderTimer = 1.5 + Math.random() * 3;
                            squirrel.userData.velocity.set(
                                (Math.random() - 0.5) * WANDER_SPEED,
                                0,
                                (Math.random() - 0.5) * WANDER_SPEED
                            );
                            if (squirrel.userData.sqPlayAnim) squirrel.userData.sqPlayAnim('walk', true, 1.0);
                        }
                        return; // Don't move while sitting
                    }
                    // Random direction nudge while wandering
                    if (Math.random() < 0.02) {
                        squirrel.userData.velocity.set(
                            (Math.random() - 0.5) * WANDER_SPEED,
                            0,
                            (Math.random() - 0.5) * WANDER_SPEED
                        );
                    }
                }

                // ── Movement ──
                const nextPos = _scratchV3a.copy(squirrel.position).add(squirrel.userData.velocity);
                if (collidesWithNature(nextPos, 0.25)) {
                    squirrel.userData.velocity.set(
                        (Math.random() - 0.5) * 0.03, 0, (Math.random() - 0.5) * 0.03
                    );
                    squirrel.userData.stuckFrames = (squirrel.userData.stuckFrames || 0) + 1;
                    if (squirrel.userData.stuckFrames > 60) {
                        for (let attempt = 0; attempt < 16; attempt++) {
                            const angle = Math.random() * Math.PI * 2;
                            const radius = 0.4 + attempt * 0.2;
                            const escapePos = _scratchV3b.set(
                                squirrel.position.x + Math.cos(angle) * radius,
                                squirrel.position.y,
                                squirrel.position.z + Math.sin(angle) * radius
                            );
                            if (!collidesWithNature(escapePos, 0.25)) {
                                squirrel.position.copy(escapePos);
                                squirrel.userData.velocity.set(Math.cos(angle)*0.02, 0, Math.sin(angle)*0.02);
                                break;
                            }
                        }
                        squirrel.userData.stuckFrames = 0;
                    }
                } else {
                    squirrel.position.copy(nextPos);
                    squirrel.userData.stuckFrames = 0;
                }

                // Random direction changes
                if (Math.random() < 0.02) {
                    squirrel.userData.velocity.set(
                        (Math.random() - 0.5) * 0.03, 0, (Math.random() - 0.5) * 0.03
                    );
                }

                // ── Face direction of travel (skip in alert — rotation already set toward player) ──
                if (squirrel.userData.state !== 'alert' && squirrel.userData.velocity.length() > 0.001) {
                    const yaw = Math.atan2(squirrel.userData.velocity.x, squirrel.userData.velocity.z);
                    squirrel.rotation.y = yaw;
                }

                // ── Animation selection ──
                const speed = squirrel.userData.velocity.length();
                if (squirrel.userData.sqPlayAnim) {
                    if (squirrel.userData.state === 'flee') {
                        squirrel.userData.sqPlayAnim('run', true, 1.5);
                    } else if (squirrel.userData.state === 'alert') {
                        squirrel.userData.sqPlayAnim('idle', true, 1.0);
                    } else if (speed > 0.005) {
                        squirrel.userData.sqPlayAnim('walk', true, 1.0);
                    } else {
                        squirrel.userData.sqPlayAnim('idle', true, 1.0);
                    }
                }
            });
        }
        
        // ===== ANIMATIONS =====
        function updateGrass() {
            grassBlades.forEach(grass => {
                const sway = Math.sin(_frameTime * grass.userData.windSpeed + grass.userData.windPhase) * 0.15;
                grass.rotation.x = sway;
            });
            // Desert tufts sway slowly - dry heat droop
            desertGrassTufts.forEach(tuft => {
                const sway = Math.sin(_frameTime * tuft.userData.windSpeed + tuft.userData.windPhase) * 0.09;
                tuft.rotation.x = sway;
                tuft.rotation.z = Math.sin(_frameTime * tuft.userData.windSpeed * 0.7 + tuft.userData.windPhase) * 0.05;
            });
        }
        
        function updateClouds() {
            const darkCloudColor   = _cloudDark;
            const brightCloudColor = _cloudBright;

            // Fade clouds at night so stars/aurora show through
            const nightBlend = sky.material.uniforms.uNight ? sky.material.uniforms.uNight.value : 0;
            const nightFade  = Math.max(0, 1 - nightBlend * 2.5);

            clouds.forEach(cloud => {
                cloud.position.x += cloud.userData.speed;
                if (cloud.position.x > 310) cloud.position.x = -110;

                const float = Math.sin(_frameTime * cloud.userData.floatSpeed + cloud.userData.floatPhase);
                cloud.position.y = cloud.userData.baseY + float * 0.5;
                cloud.material.opacity = (cloud.userData.baseOpacity + Math.abs(float) * 0.08) * nightFade;

                cloud.visible = cloud.material.opacity > 0.01;
                if (!cloud.visible) return;

                // Storm colour transition — PointsMaterial only has .color
                if (typeof cloud.userData.stormProgress === 'undefined') cloud.userData.stormProgress = 0;
                const spd = 0.01;
                if (isRaining) cloud.userData.stormProgress = Math.min(1, cloud.userData.stormProgress + spd);
                else           cloud.userData.stormProgress = Math.max(0, cloud.userData.stormProgress - spd);

                const targetColor = _cloudTarget.lerpColors(brightCloudColor, darkCloudColor, cloud.userData.stormProgress * 0.7);
                cloud.material.color.copy(targetColor);
            });
        }
        
        function updateBerryRespawn() {
            // Cactus respawn is now handled by setTimeout in the harvest handler —
            // harvested cacti are removed from scene and respawn at a new desert
            // location after 5 minutes. No frame-counter needed here.

            berryBushes.forEach(bush => {
                bush.userData.berries.forEach(berry => {
                    if (!berry.userData.isVisible && berry.userData.respawnTime > 0) {
                        berry.userData.respawnTime--;
                        if (berry.userData.respawnTime <= 0) {
                            berry.visible = true;
                            berry.userData.isVisible = true;
                        }
                    }
                });
            });
        }

        // Wild plant respawn is now handled by setTimeout in the harvest handler —
        // plants are fully removed from the scene on harvest and a new one is spawned
        // at a fresh location after 15 minutes. Nothing to poll here.
        function updateWildPlantRespawn() { /* intentionally empty */ }
        function updateResourceRespawns() {
            const now = Date.now();
            
            // Check tree stump respawns
            for (let i = stumpRespawnQueue.length - 1; i >= 0; i--) {
                const item = stumpRespawnQueue[i];
                if (now >= item.respawnTime) {
                    // Remove stump
                    if (item.stump && item.stump.parent) {
                        scene.remove(item.stump);
                    }
                    
                    // Find new random position (away from player and other trees)
                    let newX, newZ, validPosition;
                    let attempts = 0;
                    do {
                        validPosition = true;
                        newX = (Math.random() - 0.5) * 180;
                        newZ = (Math.random() - 0.5) * 180;
                        
                        // Not too close to player
                        const distToPlayer = Math.sqrt(
                            Math.pow(newX - camera.position.x, 2) + 
                            Math.pow(newZ - camera.position.z, 2)
                        );
                        if (distToPlayer < 20) {
                            validPosition = false;
                            attempts++;
                            continue;
                        }
                        
                        // Not too close to other trees
                        for (let pos of treePositions) {
                            const dist = Math.sqrt(
                                Math.pow(newX - pos.x, 2) + 
                                Math.pow(newZ - pos.z, 2)
                            );
                            if (dist < 8) {
                                validPosition = false;
                                break;
                            }
                        }
                        attempts++;
                    } while (!validPosition && attempts < 50);
                    
                    // Spawn new tree if valid position found
                    if (validPosition) {
                        createTree(newX, newZ);
                    }
                    
                    // Remove from queue
                    stumpRespawnQueue.splice(i, 1);
                }
            }
            
            // Check rock respawns
            for (let i = rockRespawnQueue.length - 1; i >= 0; i--) {
                const item = rockRespawnQueue[i];
                if (now >= item.respawnTime) {
                    // Find new random position
                    let newX, newZ, validPosition;
                    let attempts = 0;
                    do {
                        validPosition = true;
                        newX = (Math.random() - 0.5) * 180;
                        newZ = (Math.random() - 0.5) * 180;
                        
                        // Not too close to player
                        const distToPlayer = Math.sqrt(
                            Math.pow(newX - camera.position.x, 2) + 
                            Math.pow(newZ - camera.position.z, 2)
                        );
                        if (distToPlayer < 15) {
                            validPosition = false;
                            attempts++;
                            continue;
                        }
                        
                        // Not too close to trees or other rocks
                        for (let pos of [...treePositions, ...rockPositions]) {
                            const dist = Math.sqrt(
                                Math.pow(newX - pos.x, 2) + 
                                Math.pow(newZ - pos.z, 2)
                            );
                            if (dist < 5) {
                                validPosition = false;
                                break;
                            }
                        }
                        attempts++;
                    } while (!validPosition && attempts < 50);
                    
                    // Spawn new rock
                    if (validPosition) {
                        createRock(newX, newZ);
                    }
                    
                    // Remove from queue
                    rockRespawnQueue.splice(i, 1);
                }
            }
            
            // Check ore respawns
            for (let i = oreRespawnQueue.length - 1; i >= 0; i--) {
                const item = oreRespawnQueue[i];
                if (now >= item.respawnTime) {
                    // Find new random position
                    let newX, newZ, validPosition;
                    let attempts = 0;
                    do {
                        validPosition = true;
                        newX = (Math.random() - 0.5) * 180;
                        newZ = (Math.random() - 0.5) * 180;
                        
                        // Not too close to player
                        const distToPlayer = Math.sqrt(
                            Math.pow(newX - camera.position.x, 2) + 
                            Math.pow(newZ - camera.position.z, 2)
                        );
                        if (distToPlayer < 15) {
                            validPosition = false;
                            attempts++;
                            continue;
                        }
                        
                        // Not too close to trees, rocks, or other ores
                        for (let pos of [...treePositions, ...rockPositions, ...orePositions]) {
                            const dist = Math.sqrt(
                                Math.pow(newX - pos.x, 2) + 
                                Math.pow(newZ - pos.z, 2)
                            );
                            if (dist < 6) {
                                validPosition = false;
                                break;
                            }
                        }
                        attempts++;
                    } while (!validPosition && attempts < 50);
                    
                    // Spawn new ore (correct type)
                    if (validPosition) {
                        if (item.type === 'sulfur') {
                            createSulfurOre(newX, newZ);
                        } else if (item.type === 'crystal_node') {
                            createCrystalNode(newX, newZ);
                        } else {
                            createMetalOre(newX, newZ);
                        }
                    }
                    
                    // Remove from queue
                    oreRespawnQueue.splice(i, 1);
                }
            }
        }
        
        // Tree sway animation
        // ===== DISTANCE CULLING =====
        // Smoothly fades world objects out as they approach the render distance,
        // then hard-culls them just beyond it so the GPU skips them entirely.
        //
        // Fade zone: from fadeStart (75% of dist) to dist — opacity goes 1→0.
        // Hard cull: objects beyond cullDist (dist + 15%) are set invisible.
        // By the time the hard cull fires the object is already transparent,
        // so there is zero visible pop-in or pop-out.

        function _setGroupOpacity(obj, opacity) {
            const fullyVisible = opacity >= 0.999;
            const fullyHidden  = opacity <= 0.001;
            // Cache the mesh+material list on first traversal — avoids re-walking the tree every frame
            if (!obj.userData._cachedMats) {
                obj.userData._cachedMats = [];
                obj.traverse(child => {
                    if (!child.isMesh) return;
                    const mats = Array.isArray(child.material) ? child.material : [child.material];
                    mats.forEach(mat => { if (mat) obj.userData._cachedMats.push(mat); });
                });
            }
            const mats = obj.userData._cachedMats;
            for (let i = 0; i < mats.length; i++) {
                const mat = mats[i];
                if (mat.userData._origOpacity === undefined) {
                    mat.userData._origOpacity     = mat.opacity;
                    mat.userData._origTransparent = mat.transparent;
                }
                if (fullyVisible) {
                    mat.opacity     = mat.userData._origOpacity;
                    mat.transparent = mat.userData._origTransparent;
                } else {
                    mat.transparent = true;
                    mat.opacity     = fullyHidden ? 0 : opacity * mat.userData._origOpacity;
                }
                mat.needsUpdate = true;
            }
        }

        function updateDistanceCulling() {
            const cx = camera.position.x, cz = camera.position.z;
            const dist      = volumeSettings.renderDistance;
            const fadeStart = dist * 0.75;
            const cullDist  = dist * 1.15;

            const fadeStartSq = fadeStart * fadeStart;
            const distSq      = dist      * dist;
            const cullDistSq  = cullDist  * cullDist;
            const fadeRange   = distSq - fadeStartSq;

            function cullObject(obj) {
                const dx = obj.position.x - cx, dz = obj.position.z - cz;
                const dSq = dx*dx + dz*dz;
                if (dSq > cullDistSq) {
                    if (obj.visible) { _setGroupOpacity(obj, 0); obj.visible = false; }
                } else if (dSq > fadeStartSq) {
                    const t = (dSq - fadeStartSq) / fadeRange;
                    const opacity = Math.max(0, 1 - t);
                    obj.visible = true;
                    _setGroupOpacity(obj, opacity);
                } else {
                    if (!obj.visible) obj.visible = true;
                    _setGroupOpacity(obj, 1);
                }
            }

            for (let i = 0; i < trees.length;     i++) cullObject(trees[i]);
            for (let i = 0; i < rocks.length;     i++) cullObject(rocks[i]);
            for (let i = 0; i < buildings.length; i++) cullObject(buildings[i]);

            scene.children.forEach(obj => {
                if (!obj.isPoints && !obj.isLight && !obj.isMesh && obj.children.length === 0) return;
                if (obj.userData.noCull) return;
                if (!obj.userData.isSnowTree && !obj.userData.isBush && !obj.userData.isOre &&
                    !obj.userData.isDesertRock && !obj.userData.isRiverProp &&
                    !obj.userData.isSnowBush && !obj.userData.isSnowRock) return;
                cullObject(obj);
            });
        }

        function updateTrees() {
            const SWAY_FULL_DIST = 40;  // full sway rate within 40 units
            const SWAY_SKIP_DIST = 80;  // no sway update beyond 80 units (invisible)
            trees.forEach(tree => {
                // Check if tree is falling — always update regardless of distance
                if (tree.userData.falling) {
                    tree.userData.fallProgress++;
                    const progress = tree.userData.fallProgress / tree.userData.fallDuration;
                    
                    if (progress < 1) {
                        // Animate falling - rotate around base
                        const fallAngle = progress * (Math.PI / 2); // Fall 90 degrees
                        tree.rotation.x = fallAngle;
                        tree.rotation.y = tree.userData.fallDirection;
                        
                        // Move down slightly as it falls
                        tree.position.y = -progress * 2;
                    } else {
                        // Fall complete
                        if (tree.userData.onFallComplete) {
                            tree.userData.onFallComplete();
                        }
                    }
                } else {
                    // Sway animation — skip for trees too far away to notice
                    const _tdx = tree.position.x - camera.position.x;
                    const _tdz = tree.position.z - camera.position.z;
                    const _tdSq = _tdx*_tdx + _tdz*_tdz;
                    if (_tdSq > SWAY_SKIP_DIST * SWAY_SKIP_DIST) return; // beyond cull range, skip
                    if (_tdSq > SWAY_FULL_DIST * SWAY_FULL_DIST) {
                        // Mid-range: update every other frame
                        tree.userData._swayFrame = (tree.userData._swayFrame || 0) + 1;
                        if (tree.userData._swayFrame % 2 !== 0) return;
                    }
                    // Sway animation — only runs if swayPhase/swaySpeed are set.
                    // GLB trees always have these set at spawn time; guard prevents
                    // NaN rotation (undefined → Math.sin(NaN) → NaN matrix → invisible).
                    if (tree.userData.swayPhase !== undefined && tree.userData.swaySpeed !== undefined) {
                        const amp  = tree.userData.swayAmp !== undefined ? tree.userData.swayAmp : 0.03;
                        const sway = Math.sin(_frameTime * tree.userData.swaySpeed + tree.userData.swayPhase) * amp;
                        tree.rotation.z = sway;
                        if (tree.userData.dirtPatch) { tree.userData.dirtPatch.rotation.z = -sway; }
                    }
                }
            });
        }
        
        // ===== UI UPDATES =====

        // Stamina bar updated every frame for smooth real-time display
        const _staminaBarEl  = null; // resolved lazily
        let _staminaBarDOM   = null;
        let _staminaTextDOM  = null;
        function _updateStaminaBar() {
            if (!_staminaBarDOM)  _staminaBarDOM  = document.getElementById('stamina-bar');
            if (!_staminaTextDOM) _staminaTextDOM = document.getElementById('stamina-text');
            if (!_staminaBarDOM)  return;
            const pct = Math.max(0, Math.min(100, stamina));
            _staminaBarDOM.style.width = pct + '%';
            _staminaTextDOM.textContent = Math.floor(pct) + ' / 100';
            if (staminaExhausted) {
                _staminaBarDOM.classList.add('stamina-exhausted');
            } else {
                _staminaBarDOM.classList.remove('stamina-exhausted');
            }
        }

        function updateUI() {
            const effectiveMaxHealth = activeBuffs.meat_stew ? 130 : 100;
            const healthPct = (health / effectiveMaxHealth) * 100;
            document.getElementById('health-bar').style.width = Math.min(100, healthPct) + '%';
            document.getElementById('health-text').textContent = `${Math.floor(health)} / ${effectiveMaxHealth}`;
            
            document.getElementById('hunger-bar').style.width = hunger + '%';
            document.getElementById('hunger-text').textContent = `${Math.floor(hunger)} / 100`;
            
            document.getElementById('thirst-bar').style.width = thirst + '%';
            document.getElementById('thirst-text').textContent = `${Math.floor(thirst)} / 100`;
            
            _updateStaminaBar();
            
            document.getElementById('day').textContent = day;
            
            updateInventoryUI();
            updateHotbar();
        }
        
        // ===== RUST-STYLE DRAGGABLE INVENTORY SYSTEM =====
        let draggedItem = null;
        let draggedFromSlot = null;
        let draggedFromType = null; // 'inventory', 'hotbar', or 'storage'
        let currentStorageBox = null;
        
        // ===== ITEM ICONS =====
        // All emojis are stored as \uXXXX escape sequences so they survive
        // file saves and transfers without corruption. To get the escaped
        // version of any emoji, run this in the browser console:
        //   escapeEmoji('🗡️')
        // Then paste the result as the icon value below.
        window.escapeEmoji = str => [...str].map(c => {
            const cp = c.codePointAt(0);
            if (cp <= 0x7F) return c;
            if (cp <= 0xFFFF) return '\\u' + cp.toString(16).padStart(4,'0');
            const hi = Math.floor((cp - 0x10000) / 0x400) + 0xD800;
            const lo = ((cp - 0x10000) % 0x400) + 0xDC00;
            return '\\u' + hi.toString(16).padStart(4,'0') + '\\u' + lo.toString(16).padStart(4,'0');
        }).join('');

        const itemIcons = {
            'crystal_shard': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0a0a1a"/><polygon points="16,3 21,10 19,29 16,27 13,29 11,10" fill="#5599ee" stroke="#88ccff" stroke-width="0.8"/><polygon points="16,3 21,10 19,29 16,27" fill="#88bbff" opacity="0.85"/><polygon points="16,3 11,10 13,29 16,27" fill="#3377cc" opacity="0.85"/><polygon points="22,8 29,13 27,22 21,10" fill="#4488dd" stroke="#88ccff" stroke-width="0.6" opacity="0.8"/><polygon points="10,8 3,13 5,22 11,10" fill="#3366cc" stroke="#6699ee" stroke-width="0.6" opacity="0.8"/><line x1="16" y1="3" x2="16" y2="27" stroke="#aaddff" stroke-width="0.6" opacity="0.5"/><ellipse cx="16" cy="10" rx="2" ry="1" fill="#cceeff" opacity="0.6"/></svg>',
            'sharp_stone': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1a2e"/><rect x="2" y="2" width="28" height="28" rx="3" fill="#333"/><polygon points="16,3 26,10 28,22 20,29 8,28 3,18 6,8" fill="#777" stroke="#999" stroke-width="1"/><polygon points="16,3 26,10 20,29 8,28" fill="#999" stroke="none" stroke-width="1"/><polygon points="16,3 6,8 3,18 8,28" fill="#666" stroke="none" stroke-width="1"/><line x1="16" y1="3" x2="8" y2="28" stroke="#aaa" stroke-width="0.5" stroke-linecap="round"/><line x1="16" y1="3" x2="28" y2="22" stroke="#aaa" stroke-width="0.5" stroke-linecap="round"/></svg>',
            'wood': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="3" y="8" width="26" height="16" rx="2" fill="#5C3A1E"/><rect x="3" y="8" width="26" height="16" rx="2" fill="#8B5E3C" opacity="0.8"/><line x1="3" y1="12" x2="29" y2="12" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="16" x2="29" y2="16" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="20" x2="29" y2="20" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/><line x1="8" y1="8" x2="8" y2="24" stroke="#5C3A1E" stroke-width="0.5" stroke-linecap="round"/><line x1="13" y1="8" x2="13" y2="24" stroke="#5C3A1E" stroke-width="0.5" stroke-linecap="round"/><line x1="19" y1="8" x2="19" y2="24" stroke="#5C3A1E" stroke-width="0.5" stroke-linecap="round"/><line x1="24" y1="8" x2="24" y2="24" stroke="#5C3A1E" stroke-width="0.5" stroke-linecap="round"/><ellipse cx="16" cy="12" rx="2" ry="1" fill="#5C3A1E" opacity="0.7"/></svg>',
            'stone': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1a2e"/><ellipse cx="16" cy="18" rx="13" ry="10" fill="#666" stroke="#888" stroke-width="1"/><ellipse cx="16" cy="16" rx="11" ry="8" fill="#888"/><ellipse cx="13" cy="13" rx="4" ry="3" fill="#999" opacity="0.5"/><ellipse cx="11" cy="19" rx="3" ry="2" fill="#555" opacity="0.6"/></svg>',
            'berries': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0810"/><circle cx="11" cy="18" r="5" fill="#cc2244"/><circle cx="11" cy="18" r="5" fill="none" stroke="#ff4466" stroke-width="0.5"/><circle cx="19" cy="18" r="5" fill="#aa1133"/><circle cx="15" cy="13" r="5" fill="#dd3355"/><circle cx="11" cy="13" r="2" fill="#663311" opacity="0.5"/><path d="M15,8 Q13,6 14,4" fill="none" stroke="#338833" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M15,8 Q17,6 16,4" fill="none" stroke="#44aa44" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
            'worms': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0e08"/><path d="M5,22 Q8,16 12,18 Q16,20 18,14 Q20,8 24,10 Q28,12 27,18" fill="none" stroke="#c47a3a" stroke-width="3.5" stroke-linecap="round"/><path d="M5,22 Q8,16 12,18 Q16,20 18,14 Q20,8 24,10 Q28,12 27,18" fill="none" stroke="#e8a060" stroke-width="1.5" stroke-linecap="round" opacity="0.6"/><circle cx="27" cy="18" r="2.5" fill="#d46030"/><circle cx="26.5" cy="17.2" r="0.8" fill="#1a0e08" opacity="0.7"/><path d="M7,24 Q10,20 13,21 Q16,22 17,18" fill="none" stroke="#b06830" stroke-width="2.5" stroke-linecap="round" opacity="0.7"/><path d="M7,24 Q10,20 13,21 Q16,22 17,18" fill="none" stroke="#d49060" stroke-width="1" stroke-linecap="round" opacity="0.5"/><circle cx="17" cy="18" r="2" fill="#c05828"/><circle cx="16.5" cy="17.3" r="0.65" fill="#1a0e08" opacity="0.7"/></svg>',
            'meat': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a0a00"/><path d="M8,22 Q6,14 10,10 Q16,5 22,8 Q28,12 26,20 Q24,28 16,27 Q8,26 8,22Z" fill="#cc4422" stroke="#ff6644" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/><path d="M10,20 Q9,15 12,12 Q16,9 20,11" fill="none" stroke="#ff8866" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" opacity="0.5"/><circle cx="16" cy="18" r="3" fill="#ee5533" opacity="0.3"/></svg>',
            'cooked_meat': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a0a00"/><path d="M8,22 Q6,14 10,10 Q16,5 22,8 Q28,12 26,20 Q24,28 16,27 Q8,26 8,22Z" fill="#8B4513" stroke="#A0522D" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/><path d="M9,16 Q12,12 16,11 Q20,12 23,16" fill="none" stroke="#6B3000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" opacity="0.6"/><path d="M10,20 Q13,17 16,16 Q19,17 22,20" fill="none" stroke="#5a2500" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" opacity="0.5"/><ellipse cx="16" cy="23" rx="5" ry="2" fill="#cc8844" opacity="0.4"/></svg>',
            'mushroom': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0d05"/><rect x="13" y="19" width="6" height="10" rx="2" fill="#e8d5b0" stroke="#c9b48a" stroke-width="0.8"/><line x1="13" y1="22" x2="19" y2="22" stroke="#c9b48a" stroke-width="0.6" opacity="0.7"/><line x1="13" y1="25" x2="19" y2="25" stroke="#c9b48a" stroke-width="0.6" opacity="0.5"/><ellipse cx="16" cy="19" rx="12" ry="3" fill="#5a2d00" opacity="0.5"/><ellipse cx="16" cy="13" rx="12" ry="8" fill="#7B3F00" stroke="#9B5A1A" stroke-width="1"/><ellipse cx="16" cy="12" rx="10" ry="6.5" fill="#A0522D"/><ellipse cx="12" cy="10" rx="3" ry="2" fill="#FFE4C4" opacity="0.75"/><circle cx="20" cy="10" r="1.8" fill="#FFE4C4" opacity="0.65"/><circle cx="16" cy="13" r="1.2" fill="#FFE4C4" opacity="0.55"/><path d="M5,16 Q10,21 16,19 Q22,21 27,16" fill="none" stroke="#5a2d00" stroke-width="1" opacity="0.6"/></svg>',
            'roasted_mushroom': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0a00"/><rect x="13" y="19" width="6" height="10" rx="2" fill="#c4a060" stroke="#9a7a3a" stroke-width="0.8"/><line x1="13" y1="22" x2="19" y2="22" stroke="#9a7a3a" stroke-width="0.6" opacity="0.7"/><line x1="13" y1="25" x2="19" y2="25" stroke="#9a7a3a" stroke-width="0.6" opacity="0.5"/><ellipse cx="16" cy="19" rx="12" ry="3" fill="#3a1800" opacity="0.6"/><ellipse cx="16" cy="13" rx="12" ry="8" fill="#5C2800" stroke="#7a3a00" stroke-width="1"/><ellipse cx="16" cy="12" rx="10" ry="6.5" fill="#7a3a00"/><ellipse cx="12" cy="10" rx="3" ry="2" fill="#cc8844" opacity="0.6"/><circle cx="20" cy="10" r="1.8" fill="#cc8844" opacity="0.5"/><circle cx="16" cy="13" r="1.2" fill="#bb7733" opacity="0.5"/><path d="M5,16 Q10,21 16,19 Q22,21 27,16" fill="none" stroke="#3a1800" stroke-width="1" opacity="0.6"/><path d="M13,4 Q14,2 13,1" fill="none" stroke="#aa6622" stroke-width="1.2" stroke-linecap="round" opacity="0.7"/><path d="M16,3 Q17,1 16,0" fill="none" stroke="#cc8833" stroke-width="1.2" stroke-linecap="round" opacity="0.7"/><path d="M19,4 Q20,2 19,1" fill="none" stroke="#aa6622" stroke-width="1.2" stroke-linecap="round" opacity="0.6"/></svg>',
            'sticks': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><path d="M6,26 L18,6" fill="none" stroke="#B07A52" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/><path d="M10,28 L22,8" fill="none" stroke="#8B5E3C" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/><path d="M14,27 L26,10" fill="none" stroke="#5C3A1E" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/></svg>',
            'fiber': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2010"/><path d="M5,25 Q10,15 8,8" fill="none" stroke="#4a9a4a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M10,27 Q16,14 14,6" fill="none" stroke="#5cb85c" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M15,26 Q20,15 18,7" fill="none" stroke="#4a9a4a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M20,25 Q24,16 22,9" fill="none" stroke="#3a7a3a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M25,24 Q28,16 26,10" fill="none" stroke="#5cb85c" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
            'iron_ore': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e2a38"/><ellipse cx="16" cy="18" rx="13" ry="10" fill="#445" stroke="#667" stroke-width="1"/><ellipse cx="16" cy="17" rx="11" ry="8" fill="#4a5a6a"/><circle cx="10" cy="15" r="3" fill="#8AABB8" opacity="0.8"/><circle cx="18" cy="18" r="2" fill="#8AABB8" opacity="0.7"/><circle cx="22" cy="14" r="2" fill="#6a8a9a" opacity="0.8"/><circle cx="13" cy="20" r="1.5" fill="#aabbc8" opacity="0.6"/></svg>',
            'iron_ingot': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e2a38"/><rect x="4" y="10" width="24" height="12" rx="2" fill="#5A8090"/><rect x="4" y="10" width="24" height="10" rx="2" fill="#8AABB8"/><rect x="4" y="10" width="24" height="4" rx="2" fill="#AABFCC" opacity="0.5"/><line x1="4" y1="16" x2="28" y2="16" stroke="#5A8090" stroke-width="0.5" stroke-linecap="round"/><text x="16" y="21" fill="#CCDDEE" font-size="9" font-weight="bold" text-anchor="middle" font-family="system-ui,sans-serif">Fe</text></svg>',
            'coal': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#111"/><ellipse cx="16" cy="18" rx="12" ry="9" fill="#1a1a1a" stroke="#333" stroke-width="1"/><ellipse cx="16" cy="17" rx="10" ry="7" fill="#2a2a2a"/><circle cx="11" cy="14" r="2" fill="#444" opacity="0.7"/><circle cx="20" cy="19" r="2" fill="#444" opacity="0.6"/><circle cx="15" cy="20" r="1.5" fill="#555" opacity="0.5"/><ellipse cx="12" cy="13" rx="1" ry="0.6" fill="#555" opacity="0.8"/></svg>',
            'sulfur_ore': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1f1a00"/><ellipse cx="16" cy="18" rx="12" ry="9" fill="#5a4a00" stroke="#aa8800" stroke-width="1"/><ellipse cx="16" cy="17" rx="10" ry="7" fill="#7a6800"/><circle cx="11" cy="14" r="2.5" fill="#ccaa00" opacity="0.8"/><circle cx="20" cy="16" r="2" fill="#ddbb00" opacity="0.7"/><circle cx="16" cy="20" r="2" fill="#aa9000" opacity="0.8"/></svg>',
            'smelted_sulfur': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1f1a00"/><rect x="4" y="10" width="24" height="12" rx="2" fill="#5A8090"/><rect x="4" y="10" width="24" height="10" rx="2" fill="#ccaa00"/><rect x="4" y="10" width="24" height="4" rx="2" fill="#ffdd44" opacity="0.5"/><text x="16" y="21" fill="#fff" font-size="10" font-weight="bold" text-anchor="middle" font-family="system-ui,sans-serif">S</text></svg>',
            'gunpowder': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#111"/><circle cx="16" cy="16" r="11" fill="#222" stroke="#444" stroke-width="1"/><circle cx="16" cy="16" r="8" fill="#111"/><circle cx="11" cy="12" r="2" fill="#3a3a3a"/><circle cx="20" cy="13" r="1.5" fill="#3a3a3a"/><circle cx="14" cy="20" r="1.5" fill="#3a3a3a"/><path d="M14,6 L16,3 L18,6" fill="none" stroke="#cc4400" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,3 L16,10" fill="none" stroke="#ff6600" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
            'ash': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1a1a"/><ellipse cx="16" cy="22" rx="13" ry="7" fill="#333" opacity="0.8"/><path d="M8,22 Q16,8 24,22" fill="none" stroke="#aaa" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" opacity="0.5"/><path d="M10,22 Q14,14 18,22" fill="none" stroke="#ccc" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" opacity="0.4"/><path d="M12,22 Q16,16 20,22" fill="none" stroke="#bbb" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" opacity="0.3"/><circle cx="16" cy="22" r="4" fill="#555" opacity="0.5"/><ellipse cx="16" cy="24" rx="10" ry="3" fill="#555" opacity="0.4"/></svg>',
            'meat_stew': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1205"/><ellipse cx="16" cy="20" rx="13" ry="9" fill="#5a3010" stroke="#7a4a20" stroke-width="1"/><ellipse cx="16" cy="18" rx="12" ry="7" fill="#8B4513"/><ellipse cx="16" cy="16" rx="10" ry="5" fill="#cc6633" opacity="0.8"/><circle cx="10" cy="17" r="2" fill="#cc4422" opacity="0.8"/><circle cx="22" cy="16" r="2" fill="#44aa44" opacity="0.7"/><circle cx="15" cy="14" r="1.5" fill="#ccaa44" opacity="0.8"/><circle cx="19" cy="18" r="1.5" fill="#cc4422" opacity="0.7"/><ellipse cx="16" cy="13" rx="6" ry="2" fill="#aa7744" opacity="0.4"/></svg>',
            'vegetable_stew': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2010"/><ellipse cx="16" cy="20" rx="13" ry="9" fill="#1a3a10" stroke="#2a5a20" stroke-width="1"/><ellipse cx="16" cy="18" rx="12" ry="7" fill="#2d5a1a"/><ellipse cx="16" cy="16" rx="10" ry="5" fill="#44aa44" opacity="0.8"/><circle cx="11" cy="16" r="2" fill="#88cc44" opacity="0.9"/><circle cx="21" cy="17" r="2" fill="#cc8822" opacity="0.8"/><circle cx="16" cy="14" r="1.5" fill="#ee4422" opacity="0.8"/><circle cx="14" cy="18" r="1" fill="#ffcc00" opacity="0.7"/><ellipse cx="16" cy="13" rx="5" ry="2" fill="#55bb55" opacity="0.4"/></svg>',
            'omelette': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1000"/><ellipse cx="16" cy="20" rx="13" ry="8" fill="#c8830a" stroke="#a06008" stroke-width="1"/><ellipse cx="16" cy="18" rx="11" ry="6" fill="#f5c842"/><ellipse cx="13" cy="16" rx="5" ry="3" fill="#fff9e0" opacity="0.85"/><ellipse cx="20" cy="17" rx="3.5" ry="2" fill="#fff9e0" opacity="0.6"/><circle cx="13" cy="16" r="2" fill="#ffcc00" opacity="0.5"/><path d="M8,20 Q16,15 24,20" fill="none" stroke="#a06008" stroke-width="1" stroke-linecap="round" opacity="0.4"/></svg>',
            'scrambled_eggs': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1000"/><ellipse cx="16" cy="21" rx="12" ry="7" fill="#b07010" stroke="#8a5000" stroke-width="1"/><path d="M6,21 Q10,14 16,16 Q22,14 26,21" fill="#f5c030" stroke="none"/><path d="M8,20 Q12,15 16,17 Q20,15 24,20" fill="#ffe060" stroke="none" opacity="0.7"/><circle cx="11" cy="18" r="2" fill="#fff9cc" opacity="0.7"/><circle cx="18" cy="17" r="2.5" fill="#fff9cc" opacity="0.6"/><circle cx="22" cy="19" r="1.5" fill="#ffe060" opacity="0.5"/></svg>',
            'honey_cake': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0e00"/><rect x="4" y="16" width="24" height="12" rx="3" fill="#c8860a" stroke="#a06000" stroke-width="1"/><rect x="4" y="16" width="24" height="6" rx="3" fill="#D4A017"/><rect x="6" y="10" width="20" height="8" rx="2" fill="#e8b828"/><rect x="6" y="10" width="20" height="4" rx="2" fill="#f5cc40" opacity="0.9"/><ellipse cx="16" cy="10" rx="8" ry="3" fill="#FFD700" opacity="0.9"/><path d="M10,10 Q16,5 22,10" fill="#FFD700" stroke="#e8b000" stroke-width="0.5"/><circle cx="11" cy="21" r="1.5" fill="#FFD700" opacity="0.5"/><circle cx="18" cy="23" r="1" fill="#FFD700" opacity="0.4"/></svg>',
            'honey_porridge': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1000"/><ellipse cx="16" cy="21" rx="13" ry="8" fill="#7a5010" stroke="#5a3800" stroke-width="1"/><ellipse cx="16" cy="19" rx="11" ry="6" fill="#c89040"/><ellipse cx="16" cy="17" rx="9" ry="4" fill="#e8b060" opacity="0.9"/><path d="M9,17 Q13,14 16,16 Q19,14 23,17" fill="none" stroke="#c87800" stroke-width="1.5" stroke-linecap="round" opacity="0.7"/><ellipse cx="13" cy="16" rx="2.5" ry="1" fill="#FFD700" opacity="0.7"/><ellipse cx="20" cy="17" rx="2" ry="1" fill="#FFD700" opacity="0.6"/></svg>',
            'berry_jam': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a0010"/><rect x="8" y="10" width="16" height="16" rx="2" fill="#4a0010" stroke="#8a1a30" stroke-width="1"/><rect x="8" y="6" width="16" height="6" rx="2" fill="#cc2244"/><rect x="8" y="6" width="16" height="4" rx="2" fill="#ee3355"/><rect x="6" y="8" width="20" height="4" rx="1" fill="#aa1133"/><circle cx="14" cy="17" r="2" fill="#ff4466" opacity="0.6"/><circle cx="18" cy="20" r="1.5" fill="#dd2244" opacity="0.5"/><circle cx="12" cy="21" r="1.5" fill="#cc3355" opacity="0.5"/></svg>',
            'corn_bread': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1f1a00"/><ellipse cx="16" cy="18" rx="13" ry="10" fill="#8B6914" stroke="#AA8822" stroke-width="1"/><ellipse cx="16" cy="16" rx="11" ry="8" fill="#D4A017"/><ellipse cx="14" cy="13" rx="4" ry="2" fill="#E8BB33" opacity="0.5"/><path d="M8,18 Q16,13 24,18" fill="none" stroke="#AA8822" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" opacity="0.5"/><circle cx="10" cy="17" r="1" fill="#CC9900" opacity="0.4"/><circle cx="20" cy="15" r="1" fill="#DDAA11" opacity="0.4"/></svg>',
            'hearty_meal': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1205"/><rect x="3" y="18" width="26" height="10" rx="2" fill="#3a2010" stroke="#5a3020" stroke-width="1"/><ellipse cx="8" cy="18" rx="4" ry="3" fill="#8B4513"/><ellipse cx="16" cy="17" rx="4" ry="3" fill="#44aa44"/><ellipse cx="24" cy="18" rx="4" ry="3" fill="#cc6633"/><ellipse cx="12" cy="20" rx="3" ry="2" fill="#ccaa44"/><ellipse cx="20" cy="21" rx="3" ry="2" fill="#8B4513"/><rect x="6" y="15" width="2" height="6" rx="1" fill="#5a3010"/><rect x="15" y="14" width="2" height="7" rx="1" fill="#3a7a1a"/><rect x="22" y="15" width="2" height="6" rx="1" fill="#5a2010"/></svg>',
            'cloth': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1408"/><rect x="3" y="6" width="26" height="20" rx="2" fill="#CCAA77" stroke="#AA8855" stroke-width="1"/><line x1="3" y1="10" x2="29" y2="10" stroke="#AA8855" stroke-width="0.5" stroke-linecap="round"/><line x1="3" y1="14" x2="29" y2="14" stroke="#AA8855" stroke-width="0.5" stroke-linecap="round"/><line x1="3" y1="18" x2="29" y2="18" stroke="#AA8855" stroke-width="0.5" stroke-linecap="round"/><line x1="3" y1="22" x2="29" y2="22" stroke="#AA8855" stroke-width="0.5" stroke-linecap="round"/><line x1="7" y1="6" x2="7" y2="26" stroke="#AA8855" stroke-width="0.5" stroke-linecap="round"/><line x1="13" y1="6" x2="13" y2="26" stroke="#AA8855" stroke-width="0.5" stroke-linecap="round"/><line x1="19" y1="6" x2="19" y2="26" stroke="#AA8855" stroke-width="0.5" stroke-linecap="round"/><line x1="25" y1="6" x2="25" y2="26" stroke="#AA8855" stroke-width="0.5" stroke-linecap="round"/><path d="M3,6 Q5,3 8,6" fill="none" stroke="#DDBB88" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/><path d="M26,6 Q28,3 29,6" fill="none" stroke="#DDBB88" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/></svg>',
            'arrows': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><path d="M6,26 L22,10" fill="none" stroke="#8B5E3C" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><polygon points="22,10 20,14 24,14" fill="#AAAAAA"/><path d="M6,26 L8,22" fill="none" stroke="#CCAA77" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M8,26 L24,10" fill="none" stroke="#B07A52" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><polygon points="24,10 22,14 26,14" fill="#AAAAAA"/><path d="M10,28 L26,12" fill="none" stroke="#5C3A1E" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><polygon points="26,12 24,16 28,16" fill="#AAAAAA"/></svg>',
            'axe': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="14" y="3" width="4" height="26" rx="1" fill="#6B4423"/><polygon points="8,5 18,3 20,14 16,14 16,10 8,12" fill="#8AABB8" stroke="#aabbcc" stroke-width="1"/><polygon points="8,5 4,10 8,12 16,10 16,14 8,14" fill="#6A8898"/><line x1="8" y1="12" x2="16" y2="14" stroke="#4A6878" stroke-width="0.5" stroke-linecap="round"/></svg>',
            'pickaxe': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#252525"/><rect x="15" y="10" width="3" height="20" rx="1" fill="#6B4423"/><polygon points="5,6 16,3 16,12 12,13 10,10" fill="#888" stroke="#aaa" stroke-width="1"/><polygon points="27,6 16,3 16,12 20,13 22,10" fill="#aaa" stroke="#ccc" stroke-width="1"/><rect x="12" y="10" width="8" height="4" rx="1" fill="#777"/></svg>',
            'sword': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2535"/><path d="M16,3 L19,16 L16,28 L13,16 Z" fill="#7BAFD4" stroke="#AAD0F0" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,3 L19,16 L16,28" fill="#7BAFD4"/><rect x="10" y="15" width="12" height="4" rx="1" fill="#8B6914"/><rect x="14" y="19" width="4" height="8" rx="1" fill="#B8860B"/><ellipse cx="16" cy="5" rx="1.5" ry="2.5" fill="#d0e8ff" opacity="0.7"/></svg>',
            'spear': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="15" y="12" width="3" height="18" rx="1" fill="#6B4423"/><polygon points="16,3 20,12 16,14 12,12" fill="#8AABB8" stroke="#AAD0F0" stroke-width="1"/><polygon points="16,3 20,12 16,14" fill="#6A8898"/><ellipse cx="16" cy="14" rx="2" ry="1" fill="#888" opacity="0.5"/></svg>',
            'bow': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><path d="M8,4 Q3,16 8,28" fill="none" stroke="#8B5E3C" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/><path d="M8,4 L8,28" fill="none" stroke="#8B5E3C" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" opacity="0.5"/><path d="M8,4 Q16,16 8,28" fill="none" stroke="#CCAA77" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/><line x1="8" y1="16" x2="22" y2="16" stroke="#CCCCCC" stroke-width="1.5" stroke-linecap="round"/><polygon points="22,14 26,16 22,18" fill="#CCCCCC"/></svg>',
            'pistol': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2535"/><rect x="4" y="12" width="18" height="10" rx="2" fill="#555"/><rect x="14" y="8" width="10" height="6" rx="2" fill="#444"/><rect x="4" y="20" width="10" height="8" rx="2" fill="#444"/><rect x="22" y="10" width="6" height="4" rx="1" fill="#333"/><rect x="22" y="10" width="6" height="2" rx="1" fill="#555"/><circle cx="28" cy="11" r="1" fill="#888"/><rect x="5" y="13" width="12" height="4" rx="1" fill="#666" opacity="0.4"/><line x1="4" y1="22" x2="14" y2="22" stroke="#666" stroke-width="0.5" stroke-linecap="round"/></svg>',
            'pistol_ammo': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2535"/><rect x="10" y="4" width="5" height="20" rx="2" fill="#cc8800"/><rect x="10" y="4" width="5" height="6" rx="2" fill="#eeaa00"/><rect x="15" y="4" width="5" height="20" rx="2" fill="#cc8800" opacity="0.8"/><rect x="20" y="4" width="5" height="20" rx="2" fill="#aa7700" opacity="0.6"/><rect x="9" y="22" width="14" height="6" rx="2" fill="#555"/><rect x="9" y="22" width="14" height="3" rx="2" fill="#777"/></svg>',
            'machine_gun': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#111a22"/><rect x="2" y="11" width="20" height="9" rx="2" fill="#444"/><rect x="2" y="11" width="20" height="4" rx="2" fill="#555"/><rect x="12" y="7" width="10" height="5" rx="1" fill="#3a3a3a"/><rect x="2" y="19" width="10" height="9" rx="2" fill="#333"/><rect x="7" y="21" width="6" height="8" rx="1" fill="#2a2a2a"/><rect x="22" y="9" width="9" height="3" rx="1" fill="#333"/><rect x="23" y="10" width="9" height="1.5" rx="0.5" fill="#555"/><circle cx="31" cy="10.5" r="1.2" fill="#777"/><rect x="3" y="12" width="14" height="3" rx="1" fill="#666" opacity="0.3"/><line x1="2" y1="20" x2="12" y2="20" stroke="#555" stroke-width="0.8" stroke-linecap="round"/><rect x="4" y="15" width="3" height="5" rx="1" fill="#222" opacity="0.6"/><rect x="8" y="15" width="3" height="5" rx="1" fill="#222" opacity="0.4"/></svg>',
            'mg_ammo': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#111a22"/><rect x="6" y="3" width="4" height="18" rx="2" fill="#cc5500"/><rect x="6" y="3" width="4" height="5" rx="2" fill="#ff7722"/><rect x="11" y="3" width="4" height="18" rx="2" fill="#cc5500" opacity="0.9"/><rect x="11" y="3" width="4" height="5" rx="2" fill="#ff7722" opacity="0.9"/><rect x="16" y="3" width="4" height="18" rx="2" fill="#aa4400" opacity="0.8"/><rect x="16" y="3" width="4" height="5" rx="2" fill="#ee6611" opacity="0.8"/><rect x="21" y="3" width="4" height="18" rx="2" fill="#993300" opacity="0.6"/><rect x="5" y="19" width="21" height="7" rx="2" fill="#444"/><rect x="5" y="19" width="21" height="4" rx="2" fill="#555"/></svg>',
            'pistol_ammo': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2535"/><rect x="10" y="4" width="5" height="20" rx="2" fill="#cc8800"/><rect x="10" y="4" width="5" height="6" rx="2" fill="#eeaa00"/><rect x="15" y="4" width="5" height="20" rx="2" fill="#cc8800" opacity="0.8"/><rect x="20" y="4" width="5" height="20" rx="2" fill="#aa7700" opacity="0.6"/><rect x="9" y="22" width="14" height="6" rx="2" fill="#555"/><rect x="9" y="22" width="14" height="3" rx="2" fill="#777"/></svg>',
            'building_hammer': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="14" y="3" width="4" height="22" rx="1" fill="#6B4423"/><rect x="6" y="3" width="20" height="10" rx="2" fill="#888"/><rect x="6" y="3" width="20" height="4" rx="2" fill="#aaa"/><rect x="6" y="3" width="8" height="10" rx="2" fill="#999"/><circle cx="16" cy="28" r="3" fill="#6B4423"/></svg>',
            'code_lock': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2535"/><rect x="5" y="14" width="22" height="15" rx="3" fill="#555"/><path d="M10,14 Q10,6 16,5 Q22,6 22,14" fill="none" stroke="#888" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="20" r="4" fill="#333" stroke="#777" stroke-width="1"/><rect x="15" y="20" width="2" height="5" rx="0" fill="#333"/><text x="16" y="24" fill="#aaa" font-size="7" font-weight="bold" text-anchor="middle" font-family="system-ui,sans-serif">0</text></svg>',
            'bandage': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1a2e"/><rect x="4" y="10" width="24" height="12" rx="3" fill="#EEE" stroke="#CCC" stroke-width="1"/><rect x="12" y="6" width="8" height="20" rx="3" fill="#EEE" stroke="#CCC" stroke-width="1"/><rect x="13" y="10" width="6" height="12" rx="1" fill="#DDD"/><rect x="14" y="14" width="4" height="4" rx="1" fill="#cc2222"/><line x1="16" y1="14" x2="16" y2="18" stroke="#EEE" stroke-width="1" stroke-linecap="round"/><line x1="14" y1="16" x2="18" y2="16" stroke="#EEE" stroke-width="1" stroke-linecap="round"/></svg>',
            'medkit': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a0808"/><rect x="3" y="7" width="26" height="22" rx="3" fill="#cc2222" stroke="#ee3333" stroke-width="1"/><rect x="3" y="7" width="26" height="6" rx="3" fill="#ee3333"/><rect x="11" y="3" width="10" height="6" rx="2" fill="#cc2222"/><rect x="11" y="12" width="10" height="12" rx="1" fill="#fff"/><rect x="15" y="10" width="2" height="16" rx="0" fill="#fff"/><rect x="11" y="16" width="10" height="2" rx="0" fill="#fff"/></svg>',
            'wall': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="3" y="3" width="26" height="26" rx="1" fill="#5C3A1E"/><rect x="3" y="3" width="26" height="1" rx="0" fill="#222"/><rect x="3" y="12" width="26" height="1" rx="0" fill="#222"/><rect x="3" y="21" width="26" height="1" rx="0" fill="#222"/><rect x="4" y="4" width="11" height="8" rx="1" fill="#8B5E3C"/><rect x="17" y="4" width="11" height="8" rx="1" fill="#B07A52"/><rect x="4" y="13" width="7" height="8" rx="1" fill="#B07A52"/><rect x="13" y="13" width="11" height="8" rx="1" fill="#8B5E3C"/><rect x="26" y="13" width="4" height="8" rx="1" fill="#5C3A1E"/><rect x="4" y="22" width="11" height="6" rx="1" fill="#8B5E3C"/><rect x="17" y="22" width="11" height="6" rx="1" fill="#B07A52"/></svg>',
            'stone_wall': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#252525"/><rect x="3" y="3" width="26" height="26" rx="1" fill="#555555"/><rect x="3" y="3" width="26" height="1" rx="0" fill="#222"/><rect x="3" y="12" width="26" height="1" rx="0" fill="#222"/><rect x="3" y="21" width="26" height="1" rx="0" fill="#222"/><rect x="4" y="4" width="11" height="8" rx="1" fill="#888888"/><rect x="17" y="4" width="11" height="8" rx="1" fill="#aaaaaa"/><rect x="4" y="13" width="7" height="8" rx="1" fill="#aaaaaa"/><rect x="13" y="13" width="11" height="8" rx="1" fill="#888888"/><rect x="26" y="13" width="4" height="8" rx="1" fill="#555555"/><rect x="4" y="22" width="11" height="6" rx="1" fill="#888888"/><rect x="17" y="22" width="11" height="6" rx="1" fill="#aaaaaa"/></svg>',
            'metal_wall': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2535"/><rect x="3" y="3" width="26" height="26" rx="1" fill="#4A8AAA"/><rect x="3" y="3" width="26" height="1" rx="0" fill="#222"/><rect x="3" y="12" width="26" height="1" rx="0" fill="#222"/><rect x="3" y="21" width="26" height="1" rx="0" fill="#222"/><rect x="4" y="4" width="11" height="8" rx="1" fill="#7BAFD4"/><rect x="17" y="4" width="11" height="8" rx="1" fill="#A8CBDF"/><rect x="4" y="13" width="7" height="8" rx="1" fill="#A8CBDF"/><rect x="13" y="13" width="11" height="8" rx="1" fill="#7BAFD4"/><rect x="26" y="13" width="4" height="8" rx="1" fill="#4A8AAA"/><rect x="4" y="22" width="11" height="6" rx="1" fill="#7BAFD4"/><rect x="17" y="22" width="11" height="6" rx="1" fill="#A8CBDF"/></svg>',
            'window_wall': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="3" y="3" width="26" height="26" rx="1" fill="#5C3A1E"/><rect x="3" y="3" width="26" height="1" rx="0" fill="#222"/><rect x="3" y="12" width="26" height="1" rx="0" fill="#222"/><rect x="3" y="21" width="26" height="1" rx="0" fill="#222"/><rect x="4" y="4" width="5" height="8" rx="1" fill="#8B5E3C"/><rect x="21" y="4" width="8" height="8" rx="1" fill="#B07A52"/><rect x="4" y="13" width="5" height="8" rx="1" fill="#B07A52"/><rect x="21" y="13" width="8" height="8" rx="1" fill="#8B5E3C"/><rect x="4" y="22" width="5" height="6" rx="1" fill="#8B5E3C"/><rect x="21" y="22" width="8" height="6" rx="1" fill="#B07A52"/><rect x="10" y="8" width="12" height="16" rx="1" fill="#88CCFF" opacity="0.7"/><rect x="10" y="15" width="12" height="1" rx="0" fill="#5C3A1E"/><rect x="15" y="8" width="1" height="16" rx="0" fill="#5C3A1E"/><rect x="11" y="9" width="4" height="5" rx="0" fill="#CCEEFF" opacity="0.4"/></svg>',
            'stone_window_wall': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#252525"/><rect x="3" y="3" width="26" height="26" rx="1" fill="#555555"/><rect x="3" y="3" width="26" height="1" rx="0" fill="#222"/><rect x="3" y="12" width="26" height="1" rx="0" fill="#222"/><rect x="3" y="21" width="26" height="1" rx="0" fill="#222"/><rect x="4" y="4" width="5" height="8" rx="1" fill="#888888"/><rect x="21" y="4" width="8" height="8" rx="1" fill="#aaaaaa"/><rect x="4" y="13" width="5" height="8" rx="1" fill="#aaaaaa"/><rect x="21" y="13" width="8" height="8" rx="1" fill="#888888"/><rect x="4" y="22" width="5" height="6" rx="1" fill="#888888"/><rect x="21" y="22" width="8" height="6" rx="1" fill="#aaaaaa"/><rect x="10" y="8" width="12" height="16" rx="1" fill="#88CCFF" opacity="0.7"/><rect x="10" y="15" width="12" height="1" rx="0" fill="#555555"/><rect x="15" y="8" width="1" height="16" rx="0" fill="#555555"/><rect x="11" y="9" width="4" height="5" rx="0" fill="#CCEEFF" opacity="0.4"/></svg>',
            'metal_window_wall': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2535"/><rect x="3" y="3" width="26" height="26" rx="1" fill="#4A8AAA"/><rect x="3" y="3" width="26" height="1" rx="0" fill="#222"/><rect x="3" y="12" width="26" height="1" rx="0" fill="#222"/><rect x="3" y="21" width="26" height="1" rx="0" fill="#222"/><rect x="4" y="4" width="5" height="8" rx="1" fill="#7BAFD4"/><rect x="21" y="4" width="8" height="8" rx="1" fill="#A8CBDF"/><rect x="4" y="13" width="5" height="8" rx="1" fill="#A8CBDF"/><rect x="21" y="13" width="8" height="8" rx="1" fill="#7BAFD4"/><rect x="4" y="22" width="5" height="6" rx="1" fill="#7BAFD4"/><rect x="21" y="22" width="8" height="6" rx="1" fill="#A8CBDF"/><rect x="10" y="8" width="12" height="16" rx="1" fill="#88CCFF" opacity="0.7"/><rect x="10" y="15" width="12" height="1" rx="0" fill="#4A8AAA"/><rect x="15" y="8" width="1" height="16" rx="0" fill="#4A8AAA"/><rect x="11" y="9" width="4" height="5" rx="0" fill="#CCEEFF" opacity="0.4"/></svg>',
            'door_frame': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0f06"/><rect x="2" y="2" width="6" height="28" rx="1" fill="#5C3A1E"/><rect x="24" y="2" width="6" height="28" rx="1" fill="#5C3A1E"/><rect x="2" y="2" width="28" height="5" rx="1" fill="#5C3A1E"/><rect x="2" y="27" width="28" height="3" rx="1" fill="#5C3A1E"/></svg>',
            'door': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0f06"/><rect x="2" y="2" width="5" height="28" rx="1" fill="#5C3A1E"/><rect x="25" y="2" width="5" height="28" rx="1" fill="#5C3A1E"/><rect x="2" y="2" width="28" height="4" rx="1" fill="#5C3A1E"/><rect x="7" y="6" width="18" height="24" rx="1" fill="#9C7A3C"/><rect x="7" y="6" width="18" height="5" rx="0" fill="#B8924A" opacity="0.5"/><rect x="7" y="13" width="18" height="5" rx="0" fill="#B8924A" opacity="0.5"/><rect x="7" y="20" width="18" height="4" rx="0" fill="#B8924A" opacity="0.5"/><circle cx="21" cy="18" r="2" fill="#FFD700"/></svg>',
            'double_door': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0f06"/><rect x="1" y="2" width="4" height="28" rx="1" fill="#5C3A1E"/><rect x="27" y="2" width="4" height="28" rx="1" fill="#5C3A1E"/><rect x="1" y="2" width="30" height="4" rx="1" fill="#5C3A1E"/><rect x="5" y="6" width="11" height="24" rx="1" fill="#9C7A3C"/><rect x="16" y="6" width="11" height="24" rx="1" fill="#9C7A3C"/><rect x="5" y="6" width="11" height="4" rx="0" fill="#B8924A" opacity="0.5"/><rect x="16" y="6" width="11" height="4" rx="0" fill="#B8924A" opacity="0.5"/><rect x="5" y="14" width="11" height="4" rx="0" fill="#B8924A" opacity="0.4"/><rect x="16" y="14" width="11" height="4" rx="0" fill="#B8924A" opacity="0.4"/><circle cx="14" cy="18" r="1.5" fill="#FFD700"/><circle cx="18" cy="18" r="1.5" fill="#FFD700"/></svg>',
                        'stone_door': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0f06"/><rect x="2" y="2" width="5" height="28" rx="1" fill="#4A2E10"/><rect x="25" y="2" width="5" height="28" rx="1" fill="#4A2E10"/><rect x="2" y="2" width="28" height="4" rx="1" fill="#4A2E10"/><rect x="7" y="6" width="18" height="24" rx="1" fill="#7A5C2E"/><rect x="7" y="6" width="18" height="4" fill="#8A6C3E" opacity="0.5"/><rect x="8" y="14" width="16" height="8" rx="1" fill="#88CCEE" opacity="0.5"/><rect x="8" y="14" width="16" height="1" fill="#4A2E10"/><rect x="8" y="21" width="16" height="1" fill="#4A2E10"/><rect x="15" y="14" width="2" height="8" fill="#4A2E10"/><rect x="9" y="25" width="14" height="4" rx="1" fill="#5A3A18" opacity="0.4"/><circle cx="22" cy="19" r="1.5" fill="#B08040"/></svg>',
            'stone_double_door': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0f06"/><rect x="1" y="2" width="4" height="28" rx="1" fill="#4A2E10"/><rect x="27" y="2" width="4" height="28" rx="1" fill="#4A2E10"/><rect x="1" y="2" width="30" height="4" rx="1" fill="#4A2E10"/><rect x="5" y="6" width="11" height="24" rx="1" fill="#7A5C2E"/><rect x="16" y="6" width="11" height="24" rx="1" fill="#7A5C2E"/><rect x="5" y="14" width="11" height="7" rx="1" fill="#88CCEE" opacity="0.5"/><rect x="16" y="14" width="11" height="7" rx="1" fill="#88CCEE" opacity="0.5"/><rect x="5" y="14" width="11" height="1" fill="#4A2E10"/><rect x="5" y="20" width="11" height="1" fill="#4A2E10"/><rect x="16" y="14" width="11" height="1" fill="#4A2E10"/><rect x="16" y="20" width="11" height="1" fill="#4A2E10"/><circle cx="14" cy="18" r="1.5" fill="#B08040"/><circle cx="18" cy="18" r="1.5" fill="#B08040"/></svg>',
            'metal_door': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1e22"/><rect x="2" y="2" width="5" height="28" rx="1" fill="#555960"/><rect x="25" y="2" width="5" height="28" rx="1" fill="#555960"/><rect x="2" y="2" width="28" height="4" rx="1" fill="#555960"/><rect x="7" y="6" width="18" height="24" fill="#A0A8B0"/><rect x="7" y="6" width="10" height="12" fill="#BEC4CC"/><rect x="17" y="18" width="8" height="12" fill="#787E86"/><rect x="7" y="6" width="6" height="24" fill="#909899" opacity="0.5"/><line x1="9" y1="6" x2="9" y2="30" stroke="#C0C8D0" stroke-width="0.8"/><line x1="11" y1="6" x2="11" y2="30" stroke="#C0C8D0" stroke-width="0.8"/><line x1="13" y1="6" x2="13" y2="30" stroke="#C0C8D0" stroke-width="0.8"/><rect x="13" y="6" width="12" height="0.8" fill="#3A3020"/><rect x="13" y="18" width="12" height="0.8" fill="#3A3020"/><circle cx="8" cy="10" r="1" fill="#555960"/><circle cx="8" cy="26" r="1" fill="#555960"/><circle cx="24" cy="10" r="1" fill="#555960"/><circle cx="24" cy="26" r="1" fill="#555960"/><rect x="22" y="16" width="3" height="7" rx="1" fill="#888E96"/></svg>',
            'metal_double_door': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1e22"/><rect x="1" y="2" width="4" height="28" rx="1" fill="#555960"/><rect x="27" y="2" width="4" height="28" rx="1" fill="#555960"/><rect x="1" y="2" width="30" height="4" rx="1" fill="#555960"/><rect x="5" y="6" width="11" height="24" fill="#A0A8B0"/><rect x="16" y="6" width="11" height="24" fill="#A0A8B0"/><rect x="5" y="6" width="5" height="24" fill="#909899" opacity="0.6"/><rect x="22" y="6" width="5" height="24" fill="#787E86" opacity="0.6"/><line x1="7" y1="6" x2="7" y2="30" stroke="#C0C8D0" stroke-width="0.8"/><line x1="9" y1="6" x2="9" y2="30" stroke="#C0C8D0" stroke-width="0.8"/><line x1="25" y1="6" x2="25" y2="30" stroke="#C0C8D0" stroke-width="0.8"/><line x1="23" y1="6" x2="23" y2="30" stroke="#C0C8D0" stroke-width="0.8"/><rect x="5" y="18" width="11" height="0.8" fill="#3A3020"/><rect x="16" y="15" width="11" height="0.8" fill="#3A3020"/><circle cx="6" cy="10" r="1" fill="#555960"/><circle cx="6" cy="26" r="1" fill="#555960"/><circle cx="26" cy="10" r="1" fill="#555960"/><circle cx="26" cy="26" r="1" fill="#555960"/><circle cx="14" cy="17" r="1.5" fill="#888E96"/><circle cx="18" cy="17" r="1.5" fill="#888E96"/></svg>',
            'double_door_frame': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0f06"/><rect x="1" y="2" width="5" height="28" rx="1" fill="#5C3A1E"/><rect x="26" y="2" width="5" height="28" rx="1" fill="#5C3A1E"/><rect x="1" y="2" width="30" height="4" rx="1" fill="#5C3A1E"/><rect x="1" y="28" width="30" height="2" rx="1" fill="#5C3A1E"/></svg>',
            'floor': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="2" y="2" width="28" height="28" rx="2" fill="#5C3A1E"/><rect x="3" y="3" width="12" height="12" rx="1" fill="#8B5E3C"/><rect x="17" y="3" width="12" height="12" rx="1" fill="#B07A52"/><rect x="3" y="17" width="12" height="12" rx="1" fill="#B07A52"/><rect x="17" y="17" width="12" height="12" rx="1" fill="#8B5E3C"/><line x1="5" y1="5" x2="5" y2="14" stroke="#5C3A1E" stroke-width="0.5" stroke-linecap="round"/><line x1="8" y1="5" x2="8" y2="14" stroke="#5C3A1E" stroke-width="0.5" stroke-linecap="round"/><line x1="19" y1="5" x2="19" y2="14" stroke="#5C3A1E" stroke-width="0.5" stroke-linecap="round"/><line x1="22" y1="5" x2="22" y2="14" stroke="#5C3A1E" stroke-width="0.5" stroke-linecap="round"/></svg>',
            'stone_floor': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#252525"/><rect x="2" y="2" width="28" height="28" rx="2" fill="#555555"/><rect x="3" y="3" width="12" height="12" rx="1" fill="#888888"/><rect x="17" y="3" width="12" height="12" rx="1" fill="#aaaaaa"/><rect x="3" y="17" width="12" height="12" rx="1" fill="#aaaaaa"/><rect x="17" y="17" width="12" height="12" rx="1" fill="#888888"/><line x1="5" y1="5" x2="5" y2="14" stroke="#555555" stroke-width="0.5" stroke-linecap="round"/><line x1="8" y1="5" x2="8" y2="14" stroke="#555555" stroke-width="0.5" stroke-linecap="round"/><line x1="19" y1="5" x2="19" y2="14" stroke="#555555" stroke-width="0.5" stroke-linecap="round"/><line x1="22" y1="5" x2="22" y2="14" stroke="#555555" stroke-width="0.5" stroke-linecap="round"/></svg>',
            'metal_floor': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2535"/><rect x="2" y="2" width="28" height="28" rx="2" fill="#4A8AAA"/><rect x="3" y="3" width="12" height="12" rx="1" fill="#7BAFD4"/><rect x="17" y="3" width="12" height="12" rx="1" fill="#A8CBDF"/><rect x="3" y="17" width="12" height="12" rx="1" fill="#A8CBDF"/><rect x="17" y="17" width="12" height="12" rx="1" fill="#7BAFD4"/><line x1="5" y1="5" x2="5" y2="14" stroke="#4A8AAA" stroke-width="0.5" stroke-linecap="round"/><line x1="8" y1="5" x2="8" y2="14" stroke="#4A8AAA" stroke-width="0.5" stroke-linecap="round"/><line x1="19" y1="5" x2="19" y2="14" stroke="#4A8AAA" stroke-width="0.5" stroke-linecap="round"/><line x1="22" y1="5" x2="22" y2="14" stroke="#4A8AAA" stroke-width="0.5" stroke-linecap="round"/></svg>',
            'ceiling': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="2" y="2" width="28" height="28" rx="2" fill="#5C3A1E"/><rect x="3" y="3" width="12" height="12" rx="1" fill="#8B5E3C"/><rect x="17" y="3" width="12" height="12" rx="1" fill="#B07A52"/><rect x="3" y="17" width="12" height="12" rx="1" fill="#B07A52"/><rect x="17" y="17" width="12" height="12" rx="1" fill="#8B5E3C"/><rect x="2" y="2" width="28" height="4" rx="0" fill="#000000" opacity="0.4"/></svg>',
            'stone_ceiling': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#252525"/><rect x="2" y="2" width="28" height="28" rx="2" fill="#555555"/><rect x="3" y="3" width="12" height="12" rx="1" fill="#888888"/><rect x="17" y="3" width="12" height="12" rx="1" fill="#aaaaaa"/><rect x="3" y="17" width="12" height="12" rx="1" fill="#aaaaaa"/><rect x="17" y="17" width="12" height="12" rx="1" fill="#888888"/><rect x="2" y="2" width="28" height="4" rx="0" fill="#000000" opacity="0.4"/></svg>',
            'metal_ceiling': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2535"/><rect x="2" y="2" width="28" height="28" rx="2" fill="#4A8AAA"/><rect x="3" y="3" width="12" height="12" rx="1" fill="#7BAFD4"/><rect x="17" y="3" width="12" height="12" rx="1" fill="#A8CBDF"/><rect x="3" y="17" width="12" height="12" rx="1" fill="#A8CBDF"/><rect x="17" y="17" width="12" height="12" rx="1" fill="#7BAFD4"/><rect x="2" y="2" width="28" height="4" rx="0" fill="#000000" opacity="0.4"/></svg>',
            'ladder_ceiling': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="2" y="2" width="28" height="28" rx="2" fill="#5C3A1E"/><rect x="3" y="3" width="12" height="12" rx="1" fill="#8B5E3C"/><rect x="17" y="3" width="12" height="12" rx="1" fill="#B07A52"/><rect x="3" y="17" width="12" height="12" rx="1" fill="#B07A52"/><rect x="17" y="17" width="12" height="12" rx="1" fill="#8B5E3C"/><rect x="2" y="2" width="28" height="4" rx="0" fill="#000000" opacity="0.4"/></svg>',
            'stairs': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="3" y="22" width="26" height="6" rx="1" fill="#5C3A1E"/><rect x="3" y="16" width="20" height="6" rx="1" fill="#8B5E3C"/><rect x="3" y="10" width="14" height="6" rx="1" fill="#B07A52"/><rect x="3" y="4" width="8" height="6" rx="1" fill="#8B5E3C"/><line x1="3" y1="22" x2="29" y2="22" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="16" x2="23" y2="16" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="10" x2="17" y2="10" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="4" x2="11" y2="4" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/></svg>',
            'stone_stairs': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#252525"/><rect x="3" y="22" width="26" height="6" rx="1" fill="#555555"/><rect x="3" y="16" width="20" height="6" rx="1" fill="#888888"/><rect x="3" y="10" width="14" height="6" rx="1" fill="#aaaaaa"/><rect x="3" y="4" width="8" height="6" rx="1" fill="#888888"/><line x1="3" y1="22" x2="29" y2="22" stroke="#555555" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="16" x2="23" y2="16" stroke="#555555" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="10" x2="17" y2="10" stroke="#555555" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="4" x2="11" y2="4" stroke="#555555" stroke-width="1" stroke-linecap="round"/></svg>',
            'metal_stairs': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2535"/><rect x="3" y="22" width="26" height="6" rx="1" fill="#4A8AAA"/><rect x="3" y="16" width="20" height="6" rx="1" fill="#7BAFD4"/><rect x="3" y="10" width="14" height="6" rx="1" fill="#A8CBDF"/><rect x="3" y="4" width="8" height="6" rx="1" fill="#7BAFD4"/><line x1="3" y1="22" x2="29" y2="22" stroke="#4A8AAA" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="16" x2="23" y2="16" stroke="#4A8AAA" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="10" x2="17" y2="10" stroke="#4A8AAA" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="4" x2="11" y2="4" stroke="#4A8AAA" stroke-width="1" stroke-linecap="round"/></svg>',
            'corner_stairs_left': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="3" y="22" width="26" height="6" rx="1" fill="#5C3A1E"/><rect x="3" y="16" width="20" height="6" rx="1" fill="#8B5E3C"/><rect x="3" y="10" width="14" height="6" rx="1" fill="#B07A52"/><rect x="3" y="4" width="8" height="6" rx="1" fill="#8B5E3C"/><line x1="3" y1="22" x2="29" y2="22" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="16" x2="23" y2="16" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="10" x2="17" y2="10" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="4" x2="11" y2="4" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/></svg>',
            'stone_corner_stairs_left': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#252525"/><rect x="3" y="22" width="26" height="6" rx="1" fill="#555555"/><rect x="3" y="16" width="20" height="6" rx="1" fill="#888888"/><rect x="3" y="10" width="14" height="6" rx="1" fill="#aaaaaa"/><rect x="3" y="4" width="8" height="6" rx="1" fill="#888888"/><line x1="3" y1="22" x2="29" y2="22" stroke="#555555" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="16" x2="23" y2="16" stroke="#555555" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="10" x2="17" y2="10" stroke="#555555" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="4" x2="11" y2="4" stroke="#555555" stroke-width="1" stroke-linecap="round"/></svg>',
            'metal_corner_stairs_left': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2535"/><rect x="3" y="22" width="26" height="6" rx="1" fill="#4A8AAA"/><rect x="3" y="16" width="20" height="6" rx="1" fill="#7BAFD4"/><rect x="3" y="10" width="14" height="6" rx="1" fill="#A8CBDF"/><rect x="3" y="4" width="8" height="6" rx="1" fill="#7BAFD4"/><line x1="3" y1="22" x2="29" y2="22" stroke="#4A8AAA" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="16" x2="23" y2="16" stroke="#4A8AAA" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="10" x2="17" y2="10" stroke="#4A8AAA" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="4" x2="11" y2="4" stroke="#4A8AAA" stroke-width="1" stroke-linecap="round"/></svg>',
            'corner_stairs_right': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="3" y="22" width="26" height="6" rx="1" fill="#5C3A1E"/><rect x="3" y="16" width="20" height="6" rx="1" fill="#8B5E3C"/><rect x="3" y="10" width="14" height="6" rx="1" fill="#B07A52"/><rect x="3" y="4" width="8" height="6" rx="1" fill="#8B5E3C"/><line x1="3" y1="22" x2="29" y2="22" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="16" x2="23" y2="16" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="10" x2="17" y2="10" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="4" x2="11" y2="4" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/></svg>',
            'stone_corner_stairs_right': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#252525"/><rect x="3" y="22" width="26" height="6" rx="1" fill="#555555"/><rect x="3" y="16" width="20" height="6" rx="1" fill="#888888"/><rect x="3" y="10" width="14" height="6" rx="1" fill="#aaaaaa"/><rect x="3" y="4" width="8" height="6" rx="1" fill="#888888"/><line x1="3" y1="22" x2="29" y2="22" stroke="#555555" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="16" x2="23" y2="16" stroke="#555555" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="10" x2="17" y2="10" stroke="#555555" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="4" x2="11" y2="4" stroke="#555555" stroke-width="1" stroke-linecap="round"/></svg>',
            'metal_corner_stairs_right': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2535"/><rect x="3" y="22" width="26" height="6" rx="1" fill="#4A8AAA"/><rect x="3" y="16" width="20" height="6" rx="1" fill="#7BAFD4"/><rect x="3" y="10" width="14" height="6" rx="1" fill="#A8CBDF"/><rect x="3" y="4" width="8" height="6" rx="1" fill="#7BAFD4"/><line x1="3" y1="22" x2="29" y2="22" stroke="#4A8AAA" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="16" x2="23" y2="16" stroke="#4A8AAA" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="10" x2="17" y2="10" stroke="#4A8AAA" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="4" x2="11" y2="4" stroke="#4A8AAA" stroke-width="1" stroke-linecap="round"/></svg>',
            'ladder': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="5" y="2" width="4" height="28" rx="1" fill="#8B5E3C"/><rect x="23" y="2" width="4" height="28" rx="1" fill="#8B5E3C"/><rect x="9" y="5" width="14" height="3" rx="1" fill="#B07A52"/><rect x="9" y="11" width="14" height="3" rx="1" fill="#B07A52"/><rect x="9" y="17" width="14" height="3" rx="1" fill="#B07A52"/><rect x="9" y="23" width="14" height="3" rx="1" fill="#B07A52"/></svg>',
            'sleeping_bag': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d0d1a"/><ellipse cx="16" cy="20" rx="13" ry="9" fill="#3a3a5a" stroke="#5a5a7a" stroke-width="1"/><ellipse cx="16" cy="18" rx="11" ry="7" fill="#5a5a8a"/><ellipse cx="16" cy="10" rx="8" ry="8" fill="#8a7a6a" stroke="#aa9a8a" stroke-width="1"/><ellipse cx="16" cy="9" rx="6" ry="6" fill="#ccaa88"/><ellipse cx="15" cy="8" rx="3" ry="3" fill="#ddbba0" opacity="0.7"/></svg>',
            'campfire': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#12080a"/><ellipse cx="16" cy="26" rx="10" ry="4" fill="#333" opacity="0.8"/><rect x="10" y="22" width="3" height="6" rx="1" fill="#5a3010"/><rect x="14" y="21" width="3" height="8" rx="1" fill="#6b4020"/><rect x="18" y="22" width="3" height="7" rx="1" fill="#5a3010"/><rect x="21" y="23" width="3" height="5" rx="1" fill="#4a2800"/><path d="M16,20 Q11,14 13,8" fill="none" stroke="#FF4400" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,20 Q20,12 18,6" fill="none" stroke="#FF6600" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,20 Q14,16 15,10" fill="none" stroke="#FFAA00" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,20 Q18,16 17,11" fill="none" stroke="#FFDD00" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
            'workbench': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="2" y="18" width="28" height="10" rx="2" fill="#5C3A1E"/><rect x="2" y="14" width="28" height="5" rx="1" fill="#8B5E3C"/><rect x="2" y="14" width="28" height="2" rx="1" fill="#B07A52" opacity="0.5"/><rect x="4" y="24" width="5" height="6" rx="1" fill="#5C3A1E"/><rect x="23" y="24" width="5" height="6" rx="1" fill="#5C3A1E"/><rect x="5" y="8" width="6" height="8" rx="1" fill="#8AABB8"/><rect x="14" y="6" width="4" height="10" rx="1" fill="#aaa"/><rect x="21" y="8" width="6" height="8" rx="1" fill="#B07A52"/><line x1="2" y1="18" x2="30" y2="18" stroke="#5C3A1E" stroke-width="0.5" stroke-linecap="round"/></svg>',
            'building_bench': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="2" y="18" width="28" height="10" rx="2" fill="#5C3A1E"/><rect x="2" y="14" width="28" height="5" rx="1" fill="#8B5E3C"/><rect x="2" y="14" width="28" height="2" rx="1" fill="#B07A52" opacity="0.5"/><rect x="4" y="24" width="5" height="6" rx="1" fill="#5C3A1E"/><rect x="23" y="24" width="5" height="6" rx="1" fill="#5C3A1E"/><rect x="7" y="7" width="6" height="9" rx="1" fill="#888"/><rect x="13" y="5" width="6" height="11" rx="1" fill="#aaa"/><rect x="19" y="7" width="6" height="9" rx="1" fill="#888"/><line x1="2" y1="18" x2="30" y2="18" stroke="#5C3A1E" stroke-width="0.5" stroke-linecap="round"/></svg>',
            'furnace': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#252525"/><rect x="4" y="4" width="24" height="25" rx="3" fill="#555555"/><rect x="4" y="4" width="24" height="12" rx="3" fill="#888888"/><rect x="4" y="4" width="24" height="4" rx="3" fill="#aaaaaa" opacity="0.5"/><rect x="9" y="16" width="14" height="10" rx="2" fill="#111"/><path d="M9,16 Q11,20 16,22 Q21,20 23,16" fill="none" stroke="#FF4400" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/><path d="M12,16 Q14,19 16,20 Q18,19 20,16" fill="none" stroke="#FF8800" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><rect x="13" y="25" width="6" height="5" rx="1" fill="#333"/><line x1="4" y1="14" x2="28" y2="14" stroke="#555555" stroke-width="1" stroke-linecap="round"/></svg>',
            'cooking_station': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#111"/><rect x="3" y="20" width="26" height="9" rx="2" fill="#333"/><rect x="3" y="16" width="26" height="5" rx="1" fill="#444"/><circle cx="11" cy="15" r="5" fill="#555" stroke="#888" stroke-width="1"/><circle cx="21" cy="15" r="5" fill="#555" stroke="#888" stroke-width="1"/><circle cx="11" cy="15" r="3" fill="#FF4400" opacity="0.7"/><circle cx="21" cy="15" r="3" fill="#FF6600" opacity="0.6"/><rect x="8" y="20" width="4" height="4" rx="1" fill="#666"/><rect x="20" y="20" width="4" height="4" rx="1" fill="#666"/><rect x="5" y="8" width="8" height="14" rx="1" fill="#8B4513"/><rect x="19" y="6" width="8" height="16" rx="1" fill="#8B4513"/><ellipse cx="9" cy="8" rx="4" ry="2" fill="#c86400"/><ellipse cx="23" cy="6" rx="4" ry="2" fill="#c86400"/></svg>',
            'storage_box': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="2" y="10" width="28" height="18" rx="2" fill="#8B5E3C" stroke="#5C3A1E" stroke-width="1"/><rect x="2" y="10" width="28" height="6" rx="2" fill="#B07A52"/><rect x="2" y="9" width="28" height="4" rx="2" fill="#555"/><rect x="13" y="7" width="6" height="4" rx="1" fill="#777"/><rect x="2" y="9" width="28" height="2" rx="0" fill="#5C3A1E"/><line x1="2" y1="20" x2="30" y2="20" stroke="#5C3A1E" stroke-width="0.5" stroke-linecap="round"/><rect x="11" y="21" width="10" height="5" rx="1" fill="#666"/><circle cx="16" cy="24" r="2" fill="#999"/></svg>',
            'small_storage_box': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="4" y="12" width="24" height="15" rx="2" fill="#8B5E3C" stroke="#5C3A1E" stroke-width="1"/><rect x="4" y="12" width="24" height="5" rx="2" fill="#B07A52"/><rect x="4" y="11" width="24" height="4" rx="2" fill="#555"/><rect x="13" y="9" width="6" height="4" rx="1" fill="#777"/><rect x="4" y="11" width="24" height="2" rx="0" fill="#5C3A1E"/><rect x="12" y="20" width="8" height="4" rx="1" fill="#666"/><circle cx="16" cy="22" r="1.5" fill="#999"/></svg>',
            'storage_shelf': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="3" y="3" width="3" height="26" rx="1" fill="#5C3A1E"/><rect x="26" y="3" width="3" height="26" rx="1" fill="#5C3A1E"/><rect x="3" y="3" width="26" height="3" rx="1" fill="#8B5E3C"/><rect x="3" y="13" width="26" height="3" rx="1" fill="#8B5E3C"/><rect x="3" y="23" width="26" height="3" rx="1" fill="#8B5E3C"/><rect x="7" y="6" width="6" height="7" rx="1" fill="#B07A52" opacity="0.5"/><rect x="14" y="6" width="5" height="7" rx="1" fill="#B07A52" opacity="0.4"/><rect x="20" y="6" width="4" height="7" rx="1" fill="#B07A52" opacity="0.3"/><rect x="7" y="16" width="8" height="7" rx="1" fill="#B07A52" opacity="0.4"/><rect x="17" y="16" width="5" height="7" rx="1" fill="#B07A52" opacity="0.5"/></svg>',
            'wall_shelf': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="3" y="16" width="26" height="4" rx="1" fill="#8B5E3C"/><rect x="4" y="20" width="4" height="8" rx="1" fill="#5C3A1E"/><rect x="24" y="20" width="4" height="8" rx="1" fill="#5C3A1E"/><rect x="4" y="16" width="4" height="4" rx="1" fill="#5C3A1E"/><rect x="24" y="16" width="4" height="4" rx="1" fill="#5C3A1E"/><rect x="7" y="8" width="5" height="9" rx="1" fill="#B07A52" opacity="0.6"/><rect x="13" y="6" width="6" height="10" rx="1" fill="#B07A52" opacity="0.5"/><rect x="20" y="8" width="5" height="9" rx="1" fill="#B07A52" opacity="0.6"/></svg>',
            'sewing_table': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="3" y="20" width="26" height="8" rx="2" fill="#5C3A1E"/><rect x="3" y="17" width="26" height="4" rx="1" fill="#8B5E3C"/><rect x="5" y="25" width="4" height="5" rx="1" fill="#5C3A1E"/><rect x="23" y="25" width="4" height="5" rx="1" fill="#5C3A1E"/><rect x="8" y="8" width="16" height="11" rx="2" fill="#CCAA77" stroke="#5C3A1E" stroke-width="1"/><circle cx="16" cy="13" r="3" fill="#888" stroke="#aaa" stroke-width="1"/><rect x="15" y="7" width="2" height="8" rx="0" fill="#666"/><circle cx="16" cy="6" r="2" fill="#999"/></svg>',
            'recycler': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2535"/><circle cx="16" cy="16" r="12" fill="#4A8AAA" stroke="#7BAFD4" stroke-width="1"/><circle cx="16" cy="16" r="9" fill="#7BAFD4"/><path d="M12,10 Q8,16 12,22 L10,24 L14,24 L14,20 L12,20 Q9,16 12,11Z" fill="#88CCFF"/><path d="M20,10 Q24,16 20,22 L22,24 L18,24 L18,20 L20,20 Q23,16 20,11Z" fill="#88CCFF"/><circle cx="16" cy="16" r="3" fill="#2a3a4a"/></svg>',
            'water_catcher': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#08102a"/><ellipse cx="16" cy="22" rx="12" ry="7" fill="#2244AA" stroke="#4466CC" stroke-width="1"/><path d="M4,22 Q8,14 12,22" fill="none" stroke="#4466CC" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/><path d="M12,22 Q16,10 20,22" fill="none" stroke="#5577DD" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/><path d="M20,22 Q24,14 28,22" fill="none" stroke="#4466CC" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/><ellipse cx="16" cy="22" rx="10" ry="5" fill="#3355BB" opacity="0.6"/><path d="M10,4 Q16,2 22,4 L20,14 Q16,16 12,14 Z" fill="#6688CC" opacity="0.7"/><ellipse cx="16" cy="4" rx="6" ry="2" fill="#88AAEE" opacity="0.5"/></svg>',
            'sofa': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="2" y="18" width="28" height="10" rx="3" fill="#8B6F47"/><rect x="4" y="12" width="24" height="8" rx="2" fill="#9B7D5A"/><rect x="2" y="12" width="5" height="13" rx="2" fill="#6B4A2E"/><rect x="25" y="12" width="5" height="13" rx="2" fill="#6B4A2E"/><rect x="8" y="12" width="7" height="8" rx="1" fill="#A8855F" opacity="0.7"/><rect x="17" y="12" width="7" height="8" rx="1" fill="#A8855F" opacity="0.7"/><rect x="4" y="26" width="4" height="4" rx="1" fill="#5C3A1E"/><rect x="24" y="26" width="4" height="4" rx="1" fill="#5C3A1E"/></svg>',
            'bookcase': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0e05"/><rect x="3" y="2" width="26" height="28" rx="2" fill="#5C3A1E"/><rect x="5" y="2" width="22" height="28" rx="1" fill="#3D2008"/><rect x="5" y="8" width="22" height="2" fill="#5C3A1E"/><rect x="5" y="16" width="22" height="2" fill="#5C3A1E"/><rect x="5" y="24" width="22" height="2" fill="#5C3A1E"/><rect x="6" y="4" width="3" height="4" rx="0" fill="#C0392B"/><rect x="10" y="4" width="4" height="4" rx="0" fill="#2980B9"/><rect x="15" y="3" width="3" height="5" rx="0" fill="#27AE60"/><rect x="19" y="4" width="4" height="4" rx="0" fill="#E67E22"/><rect x="6" y="11" width="4" height="5" rx="0" fill="#8E44AD"/><rect x="12" y="10" width="3" height="6" rx="0" fill="#1ABC9C"/><rect x="16" y="11" width="4" height="5" rx="0" fill="#E74C3C"/><rect x="21" y="11" width="4" height="5" rx="0" fill="#3498DB"/><rect x="6" y="19" width="3" height="5" rx="0" fill="#F39C12"/><rect x="11" y="19" width="4" height="5" rx="0" fill="#E74C3C"/><rect x="17" y="18" width="3" height="6" rx="0" fill="#2ECC71"/><rect x="22" y="19" width="4" height="5" rx="0" fill="#9B59B6"/></svg>',
            'table': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="2" y="12" width="28" height="4" rx="2" fill="#8B5E3C"/><rect x="6" y="16" width="3" height="14" rx="1" fill="#6B4423"/><rect x="23" y="16" width="3" height="14" rx="1" fill="#6B4423"/><rect x="8" y="16" width="2" height="10" rx="1" fill="#5C3A1E" opacity="0.5"/><rect x="22" y="16" width="2" height="10" rx="1" fill="#5C3A1E" opacity="0.5"/><rect x="4" y="11" width="24" height="2" rx="1" fill="#A07040"/></svg>',
            'chair': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0e05"/><rect x="8" y="14" width="16" height="4" rx="2" fill="#9B7D5A"/><rect x="8" y="4" width="3" height="24" rx="1" fill="#6B4423"/><rect x="21" y="4" width="3" height="24" rx="1" fill="#6B4423"/><rect x="11" y="18" width="10" height="10" rx="1" fill="#8B6F47"/><rect x="9" y="7" width="14" height="3" rx="1" fill="#8B6347" opacity="0.7"/><rect x="9" y="11" width="14" height="3" rx="1" fill="#8B6347" opacity="0.7"/></svg>',
            'wall_shelf_b': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0e05"/><rect x="2" y="10" width="28" height="4" rx="1" fill="#7B5230"/><rect x="2" y="20" width="28" height="4" rx="1" fill="#7B5230"/><rect x="3" y="10" width="5" height="14" rx="1" fill="#5C3A1E"/><rect x="24" y="10" width="5" height="14" rx="1" fill="#5C3A1E"/><rect x="8" y="6" width="4" height="4" rx="1" fill="#8B5E3C" opacity="0.7"/><rect x="14" y="4" width="5" height="6" rx="1" fill="#8B5E3C" opacity="0.6"/><rect x="20" y="7" width="4" height="3" rx="1" fill="#8B5E3C" opacity="0.7"/></svg>',
            'candle': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0a0806"/><ellipse cx="16" cy="28" rx="7" ry="3" fill="#666655"/><rect x="12" y="14" width="8" height="14" rx="2" fill="#FFFACD"/><ellipse cx="16" cy="14" rx="4" ry="1.5" fill="#F5E8A0"/><rect x="15" y="10" width="2" height="5" rx="1" fill="#444400"/><ellipse cx="16" cy="9" rx="3" ry="4" fill="#FFCC00" opacity="0.9"/><ellipse cx="16" cy="7" rx="2" ry="3" fill="#FFEE88" opacity="0.7"/><circle cx="16" cy="9" r="1" fill="white" opacity="0.5"/></svg>',
            'wall_light': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d0d14"/><rect x="13" y="2" width="6" height="10" rx="2" fill="#555"/><rect x="14" y="10" width="4" height="6" rx="1" fill="#666"/><path d="M8,16 L24,16 L20,28 L12,28 Z" fill="#888877" opacity="0.8"/><ellipse cx="16" cy="16" rx="5" ry="3" fill="#FFFFAA" opacity="0.9"/><ellipse cx="16" cy="22" rx="7" ry="6" fill="#FFEE66" opacity="0.25"/><circle cx="16" cy="16" r="3" fill="white" opacity="0.6"/></svg>',
            'bee_hive': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0e00"/><rect x="10" y="22" width="12" height="3" rx="1" fill="#7B5A2A"/><rect x="8" y="18" width="16" height="5" rx="2" fill="#9C7A3C"/><rect x="7" y="13" width="18" height="6" rx="2" fill="#B8922A"/><rect x="8" y="8" width="16" height="6" rx="2" fill="#D4A832"/><path d="M10,8 L22,8 L19,4 L13,4 Z" fill="#5C3A1E"/><circle cx="16" cy="19" r="2" fill="#2d1a00"/><circle cx="14" cy="25" r="1" fill="#FFD700" opacity="0.6"/></svg>',
            'chicken_coop': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d0a05"/><rect x="2" y="16" width="28" height="14" rx="2" fill="#8B6F47"/><path d="M2,16 L16,6 L30,16 Z" fill="#CC4400"/><rect x="5" y="18" width="10" height="10" rx="1" fill="#A08050" stroke="#7B5A2A" stroke-width="0.5"/><rect x="17" y="18" width="10" height="10" rx="1" fill="#7B5A30"/><line x1="18" y1="18" x2="26" y2="26" stroke="#5C3A1E" stroke-width="1"/><line x1="26" y1="18" x2="18" y2="26" stroke="#5C3A1E" stroke-width="1"/><circle cx="21" cy="22" r="3" fill="#CC6600"/><circle cx="22" cy="21" r="1" fill="#333"/><rect x="21" y="23" width="3" height="2" rx="0.5" fill="#FF9900"/></svg>',
            'oil_smelter': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0a0c10"/><rect x="3" y="26" width="26" height="4" rx="1" fill="#2A2E32"/><ellipse cx="16" cy="18" rx="12" ry="8" fill="#444A50"/><ellipse cx="16" cy="18" rx="10" ry="6" fill="#3A4046"/><rect x="6" y="24" width="6" height="3" rx="1" fill="#2A2E32"/><rect x="20" y="24" width="6" height="3" rx="1" fill="#2A2E32"/><rect x="8" y="14" width="16" height="5" rx="8" fill="#555A60" stroke="#666C74" stroke-width="1"/><circle cx="23" cy="16" r="2.5" fill="#B87333" stroke="#DAA520" stroke-width="0.5"/><rect x="5" y="5" width="4" height="10" rx="2" fill="#2A2E32"/><rect x="5" y="4" width="5" height="2" rx="1" fill="#1A1E22"/><rect x="14" y="22" width="4" height="5" rx="1" fill="#B87333" opacity="0.6"/><circle cx="11" cy="19" r="1.5" fill="#FF6600" opacity="0.8"/></svg>',
            'honey': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0e00"/><rect x="10" y="8" width="12" height="18" rx="4" fill="#DAA520"/><rect x="12" y="4" width="8" height="6" rx="2" fill="#B8860B"/><rect x="11" y="22" width="10" height="5" rx="2" fill="#B8860B"/><ellipse cx="16" cy="8" rx="4" ry="2" fill="#FFD700"/><rect x="13" y="12" width="6" height="2" rx="1" fill="#B8860B" opacity="0.6"/><rect x="13" y="16" width="6" height="2" rx="1" fill="#B8860B" opacity="0.6"/></svg>',
            'egg': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0a0806"/><ellipse cx="16" cy="17" rx="9" ry="11" fill="#FFF5DC"/><ellipse cx="14" cy="14" rx="3" ry="2" fill="white" opacity="0.3"/></svg>',
            'water_bottle': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#08102a"/><rect x="12" y="3" width="8" height="5" rx="1" fill="#88AACC"/><rect x="10" y="8" width="12" height="20" rx="3" fill="#2255AA" stroke="#4477CC" stroke-width="1"/><rect x="10" y="8" width="12" height="8" rx="3" fill="#3366BB"/><rect x="11" y="12" width="10" height="12" rx="2" fill="#4488DD" opacity="0.5"/><ellipse cx="16" cy="14" rx="3" ry="2" fill="#88BBFF" opacity="0.4"/><rect x="13" y="4" width="6" height="2" rx="1" fill="#AACCEE" opacity="0.6"/></svg>',
            'flour': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#252535"/><rect x="7" y="8" width="18" height="18" rx="2" fill="#ddd" stroke="#bbb" stroke-width="1"/><rect x="7" y="8" width="18" height="6" rx="2" fill="#eee"/><rect x="10" y="8" width="3" height="18" rx="0" fill="#ccc"/><rect x="14" y="8" width="3" height="18" rx="0" fill="#ccc"/><rect x="18" y="8" width="3" height="18" rx="0" fill="#ccc"/><text x="16" y="20" fill="#888" font-size="9" font-weight="bold" text-anchor="middle" font-family="system-ui,sans-serif">F</text></svg>',
            'bread': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1205"/><ellipse cx="16" cy="19" rx="13" ry="9" fill="#8B4513" stroke="#A0522D" stroke-width="1"/><ellipse cx="16" cy="17" rx="11" ry="7" fill="#D2691E"/><ellipse cx="16" cy="15" rx="9" ry="5" fill="#DAA520" opacity="0.6"/><path d="M8,18 Q16,13 24,18" fill="none" stroke="#8B4513" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" opacity="0.5"/></svg>',
            'blackcurrant_jam': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0828"/><rect x="8" y="10" width="16" height="16" rx="2" fill="#1a0030" stroke="#4a1a60" stroke-width="1"/><rect x="8" y="6" width="16" height="6" rx="2" fill="#6600aa"/><rect x="8" y="6" width="16" height="4" rx="2" fill="#8822cc"/><rect x="6" y="8" width="20" height="4" rx="1" fill="#550088"/><circle cx="14" cy="17" r="2" fill="#aa44ee" opacity="0.6"/><circle cx="18" cy="20" r="1.5" fill="#882299" opacity="0.5"/><circle cx="12" cy="21" r="1.5" fill="#9933bb" opacity="0.5"/></svg>',
            'strawberry_jam': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a0808"/><rect x="8" y="10" width="16" height="16" rx="2" fill="#2a0008" stroke="#7a1020" stroke-width="1"/><rect x="8" y="6" width="16" height="6" rx="2" fill="#cc1122"/><rect x="8" y="6" width="16" height="4" rx="2" fill="#ee2233"/><rect x="6" y="8" width="20" height="4" rx="1" fill="#aa0011"/><circle cx="14" cy="17" r="2" fill="#ff3344" opacity="0.6"/><circle cx="18" cy="20" r="1.5" fill="#dd1122" opacity="0.5"/></svg>',
            'toast_jam': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1205"/><rect x="5" y="7" width="22" height="20" rx="2" fill="#D2691E" stroke="#8B4513" stroke-width="1"/><rect x="5" y="7" width="22" height="6" rx="2" fill="#DAA520"/><rect x="7" y="13" width="18" height="12" rx="1" fill="#cc2244" opacity="0.8"/><rect x="7" y="13" width="18" height="3" rx="1" fill="#ee3355" opacity="0.6"/><circle cx="11" cy="19" r="1.5" fill="#ff4466" opacity="0.5"/><circle cx="17" cy="21" r="1" fill="#dd1133" opacity="0.5"/></svg>',
            'ham_sandwich': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1205"/><rect x="4" y="20" width="24" height="8" rx="3" fill="#D2691E" stroke="#8B4513" stroke-width="1"/><rect x="4" y="15" width="24" height="6" rx="0" fill="#F4A460"/><rect x="4" y="12" width="24" height="4" rx="0" fill="#cc4422"/><rect x="4" y="9" width="24" height="4" rx="0" fill="#88cc44"/><rect x="4" y="6" width="24" height="4" rx="0" fill="#F4A460"/><rect x="4" y="4" width="24" height="3" rx="3" fill="#D2691E"/><line x1="4" y1="8" x2="28" y2="8" stroke="#8B4513" stroke-width="0.5" stroke-linecap="round"/><line x1="4" y1="13" x2="28" y2="13" stroke="#8B4513" stroke-width="0.5" stroke-linecap="round"/><line x1="4" y1="16" x2="28" y2="16" stroke="#8B4513" stroke-width="0.5" stroke-linecap="round"/></svg>',
            'planter_box': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1005"/><rect x="4" y="16" width="24" height="12" rx="2" fill="#5a3010" stroke="#7a4a20" stroke-width="1"/><rect x="4" y="12" width="24" height="5" rx="1" fill="#7a4a20"/><rect x="6" y="17" width="20" height="9" rx="1" fill="#3a1a00" opacity="0.5"/><path d="M8,12 Q8,5 10,4 Q12,3 12,12" fill="none" stroke="#44aa44" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M14,12 Q13,4 16,3 Q19,4 18,12" fill="none" stroke="#55bb55" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M20,12 Q20,5 22,4 Q24,3 24,12" fill="none" stroke="#44aa44" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
            'large_planter': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1005"/><rect x="2" y="16" width="28" height="12" rx="2" fill="#5a3010" stroke="#7a4a20" stroke-width="1"/><rect x="2" y="12" width="28" height="5" rx="1" fill="#7a4a20"/><rect x="4" y="17" width="24" height="9" rx="1" fill="#3a1a00" opacity="0.5"/><path d="M6,12 Q6,4 8,3 Q10,2 10,12" fill="none" stroke="#44aa44" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M12,12 Q11,3 14,2 Q17,3 16,12" fill="none" stroke="#66cc44" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M18,12 Q17,3 20,2 Q23,3 22,12" fill="none" stroke="#55bb55" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M24,12 Q24,4 26,3 Q28,2 28,12" fill="none" stroke="#44aa44" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
            'pumpkin_seed': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1f1a00"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#CC8800" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#44aa22" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#44aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#44aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'wheat_seed': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1f1a00"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#D4A017" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#88aa22" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#88aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#88aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'cabbage_seed': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2010"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#6aaa22" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#44cc22" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#44cc22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#44cc22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'cucumber_seed': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2010"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#338822" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#55cc33" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#55cc33" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#55cc33" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'potato_seed': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1005"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#AA8844" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#667733" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#667733" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#667733" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'carrot_seed': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1005"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#DD6600" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#44aa22" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#44aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#44aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'hemp_seed': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2010"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#558833" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#77aa33" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#77aa33" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#77aa33" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'corn_seed': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1f1a00"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#DDaa00" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#88aa22" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#88aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#88aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'mushroom_seed': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0d05"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#885522" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#AA7744" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#AA7744" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#AA7744" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'red_berry_seed': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a0808"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#cc2244" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#44aa22" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#44aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#44aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'black_berry_seed': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0828"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#440066" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#2a6622" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#2a6622" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#2a6622" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'strawberry_seed': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a0808"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#cc2233" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#44bb22" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#44bb22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#44bb22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'tomato_seed': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a0808"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#cc3311" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#44aa22" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#44aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#44aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'pumpkin': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1f1a00"/><ellipse cx="16" cy="18" rx="11" ry="9" fill="#cc6600" stroke="#ee8800" stroke-width="1"/><ellipse cx="12" cy="17" rx="4" ry="7" fill="#DD7700" opacity="0.8"/><ellipse cx="16" cy="17" rx="4" ry="8" fill="#FF8800" opacity="0.9"/><ellipse cx="20" cy="17" rx="4" ry="7" fill="#DD7700" opacity="0.8"/><path d="M16,9 Q15,5 14,4" fill="none" stroke="#338833" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,9 Q18,6 19,5 Q17,4 16,5" fill="none" stroke="#44aa44" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><ellipse cx="16" cy="26" rx="8" ry="3" fill="#995500" opacity="0.4"/></svg>',
            'wheat': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1f1a00"/><path d="M16,28 L16,8" fill="none" stroke="#8B8000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><ellipse cx="14" cy="8" rx="2" ry="4" fill="#D4A017"/><ellipse cx="18" cy="10" rx="2" ry="4" fill="#D4A017"/><ellipse cx="14" cy="13" rx="2" ry="4" fill="#D4A017"/><ellipse cx="18" cy="15" rx="2" ry="4" fill="#D4A017"/><ellipse cx="14" cy="18" rx="2" ry="4" fill="#CCAA00"/><ellipse cx="18" cy="20" rx="2" ry="4" fill="#CCAA00"/><path d="M12,4 Q14,2 16,4 Q18,2 20,4" fill="none" stroke="#ccaa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
            'cabbage': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2010"/><circle cx="16" cy="17" r="12" fill="#2a6a1a" stroke="#44aa22" stroke-width="1"/><circle cx="16" cy="17" r="9" fill="#44aa22"/><circle cx="16" cy="17" r="6" fill="#66cc33"/><path d="M10,14 Q16,10 22,14" fill="none" stroke="#88dd44" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" opacity="0.6"/><path d="M9,18 Q16,15 23,18" fill="none" stroke="#88dd44" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" opacity="0.5"/></svg>',
            'cucumber': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2010"/><ellipse cx="16" cy="16" rx="5" ry="13" fill="#3a8822" stroke="#55aa33" stroke-width="1"/><ellipse cx="16" cy="16" rx="4" ry="11" fill="#55bb33"/><line x1="13" y1="10" x2="19" y2="10" stroke="#44aa22" stroke-width="1" stroke-linecap="round"/><line x1="13" y1="13" x2="19" y2="13" stroke="#44aa22" stroke-width="1" stroke-linecap="round"/><line x1="13" y1="16" x2="19" y2="16" stroke="#44aa22" stroke-width="1" stroke-linecap="round"/><line x1="13" y1="19" x2="19" y2="19" stroke="#44aa22" stroke-width="1" stroke-linecap="round"/><ellipse cx="16" cy="5" rx="2" ry="3" fill="#338822"/><circle cx="16" cy="4" r="1" fill="#666"/></svg>',
            'potato': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1005"/><ellipse cx="16" cy="17" rx="11" ry="9" fill="#8B7355" stroke="#AA9977" stroke-width="1"/><ellipse cx="16" cy="16" rx="9" ry="7" fill="#AA9977"/><circle cx="11" cy="14" r="1.5" fill="#776644" opacity="0.7"/><circle cx="20" cy="16" r="1" fill="#776644" opacity="0.6"/><circle cx="14" cy="20" r="1" fill="#776644" opacity="0.5"/><circle cx="18" cy="13" r="1" fill="#887766" opacity="0.4"/></svg>',
            'carrot': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1005"/><path d="M16,6 Q10,10 12,24 Q14,28 16,28 Q18,28 20,24 Q22,10 16,6Z" fill="#DD6600" stroke="#FF8822" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/><path d="M12,14 Q16,12 20,14" fill="none" stroke="#CC5500" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" opacity="0.5"/><path d="M11,18 Q16,16 21,18" fill="none" stroke="#CC5500" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" opacity="0.4"/><path d="M14,6 Q12,2 10,2" fill="none" stroke="#44aa44" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,5 Q16,2 16,1" fill="none" stroke="#55bb44" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M18,6 Q20,2 22,2" fill="none" stroke="#44aa44" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
            'hemp_fiber': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2010"/><path d="M8,28 Q10,18 12,10 Q14,5 16,4" fill="none" stroke="#5a9a22" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M12,28 Q14,18 15,12 Q16,7 17,4" fill="none" stroke="#66aa33" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M18,28 Q18,18 18,12 Q18,7 18,4" fill="none" stroke="#5a9a22" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M22,28 Q22,18 21,12 Q20,7 19,4" fill="none" stroke="#447722" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M10,16 Q16,13 22,16" fill="none" stroke="#88cc44" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" opacity="0.6"/><path d="M9,20 Q16,17 23,20" fill="none" stroke="#77bb33" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" opacity="0.5"/></svg>',
            'corn': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1f1a00"/><ellipse cx="16" cy="17" rx="7" ry="12" fill="#8B6914" stroke="#AA8822" stroke-width="1"/><ellipse cx="16" cy="17" rx="5" ry="10" fill="#D4A017"/><circle cx="13" cy="13" r="1" fill="#FFD700"/><circle cx="15" cy="12" r="1" fill="#FFD700"/><circle cx="17" cy="12" r="1" fill="#FFD700"/><circle cx="19" cy="13" r="1" fill="#FFD700"/><circle cx="12" cy="16" r="1" fill="#FFD700"/><circle cx="14" cy="15" r="1" fill="#FFD700"/><circle cx="16" cy="14" r="1" fill="#FFD700"/><circle cx="18" cy="15" r="1" fill="#FFD700"/><circle cx="20" cy="16" r="1" fill="#FFD700"/><circle cx="13" cy="19" r="1" fill="#FFD700"/><circle cx="15" cy="18" r="1" fill="#FFD700"/><circle cx="17" cy="18" r="1" fill="#FFD700"/><circle cx="19" cy="19" r="1" fill="#FFD700"/><circle cx="14" cy="22" r="1" fill="#DDaa00"/><circle cx="16" cy="22" r="1" fill="#FFD700"/><circle cx="18" cy="22" r="1" fill="#DDaa00"/><path d="M21,8 Q24,4 22,2" fill="none" stroke="#44aa22" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M19,10 Q22,6 20,4" fill="none" stroke="#66cc33" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
            'mushroom_crop': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0d05"/><ellipse cx="16" cy="14" rx="12" ry="9" fill="#8B4513" stroke="#AA6633" stroke-width="1"/><ellipse cx="16" cy="13" rx="10" ry="7" fill="#A0522D"/><circle cx="11" cy="12" r="2" fill="#FFE4C4" opacity="0.8"/><circle cx="19" cy="11" r="1.5" fill="#FFE4C4" opacity="0.7"/><circle cx="15" cy="14" r="1" fill="#FFE4C4" opacity="0.6"/><rect x="13" y="20" width="6" height="9" rx="1" fill="#F5DEB3"/><line x1="13" y1="22" x2="19" y2="22" stroke="#DDD" stroke-width="0.5" stroke-linecap="round"/><line x1="13" y1="24" x2="19" y2="24" stroke="#DDD" stroke-width="0.5" stroke-linecap="round"/></svg>',
            'red_berries': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a0808"/><circle cx="10" cy="18" r="4" fill="#cc2222" stroke="#ee3333" stroke-width="0.5"/><circle cx="17" cy="16" r="4" fill="#dd1133"/><circle cx="22" cy="19" r="4" fill="#cc2244"/><circle cx="13" cy="14" r="3" fill="#ee2233"/><circle cx="20" cy="13" r="3" fill="#dd1122"/><path d="M10,14 Q12,10 14,12" fill="none" stroke="#44aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M17,12 Q18,8 20,10" fill="none" stroke="#44aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="10" cy="18" r="2" fill="#ff4444" opacity="0.4"/><circle cx="17" cy="16" r="2" fill="#ff3355" opacity="0.3"/></svg>',
            'black_berries': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0828"/><circle cx="10" cy="18" r="4" fill="#2a0044" stroke="#5511aa" stroke-width="0.5"/><circle cx="17" cy="16" r="4" fill="#1a0033"/><circle cx="22" cy="19" r="4" fill="#330055"/><circle cx="13" cy="14" r="3" fill="#440066"/><circle cx="20" cy="13" r="3" fill="#2a0044"/><path d="M10,14 Q12,10 14,12" fill="none" stroke="#44aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M17,12 Q18,8 20,10" fill="none" stroke="#44aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="10" cy="18" r="2" fill="#8844cc" opacity="0.4"/><circle cx="17" cy="16" r="2" fill="#6622aa" opacity="0.3"/></svg>',
            'strawberry': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a0808"/><path d="M16,28 Q8,22 8,15 Q8,7 16,7 Q24,7 24,15 Q24,22 16,28Z" fill="#cc1133" stroke="#ee2244" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/><circle cx="12" cy="14" r="1" fill="#FFE4E1" opacity="0.6"/><circle cx="18" cy="12" r="1" fill="#FFE4E1" opacity="0.5"/><circle cx="20" cy="17" r="1" fill="#FFE4E1" opacity="0.5"/><circle cx="13" cy="19" r="1" fill="#FFE4E1" opacity="0.4"/><path d="M14,7 Q13,3 12,2" fill="none" stroke="#44aa22" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,6 Q16,3 16,2" fill="none" stroke="#55bb33" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M18,7 Q19,3 20,2" fill="none" stroke="#44aa22" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
            'tomato': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a0808"/><circle cx="16" cy="18" r="11" fill="#cc2211" stroke="#ee3322" stroke-width="1"/><circle cx="16" cy="17" r="9" fill="#dd3322"/><ellipse cx="14" cy="14" rx="3" ry="2" fill="#ff5533" opacity="0.4"/><path d="M13,7 Q14,4 16,3 Q18,4 19,7" fill="none" stroke="#44aa22" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,7 Q15,4 14,3" fill="none" stroke="#55bb33" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,7 Q17,4 18,3" fill="none" stroke="#55bb33" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="26" r="4" fill="#aa1100" opacity="0.3"/></svg>',
            'floor_rug_red': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#200808"/><rect x="2" y="2" width="28" height="28" rx="2" fill="#aa0000"/><rect x="4" y="4" width="24" height="24" rx="1" fill="#cc2222"/><rect x="7" y="7" width="18" height="18" rx="1" fill="#aa0000"/><rect x="10" y="10" width="12" height="12" rx="1" fill="#ee4444" opacity="0.7"/><polygon points="16,11 21,16 16,21 11,16" fill="#cc2222" stroke="#aa0000" stroke-width="0.5"/></svg>',
            'floor_rug_blue': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#080820"/><rect x="2" y="2" width="28" height="28" rx="2" fill="#001188"/><rect x="4" y="4" width="24" height="24" rx="1" fill="#2244cc"/><rect x="7" y="7" width="18" height="18" rx="1" fill="#001188"/><rect x="10" y="10" width="12" height="12" rx="1" fill="#4466ee" opacity="0.7"/><polygon points="16,11 21,16 16,21 11,16" fill="#2244cc" stroke="#001188" stroke-width="0.5"/></svg>',
            'floor_rug_green': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#081808"/><rect x="2" y="2" width="28" height="28" rx="2" fill="#006600"/><rect x="4" y="4" width="24" height="24" rx="1" fill="#228822"/><rect x="7" y="7" width="18" height="18" rx="1" fill="#006600"/><rect x="10" y="10" width="12" height="12" rx="1" fill="#44aa44" opacity="0.7"/><polygon points="16,11 21,16 16,21 11,16" fill="#228822" stroke="#006600" stroke-width="0.5"/></svg>',
            'curtain_red': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0808"/><path d="M4,5 Q8,12 5,20 Q7,25 5,30" fill="none" stroke="#cc2222" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M9,5 Q13,14 10,22 Q12,27 10,30" fill="none" stroke="#ee4444" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M18,5 Q22,12 19,20 Q21,25 19,30" fill="none" stroke="#ee4444" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M23,5 Q27,14 24,22 Q26,27 24,30" fill="none" stroke="#cc2222" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><rect x="2" y="2" width="28" height="3" rx="1" fill="#880000"/><circle cx="7" cy="3" r="2" fill="#880000"/><circle cx="13" cy="3" r="2" fill="#880000"/><circle cx="19" cy="3" r="2" fill="#880000"/><circle cx="25" cy="3" r="2" fill="#880000"/></svg>',
            'curtain_blue': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#08081a"/><path d="M4,5 Q8,12 5,20 Q7,25 5,30" fill="none" stroke="#2244cc" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M9,5 Q13,14 10,22 Q12,27 10,30" fill="none" stroke="#4466ee" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M18,5 Q22,12 19,20 Q21,25 19,30" fill="none" stroke="#4466ee" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M23,5 Q27,14 24,22 Q26,27 24,30" fill="none" stroke="#2244cc" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><rect x="2" y="2" width="28" height="3" rx="1" fill="#001188"/><circle cx="7" cy="3" r="2" fill="#001188"/><circle cx="13" cy="3" r="2" fill="#001188"/><circle cx="19" cy="3" r="2" fill="#001188"/><circle cx="25" cy="3" r="2" fill="#001188"/></svg>',
            'curtain_green': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#081808"/><path d="M4,5 Q8,12 5,20 Q7,25 5,30" fill="none" stroke="#228822" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M9,5 Q13,14 10,22 Q12,27 10,30" fill="none" stroke="#44aa44" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M18,5 Q22,12 19,20 Q21,25 19,30" fill="none" stroke="#44aa44" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M23,5 Q27,14 24,22 Q26,27 24,30" fill="none" stroke="#228822" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><rect x="2" y="2" width="28" height="3" rx="1" fill="#005500"/><circle cx="7" cy="3" r="2" fill="#005500"/><circle cx="13" cy="3" r="2" fill="#005500"/><circle cx="19" cy="3" r="2" fill="#005500"/><circle cx="25" cy="3" r="2" fill="#005500"/></svg>',
            'curtain_white': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1a1a"/><path d="M4,5 Q8,12 5,20 Q7,25 5,30" fill="none" stroke="#dddddd" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M9,5 Q13,14 10,22 Q12,27 10,30" fill="none" stroke="#ffffff" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M18,5 Q22,12 19,20 Q21,25 19,30" fill="none" stroke="#ffffff" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M23,5 Q27,14 24,22 Q26,27 24,30" fill="none" stroke="#dddddd" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><rect x="2" y="2" width="28" height="3" rx="1" fill="#aaaaaa"/><circle cx="7" cy="3" r="2" fill="#aaaaaa"/><circle cx="13" cy="3" r="2" fill="#aaaaaa"/><circle cx="19" cy="3" r="2" fill="#aaaaaa"/><circle cx="25" cy="3" r="2" fill="#aaaaaa"/></svg>',
            'curtain_beige': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#15100a"/><path d="M4,5 Q8,12 5,20 Q7,25 5,30" fill="none" stroke="#ccaa77" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M9,5 Q13,14 10,22 Q12,27 10,30" fill="none" stroke="#ddbb88" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M18,5 Q22,12 19,20 Q21,25 19,30" fill="none" stroke="#ddbb88" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M23,5 Q27,14 24,22 Q26,27 24,30" fill="none" stroke="#ccaa77" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><rect x="2" y="2" width="28" height="3" rx="1" fill="#997744"/><circle cx="7" cy="3" r="2" fill="#997744"/><circle cx="13" cy="3" r="2" fill="#997744"/><circle cx="19" cy="3" r="2" fill="#997744"/><circle cx="25" cy="3" r="2" fill="#997744"/></svg>',
            'iron_helmet': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e2a38"/><path d="M6,20 Q6,6 16,5 Q26,6 26,20 Z" fill="#8AABB8"/><path d="M10,18 Q10,10 16,9 Q22,10 22,18 Z" fill="#AABFCC" opacity="0.4"/><rect x="5" y="19" width="22" height="4" rx="1" fill="#5A8090"/><rect x="9" y="13" width="14" height="5" rx="2" fill="#2255AA"/><rect x="10" y="14" width="5" height="2" rx="1" fill="#88BBFF" opacity="0.6"/><rect x="5" y="21" width="5" height="6" rx="1" fill="#5A8090"/><rect x="22" y="21" width="5" height="6" rx="1" fill="#5A8090"/></svg>',
            'iron_vest': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e2a38"/><rect x="3" y="6" width="8" height="8" rx="2" fill="#5A8090"/><rect x="21" y="6" width="8" height="8" rx="2" fill="#5A8090"/><rect x="5" y="8" width="22" height="20" rx="2" fill="#8AABB8"/><rect x="10" y="10" width="12" height="10" rx="2" fill="#AABFCC" opacity="0.6"/><path d="M12,8 L16,12 L20,8 Z" fill="#5A8090"/><rect x="6" y="19" width="20" height="2" rx="0" fill="#5A8090"/><rect x="6" y="22" width="20" height="2" rx="0" fill="#5A8090"/></svg>',
            'iron_gloves': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e2a38"/><rect x="5" y="5" width="2" height="8" rx="1" fill="#8AABB8"/><rect x="8" y="4" width="2" height="9" rx="1" fill="#8AABB8"/><rect x="11" y="5" width="2" height="8" rx="1" fill="#8AABB8"/><rect x="19" y="5" width="2" height="8" rx="1" fill="#8AABB8"/><rect x="22" y="4" width="2" height="9" rx="1" fill="#8AABB8"/><rect x="25" y="5" width="2" height="8" rx="1" fill="#8AABB8"/><rect x="4" y="10" width="10" height="16" rx="2" fill="#8AABB8"/><rect x="18" y="10" width="10" height="16" rx="2" fill="#8AABB8"/><rect x="4" y="10" width="10" height="3" rx="1" fill="#5A8090"/><rect x="18" y="10" width="10" height="3" rx="1" fill="#5A8090"/><rect x="4" y="13" width="10" height="2" rx="0" fill="#AABFCC" opacity="0.3"/><rect x="18" y="13" width="10" height="2" rx="0" fill="#AABFCC" opacity="0.3"/></svg>',
            'iron_pants': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e2a38"/><rect x="5" y="4" width="22" height="6" rx="2" fill="#5A8090"/><rect x="5" y="10" width="10" height="18" rx="2" fill="#8AABB8"/><rect x="17" y="10" width="10" height="18" rx="2" fill="#8AABB8"/><rect x="5" y="16" width="10" height="4" rx="1" fill="#AABFCC" opacity="0.5"/><rect x="17" y="16" width="10" height="4" rx="1" fill="#AABFCC" opacity="0.5"/><rect x="5" y="14" width="10" height="1" rx="0" fill="#5A8090"/><rect x="17" y="14" width="10" height="1" rx="0" fill="#5A8090"/></svg>',
            'iron_boots': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e2a38"/><rect x="4" y="4" width="10" height="16" rx="2" fill="#8AABB8"/><rect x="18" y="4" width="10" height="16" rx="2" fill="#8AABB8"/><rect x="3" y="18" width="12" height="10" rx="2" fill="#8AABB8"/><rect x="17" y="18" width="12" height="10" rx="2" fill="#8AABB8"/><rect x="3" y="22" width="12" height="6" rx="2" fill="#5A8090"/><rect x="17" y="22" width="12" height="6" rx="2" fill="#5A8090"/><rect x="4" y="6" width="10" height="4" rx="1" fill="#AABFCC" opacity="0.4"/><rect x="18" y="6" width="10" height="4" rx="1" fill="#AABFCC" opacity="0.4"/><line x1="7" y1="8" x2="11" y2="8" stroke="#5A8090" stroke-width="1.5" stroke-linecap="round"/><line x1="21" y1="8" x2="25" y2="8" stroke="#5A8090" stroke-width="1.5" stroke-linecap="round"/></svg>',
            'cloth_helmet': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a2010"/><path d="M6,20 Q6,6 16,5 Q26,6 26,20 Z" fill="#C8A96E"/><path d="M10,18 Q10,10 16,9 Q22,10 22,18 Z" fill="#E2C98A" opacity="0.4"/><rect x="5" y="19" width="22" height="4" rx="1" fill="#A07840"/><rect x="9" y="13" width="14" height="5" rx="2" fill="#8B6030"/><rect x="10" y="14" width="5" height="2" rx="1" fill="#F0D898" opacity="0.6"/><rect x="5" y="21" width="5" height="6" rx="1" fill="#A07840"/><rect x="22" y="21" width="5" height="6" rx="1" fill="#A07840"/></svg>',
            'cloth_vest': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a2010"/><rect x="3" y="6" width="8" height="8" rx="2" fill="#A07840"/><rect x="21" y="6" width="8" height="8" rx="2" fill="#A07840"/><rect x="5" y="8" width="22" height="20" rx="2" fill="#C8A96E"/><rect x="10" y="10" width="12" height="10" rx="2" fill="#E2C98A" opacity="0.6"/><path d="M12,8 L16,12 L20,8 Z" fill="#A07840"/><rect x="6" y="19" width="20" height="2" rx="0" fill="#A07840"/><rect x="6" y="22" width="20" height="2" rx="0" fill="#A07840"/></svg>',
            'cloth_gloves': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a2010"/><rect x="5" y="5" width="2" height="8" rx="1" fill="#C8A96E"/><rect x="8" y="4" width="2" height="9" rx="1" fill="#C8A96E"/><rect x="11" y="5" width="2" height="8" rx="1" fill="#C8A96E"/><rect x="19" y="5" width="2" height="8" rx="1" fill="#C8A96E"/><rect x="22" y="4" width="2" height="9" rx="1" fill="#C8A96E"/><rect x="25" y="5" width="2" height="8" rx="1" fill="#C8A96E"/><rect x="4" y="10" width="10" height="16" rx="2" fill="#C8A96E"/><rect x="18" y="10" width="10" height="16" rx="2" fill="#C8A96E"/><rect x="4" y="10" width="10" height="3" rx="1" fill="#A07840"/><rect x="18" y="10" width="10" height="3" rx="1" fill="#A07840"/><rect x="4" y="13" width="10" height="2" rx="0" fill="#E2C98A" opacity="0.3"/><rect x="18" y="13" width="10" height="2" rx="0" fill="#E2C98A" opacity="0.3"/></svg>',
            'cloth_pants': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a2010"/><rect x="5" y="4" width="22" height="6" rx="2" fill="#A07840"/><rect x="5" y="10" width="10" height="18" rx="2" fill="#C8A96E"/><rect x="17" y="10" width="10" height="18" rx="2" fill="#C8A96E"/><rect x="5" y="16" width="10" height="4" rx="1" fill="#E2C98A" opacity="0.5"/><rect x="17" y="16" width="10" height="4" rx="1" fill="#E2C98A" opacity="0.5"/><rect x="5" y="14" width="10" height="1" rx="0" fill="#A07840"/><rect x="17" y="14" width="10" height="1" rx="0" fill="#A07840"/></svg>',
            'cloth_boots': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a2010"/><rect x="4" y="4" width="10" height="16" rx="2" fill="#C8A96E"/><rect x="18" y="4" width="10" height="16" rx="2" fill="#C8A96E"/><rect x="3" y="18" width="12" height="10" rx="2" fill="#C8A96E"/><rect x="17" y="18" width="12" height="10" rx="2" fill="#C8A96E"/><rect x="3" y="22" width="12" height="6" rx="2" fill="#A07840"/><rect x="17" y="22" width="12" height="6" rx="2" fill="#A07840"/><rect x="4" y="6" width="10" height="4" rx="1" fill="#E2C98A" opacity="0.4"/><rect x="18" y="6" width="10" height="4" rx="1" fill="#E2C98A" opacity="0.4"/><line x1="7" y1="8" x2="11" y2="8" stroke="#A07840" stroke-width="1.5" stroke-linecap="round"/><line x1="21" y1="8" x2="25" y2="8" stroke="#A07840" stroke-width="1.5" stroke-linecap="round"/></svg>',
            'bronze_helmet': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a1800"/><path d="M6,20 Q6,6 16,5 Q26,6 26,20 Z" fill="#CD7F32"/><path d="M10,18 Q10,10 16,9 Q22,10 22,18 Z" fill="#E8A050" opacity="0.4"/><rect x="5" y="19" width="22" height="4" rx="1" fill="#995500"/><rect x="9" y="13" width="14" height="5" rx="2" fill="#884400"/><rect x="10" y="14" width="5" height="2" rx="1" fill="#88BBFF" opacity="0.6"/><rect x="5" y="21" width="5" height="6" rx="1" fill="#995500"/><rect x="22" y="21" width="5" height="6" rx="1" fill="#995500"/></svg>',
            'bronze_vest': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a1800"/><rect x="3" y="6" width="8" height="8" rx="2" fill="#995500"/><rect x="21" y="6" width="8" height="8" rx="2" fill="#995500"/><rect x="5" y="8" width="22" height="20" rx="2" fill="#CD7F32"/><rect x="10" y="10" width="12" height="10" rx="2" fill="#E8A050" opacity="0.6"/><path d="M12,8 L16,12 L20,8 Z" fill="#995500"/><rect x="6" y="19" width="20" height="2" rx="0" fill="#995500"/><rect x="6" y="22" width="20" height="2" rx="0" fill="#995500"/></svg>',
            'bronze_gloves': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a1800"/><rect x="5" y="5" width="2" height="8" rx="1" fill="#CD7F32"/><rect x="8" y="4" width="2" height="9" rx="1" fill="#CD7F32"/><rect x="11" y="5" width="2" height="8" rx="1" fill="#CD7F32"/><rect x="19" y="5" width="2" height="8" rx="1" fill="#CD7F32"/><rect x="22" y="4" width="2" height="9" rx="1" fill="#CD7F32"/><rect x="25" y="5" width="2" height="8" rx="1" fill="#CD7F32"/><rect x="4" y="10" width="10" height="16" rx="2" fill="#CD7F32"/><rect x="18" y="10" width="10" height="16" rx="2" fill="#CD7F32"/><rect x="4" y="10" width="10" height="3" rx="1" fill="#995500"/><rect x="18" y="10" width="10" height="3" rx="1" fill="#995500"/><rect x="4" y="13" width="10" height="2" rx="0" fill="#E8A050" opacity="0.3"/><rect x="18" y="13" width="10" height="2" rx="0" fill="#E8A050" opacity="0.3"/></svg>',
            'bronze_pants': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a1800"/><rect x="5" y="4" width="22" height="6" rx="2" fill="#995500"/><rect x="5" y="10" width="10" height="18" rx="2" fill="#CD7F32"/><rect x="17" y="10" width="10" height="18" rx="2" fill="#CD7F32"/><rect x="5" y="16" width="10" height="4" rx="1" fill="#E8A050" opacity="0.5"/><rect x="17" y="16" width="10" height="4" rx="1" fill="#E8A050" opacity="0.5"/><rect x="5" y="14" width="10" height="1" rx="0" fill="#995500"/><rect x="17" y="14" width="10" height="1" rx="0" fill="#995500"/></svg>',
            'bronze_boots': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a1800"/><rect x="4" y="4" width="10" height="16" rx="2" fill="#CD7F32"/><rect x="18" y="4" width="10" height="16" rx="2" fill="#CD7F32"/><rect x="3" y="18" width="12" height="10" rx="2" fill="#CD7F32"/><rect x="17" y="18" width="12" height="10" rx="2" fill="#CD7F32"/><rect x="3" y="22" width="12" height="6" rx="2" fill="#995500"/><rect x="17" y="22" width="12" height="6" rx="2" fill="#995500"/></svg>',
            'thermal_hood': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2233"/><path d="M6,20 Q6,5 16,4 Q26,5 26,20 Z" fill="#1a6b8a"/><rect x="5" y="19" width="22" height="5" rx="2" fill="#1a6b8a"/><rect x="5" y="21" width="5" height="7" rx="2" fill="#1a6b8a"/><rect x="22" y="21" width="5" height="7" rx="2" fill="#1a6b8a"/><rect x="9" y="12" width="14" height="6" rx="2" fill="#0d2233"/><path d="M8,8 Q16,6 24,8" stroke="#4ecdc4" stroke-width="1" fill="none" opacity="0.6"/><path d="M7,12 Q16,10 25,12" stroke="#4ecdc4" stroke-width="1" fill="none" opacity="0.4"/></svg>',
            'thermal_jacket': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2233"/><rect x="3" y="6" width="8" height="9" rx="2" fill="#1a6b8a"/><rect x="21" y="6" width="8" height="9" rx="2" fill="#1a6b8a"/><rect x="5" y="8" width="22" height="21" rx="2" fill="#1a6b8a"/><path d="M12,8 L16,13 L20,8 Z" fill="#0d2233"/><line x1="16" y1="13" x2="16" y2="29" stroke="#0d2233" stroke-width="1.5"/><circle cx="16" cy="17" r="1" fill="#4ecdc4"/><circle cx="16" cy="22" r="1" fill="#4ecdc4"/><path d="M6,10 Q8,9 8,12" stroke="#4ecdc4" stroke-width="0.8" fill="none" opacity="0.5"/><path d="M26,10 Q24,9 24,12" stroke="#4ecdc4" stroke-width="0.8" fill="none" opacity="0.5"/></svg>',
            'thermal_gloves': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2233"/><rect x="5" y="4" width="2" height="9" rx="1" fill="#1a6b8a"/><rect x="8" y="3" width="2" height="10" rx="1" fill="#1a6b8a"/><rect x="11" y="4" width="2" height="9" rx="1" fill="#1a6b8a"/><rect x="4" y="11" width="10" height="17" rx="2" fill="#1a6b8a"/><rect x="19" y="4" width="2" height="9" rx="1" fill="#1a6b8a"/><rect x="22" y="3" width="2" height="10" rx="1" fill="#1a6b8a"/><rect x="25" y="4" width="2" height="9" rx="1" fill="#1a6b8a"/><rect x="18" y="11" width="10" height="17" rx="2" fill="#1a6b8a"/><rect x="4" y="20" width="10" height="3" rx="1" fill="#4ecdc4" opacity="0.4"/><rect x="18" y="20" width="10" height="3" rx="1" fill="#4ecdc4" opacity="0.4"/></svg>',
            'thermal_pants': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2233"/><rect x="5" y="4" width="22" height="7" rx="2" fill="#1a6b8a"/><rect x="5" y="10" width="10" height="18" rx="2" fill="#1a6b8a"/><rect x="17" y="10" width="10" height="18" rx="2" fill="#1a6b8a"/><rect x="5" y="14" width="10" height="3" rx="1" fill="#4ecdc4" opacity="0.3"/><rect x="17" y="14" width="10" height="3" rx="1" fill="#4ecdc4" opacity="0.3"/><rect x="5" y="20" width="10" height="3" rx="1" fill="#4ecdc4" opacity="0.3"/><rect x="17" y="20" width="10" height="3" rx="1" fill="#4ecdc4" opacity="0.3"/></svg>',
            'thermal_boots': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2233"/><rect x="4" y="4" width="10" height="16" rx="2" fill="#1a6b8a"/><rect x="18" y="4" width="10" height="16" rx="2" fill="#1a6b8a"/><rect x="3" y="18" width="12" height="10" rx="2" fill="#1a6b8a"/><rect x="17" y="18" width="12" height="10" rx="2" fill="#1a6b8a"/><rect x="3" y="22" width="12" height="6" rx="2" fill="#0f4d63"/><rect x="17" y="22" width="12" height="6" rx="2" fill="#0f4d63"/><rect x="4" y="6" width="10" height="4" rx="1" fill="#4ecdc4" opacity="0.3"/><rect x="18" y="6" width="10" height="4" rx="1" fill="#4ecdc4" opacity="0.3"/><line x1="7" y1="8" x2="11" y2="8" stroke="#4ecdc4" stroke-width="1.5" stroke-linecap="round"/><line x1="21" y1="8" x2="25" y2="8" stroke="#4ecdc4" stroke-width="1.5" stroke-linecap="round"/></svg>',
            'small_backpack': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e1205"/><rect x="11" y="3" width="10" height="5" rx="2.5" fill="#c8883a"/><rect x="8" y="6" width="16" height="20" rx="3" fill="#c8883a"/><rect x="11" y="6" width="10" height="3" rx="1" fill="#8a5520"/><rect x="10" y="14" width="12" height="8" rx="2" fill="#8a5520" opacity="0.5"/><rect x="13" y="17" width="6" height="1.5" rx="0.75" fill="#c8883a"/><rect x="8" y="9" width="2.5" height="14" rx="1.25" fill="#a06828"/><rect x="21.5" y="9" width="2.5" height="14" rx="1.25" fill="#a06828"/></svg>',
            'large_backpack': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d1a0a"/><rect x="11" y="3" width="10" height="5" rx="2.5" fill="#4a7a3a"/><rect x="7" y="6" width="18" height="22" rx="3" fill="#4a7a3a"/><rect x="11" y="6" width="10" height="3" rx="1" fill="#2a4a1a"/><rect x="9" y="13" width="14" height="10" rx="2" fill="#2a4a1a" opacity="0.55"/><rect x="12" y="17" width="8" height="1.5" rx="0.75" fill="#4a7a3a"/><rect x="9" y="24" width="14" height="3" rx="1.5" fill="#2a4a1a" opacity="0.4"/><rect x="7" y="9" width="2.5" height="16" rx="1.25" fill="#3a6030"/><rect x="22.5" y="9" width="2.5" height="16" rx="1.25" fill="#3a6030"/></svg>',
        };
        // Populate armor slot placeholder icons from itemIcons
        (function initArmorPlaceholders() {
            const placeholders = {
                'armor-placeholder-head': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e1e2e"/><path d="M6,20 Q6,6 16,5 Q26,6 26,20 Z" fill="#9988aa"/><rect x="5" y="19" width="22" height="4" rx="1" fill="#9988aa"/><rect x="5" y="21" width="5" height="6" rx="1" fill="#9988aa"/><rect x="22" y="21" width="5" height="6" rx="1" fill="#9988aa"/><rect x="9" y="13" width="14" height="5" rx="2" fill="#1e1e2e"/></svg>',
                'armor-placeholder-chest': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e1e2e"/><rect x="3" y="6" width="8" height="8" rx="2" fill="#9988aa"/><rect x="21" y="6" width="8" height="8" rx="2" fill="#9988aa"/><rect x="5" y="8" width="22" height="20" rx="2" fill="#9988aa"/><path d="M12,8 L16,12 L20,8 Z" fill="#1e1e2e"/></svg>',
                'armor-placeholder-hands': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e1e2e"/><rect x="5" y="4" width="2" height="8" rx="1" fill="#9988aa"/><rect x="8" y="3" width="2" height="9" rx="1" fill="#9988aa"/><rect x="11" y="4" width="2" height="8" rx="1" fill="#9988aa"/><rect x="4" y="10" width="10" height="16" rx="2" fill="#9988aa"/><rect x="19" y="4" width="2" height="8" rx="1" fill="#9988aa"/><rect x="22" y="3" width="2" height="9" rx="1" fill="#9988aa"/><rect x="25" y="4" width="2" height="8" rx="1" fill="#9988aa"/><rect x="18" y="10" width="10" height="16" rx="2" fill="#9988aa"/></svg>',
                'armor-placeholder-legs': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e1e2e"/><rect x="5" y="4" width="22" height="6" rx="2" fill="#9988aa"/><rect x="5" y="10" width="10" height="18" rx="2" fill="#9988aa"/><rect x="17" y="10" width="10" height="18" rx="2" fill="#9988aa"/></svg>',
                'armor-placeholder-feet': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e1e2e"/><rect x="4" y="4" width="10" height="16" rx="2" fill="#9988aa"/><rect x="3" y="18" width="12" height="10" rx="2" fill="#9988aa"/><rect x="18" y="4" width="10" height="16" rx="2" fill="#9988aa"/><rect x="17" y="18" width="12" height="10" rx="2" fill="#9988aa"/></svg>',
            };
            function fill() {
                for (const [id, svg] of Object.entries(placeholders)) {
                    const el = document.getElementById(id);
                    if (el) el.innerHTML = svg;
                }
            }
            if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', fill);
            else fill();
        })();

        
        // Item display names (with subtitles for items that share icons)
        const itemDisplayNames = {
            'sharp_stone': 'Sharp Stone',
            'wood': 'Wood',
            'stone': 'Stone',
            'berries': 'Berries',
            'worms': 'Worms',
            'meat': 'Raw Meat',
            'cooked_meat': 'Cooked Meat',
            'mushroom': 'Mushroom',
            'roasted_mushroom': 'Roasted Mushroom',
            'sticks': 'Sticks',
            'fiber': 'Fiber',
            'iron_ore': 'Iron Ore',
            'iron_ingot': 'Iron Ingot',
            'coal': 'Coal',
            'sulfur_ore': 'Sulfur Ore',
            'smelted_sulfur': 'Smelted Sulfur',
            'gunpowder': 'Gunpowder',
            'ash': 'Ash',
            'meat_stew': 'Meat Stew',
            'vegetable_stew': 'Vegetable Stew',
            'berry_jam': 'Berry Jam',
            'corn_bread': 'Corn Bread',
            'hearty_meal': 'Hearty Meal',
            'cooking_station': 'Cooking Station',
            'cloth': 'Cloth',
            'arrows': 'Arrows',
            'axe': 'Axe',
            'pickaxe': 'Pickaxe',
            'sword': 'Sword',
            'spear': 'Spear',
            'bow': 'Bow',
            'pistol': 'Pistol',
            'pistol_ammo': 'Pistol Ammo',
            'machine_gun': 'Machine Gun',
            'mg_ammo': 'MG Ammo',
            'pistol_ammo': 'Pistol Ammo',
            'building_hammer': 'Building Hammer',
            'code_lock': 'Code Lock',
            'bandage': 'Bandage',
            'medkit': 'Medkit',
            'wall': 'Wall',
            'stone_wall': 'Stone Wall',
            'metal_wall': 'Metal Wall',
            'window_wall': 'Window Wall',
            'stone_window_wall': 'Stone Window Wall',
            'metal_window_wall': 'Metal Window Wall',
            'door_frame': 'Door Frame',
            'door': 'Door',
            'double_door': 'Double Door',
            'stone_door': 'Stone Door',
            'stone_double_door': 'Stone Double Door',
            'metal_door': 'Metal Door',
            'metal_double_door': 'Metal Double Door',
            'double_door_frame': 'Double Door Frame',
            'floor': 'Floor',
            'stone_floor': 'Stone Floor',
            'metal_floor': 'Metal Floor',
            'ceiling': 'Ceiling',
            'stone_ceiling': 'Stone Ceiling',
            'metal_ceiling': 'Metal Ceiling',
            'ladder_ceiling': 'Ladder Ceiling',
            'stairs': 'Stairs',
            'stone_stairs': 'Stone Stairs',
            'metal_stairs': 'Metal Stairs',
            'corner_stairs_left': 'Corner Stairs (Left)',
            'stone_corner_stairs_left': 'Stone Corner Stairs (Left)',
            'metal_corner_stairs_left': 'Metal Corner Stairs (Left)',
            'corner_stairs_right': 'Corner Stairs (Right)',
            'stone_corner_stairs_right': 'Stone Corner Stairs (Right)',
            'metal_corner_stairs_right': 'Metal Corner Stairs (Right)',
            'ladder': 'Ladder',
            'sleeping_bag': 'Sleeping Bag',
            'campfire': 'Campfire',
            'workbench': 'Workbench',
            'building_bench': 'Building Bench',
            'furnace': 'Furnace',
            'storage_box': 'Large Storage',
            'small_storage_box': 'Small Storage',
            'storage_shelf': 'Storage Shelf',
            'wall_shelf': 'Wall Shelf',
            'sewing_table': 'Sewing Table',
            'recycler': 'Recycler',
            'water_catcher': 'Well',
            'water_bottle': 'Water Bottle',
            'flour': 'Flour',
            'bread': 'Bread',
            'blackcurrant_jam': 'Blackcurrant Jam',
            'strawberry_jam': 'Strawberry Jam',
            'toast_jam': 'Toast with Jam',
            'ham_sandwich': 'Ham Sandwich',
            'omelette': 'Omelette',
            'scrambled_eggs': 'Scrambled Eggs',
            'honey_cake': 'Honey Cake',
            'honey_porridge': 'Honey Porridge',
            'sofa': 'Sofa',
            'bookcase': 'Bookcase',
            'table': 'Table',
            'chair': 'Chair',
            'wall_shelf_b': 'Wall Shelf B',
            'candle': 'Candle',
            'wall_light': 'Wall Light',
            'bee_hive': 'Bee Hive',
            'chicken_coop': 'Chicken Coop',
            'oil_smelter': 'Oil Smelter',
            'honey': 'Honey',
            'egg': 'Egg',
            'planter_box': 'Planter Box',
            'large_planter': 'Large Planter',
            'pumpkin_seed': 'Pumpkin Seed',
            'wheat_seed': 'Wheat Seed',
            'cabbage_seed': 'Cabbage Seed',
            'cucumber_seed': 'Cucumber Seed',
            'potato_seed': 'Potato Seed',
            'carrot_seed': 'Carrot Seed',
            'hemp_seed': 'Hemp Seed',
            'corn_seed': 'Corn Seed',
            'mushroom_seed': 'Mushroom Seed',
            'red_berry_seed': 'Red Berry Seed',
            'black_berry_seed': 'Black Berry Seed',
            'strawberry_seed': 'Strawberry Seed',
            'tomato_seed': 'Tomato Seed',
            'pumpkin': 'Pumpkin',
            'wheat': 'Wheat',
            'cabbage': 'Cabbage',
            'cucumber': 'Cucumber',
            'potato': 'Potato',
            'carrot': 'Carrot',
            'hemp_fiber': 'Hemp Fiber',
            'corn': 'Corn',
            'mushroom_crop': 'Mushroom',
            'red_berries': 'Red Berries',
            'black_berries': 'Black Berries',
            'strawberry': 'Strawberry',
            'tomato': 'Tomato',
            'floor_rug_red': 'Red Floor Rug',
            'floor_rug_blue': 'Blue Floor Rug',
            'floor_rug_green': 'Green Floor Rug',
            'curtain_red': 'Red Curtain',
            'curtain_blue': 'Blue Curtain',
            'curtain_green': 'Green Curtain',
            'curtain_white': 'White Curtain',
            'curtain_beige': 'Beige Curtain',
            'iron_helmet': 'Iron Helmet',
            'iron_vest': 'Iron Vest',
            'iron_gloves': 'Iron Gloves',
            'iron_pants': 'Iron Pants',
            'iron_boots': 'Iron Boots',
            'cloth_helmet': 'Cloth Hood',
            'cloth_vest': 'Cloth Vest',
            'cloth_gloves': 'Cloth Gloves',
            'cloth_pants': 'Cloth Pants',
            'cloth_boots': 'Cloth Boots',
            'bronze_helmet': 'Bronze Helmet',
            'bronze_vest': 'Bronze Vest',
            'bronze_gloves': 'Bronze Gloves',
            'bronze_pants': 'Bronze Pants',
            'bronze_boots': 'Bronze Boots',
            'thermal_hood': 'Thermal Hood',
            'thermal_jacket': 'Thermal Jacket',
            'thermal_gloves': 'Thermal Gloves',
            'thermal_pants': 'Thermal Pants',
            'thermal_boots': 'Thermal Boots',
            'small_backpack': 'Small Backpack',
            'large_backpack': 'Large Backpack',
            'fishing_rod': 'Fishing Rod',
            'raw_fish': 'Raw Fish',
            'cooked_fish': 'Cooked Fish',
            'grilled_fish_stew': 'Grilled Fish Stew',
            'pumpkin_soup': 'Pumpkin Soup',
            'stuffed_pumpkin': 'Stuffed Pumpkin',
            'pickled_cabbage': 'Pickled Cabbage',
            'cabbage_stew': 'Cabbage Stew',
            'red_berry_jam': 'Red Berry Jam',
            'summer_salad': 'Summer Salad'
        };

        // ── Inject fishing icons into itemIcons immediately ──────────────────────
        // (they exist in _iconFallbacks but must also be in itemIcons for UI to show them)
        (function _injectFishingIcons() {
            const _fish = {
                'fishing_rod': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2233"/><line x1="6" y1="26" x2="26" y2="6" stroke="#8B6914" stroke-width="3" stroke-linecap="round"/><line x1="26" y1="6" x2="22" y2="22" stroke="#aaddff" stroke-width="1" stroke-dasharray="2,2" opacity="0.8"/><circle cx="22" cy="22" r="2.5" fill="#aaddff" stroke="#5599cc" stroke-width="1"/><circle cx="8" cy="24" r="2" fill="#444" stroke="#666" stroke-width="1"/></svg>',
                'raw_fish': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0a1a2e"/><path d="M5,16 Q10,10 18,12 Q22,13 26,16 Q22,19 18,20 Q10,22 5,16 Z" fill="#6ab4d4"/><path d="M26,16 L30,12 L30,20 Z" fill="#6ab4d4"/><circle cx="8" cy="15" r="1.2" fill="#000"/><line x1="13" y1="11.5" x2="14" y2="20" stroke="#4a90b8" stroke-width="0.8" opacity="0.7"/><line x1="17" y1="11.5" x2="18" y2="20.5" stroke="#4a90b8" stroke-width="0.8" opacity="0.7"/></svg>',
                'cooked_fish': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1000"/><path d="M5,16 Q10,10 18,12 Q22,13 26,16 Q22,19 18,20 Q10,22 5,16 Z" fill="#c87941"/><path d="M26,16 L30,12 L30,20 Z" fill="#c87941"/><circle cx="8" cy="15" r="1.2" fill="#000"/><line x1="13" y1="11.5" x2="14" y2="20" stroke="#8B5020" stroke-width="0.8" opacity="0.9"/><line x1="17" y1="11.5" x2="18" y2="20.5" stroke="#8B5020" stroke-width="0.8" opacity="0.9"/><path d="M6,24 Q10,22 16,23 Q22,22 26,24" stroke="#ff6600" stroke-width="1.5" fill="none" opacity="0.5" stroke-linecap="round"/></svg>',
                'grilled_fish_stew': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0f00"/><ellipse cx="16" cy="20" rx="12" ry="8" fill="#5b3010"/><ellipse cx="16" cy="18" rx="11" ry="6" fill="#8B5A1F"/><path d="M9,16 Q13,13 16,14 Q19,13 23,16" stroke="#c87941" stroke-width="2" fill="none" stroke-linecap="round"/><circle cx="16" cy="12" r="1.5" fill="#ff8844" opacity="0.8"/><path d="M14,10 Q16,8 18,10" stroke="#ff8844" stroke-width="1" fill="none" opacity="0.6"/></svg>'
            };
            for (const [k, v] of Object.entries(_fish)) {
                if (!itemIcons[k] || (typeof itemIcons[k] === 'string' && itemIcons[k].trim() === '')) itemIcons[k] = v;
            }
        })();

        // ── Inject icons for new cooking station recipes ─────────────────────────
        (function _injectNewRecipeIcons() {
            const _new = {
                'pumpkin_soup': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0a00"/><ellipse cx="16" cy="22" rx="12" ry="8" fill="#5C2A00"/><ellipse cx="16" cy="20" rx="11" ry="7" fill="#8B4500"/><ellipse cx="16" cy="18" rx="10" ry="5" fill="#E8690A" opacity="0.85"/><ellipse cx="16" cy="17" rx="8" ry="3" fill="#F5830C" opacity="0.7"/><path d="M12,10 Q13,7 16,8 Q19,7 20,10" fill="none" stroke="#4a8a00" stroke-width="2" stroke-linecap="round"/><circle cx="16" cy="10" r="1.5" fill="#2d6600" opacity="0.8"/><path d="M10,17 Q13,14 16,15 Q19,14 22,17" stroke="#cc5500" stroke-width="1" fill="none" opacity="0.6"/></svg>',
                'stuffed_pumpkin': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0a00"/><ellipse cx="16" cy="20" rx="13" ry="10" fill="#cc5500"/><ellipse cx="16" cy="18" rx="12" ry="9" fill="#E8690A"/><ellipse cx="16" cy="16" rx="11" ry="8" fill="#F5830C"/><path d="M8,16 Q10,12 13,13 Q16,11 19,13 Q22,12 24,16" stroke="#8B4513" stroke-width="1.5" fill="none" stroke-linecap="round"/><circle cx="13" cy="15" r="2" fill="#8B4513" opacity="0.8"/><circle cx="19" cy="15" r="2" fill="#5a3010" opacity="0.9"/><path d="M13,8 Q14,5 16,6 Q18,5 19,8" fill="none" stroke="#3a7000" stroke-width="2" stroke-linecap="round"/><ellipse cx="16" cy="9" rx="2" ry="1.5" fill="#2d6600"/></svg>',
                'pickled_cabbage': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0a1a0a"/><ellipse cx="16" cy="22" rx="11" ry="7" fill="#2a4a2a"/><ellipse cx="16" cy="20" rx="10" ry="6" fill="#3a6a3a"/><path d="M7,18 Q10,13 16,14 Q22,13 25,18" fill="#4a8a4a" stroke="none"/><path d="M8,16 Q12,11 16,12 Q20,11 24,16" fill="#5aaa5a" stroke="none" opacity="0.7"/><path d="M10,14 Q13,10 16,11 Q19,10 22,14" fill="#66cc66" stroke="none" opacity="0.5"/><path d="M7,18 Q10,22 16,23 Q22,22 25,18" fill="none" stroke="#2a5a2a" stroke-width="1" opacity="0.5"/></svg>',
                'cabbage_stew': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0a1800"/><ellipse cx="16" cy="22" rx="12" ry="8" fill="#1a3a10"/><ellipse cx="16" cy="20" rx="11" ry="7" fill="#2a5a18"/><ellipse cx="16" cy="18" rx="10" ry="5" fill="#3a7a20" opacity="0.9"/><circle cx="10" cy="17" r="2.5" fill="#e8c060" opacity="0.85"/><circle cx="20" cy="18" r="2" fill="#e06030" opacity="0.8"/><circle cx="15" cy="16" r="1.5" fill="#4a9a2a" opacity="0.9"/><path d="M8,18 Q12,14 16,15 Q20,14 24,18" stroke="#1a5010" stroke-width="1" fill="none" opacity="0.7"/></svg>',
                'red_berry_jam': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0008"/><ellipse cx="16" cy="22" rx="11" ry="7" fill="#6a0020"/><ellipse cx="16" cy="20" rx="10" ry="6" fill="#9a0030"/><ellipse cx="16" cy="18" rx="9" ry="4.5" fill="#cc1040" opacity="0.9"/><ellipse cx="16" cy="17" rx="7" ry="3" fill="#ee2050" opacity="0.7"/><circle cx="11" cy="16" r="2" fill="#ff4466" opacity="0.6"/><circle cx="19" cy="17" r="1.5" fill="#ff2244" opacity="0.7"/><circle cx="15" cy="15" r="1.2" fill="#ff6688" opacity="0.5"/><path d="M10,12 Q12,9 14,11 Q16,9 18,11 Q20,9 22,12" fill="none" stroke="#440010" stroke-width="1" opacity="0.6"/></svg>',
                'summer_salad': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0a1800"/><ellipse cx="16" cy="22" rx="12" ry="7" fill="#1a3a10"/><ellipse cx="16" cy="20" rx="11" ry="6" fill="#2a5a18"/><circle cx="10" cy="18" r="3" fill="#cc2244" opacity="0.9"/><circle cx="20" cy="17" r="2.5" fill="#cc4422" opacity="0.9"/><ellipse cx="15" cy="16" rx="4" ry="2" fill="#4a9a2a" opacity="0.9"/><circle cx="22" cy="19" r="2" fill="#ff4455" opacity="0.8"/><ellipse cx="11" cy="20" rx="3" ry="1.5" fill="#3a8a1a" opacity="0.8"/><circle cx="18" cy="21" r="1.5" fill="#ee3344" opacity="0.7"/></svg>'
            };
            for (const [k, v] of Object.entries(_new)) {
                if (!itemIcons[k]) itemIcons[k] = v;
            }
        })();
        
        // Helper function - gets icon for an item
        function getItemIcon(itemName) {
            const icon = itemIcons[itemName] || '';
            
            // Add color styling for armor icons
            if (itemName && itemName.startsWith('cloth_')) {
                return `<span style="filter: sepia(0.3) brightness(1.05);">${icon}</span>`;
            } else if (itemName && itemName.startsWith('iron_')) {
                return `<span style="filter: grayscale(1) brightness(0.8);">${icon}</span>`;
            } else if (itemName && itemName.startsWith('bronze_')) {
                return `<span style="filter: sepia(1) saturate(3) hue-rotate(10deg) brightness(0.9);">${icon}</span>`;
            }
            
            return icon;
        }
        
        // Helper function - gets display name for an item
        function getItemDisplayName(itemName) {
            if (itemDisplayNames[itemName]) {
                return itemDisplayNames[itemName];
            }
            // Fallback: convert snake_case to Title Case
            return itemName
                .split('_')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }
        
        // Safe fallback map — every icon stored as pure \uXXXX escapes.
        // If itemIcons gets corrupted (U+FFFD replacement chars), this map
        // is used to automatically restore the correct emoji at startup.
        const _iconFallbacks = {
            'sharp_stone':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1a2e"/><rect x="2" y="2" width="28" height="28" rx="3" fill="#333"/><polygon points="16,3 26,10 28,22 20,29 8,28 3,18 6,8" fill="#777" stroke="#999" stroke-width="1"/><polygon points="16,3 26,10 20,29 8,28" fill="#999" stroke="none" stroke-width="1"/><polygon points="16,3 6,8 3,18 8,28" fill="#666" stroke="none" stroke-width="1"/><line x1="16" y1="3" x2="8" y2="28" stroke="#aaa" stroke-width="0.5" stroke-linecap="round"/><line x1="16" y1="3" x2="28" y2="22" stroke="#aaa" stroke-width="0.5" stroke-linecap="round"/></svg>',
            'wood':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="3" y="8" width="26" height="16" rx="2" fill="#5C3A1E"/><rect x="3" y="8" width="26" height="16" rx="2" fill="#8B5E3C" opacity="0.8"/><line x1="3" y1="12" x2="29" y2="12" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="16" x2="29" y2="16" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="20" x2="29" y2="20" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/><line x1="8" y1="8" x2="8" y2="24" stroke="#5C3A1E" stroke-width="0.5" stroke-linecap="round"/><line x1="13" y1="8" x2="13" y2="24" stroke="#5C3A1E" stroke-width="0.5" stroke-linecap="round"/><line x1="19" y1="8" x2="19" y2="24" stroke="#5C3A1E" stroke-width="0.5" stroke-linecap="round"/><line x1="24" y1="8" x2="24" y2="24" stroke="#5C3A1E" stroke-width="0.5" stroke-linecap="round"/><ellipse cx="16" cy="12" rx="2" ry="1" fill="#5C3A1E" opacity="0.7"/></svg>',
            'stone':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1a2e"/><ellipse cx="16" cy="18" rx="13" ry="10" fill="#666" stroke="#888" stroke-width="1"/><ellipse cx="16" cy="16" rx="11" ry="8" fill="#888"/><ellipse cx="13" cy="13" rx="4" ry="3" fill="#999" opacity="0.5"/><ellipse cx="11" cy="19" rx="3" ry="2" fill="#555" opacity="0.6"/></svg>',
            'berries':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0810"/><circle cx="11" cy="18" r="5" fill="#cc2244"/><circle cx="11" cy="18" r="5" fill="none" stroke="#ff4466" stroke-width="0.5"/><circle cx="19" cy="18" r="5" fill="#aa1133"/><circle cx="15" cy="13" r="5" fill="#dd3355"/><circle cx="11" cy="13" r="2" fill="#663311" opacity="0.5"/><path d="M15,8 Q13,6 14,4" fill="none" stroke="#338833" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M15,8 Q17,6 16,4" fill="none" stroke="#44aa44" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
            'worms':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0e08"/><path d="M5,22 Q8,16 12,18 Q16,20 18,14 Q20,8 24,10 Q28,12 27,18" fill="none" stroke="#c47a3a" stroke-width="3.5" stroke-linecap="round"/><path d="M5,22 Q8,16 12,18 Q16,20 18,14 Q20,8 24,10 Q28,12 27,18" fill="none" stroke="#e8a060" stroke-width="1.5" stroke-linecap="round" opacity="0.6"/><circle cx="27" cy="18" r="2.5" fill="#d46030"/><circle cx="26.5" cy="17.2" r="0.8" fill="#1a0e08" opacity="0.7"/><path d="M7,24 Q10,20 13,21 Q16,22 17,18" fill="none" stroke="#b06830" stroke-width="2.5" stroke-linecap="round" opacity="0.7"/><path d="M7,24 Q10,20 13,21 Q16,22 17,18" fill="none" stroke="#d49060" stroke-width="1" stroke-linecap="round" opacity="0.5"/><circle cx="17" cy="18" r="2" fill="#c05828"/><circle cx="16.5" cy="17.3" r="0.65" fill="#1a0e08" opacity="0.7"/></svg>',
            'meat':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a0a00"/><path d="M8,22 Q6,14 10,10 Q16,5 22,8 Q28,12 26,20 Q24,28 16,27 Q8,26 8,22Z" fill="#cc4422" stroke="#ff6644" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/><path d="M10,20 Q9,15 12,12 Q16,9 20,11" fill="none" stroke="#ff8866" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" opacity="0.5"/><circle cx="16" cy="18" r="3" fill="#ee5533" opacity="0.3"/></svg>',
            'cooked_meat':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a0a00"/><path d="M8,22 Q6,14 10,10 Q16,5 22,8 Q28,12 26,20 Q24,28 16,27 Q8,26 8,22Z" fill="#8B4513" stroke="#A0522D" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/><path d="M9,16 Q12,12 16,11 Q20,12 23,16" fill="none" stroke="#6B3000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" opacity="0.6"/><path d="M10,20 Q13,17 16,16 Q19,17 22,20" fill="none" stroke="#5a2500" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" opacity="0.5"/><ellipse cx="16" cy="23" rx="5" ry="2" fill="#cc8844" opacity="0.4"/></svg>',
            'mushroom':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0d05"/><rect x="13" y="19" width="6" height="10" rx="2" fill="#e8d5b0" stroke="#c9b48a" stroke-width="0.8"/><line x1="13" y1="22" x2="19" y2="22" stroke="#c9b48a" stroke-width="0.6" opacity="0.7"/><line x1="13" y1="25" x2="19" y2="25" stroke="#c9b48a" stroke-width="0.6" opacity="0.5"/><ellipse cx="16" cy="19" rx="12" ry="3" fill="#5a2d00" opacity="0.5"/><ellipse cx="16" cy="13" rx="12" ry="8" fill="#7B3F00" stroke="#9B5A1A" stroke-width="1"/><ellipse cx="16" cy="12" rx="10" ry="6.5" fill="#A0522D"/><ellipse cx="12" cy="10" rx="3" ry="2" fill="#FFE4C4" opacity="0.75"/><circle cx="20" cy="10" r="1.8" fill="#FFE4C4" opacity="0.65"/><circle cx="16" cy="13" r="1.2" fill="#FFE4C4" opacity="0.55"/><path d="M5,16 Q10,21 16,19 Q22,21 27,16" fill="none" stroke="#5a2d00" stroke-width="1" opacity="0.6"/></svg>',
            'roasted_mushroom':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0a00"/><rect x="13" y="19" width="6" height="10" rx="2" fill="#c4a060" stroke="#9a7a3a" stroke-width="0.8"/><line x1="13" y1="22" x2="19" y2="22" stroke="#9a7a3a" stroke-width="0.6" opacity="0.7"/><line x1="13" y1="25" x2="19" y2="25" stroke="#9a7a3a" stroke-width="0.6" opacity="0.5"/><ellipse cx="16" cy="19" rx="12" ry="3" fill="#3a1800" opacity="0.6"/><ellipse cx="16" cy="13" rx="12" ry="8" fill="#5C2800" stroke="#7a3a00" stroke-width="1"/><ellipse cx="16" cy="12" rx="10" ry="6.5" fill="#7a3a00"/><ellipse cx="12" cy="10" rx="3" ry="2" fill="#cc8844" opacity="0.6"/><circle cx="20" cy="10" r="1.8" fill="#cc8844" opacity="0.5"/><circle cx="16" cy="13" r="1.2" fill="#bb7733" opacity="0.5"/><path d="M5,16 Q10,21 16,19 Q22,21 27,16" fill="none" stroke="#3a1800" stroke-width="1" opacity="0.6"/><path d="M13,4 Q14,2 13,1" fill="none" stroke="#aa6622" stroke-width="1.2" stroke-linecap="round" opacity="0.7"/><path d="M16,3 Q17,1 16,0" fill="none" stroke="#cc8833" stroke-width="1.2" stroke-linecap="round" opacity="0.7"/><path d="M19,4 Q20,2 19,1" fill="none" stroke="#aa6622" stroke-width="1.2" stroke-linecap="round" opacity="0.6"/></svg>',
            'sticks':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><path d="M6,26 L18,6" fill="none" stroke="#B07A52" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/><path d="M10,28 L22,8" fill="none" stroke="#8B5E3C" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/><path d="M14,27 L26,10" fill="none" stroke="#5C3A1E" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/></svg>',
            'fiber':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2010"/><path d="M5,25 Q10,15 8,8" fill="none" stroke="#4a9a4a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M10,27 Q16,14 14,6" fill="none" stroke="#5cb85c" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M15,26 Q20,15 18,7" fill="none" stroke="#4a9a4a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M20,25 Q24,16 22,9" fill="none" stroke="#3a7a3a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M25,24 Q28,16 26,10" fill="none" stroke="#5cb85c" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
            'iron_ore':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e2a38"/><ellipse cx="16" cy="18" rx="13" ry="10" fill="#445" stroke="#667" stroke-width="1"/><ellipse cx="16" cy="17" rx="11" ry="8" fill="#4a5a6a"/><circle cx="10" cy="15" r="3" fill="#8AABB8" opacity="0.8"/><circle cx="18" cy="18" r="2" fill="#8AABB8" opacity="0.7"/><circle cx="22" cy="14" r="2" fill="#6a8a9a" opacity="0.8"/><circle cx="13" cy="20" r="1.5" fill="#aabbc8" opacity="0.6"/></svg>',
            'iron_ingot':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e2a38"/><rect x="4" y="10" width="24" height="12" rx="2" fill="#5A8090"/><rect x="4" y="10" width="24" height="10" rx="2" fill="#8AABB8"/><rect x="4" y="10" width="24" height="4" rx="2" fill="#AABFCC" opacity="0.5"/><line x1="4" y1="16" x2="28" y2="16" stroke="#5A8090" stroke-width="0.5" stroke-linecap="round"/><text x="16" y="21" fill="#CCDDEE" font-size="9" font-weight="bold" text-anchor="middle" font-family="system-ui,sans-serif">Fe</text></svg>',
            'coal':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#111"/><ellipse cx="16" cy="18" rx="12" ry="9" fill="#1a1a1a" stroke="#333" stroke-width="1"/><ellipse cx="16" cy="17" rx="10" ry="7" fill="#2a2a2a"/><circle cx="11" cy="14" r="2" fill="#444" opacity="0.7"/><circle cx="20" cy="19" r="2" fill="#444" opacity="0.6"/><circle cx="15" cy="20" r="1.5" fill="#555" opacity="0.5"/><ellipse cx="12" cy="13" rx="1" ry="0.6" fill="#555" opacity="0.8"/></svg>',
            'sulfur_ore':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1f1a00"/><ellipse cx="16" cy="18" rx="12" ry="9" fill="#5a4a00" stroke="#aa8800" stroke-width="1"/><ellipse cx="16" cy="17" rx="10" ry="7" fill="#7a6800"/><circle cx="11" cy="14" r="2.5" fill="#ccaa00" opacity="0.8"/><circle cx="20" cy="16" r="2" fill="#ddbb00" opacity="0.7"/><circle cx="16" cy="20" r="2" fill="#aa9000" opacity="0.8"/></svg>',
            'smelted_sulfur':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1f1a00"/><rect x="4" y="10" width="24" height="12" rx="2" fill="#5A8090"/><rect x="4" y="10" width="24" height="10" rx="2" fill="#ccaa00"/><rect x="4" y="10" width="24" height="4" rx="2" fill="#ffdd44" opacity="0.5"/><text x="16" y="21" fill="#fff" font-size="10" font-weight="bold" text-anchor="middle" font-family="system-ui,sans-serif">S</text></svg>',
            'gunpowder':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#111"/><circle cx="16" cy="16" r="11" fill="#222" stroke="#444" stroke-width="1"/><circle cx="16" cy="16" r="8" fill="#111"/><circle cx="11" cy="12" r="2" fill="#3a3a3a"/><circle cx="20" cy="13" r="1.5" fill="#3a3a3a"/><circle cx="14" cy="20" r="1.5" fill="#3a3a3a"/><path d="M14,6 L16,3 L18,6" fill="none" stroke="#cc4400" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,3 L16,10" fill="none" stroke="#ff6600" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
            'ash':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1a1a"/><ellipse cx="16" cy="22" rx="13" ry="7" fill="#333" opacity="0.8"/><path d="M8,22 Q16,8 24,22" fill="none" stroke="#aaa" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" opacity="0.5"/><path d="M10,22 Q14,14 18,22" fill="none" stroke="#ccc" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" opacity="0.4"/><path d="M12,22 Q16,16 20,22" fill="none" stroke="#bbb" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" opacity="0.3"/><circle cx="16" cy="22" r="4" fill="#555" opacity="0.5"/><ellipse cx="16" cy="24" rx="10" ry="3" fill="#555" opacity="0.4"/></svg>',
            'meat_stew':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1205"/><ellipse cx="16" cy="20" rx="13" ry="9" fill="#5a3010" stroke="#7a4a20" stroke-width="1"/><ellipse cx="16" cy="18" rx="12" ry="7" fill="#8B4513"/><ellipse cx="16" cy="16" rx="10" ry="5" fill="#cc6633" opacity="0.8"/><circle cx="10" cy="17" r="2" fill="#cc4422" opacity="0.8"/><circle cx="22" cy="16" r="2" fill="#44aa44" opacity="0.7"/><circle cx="15" cy="14" r="1.5" fill="#ccaa44" opacity="0.8"/><circle cx="19" cy="18" r="1.5" fill="#cc4422" opacity="0.7"/><ellipse cx="16" cy="13" rx="6" ry="2" fill="#aa7744" opacity="0.4"/></svg>',
            'vegetable_stew':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2010"/><ellipse cx="16" cy="20" rx="13" ry="9" fill="#1a3a10" stroke="#2a5a20" stroke-width="1"/><ellipse cx="16" cy="18" rx="12" ry="7" fill="#2d5a1a"/><ellipse cx="16" cy="16" rx="10" ry="5" fill="#44aa44" opacity="0.8"/><circle cx="11" cy="16" r="2" fill="#88cc44" opacity="0.9"/><circle cx="21" cy="17" r="2" fill="#cc8822" opacity="0.8"/><circle cx="16" cy="14" r="1.5" fill="#ee4422" opacity="0.8"/><circle cx="14" cy="18" r="1" fill="#ffcc00" opacity="0.7"/><ellipse cx="16" cy="13" rx="5" ry="2" fill="#55bb55" opacity="0.4"/></svg>',
            'omelette':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1000"/><ellipse cx="16" cy="20" rx="13" ry="8" fill="#c8830a" stroke="#a06008" stroke-width="1"/><ellipse cx="16" cy="18" rx="11" ry="6" fill="#f5c842"/><ellipse cx="13" cy="16" rx="5" ry="3" fill="#fff9e0" opacity="0.85"/><ellipse cx="20" cy="17" rx="3.5" ry="2" fill="#fff9e0" opacity="0.6"/><circle cx="13" cy="16" r="2" fill="#ffcc00" opacity="0.5"/><path d="M8,20 Q16,15 24,20" fill="none" stroke="#a06008" stroke-width="1" stroke-linecap="round" opacity="0.4"/></svg>',
            'scrambled_eggs':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1000"/><ellipse cx="16" cy="21" rx="12" ry="7" fill="#b07010" stroke="#8a5000" stroke-width="1"/><path d="M6,21 Q10,14 16,16 Q22,14 26,21" fill="#f5c030" stroke="none"/><path d="M8,20 Q12,15 16,17 Q20,15 24,20" fill="#ffe060" stroke="none" opacity="0.7"/><circle cx="11" cy="18" r="2" fill="#fff9cc" opacity="0.7"/><circle cx="18" cy="17" r="2.5" fill="#fff9cc" opacity="0.6"/><circle cx="22" cy="19" r="1.5" fill="#ffe060" opacity="0.5"/></svg>',
            'honey_cake':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0e00"/><rect x="4" y="16" width="24" height="12" rx="3" fill="#c8860a" stroke="#a06000" stroke-width="1"/><rect x="4" y="16" width="24" height="6" rx="3" fill="#D4A017"/><rect x="6" y="10" width="20" height="8" rx="2" fill="#e8b828"/><rect x="6" y="10" width="20" height="4" rx="2" fill="#f5cc40" opacity="0.9"/><ellipse cx="16" cy="10" rx="8" ry="3" fill="#FFD700" opacity="0.9"/><path d="M10,10 Q16,5 22,10" fill="#FFD700" stroke="#e8b000" stroke-width="0.5"/><circle cx="11" cy="21" r="1.5" fill="#FFD700" opacity="0.5"/><circle cx="18" cy="23" r="1" fill="#FFD700" opacity="0.4"/></svg>',
            'honey_porridge':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1000"/><ellipse cx="16" cy="21" rx="13" ry="8" fill="#7a5010" stroke="#5a3800" stroke-width="1"/><ellipse cx="16" cy="19" rx="11" ry="6" fill="#c89040"/><ellipse cx="16" cy="17" rx="9" ry="4" fill="#e8b060" opacity="0.9"/><path d="M9,17 Q13,14 16,16 Q19,14 23,17" fill="none" stroke="#c87800" stroke-width="1.5" stroke-linecap="round" opacity="0.7"/><ellipse cx="13" cy="16" rx="2.5" ry="1" fill="#FFD700" opacity="0.7"/><ellipse cx="20" cy="17" rx="2" ry="1" fill="#FFD700" opacity="0.6"/></svg>',
            'berry_jam':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a0010"/><rect x="8" y="10" width="16" height="16" rx="2" fill="#4a0010" stroke="#8a1a30" stroke-width="1"/><rect x="8" y="6" width="16" height="6" rx="2" fill="#cc2244"/><rect x="8" y="6" width="16" height="4" rx="2" fill="#ee3355"/><rect x="6" y="8" width="20" height="4" rx="1" fill="#aa1133"/><circle cx="14" cy="17" r="2" fill="#ff4466" opacity="0.6"/><circle cx="18" cy="20" r="1.5" fill="#dd2244" opacity="0.5"/><circle cx="12" cy="21" r="1.5" fill="#cc3355" opacity="0.5"/></svg>',
            'corn_bread':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1f1a00"/><ellipse cx="16" cy="18" rx="13" ry="10" fill="#8B6914" stroke="#AA8822" stroke-width="1"/><ellipse cx="16" cy="16" rx="11" ry="8" fill="#D4A017"/><ellipse cx="14" cy="13" rx="4" ry="2" fill="#E8BB33" opacity="0.5"/><path d="M8,18 Q16,13 24,18" fill="none" stroke="#AA8822" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" opacity="0.5"/><circle cx="10" cy="17" r="1" fill="#CC9900" opacity="0.4"/><circle cx="20" cy="15" r="1" fill="#DDAA11" opacity="0.4"/></svg>',
            'hearty_meal':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1205"/><rect x="3" y="18" width="26" height="10" rx="2" fill="#3a2010" stroke="#5a3020" stroke-width="1"/><ellipse cx="8" cy="18" rx="4" ry="3" fill="#8B4513"/><ellipse cx="16" cy="17" rx="4" ry="3" fill="#44aa44"/><ellipse cx="24" cy="18" rx="4" ry="3" fill="#cc6633"/><ellipse cx="12" cy="20" rx="3" ry="2" fill="#ccaa44"/><ellipse cx="20" cy="21" rx="3" ry="2" fill="#8B4513"/><rect x="6" y="15" width="2" height="6" rx="1" fill="#5a3010"/><rect x="15" y="14" width="2" height="7" rx="1" fill="#3a7a1a"/><rect x="22" y="15" width="2" height="6" rx="1" fill="#5a2010"/></svg>',
            'cloth':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1408"/><rect x="3" y="6" width="26" height="20" rx="2" fill="#CCAA77" stroke="#AA8855" stroke-width="1"/><line x1="3" y1="10" x2="29" y2="10" stroke="#AA8855" stroke-width="0.5" stroke-linecap="round"/><line x1="3" y1="14" x2="29" y2="14" stroke="#AA8855" stroke-width="0.5" stroke-linecap="round"/><line x1="3" y1="18" x2="29" y2="18" stroke="#AA8855" stroke-width="0.5" stroke-linecap="round"/><line x1="3" y1="22" x2="29" y2="22" stroke="#AA8855" stroke-width="0.5" stroke-linecap="round"/><line x1="7" y1="6" x2="7" y2="26" stroke="#AA8855" stroke-width="0.5" stroke-linecap="round"/><line x1="13" y1="6" x2="13" y2="26" stroke="#AA8855" stroke-width="0.5" stroke-linecap="round"/><line x1="19" y1="6" x2="19" y2="26" stroke="#AA8855" stroke-width="0.5" stroke-linecap="round"/><line x1="25" y1="6" x2="25" y2="26" stroke="#AA8855" stroke-width="0.5" stroke-linecap="round"/><path d="M3,6 Q5,3 8,6" fill="none" stroke="#DDBB88" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/><path d="M26,6 Q28,3 29,6" fill="none" stroke="#DDBB88" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/></svg>',
            'arrows':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><path d="M6,26 L22,10" fill="none" stroke="#8B5E3C" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><polygon points="22,10 20,14 24,14" fill="#AAAAAA"/><path d="M6,26 L8,22" fill="none" stroke="#CCAA77" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M8,26 L24,10" fill="none" stroke="#B07A52" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><polygon points="24,10 22,14 26,14" fill="#AAAAAA"/><path d="M10,28 L26,12" fill="none" stroke="#5C3A1E" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><polygon points="26,12 24,16 28,16" fill="#AAAAAA"/></svg>',
            'axe':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="14" y="3" width="4" height="26" rx="1" fill="#6B4423"/><polygon points="8,5 18,3 20,14 16,14 16,10 8,12" fill="#8AABB8" stroke="#aabbcc" stroke-width="1"/><polygon points="8,5 4,10 8,12 16,10 16,14 8,14" fill="#6A8898"/><line x1="8" y1="12" x2="16" y2="14" stroke="#4A6878" stroke-width="0.5" stroke-linecap="round"/></svg>',
            'pickaxe':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#252525"/><rect x="15" y="10" width="3" height="20" rx="1" fill="#6B4423"/><polygon points="5,6 16,3 16,12 12,13 10,10" fill="#888" stroke="#aaa" stroke-width="1"/><polygon points="27,6 16,3 16,12 20,13 22,10" fill="#aaa" stroke="#ccc" stroke-width="1"/><rect x="12" y="10" width="8" height="4" rx="1" fill="#777"/></svg>',
            'sword':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2535"/><path d="M16,3 L19,16 L16,28 L13,16 Z" fill="#7BAFD4" stroke="#AAD0F0" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,3 L19,16 L16,28" fill="#7BAFD4"/><rect x="10" y="15" width="12" height="4" rx="1" fill="#8B6914"/><rect x="14" y="19" width="4" height="8" rx="1" fill="#B8860B"/><ellipse cx="16" cy="5" rx="1.5" ry="2.5" fill="#d0e8ff" opacity="0.7"/></svg>',
            'spear':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="15" y="12" width="3" height="18" rx="1" fill="#6B4423"/><polygon points="16,3 20,12 16,14 12,12" fill="#8AABB8" stroke="#AAD0F0" stroke-width="1"/><polygon points="16,3 20,12 16,14" fill="#6A8898"/><ellipse cx="16" cy="14" rx="2" ry="1" fill="#888" opacity="0.5"/></svg>',
            'bow':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><path d="M8,4 Q3,16 8,28" fill="none" stroke="#8B5E3C" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/><path d="M8,4 L8,28" fill="none" stroke="#8B5E3C" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" opacity="0.5"/><path d="M8,4 Q16,16 8,28" fill="none" stroke="#CCAA77" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/><line x1="8" y1="16" x2="22" y2="16" stroke="#CCCCCC" stroke-width="1.5" stroke-linecap="round"/><polygon points="22,14 26,16 22,18" fill="#CCCCCC"/></svg>',
            'pistol':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2535"/><rect x="4" y="12" width="18" height="10" rx="2" fill="#555"/><rect x="14" y="8" width="10" height="6" rx="2" fill="#444"/><rect x="4" y="20" width="10" height="8" rx="2" fill="#444"/><rect x="22" y="10" width="6" height="4" rx="1" fill="#333"/><rect x="22" y="10" width="6" height="2" rx="1" fill="#555"/><circle cx="28" cy="11" r="1" fill="#888"/><rect x="5" y="13" width="12" height="4" rx="1" fill="#666" opacity="0.4"/><line x1="4" y1="22" x2="14" y2="22" stroke="#666" stroke-width="0.5" stroke-linecap="round"/></svg>',
            'pistol_ammo':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2535"/><rect x="10" y="4" width="5" height="20" rx="2" fill="#cc8800"/><rect x="10" y="4" width="5" height="6" rx="2" fill="#eeaa00"/><rect x="15" y="4" width="5" height="20" rx="2" fill="#cc8800" opacity="0.8"/><rect x="20" y="4" width="5" height="20" rx="2" fill="#aa7700" opacity="0.6"/><rect x="9" y="22" width="14" height="6" rx="2" fill="#555"/><rect x="9" y="22" width="14" height="3" rx="2" fill="#777"/></svg>',
            'machine_gun':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#111a22"/><rect x="2" y="11" width="20" height="9" rx="2" fill="#444"/><rect x="2" y="11" width="20" height="4" rx="2" fill="#555"/><rect x="12" y="7" width="10" height="5" rx="1" fill="#3a3a3a"/><rect x="2" y="19" width="10" height="9" rx="2" fill="#333"/><rect x="7" y="21" width="6" height="8" rx="1" fill="#2a2a2a"/><rect x="22" y="9" width="9" height="3" rx="1" fill="#333"/><rect x="23" y="10" width="9" height="1.5" rx="0.5" fill="#555"/><circle cx="31" cy="10.5" r="1.2" fill="#777"/><rect x="3" y="12" width="14" height="3" rx="1" fill="#666" opacity="0.3"/><line x1="2" y1="20" x2="12" y2="20" stroke="#555" stroke-width="0.8" stroke-linecap="round"/><rect x="4" y="15" width="3" height="5" rx="1" fill="#222" opacity="0.6"/><rect x="8" y="15" width="3" height="5" rx="1" fill="#222" opacity="0.4"/></svg>',
            'mg_ammo':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#111a22"/><rect x="6" y="3" width="4" height="18" rx="2" fill="#cc5500"/><rect x="6" y="3" width="4" height="5" rx="2" fill="#ff7722"/><rect x="11" y="3" width="4" height="18" rx="2" fill="#cc5500" opacity="0.9"/><rect x="11" y="3" width="4" height="5" rx="2" fill="#ff7722" opacity="0.9"/><rect x="16" y="3" width="4" height="18" rx="2" fill="#aa4400" opacity="0.8"/><rect x="16" y="3" width="4" height="5" rx="2" fill="#ee6611" opacity="0.8"/><rect x="21" y="3" width="4" height="18" rx="2" fill="#993300" opacity="0.6"/><rect x="5" y="19" width="21" height="7" rx="2" fill="#444"/><rect x="5" y="19" width="21" height="4" rx="2" fill="#555"/></svg>',
            'building_hammer':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="14" y="3" width="4" height="22" rx="1" fill="#6B4423"/><rect x="6" y="3" width="20" height="10" rx="2" fill="#888"/><rect x="6" y="3" width="20" height="4" rx="2" fill="#aaa"/><rect x="6" y="3" width="8" height="10" rx="2" fill="#999"/><circle cx="16" cy="28" r="3" fill="#6B4423"/></svg>',
            'code_lock':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2535"/><rect x="5" y="14" width="22" height="15" rx="3" fill="#555"/><path d="M10,14 Q10,6 16,5 Q22,6 22,14" fill="none" stroke="#888" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="20" r="4" fill="#333" stroke="#777" stroke-width="1"/><rect x="15" y="20" width="2" height="5" rx="0" fill="#333"/><text x="16" y="24" fill="#aaa" font-size="7" font-weight="bold" text-anchor="middle" font-family="system-ui,sans-serif">0</text></svg>',
            'bandage':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1a2e"/><rect x="4" y="10" width="24" height="12" rx="3" fill="#EEE" stroke="#CCC" stroke-width="1"/><rect x="12" y="6" width="8" height="20" rx="3" fill="#EEE" stroke="#CCC" stroke-width="1"/><rect x="13" y="10" width="6" height="12" rx="1" fill="#DDD"/><rect x="14" y="14" width="4" height="4" rx="1" fill="#cc2222"/><line x1="16" y1="14" x2="16" y2="18" stroke="#EEE" stroke-width="1" stroke-linecap="round"/><line x1="14" y1="16" x2="18" y2="16" stroke="#EEE" stroke-width="1" stroke-linecap="round"/></svg>',
            'medkit':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a0808"/><rect x="3" y="7" width="26" height="22" rx="3" fill="#cc2222" stroke="#ee3333" stroke-width="1"/><rect x="3" y="7" width="26" height="6" rx="3" fill="#ee3333"/><rect x="11" y="3" width="10" height="6" rx="2" fill="#cc2222"/><rect x="11" y="12" width="10" height="12" rx="1" fill="#fff"/><rect x="15" y="10" width="2" height="16" rx="0" fill="#fff"/><rect x="11" y="16" width="10" height="2" rx="0" fill="#fff"/></svg>',
            'wall':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="3" y="3" width="26" height="26" rx="1" fill="#5C3A1E"/><rect x="3" y="3" width="26" height="1" rx="0" fill="#222"/><rect x="3" y="12" width="26" height="1" rx="0" fill="#222"/><rect x="3" y="21" width="26" height="1" rx="0" fill="#222"/><rect x="4" y="4" width="11" height="8" rx="1" fill="#8B5E3C"/><rect x="17" y="4" width="11" height="8" rx="1" fill="#B07A52"/><rect x="4" y="13" width="7" height="8" rx="1" fill="#B07A52"/><rect x="13" y="13" width="11" height="8" rx="1" fill="#8B5E3C"/><rect x="26" y="13" width="4" height="8" rx="1" fill="#5C3A1E"/><rect x="4" y="22" width="11" height="6" rx="1" fill="#8B5E3C"/><rect x="17" y="22" width="11" height="6" rx="1" fill="#B07A52"/></svg>',
            'stone_wall':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#252525"/><rect x="3" y="3" width="26" height="26" rx="1" fill="#555555"/><rect x="3" y="3" width="26" height="1" rx="0" fill="#222"/><rect x="3" y="12" width="26" height="1" rx="0" fill="#222"/><rect x="3" y="21" width="26" height="1" rx="0" fill="#222"/><rect x="4" y="4" width="11" height="8" rx="1" fill="#888888"/><rect x="17" y="4" width="11" height="8" rx="1" fill="#aaaaaa"/><rect x="4" y="13" width="7" height="8" rx="1" fill="#aaaaaa"/><rect x="13" y="13" width="11" height="8" rx="1" fill="#888888"/><rect x="26" y="13" width="4" height="8" rx="1" fill="#555555"/><rect x="4" y="22" width="11" height="6" rx="1" fill="#888888"/><rect x="17" y="22" width="11" height="6" rx="1" fill="#aaaaaa"/></svg>',
            'metal_wall':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2535"/><rect x="3" y="3" width="26" height="26" rx="1" fill="#4A8AAA"/><rect x="3" y="3" width="26" height="1" rx="0" fill="#222"/><rect x="3" y="12" width="26" height="1" rx="0" fill="#222"/><rect x="3" y="21" width="26" height="1" rx="0" fill="#222"/><rect x="4" y="4" width="11" height="8" rx="1" fill="#7BAFD4"/><rect x="17" y="4" width="11" height="8" rx="1" fill="#A8CBDF"/><rect x="4" y="13" width="7" height="8" rx="1" fill="#A8CBDF"/><rect x="13" y="13" width="11" height="8" rx="1" fill="#7BAFD4"/><rect x="26" y="13" width="4" height="8" rx="1" fill="#4A8AAA"/><rect x="4" y="22" width="11" height="6" rx="1" fill="#7BAFD4"/><rect x="17" y="22" width="11" height="6" rx="1" fill="#A8CBDF"/></svg>',
            'window_wall':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="3" y="3" width="26" height="26" rx="1" fill="#5C3A1E"/><rect x="3" y="3" width="26" height="1" rx="0" fill="#222"/><rect x="3" y="12" width="26" height="1" rx="0" fill="#222"/><rect x="3" y="21" width="26" height="1" rx="0" fill="#222"/><rect x="4" y="4" width="5" height="8" rx="1" fill="#8B5E3C"/><rect x="21" y="4" width="8" height="8" rx="1" fill="#B07A52"/><rect x="4" y="13" width="5" height="8" rx="1" fill="#B07A52"/><rect x="21" y="13" width="8" height="8" rx="1" fill="#8B5E3C"/><rect x="4" y="22" width="5" height="6" rx="1" fill="#8B5E3C"/><rect x="21" y="22" width="8" height="6" rx="1" fill="#B07A52"/><rect x="10" y="8" width="12" height="16" rx="1" fill="#88CCFF" opacity="0.7"/><rect x="10" y="15" width="12" height="1" rx="0" fill="#5C3A1E"/><rect x="15" y="8" width="1" height="16" rx="0" fill="#5C3A1E"/><rect x="11" y="9" width="4" height="5" rx="0" fill="#CCEEFF" opacity="0.4"/></svg>',
            'stone_window_wall':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#252525"/><rect x="3" y="3" width="26" height="26" rx="1" fill="#555555"/><rect x="3" y="3" width="26" height="1" rx="0" fill="#222"/><rect x="3" y="12" width="26" height="1" rx="0" fill="#222"/><rect x="3" y="21" width="26" height="1" rx="0" fill="#222"/><rect x="4" y="4" width="5" height="8" rx="1" fill="#888888"/><rect x="21" y="4" width="8" height="8" rx="1" fill="#aaaaaa"/><rect x="4" y="13" width="5" height="8" rx="1" fill="#aaaaaa"/><rect x="21" y="13" width="8" height="8" rx="1" fill="#888888"/><rect x="4" y="22" width="5" height="6" rx="1" fill="#888888"/><rect x="21" y="22" width="8" height="6" rx="1" fill="#aaaaaa"/><rect x="10" y="8" width="12" height="16" rx="1" fill="#88CCFF" opacity="0.7"/><rect x="10" y="15" width="12" height="1" rx="0" fill="#555555"/><rect x="15" y="8" width="1" height="16" rx="0" fill="#555555"/><rect x="11" y="9" width="4" height="5" rx="0" fill="#CCEEFF" opacity="0.4"/></svg>',
            'metal_window_wall':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2535"/><rect x="3" y="3" width="26" height="26" rx="1" fill="#4A8AAA"/><rect x="3" y="3" width="26" height="1" rx="0" fill="#222"/><rect x="3" y="12" width="26" height="1" rx="0" fill="#222"/><rect x="3" y="21" width="26" height="1" rx="0" fill="#222"/><rect x="4" y="4" width="5" height="8" rx="1" fill="#7BAFD4"/><rect x="21" y="4" width="8" height="8" rx="1" fill="#A8CBDF"/><rect x="4" y="13" width="5" height="8" rx="1" fill="#A8CBDF"/><rect x="21" y="13" width="8" height="8" rx="1" fill="#7BAFD4"/><rect x="4" y="22" width="5" height="6" rx="1" fill="#7BAFD4"/><rect x="21" y="22" width="8" height="6" rx="1" fill="#A8CBDF"/><rect x="10" y="8" width="12" height="16" rx="1" fill="#88CCFF" opacity="0.7"/><rect x="10" y="15" width="12" height="1" rx="0" fill="#4A8AAA"/><rect x="15" y="8" width="1" height="16" rx="0" fill="#4A8AAA"/><rect x="11" y="9" width="4" height="5" rx="0" fill="#CCEEFF" opacity="0.4"/></svg>',
            'door_frame': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0f06"/><rect x="2" y="2" width="6" height="28" rx="1" fill="#5C3A1E"/><rect x="24" y="2" width="6" height="28" rx="1" fill="#5C3A1E"/><rect x="2" y="2" width="28" height="5" rx="1" fill="#5C3A1E"/><rect x="2" y="27" width="28" height="3" rx="1" fill="#5C3A1E"/></svg>',
            'door': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0f06"/><rect x="2" y="2" width="5" height="28" rx="1" fill="#5C3A1E"/><rect x="25" y="2" width="5" height="28" rx="1" fill="#5C3A1E"/><rect x="2" y="2" width="28" height="4" rx="1" fill="#5C3A1E"/><rect x="7" y="6" width="18" height="24" rx="1" fill="#9C7A3C"/><rect x="7" y="6" width="18" height="5" rx="0" fill="#B8924A" opacity="0.5"/><rect x="7" y="13" width="18" height="5" rx="0" fill="#B8924A" opacity="0.5"/><rect x="7" y="20" width="18" height="4" rx="0" fill="#B8924A" opacity="0.5"/><circle cx="21" cy="18" r="2" fill="#FFD700"/></svg>',
            'double_door': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0f06"/><rect x="1" y="2" width="4" height="28" rx="1" fill="#5C3A1E"/><rect x="27" y="2" width="4" height="28" rx="1" fill="#5C3A1E"/><rect x="1" y="2" width="30" height="4" rx="1" fill="#5C3A1E"/><rect x="5" y="6" width="11" height="24" rx="1" fill="#9C7A3C"/><rect x="16" y="6" width="11" height="24" rx="1" fill="#9C7A3C"/><rect x="5" y="6" width="11" height="4" rx="0" fill="#B8924A" opacity="0.5"/><rect x="16" y="6" width="11" height="4" rx="0" fill="#B8924A" opacity="0.5"/><rect x="5" y="14" width="11" height="4" rx="0" fill="#B8924A" opacity="0.4"/><rect x="16" y="14" width="11" height="4" rx="0" fill="#B8924A" opacity="0.4"/><circle cx="14" cy="18" r="1.5" fill="#FFD700"/><circle cx="18" cy="18" r="1.5" fill="#FFD700"/></svg>',
                        'stone_door': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0f06"/><rect x="2" y="2" width="5" height="28" rx="1" fill="#4A2E10"/><rect x="25" y="2" width="5" height="28" rx="1" fill="#4A2E10"/><rect x="2" y="2" width="28" height="4" rx="1" fill="#4A2E10"/><rect x="7" y="6" width="18" height="24" rx="1" fill="#7A5C2E"/><rect x="7" y="6" width="18" height="4" fill="#8A6C3E" opacity="0.5"/><rect x="8" y="14" width="16" height="8" rx="1" fill="#88CCEE" opacity="0.5"/><rect x="8" y="14" width="16" height="1" fill="#4A2E10"/><rect x="8" y="21" width="16" height="1" fill="#4A2E10"/><rect x="15" y="14" width="2" height="8" fill="#4A2E10"/><rect x="9" y="25" width="14" height="4" rx="1" fill="#5A3A18" opacity="0.4"/><circle cx="22" cy="19" r="1.5" fill="#B08040"/></svg>',
            'stone_double_door': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0f06"/><rect x="1" y="2" width="4" height="28" rx="1" fill="#4A2E10"/><rect x="27" y="2" width="4" height="28" rx="1" fill="#4A2E10"/><rect x="1" y="2" width="30" height="4" rx="1" fill="#4A2E10"/><rect x="5" y="6" width="11" height="24" rx="1" fill="#7A5C2E"/><rect x="16" y="6" width="11" height="24" rx="1" fill="#7A5C2E"/><rect x="5" y="14" width="11" height="7" rx="1" fill="#88CCEE" opacity="0.5"/><rect x="16" y="14" width="11" height="7" rx="1" fill="#88CCEE" opacity="0.5"/><rect x="5" y="14" width="11" height="1" fill="#4A2E10"/><rect x="5" y="20" width="11" height="1" fill="#4A2E10"/><rect x="16" y="14" width="11" height="1" fill="#4A2E10"/><rect x="16" y="20" width="11" height="1" fill="#4A2E10"/><circle cx="14" cy="18" r="1.5" fill="#B08040"/><circle cx="18" cy="18" r="1.5" fill="#B08040"/></svg>',
            'metal_door': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1e22"/><rect x="2" y="2" width="5" height="28" rx="1" fill="#555960"/><rect x="25" y="2" width="5" height="28" rx="1" fill="#555960"/><rect x="2" y="2" width="28" height="4" rx="1" fill="#555960"/><rect x="7" y="6" width="18" height="24" fill="#A0A8B0"/><rect x="7" y="6" width="10" height="12" fill="#BEC4CC"/><rect x="17" y="18" width="8" height="12" fill="#787E86"/><rect x="7" y="6" width="6" height="24" fill="#909899" opacity="0.5"/><line x1="9" y1="6" x2="9" y2="30" stroke="#C0C8D0" stroke-width="0.8"/><line x1="11" y1="6" x2="11" y2="30" stroke="#C0C8D0" stroke-width="0.8"/><line x1="13" y1="6" x2="13" y2="30" stroke="#C0C8D0" stroke-width="0.8"/><rect x="13" y="6" width="12" height="0.8" fill="#3A3020"/><rect x="13" y="18" width="12" height="0.8" fill="#3A3020"/><circle cx="8" cy="10" r="1" fill="#555960"/><circle cx="8" cy="26" r="1" fill="#555960"/><circle cx="24" cy="10" r="1" fill="#555960"/><circle cx="24" cy="26" r="1" fill="#555960"/><rect x="22" y="16" width="3" height="7" rx="1" fill="#888E96"/></svg>',
            'metal_double_door': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1e22"/><rect x="1" y="2" width="4" height="28" rx="1" fill="#555960"/><rect x="27" y="2" width="4" height="28" rx="1" fill="#555960"/><rect x="1" y="2" width="30" height="4" rx="1" fill="#555960"/><rect x="5" y="6" width="11" height="24" fill="#A0A8B0"/><rect x="16" y="6" width="11" height="24" fill="#A0A8B0"/><rect x="5" y="6" width="5" height="24" fill="#909899" opacity="0.6"/><rect x="22" y="6" width="5" height="24" fill="#787E86" opacity="0.6"/><line x1="7" y1="6" x2="7" y2="30" stroke="#C0C8D0" stroke-width="0.8"/><line x1="9" y1="6" x2="9" y2="30" stroke="#C0C8D0" stroke-width="0.8"/><line x1="25" y1="6" x2="25" y2="30" stroke="#C0C8D0" stroke-width="0.8"/><line x1="23" y1="6" x2="23" y2="30" stroke="#C0C8D0" stroke-width="0.8"/><rect x="5" y="18" width="11" height="0.8" fill="#3A3020"/><rect x="16" y="15" width="11" height="0.8" fill="#3A3020"/><circle cx="6" cy="10" r="1" fill="#555960"/><circle cx="6" cy="26" r="1" fill="#555960"/><circle cx="26" cy="10" r="1" fill="#555960"/><circle cx="26" cy="26" r="1" fill="#555960"/><circle cx="14" cy="17" r="1.5" fill="#888E96"/><circle cx="18" cy="17" r="1.5" fill="#888E96"/></svg>',
            'double_door_frame': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0f06"/><rect x="1" y="2" width="5" height="28" rx="1" fill="#5C3A1E"/><rect x="26" y="2" width="5" height="28" rx="1" fill="#5C3A1E"/><rect x="1" y="2" width="30" height="4" rx="1" fill="#5C3A1E"/><rect x="1" y="28" width="30" height="2" rx="1" fill="#5C3A1E"/></svg>',
            'floor':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="2" y="2" width="28" height="28" rx="2" fill="#5C3A1E"/><rect x="3" y="3" width="12" height="12" rx="1" fill="#8B5E3C"/><rect x="17" y="3" width="12" height="12" rx="1" fill="#B07A52"/><rect x="3" y="17" width="12" height="12" rx="1" fill="#B07A52"/><rect x="17" y="17" width="12" height="12" rx="1" fill="#8B5E3C"/><line x1="5" y1="5" x2="5" y2="14" stroke="#5C3A1E" stroke-width="0.5" stroke-linecap="round"/><line x1="8" y1="5" x2="8" y2="14" stroke="#5C3A1E" stroke-width="0.5" stroke-linecap="round"/><line x1="19" y1="5" x2="19" y2="14" stroke="#5C3A1E" stroke-width="0.5" stroke-linecap="round"/><line x1="22" y1="5" x2="22" y2="14" stroke="#5C3A1E" stroke-width="0.5" stroke-linecap="round"/></svg>',
            'stone_floor':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#252525"/><rect x="2" y="2" width="28" height="28" rx="2" fill="#555555"/><rect x="3" y="3" width="12" height="12" rx="1" fill="#888888"/><rect x="17" y="3" width="12" height="12" rx="1" fill="#aaaaaa"/><rect x="3" y="17" width="12" height="12" rx="1" fill="#aaaaaa"/><rect x="17" y="17" width="12" height="12" rx="1" fill="#888888"/><line x1="5" y1="5" x2="5" y2="14" stroke="#555555" stroke-width="0.5" stroke-linecap="round"/><line x1="8" y1="5" x2="8" y2="14" stroke="#555555" stroke-width="0.5" stroke-linecap="round"/><line x1="19" y1="5" x2="19" y2="14" stroke="#555555" stroke-width="0.5" stroke-linecap="round"/><line x1="22" y1="5" x2="22" y2="14" stroke="#555555" stroke-width="0.5" stroke-linecap="round"/></svg>',
            'metal_floor':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2535"/><rect x="2" y="2" width="28" height="28" rx="2" fill="#4A8AAA"/><rect x="3" y="3" width="12" height="12" rx="1" fill="#7BAFD4"/><rect x="17" y="3" width="12" height="12" rx="1" fill="#A8CBDF"/><rect x="3" y="17" width="12" height="12" rx="1" fill="#A8CBDF"/><rect x="17" y="17" width="12" height="12" rx="1" fill="#7BAFD4"/><line x1="5" y1="5" x2="5" y2="14" stroke="#4A8AAA" stroke-width="0.5" stroke-linecap="round"/><line x1="8" y1="5" x2="8" y2="14" stroke="#4A8AAA" stroke-width="0.5" stroke-linecap="round"/><line x1="19" y1="5" x2="19" y2="14" stroke="#4A8AAA" stroke-width="0.5" stroke-linecap="round"/><line x1="22" y1="5" x2="22" y2="14" stroke="#4A8AAA" stroke-width="0.5" stroke-linecap="round"/></svg>',
            'ceiling':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="2" y="2" width="28" height="28" rx="2" fill="#5C3A1E"/><rect x="3" y="3" width="12" height="12" rx="1" fill="#8B5E3C"/><rect x="17" y="3" width="12" height="12" rx="1" fill="#B07A52"/><rect x="3" y="17" width="12" height="12" rx="1" fill="#B07A52"/><rect x="17" y="17" width="12" height="12" rx="1" fill="#8B5E3C"/><rect x="2" y="2" width="28" height="4" rx="0" fill="#000000" opacity="0.4"/></svg>',
            'stone_ceiling':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#252525"/><rect x="2" y="2" width="28" height="28" rx="2" fill="#555555"/><rect x="3" y="3" width="12" height="12" rx="1" fill="#888888"/><rect x="17" y="3" width="12" height="12" rx="1" fill="#aaaaaa"/><rect x="3" y="17" width="12" height="12" rx="1" fill="#aaaaaa"/><rect x="17" y="17" width="12" height="12" rx="1" fill="#888888"/><rect x="2" y="2" width="28" height="4" rx="0" fill="#000000" opacity="0.4"/></svg>',
            'metal_ceiling':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2535"/><rect x="2" y="2" width="28" height="28" rx="2" fill="#4A8AAA"/><rect x="3" y="3" width="12" height="12" rx="1" fill="#7BAFD4"/><rect x="17" y="3" width="12" height="12" rx="1" fill="#A8CBDF"/><rect x="3" y="17" width="12" height="12" rx="1" fill="#A8CBDF"/><rect x="17" y="17" width="12" height="12" rx="1" fill="#7BAFD4"/><rect x="2" y="2" width="28" height="4" rx="0" fill="#000000" opacity="0.4"/></svg>',
            'ladder_ceiling':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="2" y="2" width="28" height="28" rx="2" fill="#5C3A1E"/><rect x="3" y="3" width="12" height="12" rx="1" fill="#8B5E3C"/><rect x="17" y="3" width="12" height="12" rx="1" fill="#B07A52"/><rect x="3" y="17" width="12" height="12" rx="1" fill="#B07A52"/><rect x="17" y="17" width="12" height="12" rx="1" fill="#8B5E3C"/><rect x="2" y="2" width="28" height="4" rx="0" fill="#000000" opacity="0.4"/></svg>',
            'stairs':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="3" y="22" width="26" height="6" rx="1" fill="#5C3A1E"/><rect x="3" y="16" width="20" height="6" rx="1" fill="#8B5E3C"/><rect x="3" y="10" width="14" height="6" rx="1" fill="#B07A52"/><rect x="3" y="4" width="8" height="6" rx="1" fill="#8B5E3C"/><line x1="3" y1="22" x2="29" y2="22" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="16" x2="23" y2="16" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="10" x2="17" y2="10" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="4" x2="11" y2="4" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/></svg>',
            'stone_stairs':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#252525"/><rect x="3" y="22" width="26" height="6" rx="1" fill="#555555"/><rect x="3" y="16" width="20" height="6" rx="1" fill="#888888"/><rect x="3" y="10" width="14" height="6" rx="1" fill="#aaaaaa"/><rect x="3" y="4" width="8" height="6" rx="1" fill="#888888"/><line x1="3" y1="22" x2="29" y2="22" stroke="#555555" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="16" x2="23" y2="16" stroke="#555555" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="10" x2="17" y2="10" stroke="#555555" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="4" x2="11" y2="4" stroke="#555555" stroke-width="1" stroke-linecap="round"/></svg>',
            'metal_stairs':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2535"/><rect x="3" y="22" width="26" height="6" rx="1" fill="#4A8AAA"/><rect x="3" y="16" width="20" height="6" rx="1" fill="#7BAFD4"/><rect x="3" y="10" width="14" height="6" rx="1" fill="#A8CBDF"/><rect x="3" y="4" width="8" height="6" rx="1" fill="#7BAFD4"/><line x1="3" y1="22" x2="29" y2="22" stroke="#4A8AAA" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="16" x2="23" y2="16" stroke="#4A8AAA" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="10" x2="17" y2="10" stroke="#4A8AAA" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="4" x2="11" y2="4" stroke="#4A8AAA" stroke-width="1" stroke-linecap="round"/></svg>',
            'corner_stairs_left':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="3" y="22" width="26" height="6" rx="1" fill="#5C3A1E"/><rect x="3" y="16" width="20" height="6" rx="1" fill="#8B5E3C"/><rect x="3" y="10" width="14" height="6" rx="1" fill="#B07A52"/><rect x="3" y="4" width="8" height="6" rx="1" fill="#8B5E3C"/><line x1="3" y1="22" x2="29" y2="22" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="16" x2="23" y2="16" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="10" x2="17" y2="10" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="4" x2="11" y2="4" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/></svg>',
            'stone_corner_stairs_left':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#252525"/><rect x="3" y="22" width="26" height="6" rx="1" fill="#555555"/><rect x="3" y="16" width="20" height="6" rx="1" fill="#888888"/><rect x="3" y="10" width="14" height="6" rx="1" fill="#aaaaaa"/><rect x="3" y="4" width="8" height="6" rx="1" fill="#888888"/><line x1="3" y1="22" x2="29" y2="22" stroke="#555555" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="16" x2="23" y2="16" stroke="#555555" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="10" x2="17" y2="10" stroke="#555555" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="4" x2="11" y2="4" stroke="#555555" stroke-width="1" stroke-linecap="round"/></svg>',
            'metal_corner_stairs_left':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2535"/><rect x="3" y="22" width="26" height="6" rx="1" fill="#4A8AAA"/><rect x="3" y="16" width="20" height="6" rx="1" fill="#7BAFD4"/><rect x="3" y="10" width="14" height="6" rx="1" fill="#A8CBDF"/><rect x="3" y="4" width="8" height="6" rx="1" fill="#7BAFD4"/><line x1="3" y1="22" x2="29" y2="22" stroke="#4A8AAA" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="16" x2="23" y2="16" stroke="#4A8AAA" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="10" x2="17" y2="10" stroke="#4A8AAA" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="4" x2="11" y2="4" stroke="#4A8AAA" stroke-width="1" stroke-linecap="round"/></svg>',
            'corner_stairs_right':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="3" y="22" width="26" height="6" rx="1" fill="#5C3A1E"/><rect x="3" y="16" width="20" height="6" rx="1" fill="#8B5E3C"/><rect x="3" y="10" width="14" height="6" rx="1" fill="#B07A52"/><rect x="3" y="4" width="8" height="6" rx="1" fill="#8B5E3C"/><line x1="3" y1="22" x2="29" y2="22" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="16" x2="23" y2="16" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="10" x2="17" y2="10" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="4" x2="11" y2="4" stroke="#5C3A1E" stroke-width="1" stroke-linecap="round"/></svg>',
            'stone_corner_stairs_right':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#252525"/><rect x="3" y="22" width="26" height="6" rx="1" fill="#555555"/><rect x="3" y="16" width="20" height="6" rx="1" fill="#888888"/><rect x="3" y="10" width="14" height="6" rx="1" fill="#aaaaaa"/><rect x="3" y="4" width="8" height="6" rx="1" fill="#888888"/><line x1="3" y1="22" x2="29" y2="22" stroke="#555555" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="16" x2="23" y2="16" stroke="#555555" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="10" x2="17" y2="10" stroke="#555555" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="4" x2="11" y2="4" stroke="#555555" stroke-width="1" stroke-linecap="round"/></svg>',
            'metal_corner_stairs_right':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2535"/><rect x="3" y="22" width="26" height="6" rx="1" fill="#4A8AAA"/><rect x="3" y="16" width="20" height="6" rx="1" fill="#7BAFD4"/><rect x="3" y="10" width="14" height="6" rx="1" fill="#A8CBDF"/><rect x="3" y="4" width="8" height="6" rx="1" fill="#7BAFD4"/><line x1="3" y1="22" x2="29" y2="22" stroke="#4A8AAA" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="16" x2="23" y2="16" stroke="#4A8AAA" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="10" x2="17" y2="10" stroke="#4A8AAA" stroke-width="1" stroke-linecap="round"/><line x1="3" y1="4" x2="11" y2="4" stroke="#4A8AAA" stroke-width="1" stroke-linecap="round"/></svg>',
            'ladder':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="5" y="2" width="4" height="28" rx="1" fill="#8B5E3C"/><rect x="23" y="2" width="4" height="28" rx="1" fill="#8B5E3C"/><rect x="9" y="5" width="14" height="3" rx="1" fill="#B07A52"/><rect x="9" y="11" width="14" height="3" rx="1" fill="#B07A52"/><rect x="9" y="17" width="14" height="3" rx="1" fill="#B07A52"/><rect x="9" y="23" width="14" height="3" rx="1" fill="#B07A52"/></svg>',
            'sleeping_bag':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d0d1a"/><ellipse cx="16" cy="20" rx="13" ry="9" fill="#3a3a5a" stroke="#5a5a7a" stroke-width="1"/><ellipse cx="16" cy="18" rx="11" ry="7" fill="#5a5a8a"/><ellipse cx="16" cy="10" rx="8" ry="8" fill="#8a7a6a" stroke="#aa9a8a" stroke-width="1"/><ellipse cx="16" cy="9" rx="6" ry="6" fill="#ccaa88"/><ellipse cx="15" cy="8" rx="3" ry="3" fill="#ddbba0" opacity="0.7"/></svg>',
            'campfire':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#12080a"/><ellipse cx="16" cy="26" rx="10" ry="4" fill="#333" opacity="0.8"/><rect x="10" y="22" width="3" height="6" rx="1" fill="#5a3010"/><rect x="14" y="21" width="3" height="8" rx="1" fill="#6b4020"/><rect x="18" y="22" width="3" height="7" rx="1" fill="#5a3010"/><rect x="21" y="23" width="3" height="5" rx="1" fill="#4a2800"/><path d="M16,20 Q11,14 13,8" fill="none" stroke="#FF4400" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,20 Q20,12 18,6" fill="none" stroke="#FF6600" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,20 Q14,16 15,10" fill="none" stroke="#FFAA00" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,20 Q18,16 17,11" fill="none" stroke="#FFDD00" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
            'workbench':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="2" y="18" width="28" height="10" rx="2" fill="#5C3A1E"/><rect x="2" y="14" width="28" height="5" rx="1" fill="#8B5E3C"/><rect x="2" y="14" width="28" height="2" rx="1" fill="#B07A52" opacity="0.5"/><rect x="4" y="24" width="5" height="6" rx="1" fill="#5C3A1E"/><rect x="23" y="24" width="5" height="6" rx="1" fill="#5C3A1E"/><rect x="5" y="8" width="6" height="8" rx="1" fill="#8AABB8"/><rect x="14" y="6" width="4" height="10" rx="1" fill="#aaa"/><rect x="21" y="8" width="6" height="8" rx="1" fill="#B07A52"/><line x1="2" y1="18" x2="30" y2="18" stroke="#5C3A1E" stroke-width="0.5" stroke-linecap="round"/></svg>',
            'building_bench':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="2" y="18" width="28" height="10" rx="2" fill="#5C3A1E"/><rect x="2" y="14" width="28" height="5" rx="1" fill="#8B5E3C"/><rect x="2" y="14" width="28" height="2" rx="1" fill="#B07A52" opacity="0.5"/><rect x="4" y="24" width="5" height="6" rx="1" fill="#5C3A1E"/><rect x="23" y="24" width="5" height="6" rx="1" fill="#5C3A1E"/><rect x="7" y="7" width="6" height="9" rx="1" fill="#888"/><rect x="13" y="5" width="6" height="11" rx="1" fill="#aaa"/><rect x="19" y="7" width="6" height="9" rx="1" fill="#888"/><line x1="2" y1="18" x2="30" y2="18" stroke="#5C3A1E" stroke-width="0.5" stroke-linecap="round"/></svg>',
            'furnace':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#252525"/><rect x="4" y="4" width="24" height="25" rx="3" fill="#555555"/><rect x="4" y="4" width="24" height="12" rx="3" fill="#888888"/><rect x="4" y="4" width="24" height="4" rx="3" fill="#aaaaaa" opacity="0.5"/><rect x="9" y="16" width="14" height="10" rx="2" fill="#111"/><path d="M9,16 Q11,20 16,22 Q21,20 23,16" fill="none" stroke="#FF4400" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/><path d="M12,16 Q14,19 16,20 Q18,19 20,16" fill="none" stroke="#FF8800" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><rect x="13" y="25" width="6" height="5" rx="1" fill="#333"/><line x1="4" y1="14" x2="28" y2="14" stroke="#555555" stroke-width="1" stroke-linecap="round"/></svg>',
            'cooking_station':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#111"/><rect x="3" y="20" width="26" height="9" rx="2" fill="#333"/><rect x="3" y="16" width="26" height="5" rx="1" fill="#444"/><circle cx="11" cy="15" r="5" fill="#555" stroke="#888" stroke-width="1"/><circle cx="21" cy="15" r="5" fill="#555" stroke="#888" stroke-width="1"/><circle cx="11" cy="15" r="3" fill="#FF4400" opacity="0.7"/><circle cx="21" cy="15" r="3" fill="#FF6600" opacity="0.6"/><rect x="8" y="20" width="4" height="4" rx="1" fill="#666"/><rect x="20" y="20" width="4" height="4" rx="1" fill="#666"/><rect x="5" y="8" width="8" height="14" rx="1" fill="#8B4513"/><rect x="19" y="6" width="8" height="16" rx="1" fill="#8B4513"/><ellipse cx="9" cy="8" rx="4" ry="2" fill="#c86400"/><ellipse cx="23" cy="6" rx="4" ry="2" fill="#c86400"/></svg>',
            'storage_box':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="2" y="10" width="28" height="18" rx="2" fill="#8B5E3C" stroke="#5C3A1E" stroke-width="1"/><rect x="2" y="10" width="28" height="6" rx="2" fill="#B07A52"/><rect x="2" y="9" width="28" height="4" rx="2" fill="#555"/><rect x="13" y="7" width="6" height="4" rx="1" fill="#777"/><rect x="2" y="9" width="28" height="2" rx="0" fill="#5C3A1E"/><line x1="2" y1="20" x2="30" y2="20" stroke="#5C3A1E" stroke-width="0.5" stroke-linecap="round"/><rect x="11" y="21" width="10" height="5" rx="1" fill="#666"/><circle cx="16" cy="24" r="2" fill="#999"/></svg>',
            'small_storage_box':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="4" y="12" width="24" height="15" rx="2" fill="#8B5E3C" stroke="#5C3A1E" stroke-width="1"/><rect x="4" y="12" width="24" height="5" rx="2" fill="#B07A52"/><rect x="4" y="11" width="24" height="4" rx="2" fill="#555"/><rect x="13" y="9" width="6" height="4" rx="1" fill="#777"/><rect x="4" y="11" width="24" height="2" rx="0" fill="#5C3A1E"/><rect x="12" y="20" width="8" height="4" rx="1" fill="#666"/><circle cx="16" cy="22" r="1.5" fill="#999"/></svg>',
            'storage_shelf':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="3" y="3" width="3" height="26" rx="1" fill="#5C3A1E"/><rect x="26" y="3" width="3" height="26" rx="1" fill="#5C3A1E"/><rect x="3" y="3" width="26" height="3" rx="1" fill="#8B5E3C"/><rect x="3" y="13" width="26" height="3" rx="1" fill="#8B5E3C"/><rect x="3" y="23" width="26" height="3" rx="1" fill="#8B5E3C"/><rect x="7" y="6" width="6" height="7" rx="1" fill="#B07A52" opacity="0.5"/><rect x="14" y="6" width="5" height="7" rx="1" fill="#B07A52" opacity="0.4"/><rect x="20" y="6" width="4" height="7" rx="1" fill="#B07A52" opacity="0.3"/><rect x="7" y="16" width="8" height="7" rx="1" fill="#B07A52" opacity="0.4"/><rect x="17" y="16" width="5" height="7" rx="1" fill="#B07A52" opacity="0.5"/></svg>',
            'wall_shelf':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="3" y="16" width="26" height="4" rx="1" fill="#8B5E3C"/><rect x="4" y="20" width="4" height="8" rx="1" fill="#5C3A1E"/><rect x="24" y="20" width="4" height="8" rx="1" fill="#5C3A1E"/><rect x="4" y="16" width="4" height="4" rx="1" fill="#5C3A1E"/><rect x="24" y="16" width="4" height="4" rx="1" fill="#5C3A1E"/><rect x="7" y="8" width="5" height="9" rx="1" fill="#B07A52" opacity="0.6"/><rect x="13" y="6" width="6" height="10" rx="1" fill="#B07A52" opacity="0.5"/><rect x="20" y="8" width="5" height="9" rx="1" fill="#B07A52" opacity="0.6"/></svg>',
            'sewing_table':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="3" y="20" width="26" height="8" rx="2" fill="#5C3A1E"/><rect x="3" y="17" width="26" height="4" rx="1" fill="#8B5E3C"/><rect x="5" y="25" width="4" height="5" rx="1" fill="#5C3A1E"/><rect x="23" y="25" width="4" height="5" rx="1" fill="#5C3A1E"/><rect x="8" y="8" width="16" height="11" rx="2" fill="#CCAA77" stroke="#5C3A1E" stroke-width="1"/><circle cx="16" cy="13" r="3" fill="#888" stroke="#aaa" stroke-width="1"/><rect x="15" y="7" width="2" height="8" rx="0" fill="#666"/><circle cx="16" cy="6" r="2" fill="#999"/></svg>',
            'recycler':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2535"/><circle cx="16" cy="16" r="12" fill="#4A8AAA" stroke="#7BAFD4" stroke-width="1"/><circle cx="16" cy="16" r="9" fill="#7BAFD4"/><path d="M12,10 Q8,16 12,22 L10,24 L14,24 L14,20 L12,20 Q9,16 12,11Z" fill="#88CCFF"/><path d="M20,10 Q24,16 20,22 L22,24 L18,24 L18,20 L20,20 Q23,16 20,11Z" fill="#88CCFF"/><circle cx="16" cy="16" r="3" fill="#2a3a4a"/></svg>',
            'water_catcher':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#08102a"/><ellipse cx="16" cy="22" rx="12" ry="7" fill="#2244AA" stroke="#4466CC" stroke-width="1"/><path d="M4,22 Q8,14 12,22" fill="none" stroke="#4466CC" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/><path d="M12,22 Q16,10 20,22" fill="none" stroke="#5577DD" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/><path d="M20,22 Q24,14 28,22" fill="none" stroke="#4466CC" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/><ellipse cx="16" cy="22" rx="10" ry="5" fill="#3355BB" opacity="0.6"/><path d="M10,4 Q16,2 22,4 L20,14 Q16,16 12,14 Z" fill="#6688CC" opacity="0.7"/><ellipse cx="16" cy="4" rx="6" ry="2" fill="#88AAEE" opacity="0.5"/></svg>',
            'sofa':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="2" y="18" width="28" height="10" rx="3" fill="#8B6F47"/><rect x="4" y="12" width="24" height="8" rx="2" fill="#9B7D5A"/><rect x="2" y="12" width="5" height="13" rx="2" fill="#6B4A2E"/><rect x="25" y="12" width="5" height="13" rx="2" fill="#6B4A2E"/><rect x="4" y="26" width="4" height="4" rx="1" fill="#5C3A1E"/><rect x="24" y="26" width="4" height="4" rx="1" fill="#5C3A1E"/></svg>',
            'bookcase':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0e05"/><rect x="3" y="2" width="26" height="28" rx="2" fill="#5C3A1E"/><rect x="5" y="2" width="22" height="28" rx="1" fill="#3D2008"/><rect x="5" y="8" width="22" height="2" fill="#5C3A1E"/><rect x="5" y="16" width="22" height="2" fill="#5C3A1E"/><rect x="5" y="24" width="22" height="2" fill="#5C3A1E"/><rect x="6" y="4" width="3" height="4" rx="0" fill="#C0392B"/><rect x="10" y="4" width="4" height="4" rx="0" fill="#2980B9"/><rect x="15" y="3" width="3" height="5" rx="0" fill="#27AE60"/><rect x="6" y="11" width="4" height="5" rx="0" fill="#8E44AD"/><rect x="12" y="10" width="3" height="6" rx="0" fill="#1ABC9C"/><rect x="6" y="19" width="3" height="5" rx="0" fill="#F39C12"/><rect x="11" y="19" width="4" height="5" rx="0" fill="#E74C3C"/></svg>',
            'table':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2d1a0e"/><rect x="2" y="12" width="28" height="4" rx="2" fill="#8B5E3C"/><rect x="6" y="16" width="3" height="14" rx="1" fill="#6B4423"/><rect x="23" y="16" width="3" height="14" rx="1" fill="#6B4423"/></svg>',
            'chair':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0e05"/><rect x="8" y="14" width="16" height="4" rx="2" fill="#9B7D5A"/><rect x="8" y="4" width="3" height="24" rx="1" fill="#6B4423"/><rect x="21" y="4" width="3" height="24" rx="1" fill="#6B4423"/><rect x="11" y="18" width="10" height="10" rx="1" fill="#8B6F47"/></svg>',
            'wall_shelf_b':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0e05"/><rect x="2" y="10" width="28" height="4" rx="1" fill="#7B5230"/><rect x="2" y="20" width="28" height="4" rx="1" fill="#7B5230"/><rect x="3" y="10" width="5" height="14" rx="1" fill="#5C3A1E"/><rect x="24" y="10" width="5" height="14" rx="1" fill="#5C3A1E"/></svg>',
            'candle':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0a0806"/><rect x="12" y="14" width="8" height="14" rx="2" fill="#FFFACD"/><rect x="15" y="10" width="2" height="5" rx="1" fill="#444400"/><ellipse cx="16" cy="9" rx="3" ry="4" fill="#FFCC00" opacity="0.9"/><ellipse cx="16" cy="7" rx="2" ry="3" fill="#FFEE88" opacity="0.7"/></svg>',
            'wall_light':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d0d14"/><rect x="13" y="2" width="6" height="10" rx="2" fill="#555"/><path d="M8,16 L24,16 L20,28 L12,28 Z" fill="#888877" opacity="0.8"/><ellipse cx="16" cy="16" rx="5" ry="3" fill="#FFFFAA" opacity="0.9"/><ellipse cx="16" cy="22" rx="7" ry="6" fill="#FFEE66" opacity="0.25"/></svg>',
            'bee_hive':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0e00"/><rect x="8" y="18" width="16" height="5" rx="2" fill="#9C7A3C"/><rect x="7" y="13" width="18" height="6" rx="2" fill="#B8922A"/><rect x="8" y="8" width="16" height="6" rx="2" fill="#D4A832"/><path d="M10,8 L22,8 L19,4 L13,4 Z" fill="#5C3A1E"/><circle cx="16" cy="19" r="2" fill="#2d1a00"/></svg>',
            'chicken_coop':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d0a05"/><rect x="2" y="16" width="28" height="14" rx="2" fill="#8B6F47"/><path d="M2,16 L16,6 L30,16 Z" fill="#CC4400"/><rect x="5" y="18" width="10" height="10" rx="1" fill="#A08050"/><circle cx="22" cy="22" r="4" fill="#CC6600"/></svg>',
            'oil_smelter':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0a0c10"/><rect x="3" y="26" width="26" height="4" rx="1" fill="#2A2E32"/><ellipse cx="16" cy="18" rx="12" ry="8" fill="#444A50"/><rect x="5" y="5" width="4" height="10" rx="2" fill="#2A2E32"/><rect x="14" y="22" width="4" height="5" rx="1" fill="#B87333" opacity="0.6"/><circle cx="11" cy="19" r="1.5" fill="#FF6600" opacity="0.8"/></svg>',
            'honey':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0e00"/><rect x="10" y="8" width="12" height="18" rx="4" fill="#DAA520"/><rect x="12" y="4" width="8" height="6" rx="2" fill="#B8860B"/></svg>',
            'egg':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0a0806"/><ellipse cx="16" cy="17" rx="9" ry="11" fill="#FFF5DC"/></svg>',
            'water_bottle':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#08102a"/><rect x="12" y="3" width="8" height="5" rx="1" fill="#88AACC"/><rect x="10" y="8" width="12" height="20" rx="3" fill="#2255AA" stroke="#4477CC" stroke-width="1"/><rect x="10" y="8" width="12" height="8" rx="3" fill="#3366BB"/><rect x="11" y="12" width="10" height="12" rx="2" fill="#4488DD" opacity="0.5"/><ellipse cx="16" cy="14" rx="3" ry="2" fill="#88BBFF" opacity="0.4"/><rect x="13" y="4" width="6" height="2" rx="1" fill="#AACCEE" opacity="0.6"/></svg>',
            'flour':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#252535"/><rect x="7" y="8" width="18" height="18" rx="2" fill="#ddd" stroke="#bbb" stroke-width="1"/><rect x="7" y="8" width="18" height="6" rx="2" fill="#eee"/><rect x="10" y="8" width="3" height="18" rx="0" fill="#ccc"/><rect x="14" y="8" width="3" height="18" rx="0" fill="#ccc"/><rect x="18" y="8" width="3" height="18" rx="0" fill="#ccc"/><text x="16" y="20" fill="#888" font-size="9" font-weight="bold" text-anchor="middle" font-family="system-ui,sans-serif">F</text></svg>',
            'bread':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1205"/><ellipse cx="16" cy="19" rx="13" ry="9" fill="#8B4513" stroke="#A0522D" stroke-width="1"/><ellipse cx="16" cy="17" rx="11" ry="7" fill="#D2691E"/><ellipse cx="16" cy="15" rx="9" ry="5" fill="#DAA520" opacity="0.6"/><path d="M8,18 Q16,13 24,18" fill="none" stroke="#8B4513" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" opacity="0.5"/></svg>',
            'blackcurrant_jam':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0828"/><rect x="8" y="10" width="16" height="16" rx="2" fill="#1a0030" stroke="#4a1a60" stroke-width="1"/><rect x="8" y="6" width="16" height="6" rx="2" fill="#6600aa"/><rect x="8" y="6" width="16" height="4" rx="2" fill="#8822cc"/><rect x="6" y="8" width="20" height="4" rx="1" fill="#550088"/><circle cx="14" cy="17" r="2" fill="#aa44ee" opacity="0.6"/><circle cx="18" cy="20" r="1.5" fill="#882299" opacity="0.5"/><circle cx="12" cy="21" r="1.5" fill="#9933bb" opacity="0.5"/></svg>',
            'strawberry_jam':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a0808"/><rect x="8" y="10" width="16" height="16" rx="2" fill="#2a0008" stroke="#7a1020" stroke-width="1"/><rect x="8" y="6" width="16" height="6" rx="2" fill="#cc1122"/><rect x="8" y="6" width="16" height="4" rx="2" fill="#ee2233"/><rect x="6" y="8" width="20" height="4" rx="1" fill="#aa0011"/><circle cx="14" cy="17" r="2" fill="#ff3344" opacity="0.6"/><circle cx="18" cy="20" r="1.5" fill="#dd1122" opacity="0.5"/></svg>',
            'toast_jam':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1205"/><rect x="5" y="7" width="22" height="20" rx="2" fill="#D2691E" stroke="#8B4513" stroke-width="1"/><rect x="5" y="7" width="22" height="6" rx="2" fill="#DAA520"/><rect x="7" y="13" width="18" height="12" rx="1" fill="#cc2244" opacity="0.8"/><rect x="7" y="13" width="18" height="3" rx="1" fill="#ee3355" opacity="0.6"/><circle cx="11" cy="19" r="1.5" fill="#ff4466" opacity="0.5"/><circle cx="17" cy="21" r="1" fill="#dd1133" opacity="0.5"/></svg>',
            'ham_sandwich':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1205"/><rect x="4" y="20" width="24" height="8" rx="3" fill="#D2691E" stroke="#8B4513" stroke-width="1"/><rect x="4" y="15" width="24" height="6" rx="0" fill="#F4A460"/><rect x="4" y="12" width="24" height="4" rx="0" fill="#cc4422"/><rect x="4" y="9" width="24" height="4" rx="0" fill="#88cc44"/><rect x="4" y="6" width="24" height="4" rx="0" fill="#F4A460"/><rect x="4" y="4" width="24" height="3" rx="3" fill="#D2691E"/><line x1="4" y1="8" x2="28" y2="8" stroke="#8B4513" stroke-width="0.5" stroke-linecap="round"/><line x1="4" y1="13" x2="28" y2="13" stroke="#8B4513" stroke-width="0.5" stroke-linecap="round"/><line x1="4" y1="16" x2="28" y2="16" stroke="#8B4513" stroke-width="0.5" stroke-linecap="round"/></svg>',
            'planter_box':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1005"/><rect x="4" y="16" width="24" height="12" rx="2" fill="#5a3010" stroke="#7a4a20" stroke-width="1"/><rect x="4" y="12" width="24" height="5" rx="1" fill="#7a4a20"/><rect x="6" y="17" width="20" height="9" rx="1" fill="#3a1a00" opacity="0.5"/><path d="M8,12 Q8,5 10,4 Q12,3 12,12" fill="none" stroke="#44aa44" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M14,12 Q13,4 16,3 Q19,4 18,12" fill="none" stroke="#55bb55" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M20,12 Q20,5 22,4 Q24,3 24,12" fill="none" stroke="#44aa44" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
            'large_planter':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1005"/><rect x="2" y="16" width="28" height="12" rx="2" fill="#5a3010" stroke="#7a4a20" stroke-width="1"/><rect x="2" y="12" width="28" height="5" rx="1" fill="#7a4a20"/><rect x="4" y="17" width="24" height="9" rx="1" fill="#3a1a00" opacity="0.5"/><path d="M6,12 Q6,4 8,3 Q10,2 10,12" fill="none" stroke="#44aa44" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M12,12 Q11,3 14,2 Q17,3 16,12" fill="none" stroke="#66cc44" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M18,12 Q17,3 20,2 Q23,3 22,12" fill="none" stroke="#55bb55" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M24,12 Q24,4 26,3 Q28,2 28,12" fill="none" stroke="#44aa44" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
            'pumpkin_seed':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1f1a00"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#CC8800" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#44aa22" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#44aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#44aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'wheat_seed':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1f1a00"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#D4A017" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#88aa22" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#88aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#88aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'cabbage_seed':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2010"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#6aaa22" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#44cc22" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#44cc22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#44cc22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'cucumber_seed':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2010"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#338822" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#55cc33" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#55cc33" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#55cc33" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'potato_seed':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1005"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#AA8844" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#667733" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#667733" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#667733" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'carrot_seed':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1005"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#DD6600" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#44aa22" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#44aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#44aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'hemp_seed':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2010"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#558833" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#77aa33" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#77aa33" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#77aa33" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'corn_seed':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1f1a00"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#DDaa00" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#88aa22" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#88aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#88aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'mushroom_seed':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0d05"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#885522" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#AA7744" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#AA7744" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#AA7744" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'red_berry_seed':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a0808"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#cc2244" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#44aa22" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#44aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#44aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'black_berry_seed':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0828"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#440066" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#2a6622" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#2a6622" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#2a6622" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'strawberry_seed':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a0808"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#cc2233" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#44bb22" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#44bb22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#44bb22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'tomato_seed':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a0808"/><ellipse cx="16" cy="18" rx="6" ry="5" fill="#cc3311" stroke="#8B6914" stroke-width="0.5"/><ellipse cx="16" cy="16" rx="4" ry="3" fill="#44aa22" opacity="0.7"/><path d="M16,13 Q14,8 12,6" fill="none" stroke="#44aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,13 Q18,8 20,6" fill="none" stroke="#44aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="18" r="1" fill="#8B6914" opacity="0.7"/></svg>',
            'pumpkin':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1f1a00"/><ellipse cx="16" cy="18" rx="11" ry="9" fill="#cc6600" stroke="#ee8800" stroke-width="1"/><ellipse cx="12" cy="17" rx="4" ry="7" fill="#DD7700" opacity="0.8"/><ellipse cx="16" cy="17" rx="4" ry="8" fill="#FF8800" opacity="0.9"/><ellipse cx="20" cy="17" rx="4" ry="7" fill="#DD7700" opacity="0.8"/><path d="M16,9 Q15,5 14,4" fill="none" stroke="#338833" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,9 Q18,6 19,5 Q17,4 16,5" fill="none" stroke="#44aa44" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><ellipse cx="16" cy="26" rx="8" ry="3" fill="#995500" opacity="0.4"/></svg>',
            'wheat':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1f1a00"/><path d="M16,28 L16,8" fill="none" stroke="#8B8000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><ellipse cx="14" cy="8" rx="2" ry="4" fill="#D4A017"/><ellipse cx="18" cy="10" rx="2" ry="4" fill="#D4A017"/><ellipse cx="14" cy="13" rx="2" ry="4" fill="#D4A017"/><ellipse cx="18" cy="15" rx="2" ry="4" fill="#D4A017"/><ellipse cx="14" cy="18" rx="2" ry="4" fill="#CCAA00"/><ellipse cx="18" cy="20" rx="2" ry="4" fill="#CCAA00"/><path d="M12,4 Q14,2 16,4 Q18,2 20,4" fill="none" stroke="#ccaa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
            'cabbage':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2010"/><circle cx="16" cy="17" r="12" fill="#2a6a1a" stroke="#44aa22" stroke-width="1"/><circle cx="16" cy="17" r="9" fill="#44aa22"/><circle cx="16" cy="17" r="6" fill="#66cc33"/><path d="M10,14 Q16,10 22,14" fill="none" stroke="#88dd44" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" opacity="0.6"/><path d="M9,18 Q16,15 23,18" fill="none" stroke="#88dd44" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" opacity="0.5"/></svg>',
            'cucumber':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2010"/><ellipse cx="16" cy="16" rx="5" ry="13" fill="#3a8822" stroke="#55aa33" stroke-width="1"/><ellipse cx="16" cy="16" rx="4" ry="11" fill="#55bb33"/><line x1="13" y1="10" x2="19" y2="10" stroke="#44aa22" stroke-width="1" stroke-linecap="round"/><line x1="13" y1="13" x2="19" y2="13" stroke="#44aa22" stroke-width="1" stroke-linecap="round"/><line x1="13" y1="16" x2="19" y2="16" stroke="#44aa22" stroke-width="1" stroke-linecap="round"/><line x1="13" y1="19" x2="19" y2="19" stroke="#44aa22" stroke-width="1" stroke-linecap="round"/><ellipse cx="16" cy="5" rx="2" ry="3" fill="#338822"/><circle cx="16" cy="4" r="1" fill="#666"/></svg>',
            'potato':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1005"/><ellipse cx="16" cy="17" rx="11" ry="9" fill="#8B7355" stroke="#AA9977" stroke-width="1"/><ellipse cx="16" cy="16" rx="9" ry="7" fill="#AA9977"/><circle cx="11" cy="14" r="1.5" fill="#776644" opacity="0.7"/><circle cx="20" cy="16" r="1" fill="#776644" opacity="0.6"/><circle cx="14" cy="20" r="1" fill="#776644" opacity="0.5"/><circle cx="18" cy="13" r="1" fill="#887766" opacity="0.4"/></svg>',
            'carrot':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1005"/><path d="M16,6 Q10,10 12,24 Q14,28 16,28 Q18,28 20,24 Q22,10 16,6Z" fill="#DD6600" stroke="#FF8822" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/><path d="M12,14 Q16,12 20,14" fill="none" stroke="#CC5500" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" opacity="0.5"/><path d="M11,18 Q16,16 21,18" fill="none" stroke="#CC5500" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" opacity="0.4"/><path d="M14,6 Q12,2 10,2" fill="none" stroke="#44aa44" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,5 Q16,2 16,1" fill="none" stroke="#55bb44" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M18,6 Q20,2 22,2" fill="none" stroke="#44aa44" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
            'hemp_fiber':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2010"/><path d="M8,28 Q10,18 12,10 Q14,5 16,4" fill="none" stroke="#5a9a22" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M12,28 Q14,18 15,12 Q16,7 17,4" fill="none" stroke="#66aa33" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M18,28 Q18,18 18,12 Q18,7 18,4" fill="none" stroke="#5a9a22" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M22,28 Q22,18 21,12 Q20,7 19,4" fill="none" stroke="#447722" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M10,16 Q16,13 22,16" fill="none" stroke="#88cc44" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" opacity="0.6"/><path d="M9,20 Q16,17 23,20" fill="none" stroke="#77bb33" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" opacity="0.5"/></svg>',
            'corn':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1f1a00"/><ellipse cx="16" cy="17" rx="7" ry="12" fill="#8B6914" stroke="#AA8822" stroke-width="1"/><ellipse cx="16" cy="17" rx="5" ry="10" fill="#D4A017"/><circle cx="13" cy="13" r="1" fill="#FFD700"/><circle cx="15" cy="12" r="1" fill="#FFD700"/><circle cx="17" cy="12" r="1" fill="#FFD700"/><circle cx="19" cy="13" r="1" fill="#FFD700"/><circle cx="12" cy="16" r="1" fill="#FFD700"/><circle cx="14" cy="15" r="1" fill="#FFD700"/><circle cx="16" cy="14" r="1" fill="#FFD700"/><circle cx="18" cy="15" r="1" fill="#FFD700"/><circle cx="20" cy="16" r="1" fill="#FFD700"/><circle cx="13" cy="19" r="1" fill="#FFD700"/><circle cx="15" cy="18" r="1" fill="#FFD700"/><circle cx="17" cy="18" r="1" fill="#FFD700"/><circle cx="19" cy="19" r="1" fill="#FFD700"/><circle cx="14" cy="22" r="1" fill="#DDaa00"/><circle cx="16" cy="22" r="1" fill="#FFD700"/><circle cx="18" cy="22" r="1" fill="#DDaa00"/><path d="M21,8 Q24,4 22,2" fill="none" stroke="#44aa22" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M19,10 Q22,6 20,4" fill="none" stroke="#66cc33" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
            'mushroom_crop':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0d05"/><ellipse cx="16" cy="14" rx="12" ry="9" fill="#8B4513" stroke="#AA6633" stroke-width="1"/><ellipse cx="16" cy="13" rx="10" ry="7" fill="#A0522D"/><circle cx="11" cy="12" r="2" fill="#FFE4C4" opacity="0.8"/><circle cx="19" cy="11" r="1.5" fill="#FFE4C4" opacity="0.7"/><circle cx="15" cy="14" r="1" fill="#FFE4C4" opacity="0.6"/><rect x="13" y="20" width="6" height="9" rx="1" fill="#F5DEB3"/><line x1="13" y1="22" x2="19" y2="22" stroke="#DDD" stroke-width="0.5" stroke-linecap="round"/><line x1="13" y1="24" x2="19" y2="24" stroke="#DDD" stroke-width="0.5" stroke-linecap="round"/></svg>',
            'red_berries':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a0808"/><circle cx="10" cy="18" r="4" fill="#cc2222" stroke="#ee3333" stroke-width="0.5"/><circle cx="17" cy="16" r="4" fill="#dd1133"/><circle cx="22" cy="19" r="4" fill="#cc2244"/><circle cx="13" cy="14" r="3" fill="#ee2233"/><circle cx="20" cy="13" r="3" fill="#dd1122"/><path d="M10,14 Q12,10 14,12" fill="none" stroke="#44aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M17,12 Q18,8 20,10" fill="none" stroke="#44aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="10" cy="18" r="2" fill="#ff4444" opacity="0.4"/><circle cx="17" cy="16" r="2" fill="#ff3355" opacity="0.3"/></svg>',
            'black_berries':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0828"/><circle cx="10" cy="18" r="4" fill="#2a0044" stroke="#5511aa" stroke-width="0.5"/><circle cx="17" cy="16" r="4" fill="#1a0033"/><circle cx="22" cy="19" r="4" fill="#330055"/><circle cx="13" cy="14" r="3" fill="#440066"/><circle cx="20" cy="13" r="3" fill="#2a0044"/><path d="M10,14 Q12,10 14,12" fill="none" stroke="#44aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M17,12 Q18,8 20,10" fill="none" stroke="#44aa22" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="10" cy="18" r="2" fill="#8844cc" opacity="0.4"/><circle cx="17" cy="16" r="2" fill="#6622aa" opacity="0.3"/></svg>',
            'strawberry':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a0808"/><path d="M16,28 Q8,22 8,15 Q8,7 16,7 Q24,7 24,15 Q24,22 16,28Z" fill="#cc1133" stroke="#ee2244" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/><circle cx="12" cy="14" r="1" fill="#FFE4E1" opacity="0.6"/><circle cx="18" cy="12" r="1" fill="#FFE4E1" opacity="0.5"/><circle cx="20" cy="17" r="1" fill="#FFE4E1" opacity="0.5"/><circle cx="13" cy="19" r="1" fill="#FFE4E1" opacity="0.4"/><path d="M14,7 Q13,3 12,2" fill="none" stroke="#44aa22" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,6 Q16,3 16,2" fill="none" stroke="#55bb33" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M18,7 Q19,3 20,2" fill="none" stroke="#44aa22" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
            'tomato':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a0808"/><circle cx="16" cy="18" r="11" fill="#cc2211" stroke="#ee3322" stroke-width="1"/><circle cx="16" cy="17" r="9" fill="#dd3322"/><ellipse cx="14" cy="14" rx="3" ry="2" fill="#ff5533" opacity="0.4"/><path d="M13,7 Q14,4 16,3 Q18,4 19,7" fill="none" stroke="#44aa22" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,7 Q15,4 14,3" fill="none" stroke="#55bb33" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M16,7 Q17,4 18,3" fill="none" stroke="#55bb33" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><circle cx="16" cy="26" r="4" fill="#aa1100" opacity="0.3"/></svg>',
            'floor_rug_red':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#200808"/><rect x="2" y="2" width="28" height="28" rx="2" fill="#aa0000"/><rect x="4" y="4" width="24" height="24" rx="1" fill="#cc2222"/><rect x="7" y="7" width="18" height="18" rx="1" fill="#aa0000"/><rect x="10" y="10" width="12" height="12" rx="1" fill="#ee4444" opacity="0.7"/><polygon points="16,11 21,16 16,21 11,16" fill="#cc2222" stroke="#aa0000" stroke-width="0.5"/></svg>',
            'floor_rug_blue':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#080820"/><rect x="2" y="2" width="28" height="28" rx="2" fill="#001188"/><rect x="4" y="4" width="24" height="24" rx="1" fill="#2244cc"/><rect x="7" y="7" width="18" height="18" rx="1" fill="#001188"/><rect x="10" y="10" width="12" height="12" rx="1" fill="#4466ee" opacity="0.7"/><polygon points="16,11 21,16 16,21 11,16" fill="#2244cc" stroke="#001188" stroke-width="0.5"/></svg>',
            'floor_rug_green':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#081808"/><rect x="2" y="2" width="28" height="28" rx="2" fill="#006600"/><rect x="4" y="4" width="24" height="24" rx="1" fill="#228822"/><rect x="7" y="7" width="18" height="18" rx="1" fill="#006600"/><rect x="10" y="10" width="12" height="12" rx="1" fill="#44aa44" opacity="0.7"/><polygon points="16,11 21,16 16,21 11,16" fill="#228822" stroke="#006600" stroke-width="0.5"/></svg>',
            'curtain_red':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0808"/><path d="M4,5 Q8,12 5,20 Q7,25 5,30" fill="none" stroke="#cc2222" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M9,5 Q13,14 10,22 Q12,27 10,30" fill="none" stroke="#ee4444" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M18,5 Q22,12 19,20 Q21,25 19,30" fill="none" stroke="#ee4444" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M23,5 Q27,14 24,22 Q26,27 24,30" fill="none" stroke="#cc2222" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><rect x="2" y="2" width="28" height="3" rx="1" fill="#880000"/><circle cx="7" cy="3" r="2" fill="#880000"/><circle cx="13" cy="3" r="2" fill="#880000"/><circle cx="19" cy="3" r="2" fill="#880000"/><circle cx="25" cy="3" r="2" fill="#880000"/></svg>',
            'curtain_blue':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#08081a"/><path d="M4,5 Q8,12 5,20 Q7,25 5,30" fill="none" stroke="#2244cc" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M9,5 Q13,14 10,22 Q12,27 10,30" fill="none" stroke="#4466ee" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M18,5 Q22,12 19,20 Q21,25 19,30" fill="none" stroke="#4466ee" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M23,5 Q27,14 24,22 Q26,27 24,30" fill="none" stroke="#2244cc" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><rect x="2" y="2" width="28" height="3" rx="1" fill="#001188"/><circle cx="7" cy="3" r="2" fill="#001188"/><circle cx="13" cy="3" r="2" fill="#001188"/><circle cx="19" cy="3" r="2" fill="#001188"/><circle cx="25" cy="3" r="2" fill="#001188"/></svg>',
            'curtain_green':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#081808"/><path d="M4,5 Q8,12 5,20 Q7,25 5,30" fill="none" stroke="#228822" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M9,5 Q13,14 10,22 Q12,27 10,30" fill="none" stroke="#44aa44" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M18,5 Q22,12 19,20 Q21,25 19,30" fill="none" stroke="#44aa44" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M23,5 Q27,14 24,22 Q26,27 24,30" fill="none" stroke="#228822" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><rect x="2" y="2" width="28" height="3" rx="1" fill="#005500"/><circle cx="7" cy="3" r="2" fill="#005500"/><circle cx="13" cy="3" r="2" fill="#005500"/><circle cx="19" cy="3" r="2" fill="#005500"/><circle cx="25" cy="3" r="2" fill="#005500"/></svg>',
            'curtain_white':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1a1a"/><path d="M4,5 Q8,12 5,20 Q7,25 5,30" fill="none" stroke="#dddddd" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M9,5 Q13,14 10,22 Q12,27 10,30" fill="none" stroke="#ffffff" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M18,5 Q22,12 19,20 Q21,25 19,30" fill="none" stroke="#ffffff" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M23,5 Q27,14 24,22 Q26,27 24,30" fill="none" stroke="#dddddd" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><rect x="2" y="2" width="28" height="3" rx="1" fill="#aaaaaa"/><circle cx="7" cy="3" r="2" fill="#aaaaaa"/><circle cx="13" cy="3" r="2" fill="#aaaaaa"/><circle cx="19" cy="3" r="2" fill="#aaaaaa"/><circle cx="25" cy="3" r="2" fill="#aaaaaa"/></svg>',
            'curtain_beige':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#15100a"/><path d="M4,5 Q8,12 5,20 Q7,25 5,30" fill="none" stroke="#ccaa77" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M9,5 Q13,14 10,22 Q12,27 10,30" fill="none" stroke="#ddbb88" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M18,5 Q22,12 19,20 Q21,25 19,30" fill="none" stroke="#ddbb88" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><path d="M23,5 Q27,14 24,22 Q26,27 24,30" fill="none" stroke="#ccaa77" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/><rect x="2" y="2" width="28" height="3" rx="1" fill="#997744"/><circle cx="7" cy="3" r="2" fill="#997744"/><circle cx="13" cy="3" r="2" fill="#997744"/><circle cx="19" cy="3" r="2" fill="#997744"/><circle cx="25" cy="3" r="2" fill="#997744"/></svg>',
            'iron_helmet':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e2a38"/><path d="M6,20 Q6,6 16,5 Q26,6 26,20 Z" fill="#8AABB8"/><path d="M10,18 Q10,10 16,9 Q22,10 22,18 Z" fill="#AABFCC" opacity="0.4"/><rect x="5" y="19" width="22" height="4" rx="1" fill="#5A8090"/><rect x="9" y="13" width="14" height="5" rx="2" fill="#2255AA"/><rect x="10" y="14" width="5" height="2" rx="1" fill="#88BBFF" opacity="0.6"/><rect x="5" y="21" width="5" height="6" rx="1" fill="#5A8090"/><rect x="22" y="21" width="5" height="6" rx="1" fill="#5A8090"/></svg>',
            'iron_vest':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e2a38"/><rect x="3" y="6" width="8" height="8" rx="2" fill="#5A8090"/><rect x="21" y="6" width="8" height="8" rx="2" fill="#5A8090"/><rect x="5" y="8" width="22" height="20" rx="2" fill="#8AABB8"/><rect x="10" y="10" width="12" height="10" rx="2" fill="#AABFCC" opacity="0.6"/><path d="M12,8 L16,12 L20,8 Z" fill="#5A8090"/><rect x="6" y="19" width="20" height="2" rx="0" fill="#5A8090"/><rect x="6" y="22" width="20" height="2" rx="0" fill="#5A8090"/></svg>',
            'iron_gloves':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e2a38"/><rect x="5" y="5" width="2" height="8" rx="1" fill="#8AABB8"/><rect x="8" y="4" width="2" height="9" rx="1" fill="#8AABB8"/><rect x="11" y="5" width="2" height="8" rx="1" fill="#8AABB8"/><rect x="19" y="5" width="2" height="8" rx="1" fill="#8AABB8"/><rect x="22" y="4" width="2" height="9" rx="1" fill="#8AABB8"/><rect x="25" y="5" width="2" height="8" rx="1" fill="#8AABB8"/><rect x="4" y="10" width="10" height="16" rx="2" fill="#8AABB8"/><rect x="18" y="10" width="10" height="16" rx="2" fill="#8AABB8"/><rect x="4" y="10" width="10" height="3" rx="1" fill="#5A8090"/><rect x="18" y="10" width="10" height="3" rx="1" fill="#5A8090"/><rect x="4" y="13" width="10" height="2" rx="0" fill="#AABFCC" opacity="0.3"/><rect x="18" y="13" width="10" height="2" rx="0" fill="#AABFCC" opacity="0.3"/></svg>',
            'iron_pants':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e2a38"/><rect x="5" y="4" width="22" height="6" rx="2" fill="#5A8090"/><rect x="5" y="10" width="10" height="18" rx="2" fill="#8AABB8"/><rect x="17" y="10" width="10" height="18" rx="2" fill="#8AABB8"/><rect x="5" y="16" width="10" height="4" rx="1" fill="#AABFCC" opacity="0.5"/><rect x="17" y="16" width="10" height="4" rx="1" fill="#AABFCC" opacity="0.5"/><rect x="5" y="14" width="10" height="1" rx="0" fill="#5A8090"/><rect x="17" y="14" width="10" height="1" rx="0" fill="#5A8090"/></svg>',
            'iron_boots':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1e2a38"/><rect x="4" y="4" width="10" height="16" rx="2" fill="#8AABB8"/><rect x="18" y="4" width="10" height="16" rx="2" fill="#8AABB8"/><rect x="3" y="18" width="12" height="10" rx="2" fill="#8AABB8"/><rect x="17" y="18" width="12" height="10" rx="2" fill="#8AABB8"/><rect x="3" y="22" width="12" height="6" rx="2" fill="#5A8090"/><rect x="17" y="22" width="12" height="6" rx="2" fill="#5A8090"/><rect x="4" y="6" width="10" height="4" rx="1" fill="#AABFCC" opacity="0.4"/><rect x="18" y="6" width="10" height="4" rx="1" fill="#AABFCC" opacity="0.4"/><line x1="7" y1="8" x2="11" y2="8" stroke="#5A8090" stroke-width="1.5" stroke-linecap="round"/><line x1="21" y1="8" x2="25" y2="8" stroke="#5A8090" stroke-width="1.5" stroke-linecap="round"/></svg>',
            'cloth_helmet':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a2010"/><path d="M6,20 Q6,6 16,5 Q26,6 26,20 Z" fill="#C8A96E"/><path d="M10,18 Q10,10 16,9 Q22,10 22,18 Z" fill="#E2C98A" opacity="0.4"/><rect x="5" y="19" width="22" height="4" rx="1" fill="#A07840"/><rect x="9" y="13" width="14" height="5" rx="2" fill="#8B6030"/><rect x="10" y="14" width="5" height="2" rx="1" fill="#F0D898" opacity="0.6"/><rect x="5" y="21" width="5" height="6" rx="1" fill="#A07840"/><rect x="22" y="21" width="5" height="6" rx="1" fill="#A07840"/></svg>',
            'cloth_vest':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a2010"/><rect x="3" y="6" width="8" height="8" rx="2" fill="#A07840"/><rect x="21" y="6" width="8" height="8" rx="2" fill="#A07840"/><rect x="5" y="8" width="22" height="20" rx="2" fill="#C8A96E"/><rect x="10" y="10" width="12" height="10" rx="2" fill="#E2C98A" opacity="0.6"/><path d="M12,8 L16,12 L20,8 Z" fill="#A07840"/><rect x="6" y="19" width="20" height="2" rx="0" fill="#A07840"/><rect x="6" y="22" width="20" height="2" rx="0" fill="#A07840"/></svg>',
            'cloth_gloves':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a2010"/><rect x="5" y="5" width="2" height="8" rx="1" fill="#C8A96E"/><rect x="8" y="4" width="2" height="9" rx="1" fill="#C8A96E"/><rect x="11" y="5" width="2" height="8" rx="1" fill="#C8A96E"/><rect x="19" y="5" width="2" height="8" rx="1" fill="#C8A96E"/><rect x="22" y="4" width="2" height="9" rx="1" fill="#C8A96E"/><rect x="25" y="5" width="2" height="8" rx="1" fill="#C8A96E"/><rect x="4" y="10" width="10" height="16" rx="2" fill="#C8A96E"/><rect x="18" y="10" width="10" height="16" rx="2" fill="#C8A96E"/><rect x="4" y="10" width="10" height="3" rx="1" fill="#A07840"/><rect x="18" y="10" width="10" height="3" rx="1" fill="#A07840"/><rect x="4" y="13" width="10" height="2" rx="0" fill="#E2C98A" opacity="0.3"/><rect x="18" y="13" width="10" height="2" rx="0" fill="#E2C98A" opacity="0.3"/></svg>',
            'cloth_pants':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a2010"/><rect x="5" y="4" width="22" height="6" rx="2" fill="#A07840"/><rect x="5" y="10" width="10" height="18" rx="2" fill="#C8A96E"/><rect x="17" y="10" width="10" height="18" rx="2" fill="#C8A96E"/><rect x="5" y="16" width="10" height="4" rx="1" fill="#E2C98A" opacity="0.5"/><rect x="17" y="16" width="10" height="4" rx="1" fill="#E2C98A" opacity="0.5"/><rect x="5" y="14" width="10" height="1" rx="0" fill="#A07840"/><rect x="17" y="14" width="10" height="1" rx="0" fill="#A07840"/></svg>',
            'cloth_boots':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a2010"/><rect x="4" y="4" width="10" height="16" rx="2" fill="#C8A96E"/><rect x="18" y="4" width="10" height="16" rx="2" fill="#C8A96E"/><rect x="3" y="18" width="12" height="10" rx="2" fill="#C8A96E"/><rect x="17" y="18" width="12" height="10" rx="2" fill="#C8A96E"/><rect x="3" y="22" width="12" height="6" rx="2" fill="#A07840"/><rect x="17" y="22" width="12" height="6" rx="2" fill="#A07840"/><rect x="4" y="6" width="10" height="4" rx="1" fill="#E2C98A" opacity="0.4"/><rect x="18" y="6" width="10" height="4" rx="1" fill="#E2C98A" opacity="0.4"/><line x1="7" y1="8" x2="11" y2="8" stroke="#A07840" stroke-width="1.5" stroke-linecap="round"/><line x1="21" y1="8" x2="25" y2="8" stroke="#A07840" stroke-width="1.5" stroke-linecap="round"/></svg>',
            'bronze_helmet':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a1800"/><path d="M6,20 Q6,6 16,5 Q26,6 26,20 Z" fill="#CD7F32"/><path d="M10,18 Q10,10 16,9 Q22,10 22,18 Z" fill="#E8A050" opacity="0.4"/><rect x="5" y="19" width="22" height="4" rx="1" fill="#995500"/><rect x="9" y="13" width="14" height="5" rx="2" fill="#884400"/><rect x="10" y="14" width="5" height="2" rx="1" fill="#88BBFF" opacity="0.6"/><rect x="5" y="21" width="5" height="6" rx="1" fill="#995500"/><rect x="22" y="21" width="5" height="6" rx="1" fill="#995500"/></svg>',
            'bronze_vest':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a1800"/><rect x="3" y="6" width="8" height="8" rx="2" fill="#995500"/><rect x="21" y="6" width="8" height="8" rx="2" fill="#995500"/><rect x="5" y="8" width="22" height="20" rx="2" fill="#CD7F32"/><rect x="10" y="10" width="12" height="10" rx="2" fill="#E8A050" opacity="0.6"/><path d="M12,8 L16,12 L20,8 Z" fill="#995500"/><rect x="6" y="19" width="20" height="2" rx="0" fill="#995500"/><rect x="6" y="22" width="20" height="2" rx="0" fill="#995500"/></svg>',
            'bronze_gloves':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a1800"/><rect x="5" y="5" width="2" height="8" rx="1" fill="#CD7F32"/><rect x="8" y="4" width="2" height="9" rx="1" fill="#CD7F32"/><rect x="11" y="5" width="2" height="8" rx="1" fill="#CD7F32"/><rect x="19" y="5" width="2" height="8" rx="1" fill="#CD7F32"/><rect x="22" y="4" width="2" height="9" rx="1" fill="#CD7F32"/><rect x="25" y="5" width="2" height="8" rx="1" fill="#CD7F32"/><rect x="4" y="10" width="10" height="16" rx="2" fill="#CD7F32"/><rect x="18" y="10" width="10" height="16" rx="2" fill="#CD7F32"/><rect x="4" y="10" width="10" height="3" rx="1" fill="#995500"/><rect x="18" y="10" width="10" height="3" rx="1" fill="#995500"/><rect x="4" y="13" width="10" height="2" rx="0" fill="#E8A050" opacity="0.3"/><rect x="18" y="13" width="10" height="2" rx="0" fill="#E8A050" opacity="0.3"/></svg>',
            'bronze_pants':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a1800"/><rect x="5" y="4" width="22" height="6" rx="2" fill="#995500"/><rect x="5" y="10" width="10" height="18" rx="2" fill="#CD7F32"/><rect x="17" y="10" width="10" height="18" rx="2" fill="#CD7F32"/><rect x="5" y="16" width="10" height="4" rx="1" fill="#E8A050" opacity="0.5"/><rect x="17" y="16" width="10" height="4" rx="1" fill="#E8A050" opacity="0.5"/><rect x="5" y="14" width="10" height="1" rx="0" fill="#995500"/><rect x="17" y="14" width="10" height="1" rx="0" fill="#995500"/></svg>',
            'bronze_boots':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#2a1800"/><rect x="4" y="4" width="10" height="16" rx="2" fill="#CD7F32"/><rect x="18" y="4" width="10" height="16" rx="2" fill="#CD7F32"/><rect x="3" y="18" width="12" height="10" rx="2" fill="#CD7F32"/><rect x="17" y="18" width="12" height="10" rx="2" fill="#CD7F32"/><rect x="3" y="22" width="12" height="6" rx="2" fill="#995500"/><rect x="17" y="22" width="12" height="6" rx="2" fill="#995500"/><rect x="4" y="6" width="10" height="4" rx="1" fill="#E8A050" opacity="0.4"/><rect x="18" y="6" width="10" height="4" rx="1" fill="#E8A050" opacity="0.4"/><line x1="7" y1="8" x2="11" y2="8" stroke="#995500" stroke-width="1.5" stroke-linecap="round"/><line x1="21" y1="8" x2="25" y2="8" stroke="#995500" stroke-width="1.5" stroke-linecap="round"/></svg>',
            'thermal_hood':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2233"/><path d="M6,20 Q6,5 16,4 Q26,5 26,20 Z" fill="#1a6b8a"/><rect x="5" y="19" width="22" height="5" rx="2" fill="#1a6b8a"/><rect x="5" y="21" width="5" height="7" rx="2" fill="#1a6b8a"/><rect x="22" y="21" width="5" height="7" rx="2" fill="#1a6b8a"/><rect x="9" y="12" width="14" height="6" rx="2" fill="#0d2233"/><path d="M8,8 Q16,6 24,8" stroke="#4ecdc4" stroke-width="1" fill="none" opacity="0.6"/></svg>',
            'thermal_jacket':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2233"/><rect x="3" y="6" width="8" height="9" rx="2" fill="#1a6b8a"/><rect x="21" y="6" width="8" height="9" rx="2" fill="#1a6b8a"/><rect x="5" y="8" width="22" height="21" rx="2" fill="#1a6b8a"/><path d="M12,8 L16,13 L20,8 Z" fill="#0d2233"/><line x1="16" y1="13" x2="16" y2="29" stroke="#0d2233" stroke-width="1.5"/><circle cx="16" cy="17" r="1" fill="#4ecdc4"/><circle cx="16" cy="22" r="1" fill="#4ecdc4"/></svg>',
            'thermal_gloves':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2233"/><rect x="5" y="4" width="2" height="9" rx="1" fill="#1a6b8a"/><rect x="8" y="3" width="2" height="10" rx="1" fill="#1a6b8a"/><rect x="11" y="4" width="2" height="9" rx="1" fill="#1a6b8a"/><rect x="4" y="11" width="10" height="17" rx="2" fill="#1a6b8a"/><rect x="19" y="4" width="2" height="9" rx="1" fill="#1a6b8a"/><rect x="22" y="3" width="2" height="10" rx="1" fill="#1a6b8a"/><rect x="25" y="4" width="2" height="9" rx="1" fill="#1a6b8a"/><rect x="18" y="11" width="10" height="17" rx="2" fill="#1a6b8a"/><rect x="4" y="20" width="10" height="3" rx="1" fill="#4ecdc4" opacity="0.4"/><rect x="18" y="20" width="10" height="3" rx="1" fill="#4ecdc4" opacity="0.4"/></svg>',
            'thermal_pants':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2233"/><rect x="5" y="4" width="22" height="7" rx="2" fill="#1a6b8a"/><rect x="5" y="10" width="10" height="18" rx="2" fill="#1a6b8a"/><rect x="17" y="10" width="10" height="18" rx="2" fill="#1a6b8a"/><rect x="5" y="14" width="10" height="3" rx="1" fill="#4ecdc4" opacity="0.3"/><rect x="17" y="14" width="10" height="3" rx="1" fill="#4ecdc4" opacity="0.3"/></svg>',
            'thermal_boots':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0d2233"/><rect x="4" y="4" width="10" height="16" rx="2" fill="#1a6b8a"/><rect x="18" y="4" width="10" height="16" rx="2" fill="#1a6b8a"/><rect x="3" y="18" width="12" height="10" rx="2" fill="#1a6b8a"/><rect x="17" y="18" width="12" height="10" rx="2" fill="#1a6b8a"/><rect x="3" y="22" width="12" height="6" rx="2" fill="#0f4d63"/><rect x="17" y="22" width="12" height="6" rx="2" fill="#0f4d63"/><line x1="7" y1="8" x2="11" y2="8" stroke="#4ecdc4" stroke-width="1.5" stroke-linecap="round"/><line x1="21" y1="8" x2="25" y2="8" stroke="#4ecdc4" stroke-width="1.5" stroke-linecap="round"/></svg>',
            'fishing_rod':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a2233"/><line x1="6" y1="26" x2="26" y2="6" stroke="#8B6914" stroke-width="3" stroke-linecap="round"/><line x1="26" y1="6" x2="22" y2="22" stroke="#aaddff" stroke-width="1" stroke-dasharray="2,2" opacity="0.8"/><circle cx="22" cy="22" r="2.5" fill="#aaddff" stroke="#5599cc" stroke-width="1"/><circle cx="8" cy="24" r="2" fill="#444" stroke="#666" stroke-width="1"/></svg>',
            'raw_fish':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#0a1a2e"/><path d="M5,16 Q10,10 18,12 Q22,13 26,16 Q22,19 18,20 Q10,22 5,16 Z" fill="#6ab4d4"/><path d="M26,16 L30,12 L30,20 Z" fill="#6ab4d4"/><circle cx="8" cy="15" r="1.2" fill="#000"/><line x1="13" y1="11.5" x2="14" y2="20" stroke="#4a90b8" stroke-width="0.8" opacity="0.7"/><line x1="17" y1="11.5" x2="18" y2="20.5" stroke="#4a90b8" stroke-width="0.8" opacity="0.7"/></svg>',
            'cooked_fish':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a1000"/><path d="M5,16 Q10,10 18,12 Q22,13 26,16 Q22,19 18,20 Q10,22 5,16 Z" fill="#c87941"/><path d="M26,16 L30,12 L30,20 Z" fill="#c87941"/><circle cx="8" cy="15" r="1.2" fill="#000"/><line x1="13" y1="11.5" x2="14" y2="20" stroke="#8B5020" stroke-width="0.8" opacity="0.9"/><line x1="17" y1="11.5" x2="18" y2="20.5" stroke="#8B5020" stroke-width="0.8" opacity="0.9"/><path d="M6,24 Q10,22 16,23 Q22,22 26,24" stroke="#ff6600" stroke-width="1.5" fill="none" opacity="0.5" stroke-linecap="round"/></svg>',
            'grilled_fish_stew':'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" style="width:100%;height:100%;display:block;"><rect width="32" height="32" rx="4" fill="#1a0f00"/><ellipse cx="16" cy="20" rx="12" ry="8" fill="#5b3010"/><ellipse cx="16" cy="18" rx="11" ry="6" fill="#8B5A1F"/><path d="M9,16 Q13,13 16,14 Q19,13 23,16" stroke="#c87941" stroke-width="2" fill="none" stroke-linecap="round"/><circle cx="16" cy="12" r="1.5" fill="#ff8844" opacity="0.8"/><path d="M14,10 Q16,8 18,10" stroke="#ff8844" stroke-width="1" fill="none" opacity="0.6"/></svg>',
        };

        // On startup, heal any corrupted icons using the fallback map.
        // A value is corrupted if it contains U+FFFD (the Unicode replacement char)
        // or is empty — both symptoms of a bad file save or encoding mismatch.
        (function sanitizeItemIcons() {
            let healed = 0;
            for (const key in itemIcons) {
                const val = itemIcons[key];
                if (!val || val.includes('\ufffd') || val.trim() === '') {
                    if (_iconFallbacks[key]) {
                        itemIcons[key] = _iconFallbacks[key];
                        healed++;
                    } else {
                        itemIcons[key] = '\u2753'; // ❓ — no fallback available
                        console.warn('\u26a0\ufe0f No fallback for corrupted icon: "' + key + '"');
                    }
                }
            }
            if (healed > 0) console.log('\ud83d\ude4c Healed ' + healed + ' corrupted icon(s) from fallback map');
        })();

        // Call this when adding new items to automatically add them to the admin menu
        function registerItem(itemId, icon, category = 'Other Items') {
            // Sanitize: if the icon is corrupted or empty, use fallback
            const safeIcon = (!icon || icon.includes('\ufffd') || icon.trim() === '') ? '\u2753' : icon;
            if (!itemIcons[itemId]) {
                itemIcons[itemId] = safeIcon;
                console.log(`\u2705 Registered new item: ${itemId} with icon ${safeIcon} in category ${category}`);
            } else {
                console.warn(`\u26a0\ufe0f Item ${itemId} already registered with icon ${itemIcons[itemId]}`);
            }
        }
        
        // Validation function - checks all items in game have icons
        function validateAllItemsHaveIcons() {
            const allItems = new Set();
            
            // Collect all items from all sources
            Object.keys(craftingRecipes).forEach(item => allItems.add(item));
            Object.keys(workbenchRecipes).forEach(item => allItems.add(item));
            Object.keys(buildingBenchRecipes).forEach(item => allItems.add(item));
            Object.keys(furnaceRecipes).forEach(item => allItems.add(item));
            Object.keys(buildingTypes).forEach(item => allItems.add(item));
            
            const missingIcons = [];
            allItems.forEach(item => {
                if (!itemIcons[item]) {
                    missingIcons.push(item);
                }
            });
            
            if (missingIcons.length > 0) {
                console.warn('\u26a0\ufe0f Items missing icons:', missingIcons);
                console.warn('Add icons using: registerItem("item_name", "\u2753", "Category Name")');
            } else {
                console.log('\u2705 All items have icons!');
            }
            
            return missingIcons;
        }
        
        // Track item positions in inventory slots
        const inventorySlots = new Array(18).fill(null);

        // ── BACKPACK SYSTEM ─────────────────────────────────────────────
        // Slots added by equipped backpack (12 small, 18 large)
        let backpackSlots = [];          // array of {item,count} or null
        let backpackSize  = 0;           // 0 = no backpack, 12 or 18

        function getBackpackExtraSlots() {
            if (armorSlots.back === 'small_backpack') return 12;
            if (armorSlots.back === 'large_backpack') return 18;
            return 0;
        }

        function isBackpackEmpty() {
            return backpackSlots.every(s => s === null);
        }

        // Call after equipping/unequipping a backpack to resize backpackSlots
        function syncBackpackSlots() {
            const needed = getBackpackExtraSlots();
            if (needed === backpackSize) return;
            if (needed > backpackSize) {
                // Grow
                while (backpackSlots.length < needed) backpackSlots.push(null);
            } else {
                // Shrink — only allowed when empty (enforced at unequip time)
                backpackSlots.length = needed;
            }
            backpackSize = needed;
        }
        // Per-slot count overrides for split stacks (null = use global inventory[item] total)
        const inventorySlotCounts = new Array(18).fill(null);

        // Helper: get the effective count displayed for a specific inventory slot
        function getInvSlotCount(slotIndex) {
            const name = inventorySlots[slotIndex];
            if (!name) return 0;
            return inventorySlotCounts[slotIndex] !== null ? inventorySlotCounts[slotIndex] : (inventory[name] || 0);
        }

        // Helper: clear all split-stack tracking for a given item name (consolidate on pickup)
        function clearSplitCounts(itemName) {
            for (let i = 0; i < inventorySlots.length; i++) {
                if (inventorySlots[i] === itemName) inventorySlotCounts[i] = null;
            }
        }
        
        // Box open/close sound
        let _boxAudioBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/box.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _boxAudioBuffer = buf; console.log('Box sound loaded OK'); })
            .catch(e => { console.error('Box sound fetch error:', e); });

        function playBoxSound() {
            if (!_boxAudioBuffer) { console.log('Box buffer not ready yet'); return; }
            const src = audioContext.createBufferSource();
            src.buffer = _boxAudioBuffer;
            const gain = audioContext.createGain();
            gain.gain.value = volumeSettings.sfx !== undefined ? volumeSettings.sfx : 1.0;
            src.connect(gain);
            gain.connect(audioContext.destination);
            src.start();
        }

        function openStorageBox(storageBox) {
            currentStorageBox = storageBox;
            playBoxSound();
            // Configure layout based on box type
            const isSmall = storageBox.userData.isSmallStorage;
            const panel = document.getElementById('storage-panel');
            const grid  = document.getElementById('storage-grid');
            const header = document.getElementById('storage-header');
            if (isSmall) {
                // 14 slots: 5 cols × 3 rows — no scroll needed at 500px
                panel.style.width = '500px';
                grid.style.gridTemplateColumns = 'repeat(5, 1fr)';
                header.querySelector('span').textContent = '📦 SMALL STORAGE';
            } else {
                // 26 slots: 6 cols × 5 rows (last row 2 slots) — no scroll at 560px
                panel.style.width = '560px';
                grid.style.gridTemplateColumns = 'repeat(6, 1fr)';
                header.querySelector('span').textContent = '📦 LARGE STORAGE';
            }
            // Open both storage and inventory
            panel.style.display = 'block';
            const _ip2 = document.getElementById('inventory-panel');
            positionInventoryRight(_ip2);
            _ip2.style.display = 'block';
            uiOpen();
            updateStorageDisplay();
            updateInventoryDisplay();
        }
        
        function closeStorageBox() {
            closeAllUI();
        }

        // ===== PLANTER BOX SYSTEM =====
        let currentPlanterBox = null;

        // Seeds are items whose name contains 'seed' — extensible as more are added
        function isSeedItem(itemName) {
            return itemName && itemName.toLowerCase().includes('seed');
        }

        function openPlanterBox(planterBox) {
            currentPlanterBox = planterBox;
            const slotCount = planterBox.userData.seeds.length;
            const isLarge = slotCount > 4;
            document.getElementById('planter-title').textContent = isLarge ? '🌿 Large Planter (12 Slots)' : '🌱 Planter Box (4 Slots)';
            const slotsEl = document.getElementById('planter-slots');
            slotsEl.style.gridTemplateColumns = isLarge ? 'repeat(4,1fr)' : 'repeat(4,1fr)';
            document.getElementById('planter-panel').style.display = 'block';
            uiOpen();
            updatePlanterDisplay();
        }

        function closePlanterBox() {
            closeAllUI();
        }

        function updatePlanterDisplay() {
            if (!currentPlanterBox) return;
            const seeds = currentPlanterBox.userData.seeds;
            const slotsEl = document.getElementById('planter-slots');
            slotsEl.innerHTML = '';

            seeds.forEach((seed, i) => {
                const slot = document.createElement('div');
                slot.style.cssText = `
                    background:rgba(0,0,0,0.45); border:2px solid rgba(100,200,80,0.3);
                    border-radius:10px; padding:10px 6px; text-align:center;
                    cursor:pointer; min-height:90px; display:flex; flex-direction:column;
                    align-items:center; justify-content:center; gap:5px;
                    transition:border-color 0.2s, background 0.15s;
                `;

                if (seed) {
                    const icon = itemIcons[seed.type] || '🌱';
                    const growPct = Math.min(100, Math.round((seed.waterCount / 4) * 100));
                    slot.innerHTML = `
                        <div style="font-size:22px">${icon}</div>
                        <div style="font-size:11px;color:rgba(255,255,255,0.8);word-break:break-word">${seed.type.replace(/_seed$/,'').replace(/_/g,' ')}</div>
                        <div style="font-size:10px;color:${seed.grown?'#7dff6a':'rgba(180,255,140,0.7)'}">
                            ${seed.grown ? '✅ Press E to harvest' : `💧 ${growPct}%`}
                        </div>
                        <div style="width:100%;height:5px;background:rgba(255,255,255,0.1);border-radius:3px;overflow:hidden">
                            <div style="height:100%;width:${growPct}%;background:linear-gradient(90deg,#4CAF50,#8BC34A);transition:width 0.3s"></div>
                        </div>
                    `;
                    slot.style.borderColor = seed.grown ? 'rgba(80,255,80,0.6)' : 'rgba(80,180,80,0.3)';
                    if (seed.grown) {
                        slot.addEventListener('click', () => harvestPlant(currentPlanterBox, i));
                        slot.title = `Click or press E to harvest ${seed.type.replace(/_seed$/,'').replace(/_/g,' ')}`;
                    } else {
                        slot.addEventListener('contextmenu', e => { e.preventDefault(); removeSeedFromPlanter(i); });
                        slot.title = `Slot ${i+1}: ${seed.type} — waters: ${seed.waterCount}/4 | Right-click to retrieve`;
                    }
                } else {
                    slot.innerHTML = `
                        <div style="font-size:24px;opacity:0.4">🌱</div>
                        <div style="font-size:11px;color:rgba(255,255,255,0.35)">Empty</div>
                        <div style="font-size:10px;color:rgba(255,255,255,0.25)">Click or drag seed here</div>
                    `;
                    slot.addEventListener('click', () => plantSeedInSlot(i));
                }

                // Drag-and-drop: accept seeds from inventory/hotbar
                slot.addEventListener('dragover', e => {
                    if (!seed && draggedItem && isSeedItem(draggedItem) && (inventory[draggedItem] || 0) > 0) {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        slot.style.background = 'rgba(80,200,80,0.25)';
                        slot.style.borderColor = 'rgba(80,255,80,0.7)';
                    }
                });
                slot.addEventListener('dragleave', () => {
                    slot.style.background = 'rgba(0,0,0,0.45)';
                    slot.style.borderColor = seed ? (seed.grown ? 'rgba(80,255,80,0.6)' : 'rgba(80,180,80,0.3)') : 'rgba(100,200,80,0.3)';
                });
                slot.addEventListener('drop', e => {
                    e.preventDefault();
                    slot.style.background = 'rgba(0,0,0,0.45)';
                    slot.style.borderColor = 'rgba(100,200,80,0.3)';
                    if (seed)                             { showMessage('❌ Slot already occupied!'); return; }
                    if (!draggedItem || !isSeedItem(draggedItem)) { showMessage('❌ Only seeds can be planted!'); return; }
                    if ((inventory[draggedItem] || 0) <= 0)  { showMessage('❌ No seeds left!'); return; }
                    inventory[draggedItem]--;
                    currentPlanterBox.userData.seeds[i] = { type: draggedItem, waterCount: 0, grown: false, plantMesh: null };
                    showMessage(`🌱 Planted ${draggedItem.replace(/_/g,' ')} in slot ${i + 1}`);
                    updateUI(); updatePlanterDisplay();
                });

                slotsEl.appendChild(slot);
            });

            const statusEl = document.getElementById('planter-status');
            if (isRaining) {
                statusEl.textContent = '🌧️ Raining — seeds are being watered!';
                statusEl.style.color = 'rgba(100,180,255,0.9)';
            } else {
                const activeSeeds = seeds.filter(s => s && !s.grown).length;
                statusEl.textContent = activeSeeds > 0 ? `☀️ Waiting for rain to water ${activeSeeds} seed(s)` : '';
                statusEl.style.color = 'rgba(180,255,140,0.75)';
            }
        }

        function plantSeedInSlot(slotIndex) {
            if (!currentPlanterBox) return;
            const available = Object.keys(inventory).filter(k => isSeedItem(k) && inventory[k] > 0);
            if (available.length === 0) { showMessage('❌ No seeds in inventory!'); return; }
            if (available.length === 1) { _doPlantSeed(slotIndex, available[0]); return; }
            _showSeedPicker(slotIndex, available);
        }

        function _doPlantSeed(slotIndex, seedType) {
            if (!currentPlanterBox || (inventory[seedType] || 0) <= 0) return;
            inventory[seedType]--;
            currentPlanterBox.userData.seeds[slotIndex] = { type: seedType, waterCount: 0, grown: false, plantMesh: null };
            updateUI(); updatePlanterDisplay();
            showMessage(`🌱 Planted ${seedType.replace(/_/g,' ')} in slot ${slotIndex + 1}`);
        }

        function _showSeedPicker(slotIndex, seedTypes) {
            const existing = document.getElementById('seed-picker-popup');
            if (existing) existing.remove();
            const popup = document.createElement('div');
            popup.id = 'seed-picker-popup';
            popup.style.cssText = `
                position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
                background:linear-gradient(135deg,rgba(15,35,15,0.98),rgba(10,25,10,0.97));
                border:2px solid rgba(80,200,80,0.45); border-radius:12px;
                padding:18px 20px; z-index:6000; min-width:260px; max-width:360px;
                box-shadow:0 8px 32px rgba(0,0,0,0.7); font-family:'Segoe UI',sans-serif;
                color:white; backdrop-filter:blur(12px);
            `;
            popup.innerHTML = `<div style="font-weight:bold;font-size:15px;margin-bottom:12px;text-align:center;">🌱 Choose seed for slot ${slotIndex+1}</div>`;
            const grid = document.createElement('div');
            grid.style.cssText = 'display:grid;grid-template-columns:repeat(3,1fr);gap:8px;';
            seedTypes.forEach(st => {
                const btn = document.createElement('button');
                btn.style.cssText = `background:rgba(0,0,0,0.5);border:1.5px solid rgba(80,180,80,0.35);border-radius:8px;padding:8px 4px;color:white;cursor:pointer;display:flex;flex-direction:column;align-items:center;gap:3px;font-family:inherit;transition:background 0.15s,border-color 0.15s;`;
                btn.innerHTML = `<span style="font-size:22px">${itemIcons[st]||'🌱'}</span><span style="font-size:10px;text-align:center;line-height:1.2">${st.replace(/_seed$/,'').replace(/_/g,' ')}</span><span style="font-size:10px;color:rgba(180,255,140,0.7)">×${inventory[st]||0}</span>`;
                btn.onmouseover = () => { btn.style.background='rgba(80,180,80,0.25)'; btn.style.borderColor='rgba(80,255,80,0.6)'; };
                btn.onmouseout  = () => { btn.style.background='rgba(0,0,0,0.5)';       btn.style.borderColor='rgba(80,180,80,0.35)'; };
                btn.onclick = () => { popup.remove(); _doPlantSeed(slotIndex, st); };
                grid.appendChild(btn);
            });
            popup.appendChild(grid);
            const cancel = document.createElement('button');
            cancel.textContent = 'Cancel';
            cancel.style.cssText = 'display:block;width:100%;margin-top:12px;padding:7px;background:rgba(180,0,0,0.5);border:1px solid rgba(255,80,80,0.4);border-radius:6px;color:white;cursor:pointer;font-family:inherit;font-size:13px;';
            cancel.onclick = () => popup.remove();
            popup.appendChild(cancel);
            document.body.appendChild(popup);
            setTimeout(() => {
                document.addEventListener('click', function oc(e) { if (!popup.contains(e.target)) { popup.remove(); document.removeEventListener('click', oc); } });
            }, 100);
        }

        function removeSeedFromPlanter(slotIndex) {
            if (!currentPlanterBox) return;
            const seed = currentPlanterBox.userData.seeds[slotIndex];
            if (!seed) return;
            // Return seed to inventory
            inventory[seed.type] = (inventory[seed.type] || 0) + 1;
            // Remove plant mesh if it exists
            if (seed.plantMesh) {
                currentPlanterBox.userData.plantContainer.remove(seed.plantMesh);
            }
            currentPlanterBox.userData.seeds[slotIndex] = null;
            updateUI();
            updatePlanterDisplay();
            showMessage(`↩️ Retrieved seed from slot ${slotIndex + 1}`);
        }

        // Called from updateRain when rain is active — waters all planters in the world
        function waterAllPlanters() {
            for (const building of buildings) {
                if (!building.userData.isPlanterBox) continue;
                if (building.userData.wateredThisRain) continue;
                building.userData.wateredThisRain = true;

                const seeds = building.userData.seeds;
                let anyChanged = false;
                seeds.forEach((seed, i) => {
                    if (!seed || seed.grown) return;
                    seed.waterCount = Math.min(4, seed.waterCount + 1);
                    // Spawn/update plant model at each growth stage
                    spawnPlantModel(building, i, seed.type, seed.waterCount);
                    if (seed.waterCount >= 4) {
                        seed.grown = true;
                    }
                    anyChanged = true;
                });

                if (anyChanged && currentPlanterBox === building) {
                    updatePlanterDisplay();
                }
            }
        }

        // Reset watering flag when rain stops so next rain event can water again
        function resetPlanterWaterFlags() {
            for (const building of buildings) {
                if (building.userData.isPlanterBox) {
                    building.userData.wateredThisRain = false;
                }
            }
        }

        // ─── PLANT MODEL BUILDER ───────────────────────────────────────────────────
        // stage: 1=sprout  2=young  3=maturing  4=fully grown
        // At stage 4, returns a GLB instance if loaded, otherwise falls back to procedural.
        // buildPlantModel: builds realistic plant geometry into a THREE.Group
        // Used by both planter system and wild plant spawning
        function buildPlantModel(seedType, stage, scale=1.0) {
            // ── Stage 4: use GLB model if available ──────────────────────────────
            if (stage === 4 && _plantGLBFiles[seedType]) {
                const glbInst = _buildPlantGLBInstance(seedType, scale);
                if (glbInst) return glbInst;
                // GLB not yet loaded — kick off load and return stage-3 procedural as
                // placeholder (looks better than stage-4 procedural for root veg which
                // shows raw geometry like grey lumps at stage 4).
                _loadPlantGLB(seedType).then(tmpl => {
                    if (!tmpl) return;
                    // Find all planters and wild plants using this seed at stage 4 and refresh
                    const refreshTargets = [];
                    // Planter boxes
                    buildings.forEach(b => {
                        if (!b.userData.seeds) return;
                        b.userData.seeds.forEach((seed, idx) => {
                            if (seed && seed.type === seedType && seed.waterCount >= 4) {
                                refreshTargets.push({ planterBox: b, slotIndex: idx });
                            }
                        });
                    });
                    refreshTargets.forEach(t => spawnPlantModel(t.planterBox, t.slotIndex, seedType, 4));
                    // Wild plants
                    wildPlants.forEach(wp => {
                        if (wp.userData && wp.userData.seedType === seedType && wp.userData.harvestable) {
                            const parent = wp.parent;
                            if (!parent) return;
                            const pos = wp.position.clone();
                            parent.remove(wp);
                            const _wsc2={wheat_seed:7.5,corn_seed:6.8,hemp_seed:6.5,red_berry_seed:1.2,black_berry_seed:1.2,tomato_seed:0.625,pumpkin_seed:5.0,cucumber_seed:2.5,potato_seed:2.5,carrot_seed:2.5,cabbage_seed:2.5,mushroom_seed:2.5,strawberry_seed:2.5};
                            const fresh = buildPlantModel(seedType, 4, _wsc2[seedType] || 2.5);
                            const _wSink2 = ({carrot_seed:0.18, potato_seed:0.10, strawberry_seed:0.04})[seedType] || 0;
                            fresh.position.set(pos.x, fresh.position.y - _wSink2, pos.z);
                            fresh.userData.isWildPlant = true;
                            fresh.userData.seedType  = seedType;
                            fresh.userData.harvestable = true;
                            fresh.userData.respawnAt = 0;
                            parent.add(fresh);
                            // Update wildPlants array reference
                            const wi = wildPlants.indexOf(wp);
                            if (wi !== -1) wildPlants[wi] = fresh;
                        }
                    });
                });
                // GLB not ready yet — render as stage 3 (maturing) rather than stage 4
                // procedural which produces ugly raw geometry for root vegetables.
                stage = 3;
            }
            const plant = new THREE.Group();
            const M  = (hex,r=0.8,m=0) => new THREE.MeshStandardMaterial({color:hex,roughness:r,metalness:m});
            const DM = (hex,r=0.8)     => new THREE.MeshStandardMaterial({color:hex,roughness:r,side:THREE.DoubleSide});
            const t  = stage / 4; // growth fraction 0..1

            // ── helpers ────────────────────────────────────────────────────────
            function stk(h,r,col){ const m=new THREE.Mesh(new THREE.CylinderGeometry(r*.65,r,h,7),M(col)); m.position.y=h/2; plant.add(m); return m; }
            function lf(x,y,z,w,h,rx=0,ry=0,rz=0,col=0x4dbe3c){ const m=new THREE.Mesh(new THREE.PlaneGeometry(w,h),DM(col)); m.position.set(x,y,z); m.rotation.set(rx,ry,rz); plant.add(m); return m; }
            function sp(x,y,z,r,col,s=8){ const m=new THREE.Mesh(new THREE.SphereGeometry(r,s,s),M(col)); m.position.set(x,y,z); plant.add(m); return m; }
            function cn(x,y,z,r,h,col,s=8){ const m=new THREE.Mesh(new THREE.ConeGeometry(r,h,s),M(col)); m.position.set(x,y,z); plant.add(m); return m; }
            function cy(x,y,z,rt,rb,h,col,s=8){ const m=new THREE.Mesh(new THREE.CylinderGeometry(rt,rb,h,s),M(col)); m.position.set(x,y,z); plant.add(m); return m; }

            // ── PUMPKIN ────────────────────────────────────────────────────────
            if (seedType === 'pumpkin_seed') {
                const sh = 0.06 + t*0.09; stk(sh, 0.013, 0x4a7c28);
                // Vine sprawl + broad leaves
                const lc = Math.max(2, stage*2);
                for(let i=0;i<lc;i++){
                    const a=i/lc*Math.PI*2, vr=0.05+t*0.07;
                    cy(Math.cos(a)*vr*.5,sh*.6,Math.sin(a)*vr*.5, 0.005,0.008,vr, 0x3a7020, 4);
                    lf(Math.cos(a)*vr*.9,sh*.55,Math.sin(a)*vr*.9, 0.09+t*0.04,0.08+t*0.03, -1.2,a,0, 0x5ab040);
                }
                if(stage>=3){
                    // Realistic ribbed pumpkin
                    const pg=new THREE.Group(); pg.position.set(0,sh+0.01,0);
                    const pr=0.05+t*0.09, py=pr*0.72;
                    for(let r=0;r<8;r++){
                        const ra=r/8*Math.PI*2;
                        const rib=new THREE.Mesh(new THREE.SphereGeometry(pr,8,7),M(stage===4?0xE07C1A:0xBE9010));
                        rib.scale.set(0.52,0.78,0.52); rib.position.set(Math.cos(ra)*pr*.3,0,Math.sin(ra)*pr*.3); pg.add(rib);
                    }
                    // Pumpkin stem
                    const ps=new THREE.Mesh(new THREE.CylinderGeometry(0.007,0.012,0.05,5),M(0x4a2e08));
                    ps.position.y=py+0.01; pg.add(ps);
                    // Curly tendril
                    const tc=new THREE.Mesh(new THREE.TorusGeometry(0.02,0.003,4,8,Math.PI*1.5),M(0x3a7020));
                    tc.position.set(0.03,py+0.04,0); pg.add(tc);
                    plant.add(pg);
                }

            // ── WHEAT ──────────────────────────────────────────────────────────
            } else if (seedType === 'wheat_seed') {
                const stalks = stage<2 ? [0] : [-0.042,0,0.042];
                stalks.forEach((ox,si)=>{
                    const h=0.1+t*0.24;
                    const sc2=stage<4?0x5aaa3c:0xC8A800;
                    stk(h,0.007,sc2); // main stalk
                    // Node bumps
                    if(stage>1) for(let n=1;n<3;n++) sp(ox,h*n/3,0,0.009,sc2,5);
                    // Flag leaves at each node
                    if(stage>=2){
                        [-1,1].forEach(side=>{
                            const l2=new THREE.Mesh(new THREE.PlaneGeometry(0.075+t*.02,0.22+t*.05),DM(0x5aaa3c));
                            l2.position.set(side*0.04,h*.48,0); l2.rotation.set(0.1*side,0,side*0.32); plant.add(l2);
                        });
                    }
                    // Ear — realistic elongated seed head
                    if(stage>=3){
                        const earH=0.07+t*.04;
                        const earCol=stage===4?0xD4A800:0x90C038;
                        cy(ox,h+earH/2,0, 0.015,0.011,earH, earCol, 7);
                        // Awns (bristles radiating up)
                        for(let aw=0;aw<8;aw++){
                            const aa=aw/8*Math.PI*2;
                            const awn=new THREE.Mesh(new THREE.CylinderGeometry(.0015,.001,.045,3),M(earCol));
                            awn.position.set(ox+Math.cos(aa)*.012,h+earH*.2+aw*.008,Math.sin(aa)*.012);
                            awn.rotation.set(-Math.cos(aa)*.3,0,-Math.sin(aa)*.3);
                            plant.add(awn);
                        }
                    }
                });

            // ── CABBAGE ────────────────────────────────────────────────────────
            } else if (seedType === 'cabbage_seed') {
                // Concentric layered leaves building into a tight head
                const layerCount = Math.min(stage+1, 5);
                for(let l=0;l<layerCount;l++){
                    const lR=0.03+l*0.038, lCount=4+l*2, ly=l*0.016;
                    const col = l===layerCount-1&&stage===4 ? 0x90e060 : (l<2?0xb8f070:0x60b040);
                    for(let i=0;i<lCount;i++){
                        const a=i/lCount*Math.PI*2+l*.4;
                        const leaf2=new THREE.Mesh(new THREE.SphereGeometry(lR*.7,6,5),DM(col));
                        leaf2.scale.set(1.1,0.28+l*.04,1.1); leaf2.position.set(Math.cos(a)*lR*.7,ly,Math.sin(a)*lR*.7); plant.add(leaf2);
                    }
                }
                // Tight central head stages 3+
                if(stage>=3){
                    const head=new THREE.Mesh(new THREE.SphereGeometry(0.07+t*.018,9,8),M(stage===4?0x68d040:0x88d060));
                    head.scale.set(1,.76,1); head.position.y=layerCount*.018; plant.add(head);
                }

            // ── CUCUMBER ───────────────────────────────────────────────────────
            } else if (seedType === 'cucumber_seed') {
                const h=0.06+t*0.16; stk(h,0.011,0x3a8030);
                // Big coarse leaves alternating
                for(let i=0;i<=stage;i++){
                    const side=i%2===0?1:-1, ly=h*(0.25+i/(stage+1)*.6);
                    lf(side*0.06,ly,0, 0.11+t*.02,0.09+t*.02, 0,0,side*.45, 0x3a8030);
                }
                // Tendril curl
                if(stage>=2){ const tc=new THREE.Mesh(new THREE.TorusGeometry(.03,.003,4,8,Math.PI),M(0x5aaa40)); tc.position.set(0.07,h*.8,0); plant.add(tc); }
                // Cucumbers — dark green ridged cylinder hanging diagonally
                if(stage>=3){
                    const cNum=stage===4?2:1;
                    for(let c=0;c<cNum;c++){
                        const cl=0.12+t*.04, cr=0.018;
                        const cg=new THREE.Group(); cg.position.set(c?-0.07:0.07,h*.68,c?.03:-.03); cg.rotation.z=(c?-1:1)*.45;
                        const body=new THREE.Mesh(new THREE.CylinderGeometry(cr*.88,cr,cl,8),M(stage===4?0x287820:0x48a830)); cg.add(body);
                        // Ridges
                        for(let r=0;r<8;r++){ const ra=r/8*Math.PI*2; const ridge=new THREE.Mesh(new THREE.CylinderGeometry(.003,.003,cl*.9,3),M(0x206818)); ridge.position.set(Math.cos(ra)*cr,0,Math.sin(ra)*cr); cg.add(ridge); }
                        // Yellow blossom end
                        const tip=new THREE.Mesh(new THREE.SphereGeometry(cr*.7,6,5),M(0xE0C020)); tip.position.y=cl/2+.005; cg.add(tip);
                        plant.add(cg);
                    }
                }

            // ── POTATO ─────────────────────────────────────────────────────────
            } else if (seedType === 'potato_seed') {
                const h=0.05+t*.13; stk(h,0.013,0x4a9028);
                // Pinnate compound leaves
                const nodes=stage+1;
                for(let n=0;n<nodes;n++){
                    const ny=h*(.22+n/nodes*.65);
                    [-1,1].forEach(side=>{
                        lf(side*.055,ny,0, 0.07+t*.02,0.045+t*.01, 0,0,side*.5, 0x4a9028);
                        if(stage>=3) lf(side*.09,ny-.01,.03, 0.04,0.025, 0,.4,side*.6, 0x4a9028);
                    });
                }
                // White star flowers stage 3+
                if(stage>=3){
                    for(let f=0;f<(stage===4?4:2);f++){
                        const fa=f/(stage===4?4:2)*Math.PI*2;
                        const fg=new THREE.Group(); fg.position.set(Math.cos(fa)*.08,h+.025,Math.sin(fa)*.08);
                        for(let p=0;p<5;p++){ const pa=p/5*Math.PI*2; const petal=new THREE.Mesh(new THREE.PlaneGeometry(.022,.016),DM(0xf0f0e0)); petal.position.set(Math.cos(pa)*.016,0,Math.sin(pa)*.016); petal.rotation.y=pa; fg.add(petal); }
                        const ctr=new THREE.Mesh(new THREE.SphereGeometry(.008,5,4),M(0xf8c820)); fg.add(ctr); plant.add(fg);
                    }
                }
                // Potato tubers at soil level stage 4
                if(stage===4){
                    for(let p=0;p<3;p++){
                        const pa=p/3*Math.PI*2;
                        const tub=new THREE.Mesh(new THREE.SphereGeometry(.032,8,7),M(0xBE8840)); tub.scale.set(.9,.62,1.15); tub.rotation.y=pa;
                        tub.position.set(Math.cos(pa)*.045,.006,Math.sin(pa)*.045); plant.add(tub);
                        // Eyes
                        for(let e=0;e<2;e++){ const ey=new THREE.Mesh(new THREE.SphereGeometry(.005,4,3),M(0x6a3010)); ey.position.set(tub.position.x+(e-.5)*.016,tub.position.y+.016,tub.position.z); plant.add(ey); }
                    }
                }

            // ── CARROT ─────────────────────────────────────────────────────────
            } else if (seedType === 'carrot_seed') {
                const h=0.06+t*.16;
                // Feathery umbel tops (carrot fronds)
                const fronds=Math.min(3+stage,8);
                for(let f=0;f<fronds;f++){
                    const fa=f/fronds*Math.PI*2, fh=h*(.7+Math.random()*.3);
                    const fs=new THREE.Mesh(new THREE.CylinderGeometry(.003,.007,fh,4),M(0x5ab038));
                    fs.position.set(Math.cos(fa)*.02*t,fh/2,Math.sin(fa)*.02*t);
                    fs.rotation.set(Math.sin(fa)*.35,0,Math.cos(fa)*.35); plant.add(fs);
                    if(stage>=2) for(let l=0;l<4;l++) lf(Math.cos(fa+.8*l)*.03,fh*(.4+l*.15),Math.sin(fa+.8*l)*.03, .04-.006*l,.028-.003*l, 0,fa+l*.4,0, 0x6ac040);
                }
                // Orange taproot emerging
                if(stage>=2){
                    const cr2=0.017+t*.012, ch=0.06+t*.09, visY=[-0.01,0,.01,.025,.06][stage];
                    const cg=new THREE.Group(); cg.position.y=visY;
                    const body=new THREE.Mesh(new THREE.ConeGeometry(cr2,ch+.04,9),M(0xF07828)); body.rotation.x=Math.PI; cg.add(body);
                    // Surface ridges
                    if(stage>=4) for(let r=0;r<3;r++){ const ring=new THREE.Mesh(new THREE.TorusGeometry(cr2*.85,.003,4,9),M(0xD06010)); ring.position.y=-r*.02; ring.rotation.x=Math.PI/2; cg.add(ring); }
                    plant.add(cg);
                }

            // ── HEMP ───────────────────────────────────────────────────────────
            } else if (seedType === 'hemp_seed') {
                const h=0.1+t*.32; stk(h,0.012,0x3a8028);
                // Multi-node plant with palmate fan leaves
                for(let n=0;n<stage+1;n++){
                    const ny=h*(.18+n/(stage+1)*.62);
                    const fingers=Math.min(5+n,7);
                    for(let f=0;f<fingers;f++){
                        const fa=f/fingers*Math.PI*2;
                        lf(Math.cos(fa)*.035+Math.cos(fa)*.02*n/stage,ny,Math.sin(fa)*.035+Math.sin(fa)*.02*n/stage,
                           .032+t*.018,.065+t*.035, -1.25,fa,0, 0x2d7020);
                    }
                }
                // Dense flower/resin bud cluster apex (stage 3+)
                if(stage>=3){
                    const bCol=stage===4?0x9b4ab0:0xb89020;
                    for(let b=0;b<16;b++){
                        const ba=b/16*Math.PI*2, br=.015+Math.random()*.015;
                        const bud=new THREE.Mesh(new THREE.SphereGeometry(.009,5,4),M(bCol)); bud.position.set(Math.cos(ba)*br,h+.015+b*.003,Math.sin(ba)*br); plant.add(bud);
                    }
                    if(stage===4) for(let p=0;p<6;p++){ const pa=p/6*Math.PI*2; const pi=new THREE.Mesh(new THREE.CylinderGeometry(.002,.002,.028,3),M(0xe0a0f0)); pi.position.set(Math.cos(pa)*.018,h+.05,Math.sin(pa)*.018); plant.add(pi); }
                }

            // ── CORN ───────────────────────────────────────────────────────────
            } else if (seedType === 'corn_seed') {
                const h=0.1+t*.34; stk(h,.021,0x4a9828);
                // Long arching strap leaves
                for(let s=0;s<Math.min(stage*2,8);s++){
                    const side=s%2===0?1:-1, sy=h*(.22+s/8*.55);
                    const sl=new THREE.Mesh(new THREE.PlaneGeometry(.08+t*.02,.26+t*.07),DM(0x4a9828));
                    sl.position.set(side*.06,sy,0); sl.rotation.set(.2*side,0,side*.38); plant.add(sl);
                }
                // Tassel at top
                if(stage>=2) for(let ts=0;ts<4+stage;ts++){ const ta=ts/(4+stage)*Math.PI*2; const tl=new THREE.Mesh(new THREE.CylinderGeometry(.002,.001,.07+t*.04,3),M(0xd4c040)); tl.position.set(Math.cos(ta)*.018,h+.025+ts*.005,Math.sin(ta)*.018); plant.add(tl); }
                // Ear of corn in husk (stage 3+)
                if(stage>=3){
                    const eg=new THREE.Group(); eg.position.set(.07,h*.6,0); eg.rotation.z=.45;
                    const eH=.12+t*.05, eR=.028;
                    // Husk leaves peeling back at stage 4
                    for(let hl=0;hl<4;hl++){
                        const husk=new THREE.Mesh(new THREE.ConeGeometry(eR+.006,eH*.9,8,1,true),DM(stage===4?0x8a9820:0xa8b820));
                        husk.rotation.set(stage===4?.3*hl:0,hl/4*Math.PI*2,0); eg.add(husk);
                    }
                    // Yellow cob at stage 4
                    if(stage===4){
                        const cob=new THREE.Mesh(new THREE.CylinderGeometry(eR*.85,eR*.75,eH,9),M(0xF0C040)); eg.add(cob);
                        for(let k=0;k<20;k++){ const ka=k/20*Math.PI*2,ky=k%10/10; const kern=new THREE.Mesh(new THREE.SphereGeometry(.006,4,4),M(0xF8D050)); kern.position.set(Math.cos(ka)*eR*.82,(ky-.5)*eH*.85,Math.sin(ka)*eR*.82); eg.add(kern); }
                    }
                    plant.add(eg);
                }

            // ── MUSHROOM ───────────────────────────────────────────────────────
            } else if (seedType === 'mushroom_seed') {
                const sH=[0,.022,.044,.07,.1][stage];
                const cR=[0,.022,.044,.07,.1][stage];
                // Stipe (white stalk)
                const stipe=new THREE.Mesh(new THREE.CylinderGeometry(sH*.36,sH*.48,sH,8),M(0xf0ead8)); stipe.position.y=sH/2; plant.add(stipe);
                // Annulus ring (stage 3+)
                if(stage>=3){ const ann=new THREE.Mesh(new THREE.TorusGeometry(sH*.4,.003,4,10),M(0xd8cebc)); ann.position.y=sH*.58; ann.rotation.x=Math.PI/2; plant.add(ann); }
                // Pileus (cap) — flattened red/brown sphere
                if(stage>=1){
                    const cap=new THREE.Mesh(new THREE.SphereGeometry(cR,10,8),M(0xC41c1c)); cap.scale.set(1,stage>=3?.52:.78,1); cap.position.y=sH; plant.add(cap);
                    // Gills underside
                    if(stage>=3){ const gills=new THREE.Mesh(new THREE.CylinderGeometry(cR*.88,sH*.38,cR*.16,14,1,true),M(0xe8c8b0)); gills.position.y=sH-cR*.04; plant.add(gills); }
                    // White spots (amanita style)
                    const spotN=[0,3,5,7,9][stage]||0;
                    for(let s=0;s<spotN;s++){ const sa=s/spotN*Math.PI*2; const spot=new THREE.Mesh(new THREE.SphereGeometry(cR*.15,5,4),M(0xffffff)); spot.position.set(Math.cos(sa)*cR*.6,sH+cR*.44,Math.sin(sa)*cR*.6); plant.add(spot); }
                }

            // ── RED BERRY ──────────────────────────────────────────────────────
            } else if (seedType === 'red_berry_seed') {
                const h=0.04+t*.11; stk(h,.011,0x2d6020);
                for(let b=0;b<Math.min(stage+1,4);b++){
                    const ba=b/(Math.min(stage+1,4))*Math.PI*2;
                    const brg=new THREE.Mesh(new THREE.CylinderGeometry(.006,.009,h*.7,5),M(0x2d6020));
                    brg.rotation.set(Math.sin(ba)*.55,0,Math.cos(ba)*.55); brg.position.set(Math.cos(ba)*.04*t,h*.38,Math.sin(ba)*.04*t); plant.add(brg);
                    // Oval leaves
                    lf(Math.cos(ba)*.065*t,h*.74,Math.sin(ba)*.065*t, .07,.048, 0,ba,0, 0x3a8028);
                    if(stage>=2) for(let rb=0;rb<stage;rb++){
                        const bra=ba+rb*.6, bR=stage===4?.019:.013;
                        const berry=new THREE.Mesh(new THREE.SphereGeometry(bR,7,6),M(0xcc1111)); berry.position.set(Math.cos(bra)*.07*t,h*.85+rb*.012,Math.sin(bra)*.07*t); plant.add(berry);
                        const cal=new THREE.Mesh(new THREE.ConeGeometry(bR*.4,bR*.5,5),M(0x2d6020)); cal.position.set(berry.position.x,berry.position.y+bR*.85,berry.position.z); plant.add(cal);
                    }
                }

            // ── BLACK BERRY ────────────────────────────────────────────────────
            } else if (seedType === 'black_berry_seed') {
                const h=0.04+t*.13; stk(h,.012,0x1e4a18);
                for(let b=0;b<Math.min(stage+1,4);b++){
                    const ba=b/(Math.min(stage+1,4))*Math.PI*2;
                    const cane=new THREE.Mesh(new THREE.CylinderGeometry(.006,.01,h*.75,5),M(0x1e4a18));
                    cane.rotation.set(Math.sin(ba)*.6,0,Math.cos(ba)*.6); cane.position.set(Math.cos(ba)*.045*t,h*.38,Math.sin(ba)*.045*t); plant.add(cane);
                    // Thorns
                    if(stage>=2) for(let th=0;th<2;th++){ const thorn=new THREE.Mesh(new THREE.ConeGeometry(.003,.016,4),M(0x2a1a18)); thorn.position.set(Math.cos(ba+th)*.025,h*(.28+th*.14),Math.sin(ba+th)*.025); thorn.rotation.z=Math.PI/3; plant.add(thorn); }
                    lf(Math.cos(ba)*.07*t,h*.72,Math.sin(ba)*.07*t, .065,.048, 0,ba,0, 0x1e5018);
                    // Compound drupes
                    if(stage>=2) for(let rb=0;rb<stage;rb++){
                        const bra=ba+rb*.55, bg=new THREE.Group(); bg.position.set(Math.cos(bra)*.075*t,h*.85+rb*.014,Math.sin(bra)*.075*t);
                        for(let d=0;d<9;d++){ const da=d/9*Math.PI*2, dr=.009; const drupe=new THREE.Mesh(new THREE.SphereGeometry(dr,5,4),M(d%3===0?0x1a0a28:0x100818)); drupe.position.set(Math.cos(da)*dr*1.6,d%3*.004,Math.sin(da)*dr*1.6); bg.add(drupe); }
                        plant.add(bg);
                    }
                }

            // ── STRAWBERRY ─────────────────────────────────────────────────────
            } else if (seedType === 'strawberry_seed') {
                // Low trifoliate rosette
                const lc=Math.min(4+stage*2,12);
                for(let i=0;i<lc;i++){
                    const a=i/lc*Math.PI*2, r2=.032+t*.042;
                    for(let lf2=0;lf2<3;lf2++){
                        const la=a+(lf2-1)*.38;
                        lf(Math.cos(la)*(r2+lf2*.01),.014+t*.01,Math.sin(la)*(r2+lf2*.01), .058+t*.01,.044+t*.01, -1.2,la,0, 0x3d9c28);
                    }
                }
                // Runners (stage 3+)
                if(stage>=3) for(let r3=0;r3<2;r3++){ const run=new THREE.Mesh(new THREE.CylinderGeometry(.003,.003,.09,4),M(0x5ab038)); run.rotation.z=(r3===0?1:-1)*.8; run.position.set(r3===0?.05:-.05,.01,0); plant.add(run); }
                // Fruit — realistic red cone with achenes
                if(stage>=2){
                    const fN=[0,0,1,2,3][stage];
                    const fCol=stage===4?0xe01010:(stage===3?0xe84040:0xf08050);
                    for(let f=0;f<fN;f++){
                        const fa=f/fN*Math.PI*2, fg=new THREE.Group(); fg.position.set(Math.cos(fa)*.06,.048,Math.sin(fa)*.06);
                        const fruit=new THREE.Mesh(new THREE.ConeGeometry(.025,.052,9),M(fCol)); fruit.rotation.x=Math.PI; fg.add(fruit);
                        if(stage===4) for(let s=0;s<12;s++){ const sa=s/12*Math.PI*2,sy=s%6/6; const achene=new THREE.Mesh(new THREE.SphereGeometry(.003,4,3),M(0xf0e8a0)); achene.position.set(Math.cos(sa)*.019,-.01-sy*.028,Math.sin(sa)*.019); fg.add(achene); }
                        // Green calyx
                        for(let s=0;s<5;s++){ const sa=s/5*Math.PI*2; lf(Math.cos(sa)*.018,.026,Math.sin(sa)*.018, .022,.014, -1.2,sa,0, 0x3d9c28); }
                        plant.add(fg);
                    }
                }

            // ── TOMATO ─────────────────────────────────────────────────────────
            } else if (seedType === 'tomato_seed') {
                const h=0.07+t*.2; stk(h,.014,0x3a8828);
                // Compound pinnate leaves on side branches
                for(let b=0;b<Math.min(stage,4);b++){
                    const ba=b/Math.min(stage,4)*Math.PI*2, bh=h*(.28+b/Math.min(stage,4)*.58);
                    const brMesh=new THREE.Mesh(new THREE.CylinderGeometry(.007,.011,h*.38,5),M(0x3a8828));
                    brMesh.rotation.set(Math.sin(ba)*.5,0,Math.cos(ba)*.5); brMesh.position.set(Math.cos(ba)*.028*t,bh,Math.sin(ba)*.028*t); plant.add(brMesh);
                    for(let lf3=0;lf3<5;lf3++){ const lfa=ba+(lf3-2)*.48, lr=.038+lf3*.009; lf(Math.cos(lfa)*lr+Math.cos(ba)*.025*t,bh+.01+lf3*.006,Math.sin(lfa)*lr+Math.sin(ba)*.025*t, .06,.04, 0,lfa,0, 0x3a8828); }
                    // Tomatoes on trusses
                    if(stage>=2&&b<stage-1){
                        const tN=stage===4?3:(stage===3?2:1);
                        for(let tom=0;tom<tN;tom++){
                            const tCol=stage===4?0xE01010:(stage===3?0xF04020:0xF0C010);
                            const tR=stage===4?.034:(stage===3?.024:.016);
                            const tmesh=new THREE.Mesh(new THREE.SphereGeometry(tR,9,8),M(tCol));
                            tmesh.position.set(Math.cos(ba)*.08*t+tom*.038,bh+h*.14+tom*.022,Math.sin(ba)*.08*t); plant.add(tmesh);
                            // Calyx star
                            for(let s=0;s<5;s++){ const sa=s/5*Math.PI*2; lf(tmesh.position.x+Math.cos(sa)*.022,tmesh.position.y+tR+.003,tmesh.position.z+Math.sin(sa)*.022, .024,.013, -1.2,sa,0, 0x2d7020); }
                            // Blossom scar
                            const bsc=new THREE.Mesh(new THREE.SphereGeometry(tR*.22,4,3),M(0x6a3010)); bsc.position.set(tmesh.position.x,tmesh.position.y-tR*.88,tmesh.position.z); plant.add(bsc);
                        }
                    }
                }

            // ── FALLBACK ───────────────────────────────────────────────────────
            } else {
                stk(.08+t*.1,.013,0x3a8c2f);
                [-1,1].forEach(side=>lf(side*.04,.1+t*.06,0, .08+t*.02,.05+t*.01, 0,0,side*.5));
            }

            plant.scale.setScalar(scale * ([0,.32,.56,.80,1.0][stage]||1));
            return plant;
        }

        // Per-seedType y-offset table REMOVED — replaced by automatic soil-surface positioning.
        // spawnPlantModel now reads planterBox.userData.dirtY (the actual soil surface height
        // in the planter group's local space) and places every plant at that y, so GLB models
        // always sit on the dirt regardless of their internal geometry origin.
        // Root vegetables (carrot, potato) get a small extra sink so their tops are at soil level.
        const _plantSoilSink = {
            carrot_seed:  0.18,   // sink 18cm so orange taproot is mostly underground
            potato_seed:  0.10,   // tubers half-buried
            strawberry_seed: 0.04,
        };

        function spawnPlantModel(planterBox, slotIndex, seedType, stage) {
            const container = planterBox.userData.plantContainer;
            const existing = planterBox.userData.seeds[slotIndex]?.plantMesh;
            if (existing) container.remove(existing);
            const _slotDefs = planterBox.userData.slotDefs;
            const _sx = _slotDefs ? _slotDefs[slotIndex].x : (planterBox.userData.slotPositions||[])[slotIndex]||0;
            const _sz = _slotDefs ? _slotDefs[slotIndex].z : 0;
            const plant = buildPlantModel(seedType, stage);

            // Soil surface in plantContainer local space = planterBox.userData.dirtY.
            // Procedural plants (stages 1-3) are built with y=0 at their base, so we
            // lift them to dirtY. GLB plants are also grounded at y=0 by _loadPlantGLB,
            // so the same lift applies — then we optionally sink root veg a little extra.
            const dirtY = planterBox.userData.dirtY ?? 0.15;
            const isGLB = stage === 4 && _plantGLBCache[seedType];
            const sink  = isGLB ? (_plantSoilSink[seedType] ?? 0) : 0;
            plant.position.set(_sx, dirtY - sink, _sz);
            container.add(plant);
            if (planterBox.userData.seeds[slotIndex]) planterBox.userData.seeds[slotIndex].plantMesh = plant;
        }

        // ─── HARVEST MAPPING ──────────────────────────────────────────────────────
        // seedType → { produce: itemKey, count: n, seedReturn: n }
        const _harvestMap = {
            pumpkin_seed:    { produce: 'pumpkin',      count: 1, seedReturn: 2 },
            wheat_seed:      { produce: 'wheat',        count: 3, seedReturn: 3 },
            cabbage_seed:    { produce: 'cabbage',      count: 1, seedReturn: 2 },
            cucumber_seed:   { produce: 'cucumber',     count: 2, seedReturn: 2 },
            potato_seed:     { produce: 'potato',       count: 2, seedReturn: 2 },
            carrot_seed:     { produce: 'carrot',       count: 2, seedReturn: 2 },
            hemp_seed:       { produce: 'hemp_fiber',   count: 3, seedReturn: 2 },
            corn_seed:       { produce: 'corn',         count: 2, seedReturn: 2 },
            mushroom_seed:   { produce: 'mushroom_crop',count: 2, seedReturn: 1 },
            red_berry_seed:  { produce: 'red_berries',  count: 3, seedReturn: 2 },
            black_berry_seed:{ produce: 'black_berries',count: 3, seedReturn: 2 },
            strawberry_seed: { produce: 'strawberry',   count: 3, seedReturn: 2 },
            tomato_seed:     { produce: 'tomato',       count: 2, seedReturn: 2 },
        };

        function harvestPlant(planterBox, slotIndex) {
            const seed = planterBox.userData.seeds[slotIndex];
            if (!seed || !seed.grown) return;

            const map = _harvestMap[seed.type];
            if (!map) return;

            // Give produce
            inventory[map.produce] = (inventory[map.produce] || 0) + map.count;
            // Return seeds so player can replant
            inventory[seed.type] = (inventory[seed.type] || 0) + map.seedReturn;

            // Remove plant mesh
            if (seed.plantMesh) {
                planterBox.userData.plantContainer.remove(seed.plantMesh);
            }
            // Reset slot
            planterBox.userData.seeds[slotIndex] = null;

            const produceName = itemDisplayNames[map.produce] || map.produce;
            showMessage(`\u2705 Harvested ${map.count}x ${produceName} + ${map.seedReturn} seed(s)!`);
            playCollectSound();
            updateUI();

            // Refresh planter UI if open
            if (currentPlanterBox === planterBox) updatePlanterDisplay();
        }

        function updateStorageDisplay() {
            if (!currentStorageBox) return;
            
            const grid = document.getElementById('storage-grid');
            grid.innerHTML = '';
            
            const storageInventory = currentStorageBox.userData.storageInventory;
            // Use actual capacity from the inventory array (20 for large, 10 for small)
            const slotCount = storageInventory ? storageInventory.length : 26;
            
            for (let i = 0; i < slotCount; i++) {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                slot.dataset.slotIndex = i;
                slot.dataset.slotType = 'storage';
                
                const itemData = storageInventory[i];
                
                if (itemData && itemData.name && itemData.count > 0) {
                    const icon = itemIcons[itemData.name] || '\u2753';
                    
                    slot.innerHTML = `
                        <div class="inventory-slot-icon">${icon}</div>
                        <div class="inventory-slot-name">${itemData.name}</div>
                        <div class="inventory-slot-count">${itemData.count}</div>
                    `;
                    slot.dataset.itemName = itemData.name;
                    slot.draggable = true;
                } else {
                    slot.innerHTML = '<div class="inventory-slot-empty">+</div>';
                }
                
                // Drag events
                slot.addEventListener('dragstart', handleDragStart);
                slot.addEventListener('dragover', handleDragOver);
                slot.addEventListener('drop', handleDrop);
                slot.addEventListener('dragend', handleDragEnd);
                slot.addEventListener('dragleave', handleDragLeave);
                
                // Ctrl+click: move full stack to player inventory
                if (itemData && itemData.name) {
                    slot.addEventListener('click', (e) => {
                        if (e.ctrlKey) {
                            ctrlClickMoveStack('storage', i, itemData.name);
                        }
                    });
                    slot.title = 'Ctrl+click to move stack to inventory';
                }
                
                grid.appendChild(slot);
            }
        }
        
        function toggleInventory() {
            const panel = document.getElementById('inventory-panel');
            const isVisible = panel.style.display === 'block';
            
            if (isVisible) {
                panel.style.display = 'none';
                panel.style.left = '';
                panel.style.right = '';
                panel.style.top = '';
                panel.style.transform = '';
                // Also close any station menus that were open alongside inventory
                const recyclerMenu = document.getElementById('recycler-menu');
                if (recyclerMenu.style.display === 'block') {
                    recyclerMenu.style.display = 'none';
                }
                const furnaceMenu = document.getElementById('furnace-menu');
                if (furnaceMenu.style.display === 'block') {
                    furnaceMenu.style.display = 'none';
                    furnaceMenu.style.left = '';
                    furnaceMenu.style.transform = '';
                    currentFurnace = null;
                }
                const campfireMenu = document.getElementById('campfire-menu');
                if (campfireMenu.style.display === 'block') {
                    campfireMenu.style.display = 'none';
                    campfireMenu.style.left = '';
                    campfireMenu.style.transform = '';
                    currentCampfire = null;
                }
                // Also close storage box if it was open alongside inventory
                const storagePanel = document.getElementById('storage-panel');
                if (storagePanel.style.display === 'block') {
                    storagePanel.style.display = 'none';
                    currentStorageBox = null;
                    // openStorageBox called uiOpen() once for both panels, so one uiClose() below covers both
                }
                uiClose();
            } else {
                panel.style.left = '';
                panel.style.right = '';
                panel.style.top = '';
                panel.style.transform = '';
                panel.style.display = 'block';
                document.getElementById('crafting-menu').style.display = 'none';
                document.getElementById('workbench-menu').style.display = 'none';
                document.getElementById('furnace-menu').style.display = 'none';
                uiOpen();
                updateInventoryDisplay();
            }
        }
        
        // Ctrl+click: move entire stack to the other open container
        function ctrlClickMoveStack(fromType, fromSlotIndex, itemName) {
            if (!itemName) return;
            
            if (fromType === 'inventory' && currentStorageBox) {
                // Move entire stack from inventory to storage
                const count = inventory[itemName] || 0;
                if (count <= 0) return;
                const storageInv = currentStorageBox.userData.storageInventory;
                // Find matching slot or empty slot
                let placed = false;
                for (let i = 0; i < storageInv.length; i++) {
                    if (storageInv[i] && storageInv[i].name === itemName) {
                        storageInv[i].count += count;
                        placed = true;
                        break;
                    }
                }
                if (!placed) {
                    for (let i = 0; i < storageInv.length; i++) {
                        if (!storageInv[i]) {
                            storageInv[i] = { name: itemName, count: count };
                            placed = true;
                            break;
                        }
                    }
                }
                if (placed) {
                    inventory[itemName] = 0;
                    inventorySlots[fromSlotIndex] = null;
                    updateStorageDisplay();
                    updateInventoryDisplay();
                    updateHotbar();
                    playInventoryMoveSound();
                } else {
                    showMessage('\u26a0\ufe0f Storage is full!');
                }
            } else if (fromType === 'storage' && currentStorageBox) {
                // Move entire stack from storage to inventory
                const storageInv = currentStorageBox.userData.storageInventory;
                const slotData = storageInv[fromSlotIndex];
                if (!slotData) return;
                const count = slotData.count;
                // Find matching inventory slot or empty slot
                let placed = false;
                if (inventorySlots.some(s => s === slotData.name)) {
                    if (!inventory[slotData.name]) inventory[slotData.name] = 0;
                    inventory[slotData.name] += count;
                    storageInv[fromSlotIndex] = null;
                    placed = true;
                } else {
                    const emptyIdx = inventorySlots.findIndex(s => s === null);
                    if (emptyIdx !== -1) {
                        if (!inventory[slotData.name]) inventory[slotData.name] = 0;
                        inventory[slotData.name] += count;
                        inventorySlots[emptyIdx] = slotData.name;
                        storageInv[fromSlotIndex] = null;
                        placed = true;
                    }
                }
                if (placed) {
                    updateStorageDisplay();
                    updateInventoryDisplay();
                    updateHotbar();
                    playInventoryMoveSound();
                } else {
                    showMessage('\u26a0\ufe0f Inventory is full!');
                }
            }
        }

        function updateInventoryDisplay() {
            const grid = document.getElementById('inventory-grid');
            grid.innerHTML = '';
            
            // Sync inventory slots with actual inventory
            for (let i = 0; i < inventorySlots.length; i++) {
                if (inventorySlots[i] && inventory[inventorySlots[i]] <= 0) {
                    inventorySlots[i] = null;
                    inventorySlotCounts[i] = null;
                }
                // Clear stale per-slot counts that exceed the global total
                if (inventorySlots[i] && inventorySlotCounts[i] !== null) {
                    if (inventorySlotCounts[i] <= 0) {
                        inventorySlotCounts[i] = null;
                        inventorySlots[i] = null;
                    }
                }
            }

            // Create slots
            for (let i = 0; i < 18; i++) {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                slot.dataset.slotIndex = i;
                slot.dataset.slotType = 'inventory';
                
                const itemName = inventorySlots[i];
                
                if (itemName && inventory[itemName] > 0) {
                    // Use per-slot count if this is a split stack, else use global total
                    const count = getInvSlotCount(i);
                    const icon = getItemIcon(itemName);
                    
                    slot.innerHTML = `
                        <div class="inventory-slot-icon">${icon}</div>
                        <div class="inventory-slot-name">${itemName}</div>
                        <div class="inventory-slot-count">${count}</div>
                    `;
                    slot.dataset.itemName = itemName;
                    slot.draggable = true;
                } else {
                    slot.innerHTML = '<div class="inventory-slot-empty">+</div>';
                }
                
                // Drag events
                slot.addEventListener('dragstart', handleDragStart);
                slot.addEventListener('dragover', handleDragOver);
                slot.addEventListener('drop', handleDrop);
                slot.addEventListener('dragend', handleDragEnd);
                slot.addEventListener('dragleave', handleDragLeave);
                
                // Double-click handler for armor and recycler
                if (itemName) {
                    slot.addEventListener('dblclick', () => {
                        // Check if it's armor/backpack
                        if (armorSlotMapping[itemName]) {
                            equipArmor(itemName);
                        }
                        // Double-click non-armor item → move to equipped backpack if available
                        else if (getBackpackExtraSlots() > 0 && itemName !== 'small_backpack' && itemName !== 'large_backpack') {
                            const freeIdx = backpackSlots.findIndex(s => s === null);
                            if (freeIdx !== -1) {
                                const count = getInvSlotCount(i);
                                inventory[itemName] = Math.max(0, (inventory[itemName] || 0) - count);
                                if (inventory[itemName] <= 0) inventorySlots[i] = null;
                                backpackSlots[freeIdx] = { item: itemName, count };
                                updateInventoryDisplay();
                            } else {
                                showMessage('❌ Backpack is full!');
                            }
                        }
                        // Or if recycler is open
                        else if (currentRecycler) {
                            addItemToRecycler(itemName);
                        }
                    });
                    
                    // Ctrl+click: move full stack to storage (if open)
                    slot.addEventListener('click', (e) => {
                        if (e.ctrlKey && currentStorageBox) {
                            ctrlClickMoveStack('inventory', i, itemName);
                        }
                    });
                    
                    if (armorSlotMapping[itemName]) {
                        slot.style.cursor = 'pointer';
                        slot.title = 'Double-click to equip';
                    } else if (currentRecycler) {
                        slot.style.cursor = 'pointer';
                        slot.title = 'Double-click to add to recycler';
                    } else if (currentStorageBox) {
                        slot.title = 'Ctrl+click to move stack to storage';
                    }
                }
                
                grid.appendChild(slot);
            }
            
            // Update armor display
            updateArmorDisplay();

            // Render backpack extra slots
            renderBackpackSlots();
        }

        function renderBackpackSlots() {
            const panel = document.getElementById('backpack-slots-panel');
            const grid  = document.getElementById('backpack-slots-grid');
            const label = document.getElementById('backpack-slots-label');
            const size  = getBackpackExtraSlots();

            if (size === 0) {
                panel.style.display = 'none';
                return;
            }
            panel.style.display = 'block';
            label.textContent = armorSlots.back === 'large_backpack'
                ? 'Large Backpack (' + size + ' slots)'
                : 'Small Backpack (' + size + ' slots)';

            grid.innerHTML = '';
            for (let i = 0; i < size; i++) {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                slot.dataset.slotIndex = i;
                slot.dataset.slotType  = 'equip-bp';

                const entry = backpackSlots[i] || null;
                if (entry && entry.item && entry.count > 0) {
                    const icon = getItemIcon(entry.item);
                    slot.innerHTML = `
                        <div class="inventory-slot-icon">${icon}</div>
                        <div class="inventory-slot-name">${entry.item}</div>
                        <div class="inventory-slot-count">${entry.count}</div>`;
                    slot.dataset.itemName = entry.item;
                    slot.draggable = true;
                } else {
                    slot.innerHTML = '<div class="inventory-slot-empty">+</div>';
                }

                // Drag-to-backpack support
                slot.addEventListener('dragstart', (e) => {
                    if (!entry) { e.preventDefault(); return; }
                    // Set global drag state so handleDrop on inventory/hotbar slots works
                    draggedItem     = entry.item;
                    draggedFromSlot = i;
                    draggedFromType = 'equip-bp';
                    draggedCtrl     = e.ctrlKey;
                    draggedCount    = e.ctrlKey ? Math.max(1, Math.floor(entry.count / 2)) : entry.count;
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', JSON.stringify({
                        source: 'equip-bp', slotIndex: i,
                        item: entry.item, count: entry.count
                    }));
                    slot.classList.add('dragging');
                });
                slot.addEventListener('dragend', () => {
                    slot.classList.remove('dragging');
                    draggedItem = null; draggedFromSlot = null; draggedFromType = null; draggedCtrl = false; draggedCount = 0;
                    document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                });
                slot.addEventListener('dragover',  (e) => { e.preventDefault(); slot.classList.add('drag-over'); });
                slot.addEventListener('dragleave', () => slot.classList.remove('drag-over'));
                slot.addEventListener('drop', (e) => {
                    e.preventDefault();
                    slot.classList.remove('drag-over');
                    try {
                        const data = JSON.parse(e.dataTransfer.getData('text/plain'));
                        handleBackpackDrop(data, i);
                    } catch(err) {}
                });

                // Double-click: move item back to main inventory
                if (entry) {
                    slot.addEventListener('dblclick', () => {
                        const emptyMain = inventorySlots.findIndex(s => s === null);
                        if (emptyMain === -1) { showMessage('❌ Main inventory is full!'); return; }
                        inventory[entry.item] = (inventory[entry.item] || 0) + entry.count;
                        inventorySlots[emptyMain] = entry.item;
                        backpackSlots[i] = null;
                        updateInventoryDisplay();
                    });
                }

                grid.appendChild(slot);
            }
        }

        function handleBackpackDrop(data, targetBpIdx) {
            const bpSize = getBackpackExtraSlots();
            if (bpSize === 0) return;

            if (data.source === 'inventory') {
                // Move from main inventory → backpack slot
                const srcSlot = data.slotIndex;
                const item    = data.item || inventorySlots[srcSlot];
                const count   = data.count || getInvSlotCount(srcSlot);
                if (!item || count <= 0) return;

                const existing = backpackSlots[targetBpIdx];
                if (existing) {
                    // Swap
                    const emptyMain = inventorySlots.findIndex(s => s === null);
                    if (emptyMain === -1) { showMessage('❌ Main inventory is full for swap!'); return; }
                    inventory[existing.item] = (inventory[existing.item] || 0) + existing.count;
                    inventorySlots[emptyMain] = existing.item;
                }
                // Place into backpack
                inventory[item] -= count;
                if (inventory[item] <= 0) { inventory[item] = 0; inventorySlots[srcSlot] = null; inventorySlotCounts[srcSlot] = null; }
                backpackSlots[targetBpIdx] = { item, count };
                updateInventoryDisplay();

            } else if (data.source === 'equip-bp') {
                // Swap within backpack
                const srcIdx = data.slotIndex;
                const tmp = backpackSlots[targetBpIdx];
                backpackSlots[targetBpIdx] = backpackSlots[srcIdx];
                backpackSlots[srcIdx] = tmp;
                updateInventoryDisplay();
            }
        }
        
        let draggedCtrl = false;
        let draggedCount = 0; // how many were actually picked up (full or half)

        function handleDragStart(e) {
            if (!e.target.dataset.itemName) return;
            draggedItem = e.target.dataset.itemName;
            draggedFromSlot = parseInt(e.target.dataset.slotIndex);
            draggedFromType = e.target.dataset.slotType;
            draggedCtrl = e.ctrlKey;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            // Set structured data so armor slots can read it on drop
            e.dataTransfer.setData('text/plain', JSON.stringify({
                source: draggedFromType,
                slotIndex: draggedFromSlot,
                item: draggedItem
            }));
            
            // Compute how many we're dragging
            if (draggedFromType === 'inventory' || draggedFromType === 'hotbar') {
                // Use per-slot count if this is a split stack, else use global total
                const total = draggedFromType === 'inventory'
                    ? getInvSlotCount(draggedFromSlot)
                    : (inventory[draggedItem] || 0);
                draggedCount = draggedCtrl ? Math.max(1, Math.floor(total / 2)) : total;
            } else if (draggedFromType === 'storage' && currentStorageBox) {
                const storageInv = currentStorageBox.userData.storageInventory;
                const slotData = storageInv[draggedFromSlot];
                const total = slotData ? slotData.count : 0;
                draggedCount = draggedCtrl ? Math.max(1, Math.floor(total / 2)) : total;
            } else if (draggedFromType === 'equip-bp') {
                const slotData = backpackSlots[draggedFromSlot];
                const total = slotData ? slotData.count : 0;
                draggedCount = draggedCtrl ? Math.max(1, Math.floor(total / 2)) : total;
            } else if (draggedFromType === 'backpack' && currentBackpack) {
                const slotData = (currentBackpack.userData.backpackContents || [])[draggedFromSlot];
                const total = slotData ? slotData.count : 0;
                draggedCount = draggedCtrl ? Math.max(1, Math.floor(total / 2)) : total;
            } else if (draggedFromType === 'furnace-fuel') {
                const state = currentFurnace && currentFurnace.userData.smeltingState;
                const total = state ? (state.fuelCount || 0) : 0;
                draggedCount = draggedCtrl ? Math.max(1, Math.floor(total / 2)) : total;
            } else if (draggedFromType === 'campfire-fuel') {
                const state = currentCampfire && currentCampfire.userData.smeltingState;
                const total = state ? (state.fuelCount || 0) : 0;
                draggedCount = draggedCtrl ? Math.max(1, Math.floor(total / 2)) : total;
            } else {
                draggedCount = inventory[draggedItem] || 0;
            }
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            if (!e.currentTarget.classList.contains('dragging')) {
                e.currentTarget.classList.add('drag-over');
            }
        }
        
        function handleDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }
        
        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');
            
            if (!draggedItem) return;
            
            const dropSlotType = e.currentTarget.dataset.slotType;
            const dropSlotIndex = parseInt(e.currentTarget.dataset.slotIndex);
            
            // How many to move
            const moveCount = draggedCount;
            
            // Handle drag FROM fuel slot → inventory / hotbar / storage
            if (draggedFromType === 'furnace-fuel' || draggedFromType === 'campfire-fuel') {
                const stationType = draggedFromType === 'furnace-fuel' ? 'furnace' : 'campfire';
                if (dropSlotType === 'inventory' || dropSlotType === 'hotbar' || dropSlotType === 'storage') {
                    _returnFuelToSlot(stationType, draggedCount, dropSlotType, dropSlotIndex);
                }
                draggedItem = null; draggedFromSlot = null; draggedFromType = null; draggedCtrl = false; draggedCount = 0;
                return;
            }

            // Handle dropping on equipped backpack slot
            if (dropSlotType === 'equip-bp') {
                const bpSize = getBackpackExtraSlots();
                if (bpSize === 0) { draggedItem = null; draggedFromSlot = null; draggedFromType = null; draggedCount = 0; return; }
                const targetIdx = dropSlotIndex;
                const existing = backpackSlots[targetIdx];
                if (draggedFromType === 'inventory') {
                    const slotTotal = getInvSlotCount(draggedFromSlot);
                    const actual = Math.min(moveCount, slotTotal);
                    if (actual <= 0) { draggedItem = null; draggedFromSlot = null; draggedFromType = null; draggedCount = 0; return; }
                    if (existing) {
                        // Swap: put existing back into inventory slot
                        const freeMain = inventorySlots.findIndex(s => s === null);
                        if (freeMain === -1) { showMessage('❌ Main inventory full for swap!'); draggedItem = null; draggedFromSlot = null; draggedFromType = null; draggedCount = 0; return; }
                        inventory[existing.item] = (inventory[existing.item] || 0) + existing.count;
                        inventorySlots[freeMain] = existing.item;
                    }
                    inventory[draggedItem] = Math.max(0, (inventory[draggedItem] || 0) - actual);
                    if (inventorySlotCounts[draggedFromSlot] !== null) {
                        inventorySlotCounts[draggedFromSlot] = Math.max(0, inventorySlotCounts[draggedFromSlot] - actual);
                        if (inventorySlotCounts[draggedFromSlot] <= 0) { inventorySlotCounts[draggedFromSlot] = null; inventorySlots[draggedFromSlot] = null; }
                    } else {
                        if (inventory[draggedItem] <= 0) inventorySlots[draggedFromSlot] = null;
                    }
                    backpackSlots[targetIdx] = { item: draggedItem, count: actual };
                } else if (draggedFromType === 'equip-bp') {
                    // Swap within backpack
                    const tmp = backpackSlots[targetIdx];
                    backpackSlots[targetIdx] = backpackSlots[draggedFromSlot];
                    backpackSlots[draggedFromSlot] = tmp;
                }
                updateInventoryDisplay();
                draggedItem = null; draggedFromSlot = null; draggedFromType = null; draggedCount = 0;
                return;
            }

            // Handle dropping on storage slot
            if (dropSlotType === 'storage' && currentStorageBox) {
                const storageInv = currentStorageBox.userData.storageInventory;
                
                if (draggedFromType === 'inventory') {
                    const slotTotal = getInvSlotCount(draggedFromSlot);
                    const total = inventory[draggedItem] || 0;
                    const actual = Math.min(moveCount, slotTotal);
                    if (actual <= 0) return;
                    
                    if (storageInv[dropSlotIndex] && storageInv[dropSlotIndex].name === draggedItem) {
                        storageInv[dropSlotIndex].count += actual;
                    } else if (!storageInv[dropSlotIndex]) {
                        storageInv[dropSlotIndex] = { name: draggedItem, count: actual };
                    } else {
                        // Swap — only if moving full stack
                        if (!draggedCtrl) {
                            const swapItem = storageInv[dropSlotIndex];
                            storageInv[dropSlotIndex] = { name: draggedItem, count: actual };
                            if (!inventory[swapItem.name]) inventory[swapItem.name] = 0;
                            inventory[swapItem.name] += swapItem.count;
                            inventorySlots[draggedFromSlot] = swapItem.name;
                            inventorySlotCounts[draggedFromSlot] = null;
                        } else {
                            // Can't split onto occupied different-item slot
                            return;
                        }
                    }
                    inventory[draggedItem] = Math.max(0, total - actual);
                    // Update per-slot count if this was a split slot
                    if (inventorySlotCounts[draggedFromSlot] !== null) {
                        inventorySlotCounts[draggedFromSlot] = Math.max(0, inventorySlotCounts[draggedFromSlot] - actual);
                        if (inventorySlotCounts[draggedFromSlot] <= 0) { inventorySlotCounts[draggedFromSlot] = null; inventorySlots[draggedFromSlot] = null; }
                    } else {
                        if (inventory[draggedItem] <= 0) inventorySlots[draggedFromSlot] = null;
                    }
                    
                } else if (draggedFromType === 'storage') {
                    const srcData = storageInv[draggedFromSlot];
                    if (!srcData) return;
                    const actual = Math.min(moveCount, srcData.count);
                    if (actual <= 0) return;
                    
                    if (storageInv[dropSlotIndex] && storageInv[dropSlotIndex].name === draggedItem) {
                        storageInv[dropSlotIndex].count += actual;
                        srcData.count -= actual;
                        if (srcData.count <= 0) storageInv[draggedFromSlot] = null;
                    } else if (!storageInv[dropSlotIndex]) {
                        storageInv[dropSlotIndex] = { name: draggedItem, count: actual };
                        srcData.count -= actual;
                        if (srcData.count <= 0) storageInv[draggedFromSlot] = null;
                    } else if (!draggedCtrl) {
                        // Full swap
                        const temp = storageInv[dropSlotIndex];
                        storageInv[dropSlotIndex] = storageInv[draggedFromSlot];
                        storageInv[draggedFromSlot] = temp;
                    }
                    
                } else if (draggedFromType === 'hotbar') {
                    const total = inventory[draggedItem] || 0;
                    const actual = Math.min(moveCount, total);
                    if (actual <= 0) return;
                    
                    if (storageInv[dropSlotIndex] && storageInv[dropSlotIndex].name === draggedItem) {
                        storageInv[dropSlotIndex].count += actual;
                    } else if (!storageInv[dropSlotIndex]) {
                        storageInv[dropSlotIndex] = { name: draggedItem, count: actual };
                    } else if (!draggedCtrl) {
                        const swapItem = storageInv[dropSlotIndex];
                        storageInv[dropSlotIndex] = { name: draggedItem, count: actual };
                        if (!inventory[swapItem.name]) inventory[swapItem.name] = 0;
                        inventory[swapItem.name] += swapItem.count;
                        hotbar[draggedFromSlot].item = swapItem.name;
                    } else {
                        return;
                    }
                    inventory[draggedItem] = Math.max(0, total - actual);
                    if (inventory[draggedItem] <= 0) hotbar[draggedFromSlot].item = null;
                }
                
                updateStorageDisplay();
                updateInventoryDisplay();
                updateHotbar();
            }
            // Handle dropping on backpack slot (move item FROM inventory INTO backpack)
            else if (dropSlotType === 'backpack' && currentBackpack) {
                if (draggedFromType === 'inventory') {
                    const contents = currentBackpack.userData.backpackContents || [];
                    const total = inventory[draggedItem] || 0;
                    const actual = Math.min(moveCount, total);
                    if (actual <= 0) return;
                    const existing = contents[dropSlotIndex];
                    if (existing && existing.name === draggedItem) {
                        existing.count += actual;
                    } else if (!existing) {
                        contents[dropSlotIndex] = { name: draggedItem, count: actual };
                    } else { return; }
                    inventory[draggedItem] = Math.max(0, total - actual);
                    updateBackpackDisplay(); updateInventoryDisplay(); updateUI();
                }
            }
            // Handle dropping on inventory slot
            else if (dropSlotType === 'inventory') {
                if (draggedFromType === 'storage' && currentStorageBox) {
                    const storageInv = currentStorageBox.userData.storageInventory;
                    const storageItem = storageInv[draggedFromSlot];
                    if (!storageItem) return;
                    const actual = Math.min(moveCount, storageItem.count);
                    if (actual <= 0) return;
                    
                    if (!inventory[storageItem.name]) inventory[storageItem.name] = 0;
                    
                    if (inventorySlots[dropSlotIndex] === storageItem.name) {
                        // Dropping onto a slot that already has this item
                        inventory[storageItem.name] += actual;
                        if (inventorySlotCounts[dropSlotIndex] !== null) {
                            inventorySlotCounts[dropSlotIndex] += actual;
                        }
                        storageItem.count -= actual;
                        if (storageItem.count <= 0) storageInv[draggedFromSlot] = null;
                    } else if (!inventorySlots[dropSlotIndex]) {
                        inventory[storageItem.name] += actual;
                        inventorySlots[dropSlotIndex] = storageItem.name;
                        // If this item has split stacks, track this new slot too
                        const existingSlots = inventorySlots.map((s,i) => i).filter(i => i !== dropSlotIndex && inventorySlots[i] === storageItem.name);
                        if (existingSlots.length > 0 && inventorySlotCounts[existingSlots[0]] !== null) {
                            inventorySlotCounts[dropSlotIndex] = actual;
                        } else {
                            inventorySlotCounts[dropSlotIndex] = null;
                            clearSplitCounts(storageItem.name); // consolidate
                        }
                        storageItem.count -= actual;
                        if (storageItem.count <= 0) storageInv[draggedFromSlot] = null;
                    } else if (!draggedCtrl) {
                        // Full swap
                        const swapItemName = inventorySlots[dropSlotIndex];
                        inventory[storageItem.name] += actual;
                        inventorySlots[dropSlotIndex] = storageItem.name;
                        if (swapItemName && inventory[swapItemName] > 0) {
                            storageInv[draggedFromSlot] = { name: swapItemName, count: inventory[swapItemName] };
                            inventory[swapItemName] = 0;
                            inventorySlots[draggedFromSlot] = null;
                        } else {
                            storageInv[draggedFromSlot] = null;
                        }
                    }
                    
                    updateStorageDisplay();
                    updateInventoryDisplay();
                } else if (draggedFromType === 'backpack' && currentBackpack) {
                    // Drag from backpack → inventory slot
                    const contents = currentBackpack.userData.backpackContents || [];
                    const item = contents[draggedFromSlot];
                    if (!item || item.count <= 0) return;
                    const actual = Math.min(moveCount, item.count);
                    if (inventory[item.name] === undefined) inventory[item.name] = 0;
                    inventory[item.name] += actual;
                    item.count -= actual;
                    if (item.count <= 0) contents[draggedFromSlot] = null;
                    checkBackpackEmpty(currentBackpack);
                    updateBackpackDisplay();
                    updateInventoryDisplay();
                    updateUI();
                } else if (draggedFromType === 'equip-bp') {
                    // Drag from equipped backpack slot → main inventory slot
                    const srcEntry = backpackSlots[draggedFromSlot];
                    if (!srcEntry) { draggedItem = null; draggedFromSlot = null; draggedFromType = null; draggedCount = 0; return; }
                    const actual = Math.min(draggedCount, srcEntry.count);
                    if (actual <= 0) { draggedItem = null; draggedFromSlot = null; draggedFromType = null; draggedCount = 0; return; }
                    const destItem = inventorySlots[dropSlotIndex];
                    if (destItem && destItem === srcEntry.item) {
                        // Stack onto same item in main inventory
                        inventory[srcEntry.item] = (inventory[srcEntry.item] || 0) + actual;
                        srcEntry.count -= actual;
                        if (srcEntry.count <= 0) backpackSlots[draggedFromSlot] = null;
                    } else if (!destItem) {
                        // Move into empty inventory slot
                        inventory[srcEntry.item] = (inventory[srcEntry.item] || 0) + actual;
                        inventorySlots[dropSlotIndex] = srcEntry.item;
                        inventorySlotCounts[dropSlotIndex] = null;
                        srcEntry.count -= actual;
                        if (srcEntry.count <= 0) backpackSlots[draggedFromSlot] = null;
                    } else {
                        // Swap: move destItem to backpack slot, srcEntry to inventory
                        const destCount = getInvSlotCount(dropSlotIndex);
                        // Put dest item into backpack slot
                        backpackSlots[draggedFromSlot] = { item: destItem, count: destCount };
                        // Remove from inventory
                        inventory[destItem] = Math.max(0, (inventory[destItem] || 0) - destCount);
                        if (inventory[destItem] <= 0) inventorySlots[dropSlotIndex] = null;
                        // Put src item into inventory slot
                        inventorySlots[dropSlotIndex] = srcEntry.item;
                        inventorySlotCounts[dropSlotIndex] = null;
                        inventory[srcEntry.item] = (inventory[srcEntry.item] || 0) + actual;
                        srcEntry.count -= actual;
                        if (srcEntry.count <= 0) backpackSlots[draggedFromSlot] = null;
                    }
                    updateInventoryDisplay();
                    draggedItem = null; draggedFromSlot = null; draggedFromType = null; draggedCount = 0;
                    return;
                } else {
                    if (draggedFromType === 'inventory') {
                        const srcTotal = getInvSlotCount(draggedFromSlot);
                        const destItem = inventorySlots[dropSlotIndex];
                        
                        if (destItem === draggedItem) {
                            // Dropping on same item: merge if split, otherwise just keep slot
                            if (inventorySlotCounts[draggedFromSlot] !== null || inventorySlotCounts[dropSlotIndex] !== null) {
                                // Merge split stacks into destination
                                const srcCount = getInvSlotCount(draggedFromSlot);
                                const dstCount = getInvSlotCount(dropSlotIndex);
                                inventorySlotCounts[dropSlotIndex] = dstCount + srcCount;
                                inventorySlotCounts[draggedFromSlot] = null;
                                inventorySlots[draggedFromSlot] = null;
                            } else {
                                // Same item, no split tracking — just rearrange slot pointers
                                const temp = inventorySlots[dropSlotIndex];
                                inventorySlots[dropSlotIndex] = draggedItem;
                                inventorySlots[draggedFromSlot] = temp;
                            }
                        } else if (!destItem) {
                            if (draggedCtrl && srcTotal > 1) {
                                // SPLIT: move half to empty destination slot
                                const half = Math.max(1, Math.floor(srcTotal / 2));
                                inventorySlotCounts[draggedFromSlot] = srcTotal - half;
                                inventorySlots[dropSlotIndex] = draggedItem;
                                inventorySlotCounts[dropSlotIndex] = half;
                                // Note: inventory[draggedItem] total stays the same — split is visual only
                            } else {
                                // Full move to empty slot
                                inventorySlots[dropSlotIndex] = draggedItem;
                                inventorySlotCounts[dropSlotIndex] = inventorySlotCounts[draggedFromSlot]; // carry split count
                                inventorySlots[draggedFromSlot] = null;
                                inventorySlotCounts[draggedFromSlot] = null;
                            }
                        } else if (!draggedCtrl) {
                            // Full swap with a different item
                            const temp = inventorySlots[dropSlotIndex];
                            const tempCount = inventorySlotCounts[dropSlotIndex];
                            inventorySlots[dropSlotIndex] = draggedItem;
                            inventorySlotCounts[dropSlotIndex] = inventorySlotCounts[draggedFromSlot];
                            inventorySlots[draggedFromSlot] = temp;
                            inventorySlotCounts[draggedFromSlot] = tempCount;
                        }
                        // ctrl+drag onto different item → do nothing (can't split onto occupied slot)
                    } else if (draggedFromType === 'hotbar') {
                        const temp = inventorySlots[dropSlotIndex];
                        inventorySlots[dropSlotIndex] = draggedItem;
                        inventorySlotCounts[dropSlotIndex] = null;
                        hotbar[draggedFromSlot].item = temp;
                    }
                    updateInventoryDisplay();
                    updateHotbar();
                }
            }
            // Handle dropping on hotbar slot
            else if (dropSlotType === 'hotbar') {
                if (draggedFromType === 'storage' && currentStorageBox) {
                    const storageInv = currentStorageBox.userData.storageInventory;
                    const storageItem = storageInv[draggedFromSlot];
                    if (!storageItem) return;
                    const actual = Math.min(moveCount, storageItem.count);
                    
                    if (!inventory[storageItem.name]) inventory[storageItem.name] = 0;
                    inventory[storageItem.name] += actual;
                    hotbar[dropSlotIndex].item = storageItem.name;
                    storageItem.count -= actual;
                    if (storageItem.count <= 0) storageInv[draggedFromSlot] = null;
                    
                    updateStorageDisplay();
                    updateHotbar();
                } else {
                    if (draggedFromType === 'inventory') {
                        const temp = hotbar[dropSlotIndex].item;
                        hotbar[dropSlotIndex].item = draggedItem;
                        inventorySlots[draggedFromSlot] = temp;
                    } else if (draggedFromType === 'hotbar') {
                        const temp = hotbar[dropSlotIndex].item;
                        hotbar[dropSlotIndex].item = draggedItem;
                        hotbar[draggedFromSlot].item = temp;
                    }
                    updateInventoryDisplay();
                    updateHotbar();
                }
            }
            playInventoryMoveSound();
        }
        
        // Helper: remove fuel from a station and return it to an inventory/hotbar/storage target
        function _returnFuelToSlot(stationType, amount, dropSlotType, dropSlotIndex) {
            const isF = stationType === 'furnace';
            const state = isF ? (currentFurnace && currentFurnace.userData.smeltingState)
                               : (currentCampfire && currentCampfire.userData.smeltingState);
            if (!state || !state.fuelItem || state.fuelCount <= 0) return false;
            const actual = Math.min(amount, state.fuelCount);
            if (actual <= 0) return false;
            const fuelName = state.fuelItem;
            
            if (dropSlotType === 'inventory') {
                // Drop FROM equipped backpack → main inventory
                if (draggedFromType === 'equip-bp') {
                    const srcEntry = backpackSlots[draggedFromSlot];
                    if (!srcEntry) { draggedItem = null; draggedFromSlot = null; draggedFromType = null; draggedCount = 0; return; }
                    const destItem = inventorySlots[dropSlotIndex];
                    if (destItem) {
                        // Swap
                        backpackSlots[draggedFromSlot] = { item: destItem, count: getInvSlotCount(dropSlotIndex) };
                        inventory[destItem] = Math.max(0, (inventory[destItem] || 0) - getInvSlotCount(dropSlotIndex));
                        inventorySlots[dropSlotIndex] = srcEntry.item;
                        inventory[srcEntry.item] = (inventory[srcEntry.item] || 0) + srcEntry.count;
                    } else {
                        inventorySlots[dropSlotIndex] = srcEntry.item;
                        inventory[srcEntry.item] = (inventory[srcEntry.item] || 0) + srcEntry.count;
                        backpackSlots[draggedFromSlot] = null;
                    }
                    updateInventoryDisplay();
                    draggedItem = null; draggedFromSlot = null; draggedFromType = null; draggedCount = 0;
                    return;
                }
                if (!inventory[fuelName]) inventory[fuelName] = 0;
                inventory[fuelName] += actual;
                if (!inventorySlots.includes(fuelName)) {
                    const empty = inventorySlots.findIndex(s => s === null);
                    if (empty !== -1) inventorySlots[empty] = fuelName;
                }
                clearSplitCounts(fuelName);
                updateInventoryDisplay();
            } else if (dropSlotType === 'hotbar') {
                if (!inventory[fuelName]) inventory[fuelName] = 0;
                inventory[fuelName] += actual;
                hotbar[dropSlotIndex].item = fuelName;
                updateHotbar();
            } else if (dropSlotType === 'storage' && currentStorageBox) {
                const storageInv = currentStorageBox.userData.storageInventory;
                let placed = false;
                for (let i = 0; i < storageInv.length; i++) {
                    if (storageInv[i] && storageInv[i].name === fuelName) { storageInv[i].count += actual; placed = true; break; }
                }
                if (!placed) {
                    for (let i = 0; i < storageInv.length; i++) {
                        if (!storageInv[i]) { storageInv[i] = { name: fuelName, count: actual }; placed = true; break; }
                    }
                }
                updateStorageDisplay();
            }
            
            state.fuelCount -= actual;
            if (state.fuelCount <= 0) { state.fuelCount = 0; state.fuelItem = null; }
            updateSmeltingDisplay(stationType);
            return true;
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('.drag-over').forEach(el => {
                el.classList.remove('drag-over');
            });
            draggedItem = null;
            draggedFromSlot = null;
            draggedFromType = null;
            draggedCtrl = false;
            draggedCount = 0;
        }
        
        function updateInventoryUI() {
            // Sync new items into empty slots
            for (let itemName in inventory) {
                if (inventory[itemName] > 0) {
                    const slotsForItem = inventorySlots.map((s, i) => i).filter(i => inventorySlots[i] === itemName);
                    const inHotbar = hotbar.some(slot => slot.item === itemName);
                    if (slotsForItem.length === 0 && !inHotbar) {
                        // No slot yet — place in first empty slot, consolidate any split counts
                        clearSplitCounts(itemName);
                        const emptyIndex = inventorySlots.findIndex(slot => slot === null);
                        if (emptyIndex !== -1) {
                            inventorySlots[emptyIndex] = itemName;
                        } else {
                            // Main inventory full — overflow new items into equipped backpack
                            const freeBpIdx = backpackSlots.findIndex(s => s === null);
                            if (freeBpIdx !== -1) {
                                const overflowCount = inventory[itemName];
                                backpackSlots[freeBpIdx] = { item: itemName, count: overflowCount };
                                inventory[itemName] = 0; // remove from main inventory dict (it's in BP now)
                            }
                        }
                    } else if (slotsForItem.length > 0) {
                        // Item already has slots. Check if counts are tracked and total has changed
                        const tracked = slotsForItem.filter(i => inventorySlotCounts[i] !== null);
                        if (tracked.length > 0) {
                            const trackedTotal = tracked.reduce((s, i) => s + inventorySlotCounts[i], 0);
                            const untrackedSlots = slotsForItem.filter(i => inventorySlotCounts[i] === null);
                            if (trackedTotal > inventory[itemName]) {
                                // Items were removed: scale down proportionally
                                const scale = inventory[itemName] / trackedTotal;
                                let remaining = inventory[itemName];
                                tracked.forEach((idx, j) => {
                                    if (j === tracked.length - 1) {
                                        inventorySlotCounts[idx] = remaining;
                                    } else {
                                        const newCount = Math.floor(inventorySlotCounts[idx] * scale);
                                        inventorySlotCounts[idx] = newCount;
                                        remaining -= newCount;
                                    }
                                    if (inventorySlotCounts[idx] <= 0) {
                                        inventorySlotCounts[idx] = null;
                                        inventorySlots[idx] = null;
                                    }
                                });
                            } else if (trackedTotal < inventory[itemName] && untrackedSlots.length === 0) {
                                // Items were added and no untracked slot — consolidate all into first slot (clear split)
                                clearSplitCounts(itemName);
                                // Remove duplicate slots, keep only first
                                for (let j = 1; j < slotsForItem.length; j++) {
                                    inventorySlots[slotsForItem[j]] = null;
                                }
                            }
                        }
                    }
                }
            }
            
            if (document.getElementById('inventory-panel').style.display === 'block') {
                updateInventoryDisplay();
            }
        }
        
        // Make inventory draggable \ufffd header + all edge handles
        let isDraggingInventory = false;
        let inventoryOffset = { x: 0, y: 0 };

        function startInventoryDrag(e) {
            isDraggingInventory = true;
            const panel = document.getElementById('inventory-panel');
            const rect = panel.getBoundingClientRect();
            panel.style.transform = 'none';
            panel.style.left = rect.left + 'px';
            panel.style.top  = rect.top  + 'px';
            inventoryOffset.x = e.clientX - rect.left;
            inventoryOffset.y = e.clientY - rect.top;
            e.preventDefault();
        }

        document.getElementById('inventory-header').addEventListener('mousedown', startInventoryDrag);
        document.querySelectorAll('#inventory-panel .drag-edge').forEach(el => {
            el.addEventListener('mousedown', startInventoryDrag);
        });
        
        document.getElementById('close-inventory').addEventListener('click', toggleInventory);

        // ── Trash slot: drop to permanently delete items ─────────────────
        (function() {
            const trashSlot = document.getElementById('inventory-trash-slot');
            trashSlot.addEventListener('dragover', (e) => {
                if (!draggedItem) return;
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                trashSlot.classList.add('drag-over');
            });
            trashSlot.addEventListener('dragleave', () => trashSlot.classList.remove('drag-over'));
            trashSlot.addEventListener('drop', (e) => {
                e.preventDefault();
                trashSlot.classList.remove('drag-over');
                if (!draggedItem) return;
                const item = draggedItem;
                const fromSlot = draggedFromSlot;
                const fromType = draggedFromType;
                const count = draggedCount || (inventory[item] || 0);

                if (fromType === 'inventory') {
                    // Remove from inventory slot
                    inventory[item] = Math.max(0, (inventory[item] || 0) - count);
                    if (inventory[item] <= 0) {
                        inventory[item] = 0;
                        if (fromSlot !== null && fromSlot !== undefined) {
                            inventorySlots[fromSlot] = null;
                            inventorySlotCounts[fromSlot] = null;
                        }
                        // Clear any other slots holding this item
                        for (let i = 0; i < inventorySlots.length; i++) {
                            if (inventorySlots[i] === item) { inventorySlots[i] = null; inventorySlotCounts[i] = null; }
                        }
                    }
                } else if (fromType === 'hotbar') {
                    inventory[item] = Math.max(0, (inventory[item] || 0) - count);
                    if (inventory[item] <= 0) {
                        inventory[item] = 0;
                        // Clear hotbar slot
                        for (let h = 0; h < hotbar.length; h++) {
                            if (hotbar[h].item === item) { hotbar[h].item = null; break; }
                        }
                    }
                } else if (fromType === 'storage' && currentStorageBox) {
                    const si = currentStorageBox.userData.storageInventory;
                    if (fromSlot !== null && si[fromSlot]) {
                        si[fromSlot].count -= count;
                        if (si[fromSlot].count <= 0) si[fromSlot] = null;
                    }
                    updateStorageDisplay();
                }

                draggedItem = null; draggedFromSlot = null; draggedFromType = null; draggedCount = 0;
                showMessage('🗑️ Item deleted');
                updateInventoryDisplay();
                updateHotbar();
                updateUI();
            });
        })();
        document.getElementById('close-storage').addEventListener('click', closeStorageBox);
        document.getElementById('close-planter').addEventListener('click', closePlanterBox);
        document.getElementById('close-backpack').addEventListener('click', closeBackpack);
        document.getElementById('close-junkpile').addEventListener('click', () => { document.getElementById('junkpile-panel').style.display = 'none'; uiClose(); });

        document.getElementById('junkpile-take-all').addEventListener('click', () => {
            if (!currentJunkPile || currentJunkPile.userData.looted) return;
            const taken = [];
            currentJunkPile.userData.loot.forEach((slot, i) => {
                if (!slot) return;
                inventory[slot.item] = (inventory[slot.item] || 0) + slot.count;
                taken.push(`${slot.count > 1 ? slot.count + 'x ' : ''}${getItemDisplayName(slot.item)}`);
                currentJunkPile.userData.loot[i] = null;
            });
            if (taken.length === 0) return;
            updateUI();
            updateInventoryDisplay();
            showMessage(`✅ Took: ${taken.join(', ')}`);
            _markJunkLooted(currentJunkPile);
            document.getElementById('junkpile-panel').style.display = 'none';
            uiClose();
        });
        
        // Make storage panel draggable
        let isDraggingStorage = false;
        let storageOffset = { x: 0, y: 0 };
        
        document.getElementById('storage-header').addEventListener('mousedown', (e) => {
            isDraggingStorage = true;
            const panel = document.getElementById('storage-panel');
            const rect = panel.getBoundingClientRect();
            storageOffset.x = e.clientX - rect.left;
            storageOffset.y = e.clientY - rect.top;
        });

        // Planter panel drag
        let isDraggingPlanter = false;
        let planterOffset = { x: 0, y: 0 };
        document.getElementById('planter-header').addEventListener('mousedown', (e) => {
            isDraggingPlanter = true;
            const panel = document.getElementById('planter-panel');
            const rect = panel.getBoundingClientRect();
            planterOffset.x = e.clientX - rect.left;
            planterOffset.y = e.clientY - rect.top;
        });
        
        document.addEventListener('mousemove', (e) => {
            if (isDraggingInventory) {
                const panel = document.getElementById('inventory-panel');
                panel.style.left = (e.clientX - inventoryOffset.x) + 'px';
                panel.style.top = (e.clientY - inventoryOffset.y) + 'px';
                panel.style.transform = 'none';
            }
            if (isDraggingStorage) {
                const panel = document.getElementById('storage-panel');
                panel.style.left = (e.clientX - storageOffset.x) + 'px';
                panel.style.top = (e.clientY - storageOffset.y) + 'px';
                panel.style.transform = 'none';
            }
            if (isDraggingPlanter) {
                const panel = document.getElementById('planter-panel');
                panel.style.left = (e.clientX - planterOffset.x) + 'px';
                panel.style.top = (e.clientY - planterOffset.y) + 'px';
                panel.style.transform = 'none';
            }
        });
        
        document.addEventListener('mouseup', () => {
            isDraggingInventory = false;
            isDraggingStorage = false;
            isDraggingPlanter = false;
            machineGunState.isFiring = false;
            machineGunState.shotsFired = 0;
        });
        
        // Armor slot event listeners — click to unequip, drag to swap
        document.querySelectorAll('.armor-slot').forEach(slot => {
            const slotName = slot.dataset.slot;

            // Click to unequip
            slot.addEventListener('click', () => {
                if (armorSlots[slotName]) unequipArmor(slotName);
            });

            // Drag OUT of armor slot
            slot.addEventListener('dragstart', (e) => {
                const item = armorSlots[slotName];
                if (!item) { e.preventDefault(); return; }
                // Block dragging backpack out while full
                if (slotName === 'back' && !isBackpackEmpty()) {
                    e.preventDefault();
                    showMessage('❌ Empty your backpack before moving it!');
                    return;
                }
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', JSON.stringify({
                    source: 'armor', armorSlot: slotName, item
                }));
                slot.classList.add('dragging');
            });
            slot.draggable = true; // always draggable; dragstart guards empty slots

            slot.addEventListener('dragend', () => slot.classList.remove('dragging'));

            // Drag INTO armor slot
            slot.addEventListener('dragover', (e) => {
                e.preventDefault();
                // Peek at what's being dragged to show valid/invalid indicator
                slot.classList.remove('drag-invalid');
                slot.classList.add('drag-over');
            });

            slot.addEventListener('dragleave', () => {
                slot.classList.remove('drag-over', 'drag-invalid');
            });

            slot.addEventListener('drop', (e) => {
                e.preventDefault();
                slot.classList.remove('drag-over', 'drag-invalid');
                let data;
                try { data = JSON.parse(e.dataTransfer.getData('text/plain')); } catch { return; }

                const targetSlotName = slotName;

                if (data.source === 'inventory') {
                    // Dragging from inventory → armor slot
                    const item = data.item || inventorySlots[data.slotIndex];
                    if (!item) return;
                    const expectedSlot = armorSlotMapping[item];
                    if (expectedSlot !== targetSlotName) {
                        showMessage(`❌ That item doesn't go in the ${targetSlotName} slot!`);
                        return;
                    }
                    // If slot already occupied, swap it back to inventory
                    if (armorSlots[targetSlotName]) {
                        const displaced = armorSlots[targetSlotName];
                        inventory[displaced] = (inventory[displaced] || 0) + 1;
                        // Put displaced item in the source inventory slot
                        inventorySlots[data.slotIndex] = displaced;
                        armorSlots[targetSlotName] = null;
                    } else {
                        // Clear source inventory slot
                        const count = getInvSlotCount(data.slotIndex);
                        inventory[item] = Math.max(0, (inventory[item] || 0) - 1);
                        if (inventory[item] <= 0 || count <= 1) {
                            inventorySlots[data.slotIndex] = null;
                            inventorySlotCounts[data.slotIndex] = null;
                        } else if (inventorySlotCounts[data.slotIndex] !== null) {
                            inventorySlotCounts[data.slotIndex]--;
                        }
                    }
                    // Actually consume 1 from inventory and equip
                    inventory[item] = Math.max(0, (inventory[item] || 0) - 1);
                    armorSlots[targetSlotName] = item;
                    if (targetSlotName === 'back') syncBackpackSlots();
                    updateUI(); updateInventoryDisplay(); updateArmorDisplay();

                } else if (data.source === 'armor') {
                    // Dragging from one armor slot → another armor slot (swap)
                    const srcSlotName = data.armorSlot;
                    const srcItem = data.item;
                    const dstItem = armorSlots[targetSlotName];

                    // Validate srcItem fits targetSlot and dstItem fits srcSlot
                    if (armorSlotMapping[srcItem] !== targetSlotName) {
                        showMessage(`❌ ${getItemDisplayName(srcItem)} doesn't go in the ${targetSlotName} slot!`);
                        return;
                    }
                    if (dstItem && armorSlotMapping[dstItem] !== srcSlotName) {
                        showMessage(`❌ Can't swap — items don't match slots!`);
                        return;
                    }
                    // Swap
                    armorSlots[targetSlotName] = srcItem;
                    armorSlots[srcSlotName] = dstItem || null;
                    if (targetSlotName === 'back' || srcSlotName === 'back') syncBackpackSlots();
                    updateUI(); updateInventoryDisplay(); updateArmorDisplay();
                }
            });
        });

        // Also handle drops FROM armor slots onto inventory slots
        // Patch handleDrop to accept source === 'armor'
        const _origHandleDrop = handleDrop;
        handleDrop = function(e) {
            // Check if drag originated from armor slot
            let data;
            try { data = JSON.parse(e.dataTransfer.getData('text/plain')); } catch { data = null; }
            if (data && data.source === 'armor') {
                e.preventDefault();
                e.currentTarget.classList.remove('drag-over');
                const srcSlotName = data.armorSlot;
                const item = data.item;
                const dropType = e.currentTarget.dataset.slotType;
                const dropIdx  = parseInt(e.currentTarget.dataset.slotIndex);

                if (dropType === 'inventory') {
                    // Block if backpack and not empty
                    if (srcSlotName === 'back' && !isBackpackEmpty()) {
                        showMessage('❌ Empty your backpack before removing it!');
                        return;
                    }
                    const displaced = inventorySlots[dropIdx];
                    if (displaced && armorSlotMapping[displaced] === srcSlotName) {
                        // Swap displaced armor piece into the armor slot
                        armorSlots[srcSlotName] = displaced;
                        inventory[displaced] = Math.max(0, (inventory[displaced] || 0) - 1);
                        inventorySlots[dropIdx] = item;
                        inventory[item] = (inventory[item] || 0) + 1;
                    } else if (!displaced) {
                        armorSlots[srcSlotName] = null;
                        if (srcSlotName === 'back') syncBackpackSlots();
                        inventory[item] = (inventory[item] || 0) + 1;
                        inventorySlots[dropIdx] = item;
                    } else {
                        // Occupied by incompatible item — find first empty slot instead
                        const emptySlot = inventorySlots.findIndex(s => s === null);
                        if (emptySlot !== -1) {
                            armorSlots[srcSlotName] = null;
                            if (srcSlotName === 'back') syncBackpackSlots();
                            inventory[item] = (inventory[item] || 0) + 1;
                            inventorySlots[emptySlot] = item;
                        } else {
                            showMessage('❌ Inventory is full!');
                            return;
                        }
                    }
                    if (srcSlotName === 'back') syncBackpackSlots();
                    updateUI(); updateInventoryDisplay(); updateArmorDisplay();
                }
                return;
            }
            // Otherwise fall through to original handler
            _origHandleDrop.call(this, e);
        };

        
        function updateHotbar() {
            const hotbarEl = document.getElementById('hotbar');
            hotbarEl.innerHTML = '';
            
            hotbar.forEach((slot, index) => {
                const slotEl = document.createElement('div');
                slotEl.className = 'hotbar-slot' + (index === selectedHotbarSlot ? ' selected' : '');
                slotEl.dataset.hotbarIndex = index;
                slotEl.dataset.slotIndex = index;
                slotEl.dataset.slotType = 'hotbar';
                
                let itemIcon = '';
                let itemCount = '';
                
                if (slot.item && inventory[slot.item] > 0) {
                    itemIcon = getItemIcon(slot.item);
                    itemCount = inventory[slot.item];
                    slotEl.dataset.itemName = slot.item;
                    slotEl.draggable = true;
                } else if (slot.item && inventory[slot.item] === 0) {
                    // Clear slot if item count is 0
                    slot.item = null;
                }
                
                slotEl.innerHTML = `
                    <div class="hotbar-slot-number">${index + 1}</div>
                    <div class="hotbar-slot-icon">${itemIcon}</div>
                    ${itemCount ? `<div class="hotbar-slot-count">${itemCount}</div>` : ''}
                `;
                
                // Hover to show item name
                slotEl.addEventListener('mouseenter', () => {
                    if (slot.item) {
                        showHotbarTooltip(slot.item);
                    }
                });
                
                slotEl.addEventListener('mouseleave', () => {
                    hideHotbarTooltip();
                });
                
                // Allow dragging and dropping
                slotEl.addEventListener('dragstart', handleDragStart);
                slotEl.addEventListener('dragover', handleDragOver);
                slotEl.addEventListener('drop', handleDrop);
                slotEl.addEventListener('dragleave', handleDragLeave);
                slotEl.addEventListener('dragend', handleDragEnd);
                
                slotEl.onclick = () => {
                    selectedHotbarSlot = index;
                    updateHotbar();
                    updateHeldItem();
                };
                
                // Right click to remove from hotbar
                slotEl.oncontextmenu = (e) => {
                    e.preventDefault();
                    if (slot.item) {
                        showMessage(`Removed ${slot.item} from hotbar`);
                        slot.item = null;
                        updateHotbar();
                    }
                };
                
                hotbarEl.appendChild(slotEl);
            });
        }
        
        function showHotbarTooltip(itemName) {
            const tooltip = document.getElementById('hotbar-tooltip');
            
            // Get formatted display name
            const formattedName = getItemDisplayName(itemName);
            
            // Get item icon — may be SVG string, so use innerHTML not textContent
            const icon = getItemIcon(itemName);
            
            tooltip.innerHTML = `<span style="display:inline-flex;align-items:center;vertical-align:middle;width:22px;height:22px;margin-right:6px;">${icon}</span><span>${formattedName}</span>`;
            tooltip.classList.add('visible');
        }
        
        function hideHotbarTooltip() {
            const tooltip = document.getElementById('hotbar-tooltip');
            tooltip.classList.remove('visible');
        }
        
        function showMessage(text) {
            const msg = document.getElementById('message');
            msg.textContent = text;
            msg.style.display = 'block';
            setTimeout(() => {
                msg.style.display = 'none';
            }, 3000);
        }
        
        // ===== MINIMAP =====
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        minimapCanvas.width = 180;
        minimapCanvas.height = 180;
        
        function updateMinimap() {
            minimapCtx.fillStyle = 'rgba(40, 90, 30, 0.9)';
            minimapCtx.fillRect(0, 0, 180, 180);
            
            const scale = 1.5;
            const centerX = 90;
            const centerY = 90;
            
            // Draw trees
            minimapCtx.fillStyle = 'rgba(0, 100, 0, 0.7)';
            trees.forEach(tree => {
                const x = centerX + (tree.position.x - camera.position.x) * scale;
                const y = centerY + (tree.position.z - camera.position.z) * scale;
                if (x >= 0 && x <= 180 && y >= 0 && y <= 180) {
                    minimapCtx.beginPath();
                    minimapCtx.arc(x, y, 3, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
            });
            
            // Draw rocks
            minimapCtx.fillStyle = 'rgba(128, 128, 128, 0.7)';
            rocks.forEach(rock => {
                const x = centerX + (rock.position.x - camera.position.x) * scale;
                const y = centerY + (rock.position.z - camera.position.z) * scale;
                if (x >= 0 && x <= 180 && y >= 0 && y <= 180) {
                    minimapCtx.fillRect(x - 2, y - 2, 4, 4);
                }
            });
            
            // Draw enemies
            minimapCtx.fillStyle = 'rgba(255, 0, 0, 0.9)';
            enemies.forEach(enemy => {
                const x = centerX + (enemy.position.x - camera.position.x) * scale;
                const y = centerY + (enemy.position.z - camera.position.z) * scale;
                if (x >= 0 && x <= 180 && y >= 0 && y <= 180) {
                    minimapCtx.beginPath();
                    minimapCtx.arc(x, y, 4, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
            });
            
            // Draw death backpack markers
            deathBackpacks.forEach(bp => {
                const mx = centerX + (bp.userData.deathPos.x - camera.position.x) * scale;
                const my = centerY + (bp.userData.deathPos.z - camera.position.z) * scale;
                if (mx >= 4 && mx <= 176 && my >= 4 && my <= 176) {
                    minimapCtx.strokeStyle = 'rgba(255, 90, 20, 0.95)';
                    minimapCtx.lineWidth = 2;
                    minimapCtx.beginPath();
                    minimapCtx.arc(mx, my, 7, 0, Math.PI * 2);
                    minimapCtx.stroke();
                    minimapCtx.font = '11px sans-serif';
                    minimapCtx.textAlign = 'center';
                    minimapCtx.textBaseline = 'middle';
                    minimapCtx.fillText('💀', mx, my);
                }
            });

            // Draw player
            minimapCtx.fillStyle = 'rgba(52, 152, 219, 1)';
            minimapCtx.beginPath();
            minimapCtx.arc(centerX, centerY, 5, 0, Math.PI * 2);
            minimapCtx.fill();
            
            // Draw direction indicator
            minimapCtx.strokeStyle = 'white';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.moveTo(centerX, centerY);
            const angle = camera.rotation.y;
            minimapCtx.lineTo(
                centerX + Math.sin(angle) * 10,
                centerY + Math.cos(angle) * 10
            );
            minimapCtx.stroke();
        }

        // ═══════════════════════════════════════════════════════════════
        //  FULL WORLD MAP  (press M)
        // ═══════════════════════════════════════════════════════════════
        const _fmCanvas  = document.getElementById('fullmap-canvas');
        const _fmCtx     = _fmCanvas.getContext('2d');
        const _fmOverlay = document.getElementById('fullmap-overlay');
        let   _fmOpen    = false;

        // World bounds
        const _FM_W  = 680, _FM_H = 520;
        const _FM_WX = -210, _FM_WZ = -310;
        const _FM_WW = 520,  _FM_WH = 440;  // z range: -310 to +130, covers forest up to z=100

        function _fmWorldToCanvas(wx, wz) {
            return {
                x: ((wx - _FM_WX) / _FM_WW) * _FM_W,
                y: ((wz - _FM_WZ) / _FM_WH) * _FM_H
            };
        }
        function _fmCanvasToWorld(cx, cy) {
            return {
                x: (cx / _FM_W) * _FM_WW + _FM_WX,
                z: (cy / _FM_H) * _FM_WH + _FM_WZ
            };
        }

        // --- Markers ---
        const _fmMarkers = [];

        function _fmRenderMarkerList() {
            const list = document.getElementById('fullmap-marker-list');
            if (!_fmMarkers.length) {
                list.innerHTML = '<div style="color:rgba(255,255,255,0.25);font-style:italic;">None yet</div>';
                return;
            }
            list.innerHTML = _fmMarkers.map((m, i) =>
                `<div style="display:flex;align-items:center;justify-content:space-between;gap:4px;` +
                `background:rgba(255,255,255,0.05);border-radius:4px;padding:3px 5px;">` +
                `<span style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap;flex:1;">\u{1F4CD} ${m.label || '\u2014'}</span>` +
                `<button data-mi="${i}" style="background:rgba(255,60,60,0.7);border:none;color:white;` +
                `border-radius:3px;width:18px;height:18px;cursor:pointer;font-size:10px;` +
                `line-height:18px;text-align:center;flex-shrink:0;">\u2715</button>` +
                `</div>`
            ).join('');
            list.querySelectorAll('button[data-mi]').forEach(btn => {
                btn.addEventListener('click', () => {
                    _fmMarkers.splice(+btn.dataset.mi, 1);
                    _fmRenderMarkerList();
                    _fmDraw();
                });
            });
        }

        function _fmDraw() {
            const ctx = _fmCtx;
            ctx.clearRect(0, 0, _FM_W, _FM_H);

            // Void background
            ctx.fillStyle = '#0a0d0a';
            ctx.fillRect(0, 0, _FM_W, _FM_H);

            // Beach ring (drawn first, under biomes)
            {
                const tl = _fmWorldToCanvas(-122, -322);
                const br = _fmWorldToCanvas( 322,  122);
                ctx.fillStyle = '#c8a85a';
                ctx.fillRect(tl.x, tl.y, br.x - tl.x, br.y - tl.y);
            }

            // Biome fills
            const biomes = [
                { x1:-100, z1:-100, x2:100,  z2:100,  c:'#1a3a12' },
                { x1:-100, z1:-300, x2:100,  z2:-100, c:'#3a2e10' },
                { x1: 100, z1:-300, x2:300,  z2:-100, c:'#1e2a35' },
                { x1: 100, z1:-100, x2:300,  z2:100,  c:'#0d2233' }, // river
            ];
            biomes.forEach(b => {
                const tl = _fmWorldToCanvas(b.x1, b.z1);
                const br = _fmWorldToCanvas(b.x2, b.z2);
                ctx.fillStyle = b.c;
                ctx.fillRect(tl.x, tl.y, br.x - tl.x, br.y - tl.y);
            });

            // Biome border lines
            ctx.strokeStyle = 'rgba(255,255,255,0.07)';
            ctx.lineWidth = 1;
            biomes.forEach(b => {
                const tl = _fmWorldToCanvas(b.x1, b.z1);
                const br = _fmWorldToCanvas(b.x2, b.z2);
                ctx.strokeRect(tl.x, tl.y, br.x - tl.x, br.y - tl.y);
            });

            // Biome labels
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            [
                { wx:0,   wz:0,    label:'FOREST',  color:'rgba(100,200,80,0.28)'  },
                { wx:0,   wz:-200, label:'DESERT',  color:'rgba(220,180,60,0.28)'  },
                { wx:200, wz:-200, label:'SNOW',    color:'rgba(160,200,240,0.28)' },
                { wx:200, wz:0,    label:'RIVER',   color:'rgba(80,180,220,0.28)'  },
            ].forEach(b => {
                const p = _fmWorldToCanvas(b.wx, b.wz);
                ctx.font = 'bold 14px Segoe UI';
                ctx.fillStyle = b.color;
                ctx.fillText(b.label, p.x, p.y);
            });

            // Grid lines
            ctx.strokeStyle = 'rgba(255,255,255,0.04)';
            ctx.lineWidth = 1;
            for (let wx = -200; wx <= 300; wx += 50) {
                const p1 = _fmWorldToCanvas(wx, _FM_WZ);
                const p2 = _fmWorldToCanvas(wx, _FM_WZ + _FM_WH);
                ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
            }
            for (let wz = -310; wz <= 20; wz += 50) {
                const p1 = _fmWorldToCanvas(_FM_WX, wz);
                const p2 = _fmWorldToCanvas(_FM_WX + _FM_WW, wz);
                ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
            }

            // River centreline (sinuous blue path)
            ctx.save();
            ctx.strokeStyle = 'rgba(50,140,210,0.75)';
            ctx.lineWidth = 5;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            // Approximate the river path using the same formula as rbRiverCX/rbRiverCZ
            ctx.beginPath();
            for (let i = 0; i <= 120; i++) {
                const t = i / 120;
                const wx = 200 + Math.sin(t * Math.PI * 2.1 + 0.9) * 16 + Math.sin(t * Math.PI * 1.05 - 0.3) * 10;
                const wz = (t - 0.5) * 200;
                const p = _fmWorldToCanvas(wx, wz);
                if (i === 0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();
            // Slightly wider, more transparent for the river banks
            ctx.strokeStyle = 'rgba(50,140,210,0.18)';
            ctx.lineWidth = 22;
            ctx.beginPath();
            for (let i = 0; i <= 120; i++) {
                const t = i / 120;
                const wx = 200 + Math.sin(t * Math.PI * 2.1 + 0.9) * 16 + Math.sin(t * Math.PI * 1.05 - 0.3) * 10;
                const wz = (t - 0.5) * 200;
                const p = _fmWorldToCanvas(wx, wz);
                if (i === 0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();
            ctx.restore();

            // Trees
            ctx.fillStyle = 'rgba(30,150,30,0.6)';
            if (typeof trees !== 'undefined') trees.forEach(t => {
                const p = _fmWorldToCanvas(t.position.x, t.position.z);
                ctx.beginPath(); ctx.arc(p.x, p.y, 2.5, 0, Math.PI*2); ctx.fill();
            });
            // Snow trees — scan scene live so async GLB timing doesn't matter
            ctx.fillStyle = 'rgba(200,235,255,0.9)';
            ctx.strokeStyle = 'rgba(100,180,255,0.6)';
            ctx.lineWidth = 1;
            scene.children.forEach(obj => {
                if (!obj.userData.isSnowTree) return;
                const p = _fmWorldToCanvas(obj.position.x, obj.position.z);
                ctx.beginPath(); ctx.arc(p.x, p.y, 3.5, 0, Math.PI*2); ctx.fill(); ctx.stroke();
            });

            // Rocks
            ctx.fillStyle = 'rgba(140,130,110,0.55)';
            if (typeof rocks !== 'undefined') rocks.forEach(r => {
                const p = _fmWorldToCanvas(r.position.x, r.position.z);
                ctx.fillRect(p.x-2, p.y-2, 4, 4);
            });
            // Snow rocks — scan scene live
            ctx.fillStyle = 'rgba(190,215,230,0.85)';
            scene.children.forEach(obj => {
                if (!obj.userData.isSnowRock) return;
                const p = _fmWorldToCanvas(obj.position.x, obj.position.z);
                ctx.fillRect(p.x-3, p.y-3, 6, 6);
            });
            // Crystal nodes — scan scene live
            ctx.fillStyle = 'rgba(120,200,255,0.9)';
            scene.children.forEach(obj => {
                if (!obj.userData.isCrystalNode) return;
                const p = _fmWorldToCanvas(obj.position.x, obj.position.z);
                ctx.beginPath(); ctx.arc(p.x, p.y, 3.5, 0, Math.PI*2); ctx.fill();
            });

            // Buildings
            ctx.fillStyle = 'rgba(200,150,80,0.85)';
            if (typeof buildings !== 'undefined') buildings.forEach(b => {
                const p = _fmWorldToCanvas(b.position.x, b.position.z);
                ctx.fillRect(p.x-3, p.y-3, 6, 6);
            });

            // Enemies
            ctx.fillStyle = 'rgba(255,40,40,0.9)';
            if (typeof enemies !== 'undefined') enemies.forEach(en => {
                if (en.userData && en.userData.isDead) return;
                const p = _fmWorldToCanvas(en.position.x, en.position.z);
                ctx.beginPath(); ctx.arc(p.x, p.y, 3.5, 0, Math.PI*2); ctx.fill();
            });

            // Death backpacks
            if (typeof deathBackpacks !== 'undefined') deathBackpacks.forEach(bp => {
                const dp = bp.userData.deathPos || bp.position;
                const p = _fmWorldToCanvas(dp.x, dp.z);
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText('\u{1F480}', p.x, p.y);
            });

            // Custom markers
            _fmMarkers.forEach(m => {
                const p = _fmWorldToCanvas(m.wx, m.wz);
                ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 4;
                ctx.fillStyle = '#e74c3c';
                ctx.strokeStyle = 'rgba(255,255,255,0.9)';
                ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, Math.PI*2);
                ctx.fill(); ctx.stroke();
                ctx.shadowBlur = 0;
                if (m.label) {
                    ctx.font = 'bold 11px Segoe UI';
                    ctx.fillStyle = 'white';
                    ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
                    ctx.shadowColor = 'rgba(0,0,0,0.95)'; ctx.shadowBlur = 5;
                    ctx.fillText(m.label, p.x, p.y - 9);
                    ctx.shadowBlur = 0;
                }
            });

            // Player dot
            const pp = _fmWorldToCanvas(camera.position.x, camera.position.z);
            ctx.strokeStyle = 'rgba(52,152,219,0.4)';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(pp.x, pp.y, 10, 0, Math.PI*2); ctx.stroke();
            ctx.fillStyle = '#3498db';
            ctx.beginPath(); ctx.arc(pp.x, pp.y, 5, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = 'white';
            ctx.beginPath(); ctx.arc(pp.x, pp.y, 2, 0, Math.PI*2); ctx.fill();
            // Direction line
            const angle = camera.rotation.y;
            ctx.strokeStyle = 'rgba(120,210,255,0.9)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(pp.x, pp.y);
            ctx.lineTo(pp.x + Math.sin(angle)*14, pp.y + Math.cos(angle)*14);
            ctx.stroke();

            // Coords
            ctx.font = '11px monospace';
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
            ctx.fillText('X:' + Math.round(camera.position.x) + '  Z:' + Math.round(camera.position.z), 8, _FM_H - 6);
        }

        // Marker popup logic
        let _fmPendingWorld = null;
        const _fmPopup = document.getElementById('fullmap-marker-popup');
        const _fmInput = document.getElementById('fullmap-marker-input');

        function _fmShowPopup(cx, cy, world) {
            _fmPendingWorld = world;
            const rect = _fmCanvas.getBoundingClientRect();
            const px = cx * (rect.width / _FM_W);
            const py = cy * (rect.height / _FM_H);
            _fmPopup.style.left = Math.min(px + 10, rect.width - 210) + 'px';
            _fmPopup.style.top  = Math.max(py - 65, 4) + 'px';
            _fmInput.value = '';
            _fmPopup.style.display = 'block';
            setTimeout(() => _fmInput.focus(), 30);
        }
        function _fmHidePopup() { _fmPopup.style.display = 'none'; _fmPendingWorld = null; }
        function _fmConfirmMarker() {
            if (!_fmPendingWorld) return;
            _fmMarkers.push({ wx: _fmPendingWorld.x, wz: _fmPendingWorld.z, label: _fmInput.value.trim() });
            _fmHidePopup();
            _fmRenderMarkerList();
            _fmDraw();
        }

        document.getElementById('fullmap-marker-confirm').addEventListener('click', _fmConfirmMarker);
        document.getElementById('fullmap-marker-cancel').addEventListener('click', _fmHidePopup);
        _fmInput.addEventListener('keydown', e => {
            if (e.key === 'Enter')  { e.preventDefault(); _fmConfirmMarker(); }
            if (e.key === 'Escape') { e.preventDefault(); _fmHidePopup(); }
            e.stopPropagation();
        });

        _fmCanvas.addEventListener('click', e => {
            if (_fmPopup.style.display === 'block') { _fmHidePopup(); return; }
            const rect = _fmCanvas.getBoundingClientRect();
            const cx = (e.clientX - rect.left) * (_FM_W / rect.width);
            const cy = (e.clientY - rect.top)  * (_FM_H / rect.height);
            // Click on existing marker = remove it
            for (let i = _fmMarkers.length - 1; i >= 0; i--) {
                const mp = _fmWorldToCanvas(_fmMarkers[i].wx, _fmMarkers[i].wz);
                if (Math.hypot(cx - mp.x, cy - mp.y) < 10) {
                    _fmMarkers.splice(i, 1);
                    _fmRenderMarkerList();
                    _fmDraw();
                    return;
                }
            }
            // Otherwise place new marker
            _fmShowPopup(cx, cy, _fmCanvasToWorld(cx, cy));
        });

        function openFullMap() {
            _fmOpen = true;
            _fmOverlay.style.display = 'block';
            _fmDraw();
            uiOpen();
        }
        function closeFullMap() {
            _fmOpen = false;
            _fmHidePopup();
            _fmOverlay.style.display = 'none';
            // Don't call uiClose() — it re-locks pointer; just release the flag
            setTimeout(_tryLock, 80);
        }
        document.getElementById('fullmap-close').addEventListener('click', closeFullMap);

        // ═══════════════════════════════════════════════════════════════
        //  END FULL WORLD MAP
        // ═══════════════════════════════════════════════════════════════

        // ===== DEATH BACKPACK SYSTEM =====
        const deathBackpacks = [];
        let currentBackpack  = null;

        function createBackpackModel() {
            const bp = new THREE.Group();
            const fabricMat = new THREE.MeshStandardMaterial({ color: 0x3d2a18, roughness: 0.95, metalness: 0.0 });
            const strapMat  = new THREE.MeshStandardMaterial({ color: 0x251810, roughness: 0.9,  metalness: 0.0 });
            const buckMat   = new THREE.MeshStandardMaterial({ color: 0x8a7a3a, roughness: 0.35, metalness: 0.75 });
            const pocketMat = new THREE.MeshStandardMaterial({ color: 0x2e1e0e, roughness: 0.95, metalness: 0.0 });

            // Main body
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.65, 0.28), fabricMat);
            body.position.set(0, 0.40, 0); body.castShadow = true; bp.add(body);

            // Top flap
            const flap = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.12, 0.30), fabricMat);
            flap.position.set(0, 0.76, 0); flap.castShadow = true; bp.add(flap);

            // Front pocket
            const pocket = new THREE.Mesh(new THREE.BoxGeometry(0.44, 0.30, 0.09), pocketMat);
            pocket.position.set(0, 0.28, 0.185); pocket.castShadow = true; bp.add(pocket);

            // Pocket zipper strip
            const zip = new THREE.Mesh(new THREE.BoxGeometry(0.46, 0.022, 0.022), buckMat);
            zip.position.set(0, 0.44, 0.19); bp.add(zip);

            // Shoulder straps
            [-0.20, 0.20].forEach(sx => {
                const strap = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.55, 0.05), strapMat);
                strap.position.set(sx, 0.38, -0.12); strap.rotation.x = 0.18; bp.add(strap);
            });

            // Side compression straps
            [-1, 1].forEach(side => {
                const cs = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, 0.30), strapMat);
                cs.position.set(side * 0.30, 0.38, 0.0); bp.add(cs);
                const bk = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.055, 0.04), buckMat);
                bk.position.set(side * 0.30, 0.38, 0.15); bp.add(bk);
            });

            // Top carry handle
            const handle = new THREE.Mesh(
                new THREE.TorusGeometry(0.075, 0.018, 8, 12, Math.PI), strapMat);
            handle.rotation.x = Math.PI / 2;
            handle.position.set(0, 0.84, 0.0); bp.add(handle);

            // Soul orb — glows to show the pack has contents
            const orbMat = new THREE.MeshBasicMaterial({ color: 0xff2200, transparent: true, opacity: 0.85 });
            const orb = new THREE.Mesh(new THREE.SphereGeometry(0.065, 10, 10), orbMat);
            orb.position.set(0, 0.28, 0.245); bp.add(orb);
            bp.userData.orb = orb;

            // Point light
            const glow = new THREE.PointLight(0xff3300, 0.8, 4.0);
            glow.position.set(0, 0.4, 0.2); bp.add(glow);
            bp.userData.glowLight = glow;

            bp.userData.isDeathBackpack = true;
            return bp;
        }

        function spawnDeathBackpack() {
            const contents = [];

            // Capture entire inventory
            for (const [name, count] of Object.entries(inventory)) {
                if (count > 0) { contents.push({ name, count }); inventory[name] = 0; }
            }
            // Clear hotbar slot references
            hotbar.forEach(slot => { if (slot.item) slot.item = null; });
            // Capture equipped backpack contents first, then the backpack itself
            backpackSlots.forEach(s => {
                if (s && s.item && s.count > 0) contents.push({ name: s.item, count: s.count });
            });
            backpackSlots.fill(null);
            backpackSize = 0;
            // Capture armor slots
            for (const [slot, item] of Object.entries(armorSlots)) {
                if (item) { contents.push({ name: item, count: 1 }); armorSlots[slot] = null; }
            }

            if (contents.length === 0) return;

            const bp = createBackpackModel();
            bp.position.set(
                camera.position.x + (Math.random() - 0.5) * 0.6,
                0,
                camera.position.z + (Math.random() - 0.5) * 0.6
            );
            bp.rotation.y = Math.random() * Math.PI * 2;
            bp.userData.backpackContents = contents;
            bp.userData.deathPos = { x: bp.position.x, z: bp.position.z };
            scene.add(bp);
            deathBackpacks.push(bp);
            updateUI();
            updateHotbar();
        }

        function updateDeathBackpacks() {
            if (deathBackpacks.length === 0) return;
            const t = performance.now() * 0.003;
            for (const bp of deathBackpacks) {
                if (bp.userData.orb) {
                    bp.userData.orb.material.opacity = 0.5 + Math.sin(t * 2.2) * 0.35;
                    bp.userData.orb.scale.setScalar(0.88 + Math.sin(t * 2.2) * 0.14);
                }
                if (bp.userData.glowLight) {
                    bp.userData.glowLight.intensity = 0.4 + Math.sin(t * 2.2) * 0.35;
                }
            }
        }

        function openBackpack(bp) {
            currentBackpack = bp;
            const panel = document.getElementById('backpack-panel');
            panel.style.display = 'block';
            const invPanel = document.getElementById('inventory-panel');
            positionInventoryRight(invPanel);
            invPanel.style.display = 'block';
            uiOpen();
            updateBackpackDisplay();
            updateInventoryDisplay();
        }

        function closeBackpack() {
            closeAllUI();
        }

        function updateBackpackDisplay() {
            if (!currentBackpack) return;
            const grid = document.getElementById('backpack-grid');
            grid.innerHTML = '';
            const contents = currentBackpack.userData.backpackContents || [];
            contents.forEach((itemData, i) => {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                slot.dataset.slotIndex = i;
                slot.dataset.slotType = 'backpack';
                if (itemData && itemData.name && itemData.count > 0) {
                    const icon = itemIcons[itemData.name] || '❓';
                    slot.innerHTML = `<div class="inventory-slot-icon">${icon}</div><div class="inventory-slot-name">${itemData.name}</div><div class="inventory-slot-count">${itemData.count}</div>`;
                    slot.dataset.itemName = itemData.name;
                    slot.draggable = true;
                    slot.addEventListener('click', ev => { if (ev.ctrlKey) takeFromBackpack(i); });
                    slot.title = 'Ctrl+click to take all';
                } else {
                    slot.innerHTML = '<div class="inventory-slot-empty">+</div>';
                }
                slot.addEventListener('dragstart', handleDragStart);
                slot.addEventListener('dragover',  handleDragOver);
                slot.addEventListener('drop',       handleDrop);
                slot.addEventListener('dragend',    handleDragEnd);
                slot.addEventListener('dragleave',  handleDragLeave);
                grid.appendChild(slot);
            });
        }

        function takeFromBackpack(slotIndex) {
            if (!currentBackpack) return;
            const contents = currentBackpack.userData.backpackContents;
            const item = contents[slotIndex];
            if (!item || item.count <= 0) return;
            if (inventory[item.name] !== undefined) inventory[item.name] += item.count;
            else inventory[item.name] = item.count;
            contents[slotIndex] = null;
            updateUI();
            updateBackpackDisplay();
            checkBackpackEmpty(currentBackpack);
        }

        function checkBackpackEmpty(bp) {
            const contents = bp.userData.backpackContents || [];
            if (!contents.some(c => c && c.count > 0)) {
                if (currentBackpack === bp) closeBackpack();
                scene.remove(bp);
                const idx = deathBackpacks.indexOf(bp);
                if (idx > -1) deathBackpacks.splice(idx, 1);
            }
        }

        // ===== DEATH & RESPAWN =====
        function die() {
            isDead = true;
            document.getElementById('death-screen').style.display = 'flex';
            document.getElementById('survival-time').textContent = day;

            // Release pointer lock so cursor is free on the death screen
            uiOpen();

            // Stop all creature sounds
            stopAllCoyoteSounds();
            stopAllBiteSounds();

            // Drop death backpack with all player items
            spawnDeathBackpack();
            
            // Create death camera
            deathCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
            deathCamera.position.copy(camera.position);
            deathCamera.position.y += 10;
            deathCamera.lookAt(camera.position);
        }
        
        function respawn() {
            isDead = false;
            health = 100;
            hunger = 100;
            thirst = 100;
            stamina = 100;
            // day, time, gameTime are NOT reset — time of day persists through death

            // ── Respawn location: sleeping bag first, else random forest position ──
            const sleepingBag = buildings.find(b => b.userData.isSleepingBag);
            if (sleepingBag) {
                // Spawn standing above the sleeping bag
                camera.position.set(
                    sleepingBag.position.x,
                    sleepingBag.position.y + 1.7,
                    sleepingBag.position.z + 1.0 // step slightly off the bag
                );
            } else {
                // Random forest biome spawn — forest is at positive Z (z > 0)
                const angle = Math.random() * Math.PI * 2;
                const dist  = 20 + Math.random() * 60; // 20-80 units from centre
                camera.position.set(
                    Math.cos(angle) * dist,
                    1.7,
                    Math.abs(Math.sin(angle) * dist) + 10 // keep in forest (positive Z)
                );
            }
            camera.rotation.set(0, 0, 0);

            document.getElementById('death-screen').style.display = 'none';
            deathCamera = null;

            // Re-acquire pointer lock and resume game input
            uiClose();
            updateUI();
            updateHeldItem(); // Clear any weapon/tool still visually held after death
        }
        window.respawn = respawn;
        
        // ===== LOADING =====
        function setLoadingProgress(pct, label) {
            document.getElementById('loadingProgress').style.width = Math.min(100, pct) + '%';
            if (label) document.getElementById('loading-status').textContent = label;
        }
        function finishLoading() {
            setLoadingProgress(100, 'Ready!');
            setTimeout(() => {
                document.getElementById('loadingScreen').classList.add('hidden');
                // Show click-to-play overlay — browsers require a user gesture before
                // AudioContext can run and before requestPointerLock() will succeed.
                // This single click satisfies both requirements cleanly.
                showClickToPlay();
            }, 350);
        }

        // Shared overlay helpers
        const _menuBtnCSS = [
            'display:block','width:260px','padding:16px 0','margin:10px 0',
            'font-size:20px','font-weight:700','letter-spacing:2px','color:#fff',
            'background:transparent','border:2px solid rgba(255,255,255,0.25)',
            'border-radius:10px','cursor:pointer','text-transform:uppercase'
        ].join(';');

        function showClickToPlay() {
            const overlay = document.createElement('div');
            overlay.id = 'crust-main-overlay';
            overlay.style.cssText = [
                'position:fixed','inset:0','z-index:99999',
                'display:flex','flex-direction:column',
                'align-items:center','justify-content:center',
                'background:rgba(0,0,0,0.82)',
                'font-family:Segoe UI,sans-serif','cursor:pointer'
            ].join(';');

            overlay.innerHTML = `
                <style>
                    @keyframes ctpPulse{0%,100%{opacity:0.45}50%{opacity:1}}
                    #crust-main-overlay button:hover{
                        background:rgba(255,255,255,0.12)!important;
                        border-color:rgba(255,255,255,0.6)!important;
                    }
                </style>
                <div style="font-size:52px;font-weight:900;color:#fff;letter-spacing:8px;
                            text-shadow:0 0 40px rgba(255,255,255,0.3);margin-bottom:24px;">CRUST</div>
                <div id="ctp-label" style="font-size:20px;color:rgba(255,255,255,0.7);
                            letter-spacing:3px;animation:ctpPulse 1.6s ease-in-out infinite;">
                    CLICK TO PLAY
                </div>
            `;

            // First click: unlock AudioContext, start music, reveal main menu buttons
            overlay.addEventListener('click', () => {
                audioContext.resume().then(() => { startTheme(); }).catch(() => {});
                _hasUserGesture = true;
                _showMainMenuButtons(overlay);
            }, { once: true });

            document.body.appendChild(overlay);
        }

        function _showMainMenuButtons(overlay) {
            overlay.style.cursor = 'default';
            const label = document.getElementById('ctp-label');
            if (label) label.remove();

            const menu = document.createElement('div');
            menu.id = 'crust-menu-buttons';
            menu.style.cssText = 'display:flex;flex-direction:column;align-items:center;margin-top:10px;';
            menu.innerHTML = `
                <button id="menu-new-game" style="${_menuBtnCSS}">&#127757; New Game</button>
                <button id="menu-load-game" style="${_menuBtnCSS}">&#128194; Load Game</button>
                <button id="menu-options"   style="${_menuBtnCSS}">&#9881;&#65039; Options</button>
            `;
            overlay.appendChild(menu);

            document.getElementById('menu-new-game').addEventListener('click', (e) => {
                e.stopPropagation();
                _enterGame(overlay, false);
            });
            document.getElementById('menu-load-game').addEventListener('click', (e) => {
                e.stopPropagation();
                _enterGame(overlay, true);
            });
            document.getElementById('menu-options').addEventListener('click', (e) => {
                e.stopPropagation();
                overlay.style.display = 'none';
                document.getElementById('settings-menu').style.display = 'block';
                document.getElementById('settings-menu').dataset.calledFromMenu = '1';
            });
        }

        function _enterGame(overlay, loadSave) {
            stopTheme();
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume().catch(() => {});
            }
            startAmbientSounds();
            overlay.remove();
            if (loadSave) {
                if (document.pointerLockElement) document.exitPointerLock();
                setTimeout(() => openSaveSlotModal(), 100);
            } else {
                // Acquire pointer lock. We call it directly here (inside the click handler
                // so it counts as a user gesture), then also schedule closeAllUI which
                // calls _tryLock as a reliable fallback 80ms later.
                try {
                    const req = renderer.domElement.requestPointerLock();
                    if (req && typeof req.catch === 'function') req.catch(() => {});
                } catch(e) {}
                // closeAllUI hides any stray panels and calls _tryLock to re-lock
                closeAllUI();
            }
        }

        // Also resume AudioContext on any subsequent user interaction
        // (e.g. after alt-tab, the browser may re-suspend it)
        ['click','keydown','pointerdown'].forEach(evt => {
            document.addEventListener(evt, () => {
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().catch(() => {});
                }
            }, { passive: true });
        });
        
        // ===== WINDOW RESIZE =====
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // ===== RAIN SYSTEM =====
        let isRaining = false;
        let rainParticles = null;
        let rainGainNode = null;
        let rainNoiseSource = null;
        let rainScheduleTimer = null;

        let _rainAudioBuffer = null;
        let _rainRoofAudioBuffer = null;
        let _rainRoofSource = null;
        let _rainRoofGain = null;

        // Preload RainRoof sound
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/RainRoof.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _rainRoofAudioBuffer = buf; console.log('RainRoof sound loaded OK'); })
            .catch(e => { console.error('RainRoof sound fetch error:', e); });

        function startRainRoofSound() {
            if (!_rainRoofAudioBuffer || _rainRoofSource) return;
            _rainRoofSource = audioContext.createBufferSource();
            _rainRoofSource.buffer = _rainRoofAudioBuffer;
            _rainRoofSource.loop = true;
            _rainRoofGain = audioContext.createGain();
            _rainRoofGain.gain.setValueAtTime(0.001, audioContext.currentTime);
            _rainRoofGain.gain.linearRampToValueAtTime(volumeSettings.ambient * 1.70625, audioContext.currentTime + 1.5);
            _rainRoofSource.connect(_rainRoofGain);
            _rainRoofGain.connect(audioContext.destination);
            _rainRoofSource.start();
        }

        function stopRainRoofSound() {
            if (!_rainRoofSource) return;
            _rainRoofGain.gain.linearRampToValueAtTime(0.001, audioContext.currentTime + 1.5);
            const srcToStop = _rainRoofSource;
            setTimeout(() => { try { srcToStop.stop(); } catch(e){} }, 1600);
            _rainRoofSource = null;
            _rainRoofGain = null;
        }

        let _eatAudioBuffer = null;
        // Preload eat sound
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/eat.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _eatAudioBuffer = buf; console.log('Eat sound loaded OK'); })
            .catch(e => { console.error('Eat sound fetch error:', e); });

        let _bandageAudioBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/bandage.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _bandageAudioBuffer = buf; console.log('Bandage sound loaded OK'); })
            .catch(e => { console.error('Bandage sound fetch error:', e); });

        function playBandageSound() {
            if (!_bandageAudioBuffer) return;
            const src = audioContext.createBufferSource();
            src.buffer = _bandageAudioBuffer;
            const gain = audioContext.createGain();
            gain.gain.value = volumeSettings.sfx !== undefined ? volumeSettings.sfx : 1.0;
            src.connect(gain);
            gain.connect(audioContext.destination);
            src.start();
        }

        function playEatSound() {
            if (!_eatAudioBuffer) { console.log('Eat buffer not ready yet'); return; }
            const src = audioContext.createBufferSource();
            src.buffer = _eatAudioBuffer;
            const gain = audioContext.createGain();
            gain.gain.value = volumeSettings.sfx !== undefined ? volumeSettings.sfx : 1.0;
            src.connect(gain);
            gain.connect(audioContext.destination);
            src.start();
        }

        let _plantAudioBuffer = null;
        // Preload plant sound
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/plant.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _plantAudioBuffer = buf; console.log('Plant sound loaded OK'); })
            .catch(e => { console.error('Plant sound fetch error:', e); });

        function playPlantSound() {
            if (!_plantAudioBuffer) { console.log('Plant buffer not ready yet'); return; }
            const src = audioContext.createBufferSource();
            src.buffer = _plantAudioBuffer;
            const gain = audioContext.createGain();
            gain.gain.value = volumeSettings.sfx !== undefined ? volumeSettings.sfx : 1.0;
            src.connect(gain);
            gain.connect(audioContext.destination);
            src.start();
        }

        // Preload rain sound
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/Rain.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => {
                _rainAudioBuffer = buf;
                console.log('Rain sound loaded OK');
                // If rain already started before the buffer was ready, set up audio now
                if (isRaining && !rainGainNode) {
                    buildRainAudio();
                    if (rainGainNode) {
                        rainGainNode.gain.setValueAtTime(0.001, audioContext.currentTime);
                        rainGainNode.gain.exponentialRampToValueAtTime(
                            volumeSettings.rain,
                            audioContext.currentTime + 4
                        );
                    }
                }
            })
            .catch(e => { console.error('Rain sound fetch error:', e); });

        function buildRainAudio() {
            if (!_rainAudioBuffer) { console.log('Rain buffer not ready yet — will start audio when loaded'); return; }
            rainNoiseSource = audioContext.createBufferSource();
            rainNoiseSource.buffer = _rainAudioBuffer;
            rainNoiseSource.loop = true;
            rainGainNode = audioContext.createGain();
            rainGainNode.gain.value = 0;
            rainNoiseSource.connect(rainGainNode);
            rainGainNode.connect(audioContext.destination);
            rainNoiseSource.start();
        }
        
        // Roof drip sound - for when player is under cover

        
        // Trigger a lightning strike with sound and visual
        function triggerLightning() {
            if (!isRaining) return;
            
            // Set lightning to active
            lightningActive = true;
            lightningStartTime = Date.now();
            lightningDuration = 1200; // 1.2 second total duration for fade in and out
            
            // Play thunder sound AFTER lightning (simulate light traveling faster than sound)
            // Random delay between 0.3-3 seconds to simulate different distances (sometimes close, sometimes far)
            const thunderDelay = 300 + Math.random() * 2700;
            setTimeout(() => {
                playThunderSound();
            }, thunderDelay);
            
            // Schedule next lightning strike
            if (isRaining) {
                scheduleLightning();
            }
        }
        
        // Schedule next lightning strike during rain
        function scheduleLightning() {
            if (window.lightningTimer) {
                clearTimeout(window.lightningTimer);
            }
            
            // Random delay between 5-25 seconds for next lightning (more variation)
            const delay = 5000 + Math.random() * 20000;
            window.lightningTimer = setTimeout(() => {
                if (isRaining) {
                    triggerLightning();
                }
            }, delay);
        }

        function startRain() {
            if (isRaining) return;
            isRaining = true;
            // Schedule planter watering after a short delay (seeds need some rain time)
            setTimeout(() => {
                if (isRaining) waterAllPlanters();
            }, 8000);

            // --- Visual rain: use LineSegments so each drop is a short vertical streak ---
            const rainCount = 2500;
            const linePositions = new Float32Array(rainCount * 6); // 2 verts per line
            for (let i = 0; i < rainCount; i++) {
                const rx = (Math.random() - 0.5) * 100;
                const ry = Math.random() * 35 + 2;
                const rz = (Math.random() - 0.5) * 100;
                const streak = 0.55; // length of each raindrop streak
                const drift  = 0.18; // horizontal wind drift per streak
                linePositions[i * 6 + 0] = rx;
                linePositions[i * 6 + 1] = ry;
                linePositions[i * 6 + 2] = rz;
                linePositions[i * 6 + 3] = rx - drift;
                linePositions[i * 6 + 4] = ry - streak;
                linePositions[i * 6 + 5] = rz;
            }
            const rainGeo = new THREE.BufferGeometry();
            rainGeo.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
            const rainMat = new THREE.LineBasicMaterial({
                color: 0xaaddff,
                transparent: true,
                opacity: 0, // Start invisible
            });
            rainParticles = new THREE.LineSegments(rainGeo, rainMat);
            rainParticles.frustumCulled = false; // positions update each frame relative to camera
            rainParticles.userData.targetOpacity = 0.75;
            rainParticles.userData.startTime = Date.now();
            rainParticles.userData.fadeDuration = 4000;
            scene.add(rainParticles);

            // --- Audio ---
            buildRainAudio();
            if (!rainGainNode) return; // buffer not ready yet — will retry when loaded
            rainGainNode.gain.setValueAtTime(0.001, audioContext.currentTime);
            rainGainNode.gain.exponentialRampToValueAtTime(
                volumeSettings.rain,
                audioContext.currentTime + 4
            );

            // Wind gets louder during rain - increase by additional 20%
            if (ambientWindGain) {
                const currentWind = ambientWindGain.gain.value;
                ambientWindGain.gain.cancelScheduledValues(audioContext.currentTime);
                ambientWindGain.gain.setValueAtTime(currentWind, audioContext.currentTime);
                ambientWindGain.gain.exponentialRampToValueAtTime(
                    volumeSettings.ambient * 0.175 * 1.2,
                    audioContext.currentTime + 4
                );
            }
            
            // Start lightning strikes during rain
            scheduleLightning();
            
            // Cloud color transition is now handled in updateClouds() function
        }

        function stopRain() {
            if (!isRaining) return;
            isRaining = false; // This will stop new drip sounds from scheduling
            // Reset planter watering flags so next rain event can water again
            resetPlanterWaterFlags();
            // Stop roof rain ambient sound
            if (_rainRoofSource) stopRainRoofSound();

            if (rainGainNode) {
                // Use exponential ramp for smoother fade (avoids choppy linear fade)
                const currentGain = rainGainNode.gain.value;
                rainGainNode.gain.cancelScheduledValues(audioContext.currentTime);
                rainGainNode.gain.setValueAtTime(currentGain, audioContext.currentTime);
                rainGainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 5);
                setTimeout(() => {
                    if (rainNoiseSource) { try { rainNoiseSource.stop(); } catch(e){} rainNoiseSource = null; }
                    rainGainNode = null;
                }, 5500);
            }

            if (rainParticles) {
                // Mark for fade out
                rainParticles.userData.isFadingOut = true;
                rainParticles.userData.fadeStartTime = Date.now();
                rainParticles.userData.fadeOutDuration = 5000; // 5 seconds to fade out
            }

            if (ambientWindGain) {
                const currentWind = ambientWindGain.gain.value;
                ambientWindGain.gain.cancelScheduledValues(audioContext.currentTime);
                ambientWindGain.gain.setValueAtTime(currentWind, audioContext.currentTime);
                ambientWindGain.gain.exponentialRampToValueAtTime(
                    Math.max(0.001, volumeSettings.ambient * 0.175 * 0.4),
                    audioContext.currentTime + 5
                );
            }
            
            // Stop lightning strikes
            if (window.lightningTimer) {
                clearTimeout(window.lightningTimer);
                window.lightningTimer = null;
            }
            
            // Sky and cloud color restoration is now handled automatically by the animation loop
        }

        function updateRain() {
            if (!rainParticles) return;
            
            const now = Date.now(); // must match epoch of userData.startTime / fadeStartTime (set via Date.now())
            
            // Handle opacity transitions
            if (rainParticles.userData.isFadingOut) {
                // Fading out
                const elapsed = now - rainParticles.userData.fadeStartTime;
                const progress = Math.min(elapsed / rainParticles.userData.fadeOutDuration, 1);
                const opacity = rainParticles.userData.targetOpacity * (1 - progress);
                rainParticles.material.opacity = Math.max(0, opacity);
                
                // Remove when fully faded
                if (progress >= 1) {
                    scene.remove(rainParticles);
                    rainParticles = null;
                    return;
                }
            } else if (isRaining) {
                // Fading in
                const elapsed = now - rainParticles.userData.startTime;
                const progress = Math.min(elapsed / rainParticles.userData.fadeDuration, 1);
                const opacity = rainParticles.userData.targetOpacity * progress;
                rainParticles.material.opacity = opacity;
            }
            
            // Update particle positions
            const pos = rainParticles.geometry.attributes.position;
            const dropSpeed = 0.45;
            const windDrift = 0.05;
            const streak    = 0.55;
            const driftLen  = 0.18;

            // Rebuild ceiling box cache once per frame (ceilings rarely move)
            if (!rainParticles.userData.buildingCache || rainParticles.userData.buildingCacheFrame !== window._frameCount) {
                rainParticles.userData.buildingCache = buildings.filter(b => {
                    const bt = b.userData.buildingType;
                    return bt === 'ceiling' || bt === 'stone_ceiling' || bt === 'metal_ceiling';
                }).map(b => new THREE.Box3().setFromObject(b));
                rainParticles.userData.buildingCacheFrame = window._frameCount || 0;
            }
            const roofBoxes = rainParticles.userData.buildingCache;

            // Helper: true if (x,z) is covered by any roof at or above testY
            function _isCovered(x, z, testY) {
                for (let r = 0; r < roofBoxes.length; r++) {
                    const box = roofBoxes[r];
                    if (x >= box.min.x && x <= box.max.x &&
                        z >= box.min.z && z <= box.max.z &&
                        testY <= box.max.y) return true;
                }
                return false;
            }

            for (let i = 0; i < pos.count / 2; i++) {
                let tx = pos.getX(i * 2);
                let ty = pos.getY(i * 2);
                let tz = pos.getZ(i * 2);

                // During fadeout — park all drops off-screen so they don't visibly freeze/respawn
                if (rainParticles.userData.isFadingOut) {
                    pos.setXYZ(i * 2,     0, -9999, 0);
                    pos.setXYZ(i * 2 + 1, 0, -9999, 0);
                    continue;
                }

                ty -= dropSpeed;
                tx -= windDrift;

                // Respawn if hit ground OR passed through a roof
                if (ty < 0 || (roofBoxes.length > 0 && _isCovered(tx, tz, ty))) {
                    // Pick a new spawn position that is NOT under a roof
                    let attempts = 0;
                    do {
                        tx = camera.position.x + (Math.random() - 0.5) * 100;
                        tz = camera.position.z + (Math.random() - 0.5) * 100;
                        attempts++;
                    } while (roofBoxes.length > 0 && _isCovered(tx, tz, 35) && attempts < 8);
                    ty = 35 + Math.random() * 5;
                }

                pos.setXYZ(i * 2,     tx,           ty,          tz);
                pos.setXYZ(i * 2 + 1, tx - driftLen, ty - streak, tz);
            }
            
            pos.needsUpdate = true;

            // Adjust rain volume based on whether player is under a roof
            const underRoof = isPlayerUnderRoof();
            
            if (rainGainNode && isRaining && !rainParticles.userData.isFadingOut) {
                // Only adjust if rain is stable (not fading in or out)
                const elapsed = now - rainParticles.userData.startTime;
                const fadeInComplete = elapsed > rainParticles.userData.fadeDuration;
                
                if (fadeInComplete) {
                    // Base target volume
                    let target = volumeSettings.ambient * 0.65;
                    
                    // Reduce to 50% if under roof
                    if (underRoof) {
                        target *= 0.5;
                    }
                    
                    if (Math.abs(rainGainNode.gain.value - target) > 0.05) {
                        rainGainNode.gain.linearRampToValueAtTime(target, audioContext.currentTime + 0.5);
                    }
                }
            }
            
            // Play roof drip sounds when under roof
            if (underRoof && isRaining) {
                // Start roof rain ambient loop if not already playing
                if (!_rainRoofSource) startRainRoofSound();
            } else {
                // Stop roof rain ambient if player steps outside or rain stops
                if (_rainRoofSource) stopRainRoofSound();
            }
        }

        // ===== RAIN SPLASH PARTICLES =====
        const SPLASH_MAX = 180;
        const _splashPx   = new Float32Array(SPLASH_MAX);
        const _splashPy   = new Float32Array(SPLASH_MAX);
        const _splashPz   = new Float32Array(SPLASH_MAX);
        const _splashVx   = new Float32Array(SPLASH_MAX);
        const _splashVy   = new Float32Array(SPLASH_MAX);
        const _splashVz   = new Float32Array(SPLASH_MAX);
        const _splashLife = new Float32Array(SPLASH_MAX);
        const _splashMaxL = new Float32Array(SPLASH_MAX);

        const _splashGeo     = new THREE.BufferGeometry();
        const _splashPosArr  = new Float32Array(SPLASH_MAX * 3);
        const _splashPosAttr = new THREE.BufferAttribute(_splashPosArr, 3);
        _splashGeo.setAttribute('position', _splashPosAttr);

        const _splashMat = new THREE.PointsMaterial({
            color: 0xaaddff,
            size: 0.06,
            transparent: true,
            opacity: 0.7,
            depthWrite: false,
            sizeAttenuation: true,
        });
        const _splashPoints = new THREE.Points(_splashGeo, _splashMat);
        _splashPoints.frustumCulled = false;
        scene.add(_splashPoints);

        let _splashSpawnTimer = 0;

        function _spawnSplash(x, z) {
            // Find a dead slot
            for (let i = 0; i < SPLASH_MAX; i++) {
                if (_splashLife[i] > 0) continue;
                const life = 0.28 + Math.random() * 0.18;
                _splashLife[i] = life;
                _splashMaxL[i] = life;
                _splashPx[i]   = x;
                _splashPy[i]   = 0.03;
                _splashPz[i]   = z;
                // Burst outward in a random radial direction, slight upward kick
                const angle = Math.random() * Math.PI * 2;
                const spd   = 0.018 + Math.random() * 0.022;
                _splashVx[i] = Math.cos(angle) * spd;
                _splashVy[i] = 0.025 + Math.random() * 0.03;
                _splashVz[i] = Math.sin(angle) * spd;
                return;
            }
        }

        function updateSplashParticles() {
            if (!isRaining && _splashSpawnTimer === 0) {
                // Park all dead particles
                for (let i = 0; i < SPLASH_MAX; i++) {
                    if (_splashLife[i] <= 0) _splashPosAttr.setXYZ(i, 0, -9999, 0);
                }
            }

            // Spawn new splashes while raining
            if (isRaining) {
                _splashSpawnTimer += 0.016;
                // Spawn ~14 splashes/sec spread randomly around the player
                const spawnRate = 1 / 14;
                while (_splashSpawnTimer >= spawnRate) {
                    _splashSpawnTimer -= spawnRate;
                    const angle = Math.random() * Math.PI * 2;
                    const dist  = 2 + Math.random() * 18;
                    _spawnSplash(
                        camera.position.x + Math.cos(angle) * dist,
                        camera.position.z + Math.sin(angle) * dist
                    );
                }
            } else {
                _splashSpawnTimer = 0;
            }

            // Simulate live splash droplets
            for (let i = 0; i < SPLASH_MAX; i++) {
                if (_splashLife[i] <= 0) {
                    _splashPosAttr.setXYZ(i, 0, -9999, 0);
                    continue;
                }
                _splashLife[i] -= 0.016;
                _splashVy[i]   -= 0.004;   // gravity
                _splashPx[i]   += _splashVx[i];
                _splashPy[i]   += _splashVy[i];
                _splashPz[i]   += _splashVz[i];
                if (_splashPy[i] < 0.01) _splashPy[i] = 0.01;
                _splashPosAttr.setXYZ(i, _splashPx[i], _splashPy[i], _splashPz[i]);
            }
            _splashPosAttr.needsUpdate = true;

            // Fade opacity with rain state
            const anyAlive = _splashLife.some(l => l > 0);
            _splashMat.opacity = isRaining ? 0.7 : (anyAlive ? 0.4 : 0);
        }

        // ===== WET GROUND STATE =====
        let _wetness = 0;   // 0 = dry, 1 = fully soaked
        const _groundDryRoughness   = 0.92;
        const _groundWetRoughness   = 0.22;   // smooth and shiny when wet
        const _groundDryColor       = new THREE.Color(0xffffff);
        const _groundWetColor       = new THREE.Color(0x8899aa); // cool blue-grey, wet look

        function updateWetGround() {
            const wetTarget = isRaining ? 1.0 : 0.0;
            // Soak up fast, dry out slowly (~90s to fully dry)
            const speed = isRaining ? 0.008 : 0.0008;
            _wetness += (wetTarget - _wetness) * speed;
            _wetness  = Math.max(0, Math.min(1, _wetness));

            groundMaterial.roughness = _groundDryRoughness + (_groundWetRoughness - _groundDryRoughness) * _wetness;
            groundMaterial.color.lerpColors(_groundDryColor, _groundWetColor, _wetness * 0.45);
        }

        // ── Raindrop ripple rings on river water surface ──────────────────────
        // Each raindrop that hits the river spawns an expanding circular ring
        // that grows outward and fades — pure geometry rings, no textures.
        (function() {
            const RING_POOL   = 35;
            const RING_SEGS   = 48;

            // Per-ring state
            const _rngRadius  = new Float32Array(RING_POOL);
            const _rngMaxR    = new Float32Array(RING_POOL);
            const _rngLife    = new Float32Array(RING_POOL);
            const _rngMaxL    = new Float32Array(RING_POOL);
            const _rngCX      = new Float32Array(RING_POOL);
            const _rngCZ      = new Float32Array(RING_POOL);

            const VERTS_PER_RING = RING_SEGS + 1;
            const _ringPosArr = new Float32Array(RING_POOL * VERTS_PER_RING * 3);
            const _ringAlpArr = new Float32Array(RING_POOL * VERTS_PER_RING);

            const _rngAngles = new Float32Array(VERTS_PER_RING);
            for (let s = 0; s <= RING_SEGS; s++) {
                _rngAngles[s] = (s / RING_SEGS) * Math.PI * 2;
            }

            const _ringGeo = new THREE.BufferGeometry();
            const _rPosBuf = new THREE.BufferAttribute(_ringPosArr, 3);
            const _rAlpBuf = new THREE.BufferAttribute(_ringAlpArr, 1);
            _ringGeo.setAttribute('position', _rPosBuf);
            _ringGeo.setAttribute('alpha',    _rAlpBuf);

            // LineSegments index: each ring is RING_SEGS line segments
            const _rIdx = [];
            for (let r = 0; r < RING_POOL; r++) {
                const base = r * VERTS_PER_RING;
                for (let s = 0; s < RING_SEGS; s++) {
                    _rIdx.push(base + s, base + s + 1);
                }
            }
            _ringGeo.setIndex(_rIdx);

            const _ringMat = new THREE.ShaderMaterial({
                vertexShader: `
                    attribute float alpha;
                    varying   float vAlpha;
                    void main() {
                        vAlpha = alpha;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }`,
                fragmentShader: `
                    varying float vAlpha;
                    void main() {
                        gl_FragColor = vec4(0.78, 0.93, 1.0, vAlpha);
                    }`,
                transparent: true,
                depthWrite:  false,
                blending:    THREE.NormalBlending,
            });

            const _ringMesh = new THREE.LineSegments(_ringGeo, _ringMat);
            _ringMesh.frustumCulled = false;
            _ringMesh.renderOrder   = 5;
            scene.add(_ringMesh);

            let _rngSpawnTimer = 0;
            const SPAWN_RATE   = 1 / 9;

            function _spawnRipple(wx, wz) {
                for (let r = 0; r < RING_POOL; r++) {
                    if (_rngLife[r] > 0) continue;
                    _rngCX[r]     = wx;
                    _rngCZ[r]     = wz;
                    _rngRadius[r] = 0.01;
                    _rngMaxR[r]   = 0.3 + Math.random() * 0.7;
                    _rngMaxL[r]   = 0.6 + Math.random() * 0.5;
                    _rngLife[r]   = _rngMaxL[r];
                    return;
                }
            }

            function _updateRippleRings(dt) {
                const RING_WL = -(RIVER_DEPTH * 0.46) + 0.06;

                if (isRaining && typeof rbTerrainY === 'function') {
                    _rngSpawnTimer += dt;
                    while (_rngSpawnTimer >= SPAWN_RATE) {
                        _rngSpawnTimer -= SPAWN_RATE;
                        for (let attempt = 0; attempt < 10; attempt++) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist  = 1.5 + Math.random() * 20;
                            const tx = camera.position.x + Math.cos(angle) * dist;
                            const tz = camera.position.z + Math.sin(angle) * dist;
                            const ry = rbTerrainY(tx, tz);
                            if (ry <= -(RIVER_DEPTH * 0.46) + 0.05) {
                                _spawnRipple(tx, tz);
                                break;
                            }
                        }
                    }
                } else {
                    _rngSpawnTimer = 0;
                }

                for (let r = 0; r < RING_POOL; r++) {
                    const base = r * VERTS_PER_RING;
                    if (_rngLife[r] <= 0) {
                        for (let s = 0; s < VERTS_PER_RING; s++) {
                            const vi = (base + s) * 3;
                            _ringPosArr[vi]   = 0;
                            _ringPosArr[vi+1] = -9999;
                            _ringPosArr[vi+2] = 0;
                            _ringAlpArr[base + s] = 0;
                        }
                        continue;
                    }

                    _rngLife[r] -= dt;
                    const lt     = 1.0 - (_rngLife[r] / _rngMaxL[r]);
                    // Ease-out radius expansion
                    _rngRadius[r] = _rngMaxR[r] * (1.0 - Math.pow(1.0 - lt, 2.2));
                    // Bell-curve alpha, max 0.50
                    const alpha  = Math.sin(lt * Math.PI) * 0.50;

                    const cx = _rngCX[r], cz = _rngCZ[r], rad = _rngRadius[r];
                    for (let s = 0; s < VERTS_PER_RING; s++) {
                        const ang = _rngAngles[s];
                        const vi  = (base + s) * 3;
                        _ringPosArr[vi]   = cx + Math.cos(ang) * rad;
                        _ringPosArr[vi+1] = RING_WL;
                        _ringPosArr[vi+2] = cz + Math.sin(ang) * rad;
                        _ringAlpArr[base + s] = alpha;
                    }
                }

                _rPosBuf.needsUpdate = true;
                _rAlpBuf.needsUpdate = true;
            }

            window._updateRippleRings = _updateRippleRings;
        })();
        // ── End raindrop ripple rings ─────────────────────────────────────────

                // Schedule rain randomly: starts 1\u20135 min after load, lasts 1\u20133 min, then 3\u20138 min gap
        function scheduleNextRain() {
            const delay = (60 + Math.random() * 240) * 1000;
            rainScheduleTimer = setTimeout(() => {
                // Never rain in the desert
                if (_biomeBlend > 0.4) {
                    scheduleNextRain(); // just reschedule \u2014 try again later
                    return;
                }
                startRain();
                const duration = (60 + Math.random() * 120) * 1000;
                setTimeout(() => {
                    stopRain();
                    scheduleNextRain();
                }, duration);
            }, delay);
        }
        scheduleNextRain();
        
        // Update lightning flash effect
        function updateLightning() {
            if (!lightningActive) {
                lightningLight.intensity = 0;
                return;
            }
            
            const elapsed = Date.now() - lightningStartTime;
            
            if (elapsed >= lightningDuration) {
                // Lightning finished
                lightningActive = false;
                lightningLight.intensity = 0;
                return;
            }
            
            // Calculate fade in and fade out
            const fadeInDuration = 300; // 300ms fade in
            const peakDuration = 600; // 600ms at peak brightness
            const fadeOutDuration = 300; // 300ms fade out
            
            let intensity = 0;
            
            if (elapsed < fadeInDuration) {
                // Fade in
                intensity = (elapsed / fadeInDuration) * 8.0;
            } else if (elapsed < fadeInDuration + peakDuration) {
                // Peak brightness - flicker slightly for realism
                intensity = 8.0 + (Math.random() - 0.5) * 1.0;
            } else {
                // Fade out
                const fadeOutElapsed = elapsed - fadeInDuration - peakDuration;
                intensity = 8.0 * (1 - (fadeOutElapsed / fadeOutDuration));
            }
            
            lightningLight.intensity = Math.max(0, intensity);
            
            // Move lightning position slightly for each flash
            if (elapsed < 100) {
                lightningLight.position.set(
                    camera.position.x + (Math.random() - 0.5) * 100,
                    50 + Math.random() * 30,
                    camera.position.z + (Math.random() - 0.5) * 100
                );
            }
        }

        // ===== ANIMATION LOOP =====
        let _frameTime = 0;
        let _prevFrameTime = 0; // for delta-time calculation
        // Cached DOM element references (avoid getElementById every frame)
        let _cachedFishingHint = null;
        let _cachedFishingOverlay = null;
        let _cachedTimeEl = null; // time display element

        // ── Reusable scratch objects — never allocate these inside update loops ──
        const _scratchV3a = new THREE.Vector3();
        const _scratchV3b = new THREE.Vector3();
        const _scratchV3c = new THREE.Vector3();
        const _scratchBox  = new THREE.Box3();
        const _scratchBox2 = new THREE.Box3();
        const _scratchRaycaster = new THREE.Raycaster();

        // ── Pre-built flat collision array for collidesWithNature ──
        // Rebuilt only when the world changes (tree felled, rock mined, etc.)
        let _natureColliders = [];   // { x, z, r }
        let _natureCollidersStale = true; // set true whenever world changes
        function _rebuildNatureColliders() {
            _natureColliders = [];
            for (const p of treePositions)          _natureColliders.push({ x: p.x, z: p.z, r: (p.radius || 2) * 0.55 });
            for (const p of rockPositions)          _natureColliders.push({ x: p.x, z: p.z, r: (p.radius || 1.5) * 0.7 });
            for (const p of orePositions)           _natureColliders.push({ x: p.x, z: p.z, r: 0.9 });
            for (const p of sulfurPositions)        _natureColliders.push({ x: p.x, z: p.z, r: 0.9 });
            for (const p of bushPositions)          _natureColliders.push({ x: p.x, z: p.z, r: 0.9 });
            for (const p of desertFormationColliders) _natureColliders.push(p);
            for (const p of cactiPositions)         _natureColliders.push({ x: p.x, z: p.z, r: p.radius });
            _natureCollidersStale = false;
        }

        // ── Pre-built sky color constants — never allocate inside updateDayNight ──
        const _skyDayTop     = new THREE.Color(0x1a8fff);
        const _skyDayBot     = new THREE.Color(0xd4eeff);
        const _skyNightTop   = new THREE.Color(0x020510);
        const _skyNightBot   = new THREE.Color(0x05081a);
        const _skyStormDayTop   = new THREE.Color(0x505055);
        const _skyStormDayBot   = new THREE.Color(0x606068);
        const _skyStormNightTop = new THREE.Color(0x0a0a0f);
        const _skyStormNightBot = new THREE.Color(0x15151a);
        // Working colors reused every frame (lerp targets written in-place)
        const _skyNormalTop  = new THREE.Color();
        const _skyNormalBot  = new THREE.Color();
        const _skyStormTop   = new THREE.Color();
        const _skyStormBot   = new THREE.Color();
        const _skyCurTop     = new THREE.Color();
        const _skyCurBot     = new THREE.Color();
        // Pre-built cloud colors
        const _cloudDark     = new THREE.Color(0x8a8a90);
        const _cloudBright   = new THREE.Color(0xffffff);
        const _cloudTarget   = new THREE.Color();
        let _minimapFrame = 0;
        let _grassFrame = 0;
        let _cloudFrame = 0;
        const _reusableBox = new THREE.Box3(); // reusable Box3 ? avoids per-frame allocation in physics

        // ═══════════════════════════════════════════════════════════
        // THIRD-PERSON CAMERA SYSTEM  (rewritten — reference-code pattern)
        // Player body position (tp_playerPos) is independent of camera.
        // Camera orbits around tp_playerPos using tp_orbitYaw/Pitch.
        // ═══════════════════════════════════════════════════════════
        let isThirdPerson = false;
        let playerModel   = null;
        let playerMixer   = null;
        let playerClock   = new THREE.Clock();
        let _tpAnim       = null;
        let _tpClips      = {};

        const tp_playerPos  = new THREE.Vector3();   // foot position in world space
        let   tp_orbitYaw   = 0;    // camera orbit horizontal angle
        let   tp_orbitPitch = 0.4;  // camera orbit vertical angle
        const TP_DIST       = 4.5;
        const TP_HEAD       = 1.5;  // head height above foot

        // ── Load Player.glb on demand ──────────────────────────────
        async function _ensurePlayerModel() {
            if (playerModel) return;
            await _loadAssetGLB('Player.glb');
            const tmpl = _assetGLBCache['Player.glb'];
            if (!tmpl) { console.warn('Player.glb not found'); return; }

            // Clone for use in scene
            // Wrap in a container so we can position the container freely
            // without fighting the GLB's internal baked-in transforms
            const _glbInner = tmpl.clone(true);
            _glbFixTextures(_glbInner);
            _glbInner.traverse(c => {
                c.visible = true; c.frustumCulled = false;
                if (c.isMesh) { c.castShadow = true; c.receiveShadow = true; }
            });

            // Scale to ~1.8 m tall
            const bbox = new THREE.Box3().setFromObject(_glbInner);
            const h = bbox.max.y - bbox.min.y;
            if (h > 0) _glbInner.scale.setScalar(1.8 / h);

            // Ground the inner GLB so its feet sit at y=0 of the container
            _glbInner.updateMatrixWorld(true);
            const bbox2 = new THREE.Box3().setFromObject(_glbInner);
            if (isFinite(bbox2.min.y)) _glbInner.position.y -= bbox2.min.y;

            // playerModel is the container — position THIS in the world
            playerModel = new THREE.Group();
            playerModel.add(_glbInner);

            // Mixer drives the inner GLB's skeleton
            playerMixer = new THREE.AnimationMixer(_glbInner);
            const rawClips = tmpl.userData._animClips || {};  // clips stored on original template
            const clipNames = Object.keys(rawClips);
            console.log('🧍 Player.glb clips:', clipNames.join(', ') || '(none)');

            // Map common animation name patterns
            function pickClip(...candidates) {
                for (const cand of candidates) {
                    for (const name of clipNames) {
                        if (name.includes(cand)) return rawClips[name];
                    }
                }
                return clipNames.length ? rawClips[clipNames[0]] : null;
            }
            _tpClips = {
                idle:  pickClip('idle', 'stand', 'bind'),
                walk:  pickClip('walk', 'jog', 'move'),
                run:   pickClip('run', 'sprint', 'walk'),
                jump:  pickClip('jump', 'fall', 'air'),
            };

            scene.add(playerModel);
            console.log('🧍 Player model added to scene');
        }

        // ── Play a named animation with crossfade ──────────────────
        function _tpPlayAnim(name) {
            if (!playerMixer) return;
            const clip = _tpClips[name];
            if (!clip) return;
            const next = playerMixer.clipAction(clip);
            next.setLoop(THREE.LoopRepeat, Infinity);
            if (_tpAnim !== next) {
                next.reset();
                if (_tpAnim) _tpAnim.crossFadeTo(next, 0.15, true);
                next.play();
                _tpAnim = next;
            } else if (!next.isRunning()) {
                next.reset(); next.play();
            }
        }

        // ── Toggle 3rd / 1st person ────────────────────────────────
        async function toggleThirdPerson() {
            isThirdPerson = !isThirdPerson;
            if (isThirdPerson) {
                // Seed player body position from 1st-person camera
                tp_playerPos.set(camera.position.x, camera.position.y - 1.7, camera.position.z);
                // Seed orbit yaw so camera stays behind player on entry
                tp_orbitYaw = camera.rotation.y;
                tp_orbitPitch = 0.4;
                await _ensurePlayerModel();
                heldItemGroup.visible = false;
                if (typeof fpsArmHolder !== 'undefined') fpsArmHolder.visible = false;
                showMessage('📷 Third-Person Camera (P to toggle)');
            } else {
                // Restore 1st-person camera to player body position
                camera.position.set(tp_playerPos.x, tp_playerPos.y + 1.7, tp_playerPos.z);
                camera.rotation.order = 'YXZ';
                camera.rotation.y = tp_orbitYaw;
                camera.rotation.x = 0;
                camera.rotation.z = 0;
                if (playerModel) playerModel.visible = false;
                heldItemGroup.visible = true;
                // Restore arm visibility based on currently held item
                if (typeof fpsArmGroup !== 'undefined' && currentHeldItem) {
                    const toolItems = ['axe','stone_axe','pickaxe','stone_pickaxe','sword','spear','bow','pistol','machine_gun','hammer','sharp_stone'];
                    fpsArmHolder.visible = false;
                }
                showMessage('👁️ First-Person Camera');
            }
        }

        // ── Update 3rd-person every frame (called from animate) ────
        function updateThirdPerson() {
            if (!isThirdPerson || !playerModel) return;

            // 1. MOVE player body with WASD using tp_orbitYaw as look direction
            //    Camera sits at tp_orbitYaw BEHIND the player, so forward = -orbit direction.
            const fwdX = -Math.sin(tp_orbitYaw);
            const fwdZ = -Math.cos(tp_orbitYaw);
            const rgtX =  Math.cos(tp_orbitYaw);
            const rgtZ = -Math.sin(tp_orbitYaw);

            const isMoving = keys['w'] || keys['s'] || keys['a'] || keys['d'];

            // --- Time-based stamina ---
            const _nowSec = performance.now() * 0.001;
            const _dt = _staminaLastTime ? Math.min(_nowSec - _staminaLastTime, 0.1) : 0;
            _staminaLastTime = _nowSec;

            if (stamina <= 0 && !staminaExhausted) { staminaExhausted = true; staminaExhaustedAt = performance.now(); }
            if (staminaExhausted && (performance.now() - staminaExhaustedAt) >= exhaustedDuration * 1000) staminaExhausted = false;

            const isSprinting = keys['shift'] && !staminaExhausted && stamina > 0 && isMoving;
            const spd = staminaExhausted ? exhaustedSpeed : (isSprinting ? sprintSpeed : moveSpeed);

            if (isSprinting) {
                const drainMult = activeBuffs.veggi_stew ? 0.2 : 1.0;
                stamina = Math.max(0, stamina - staminaDrainPerSec * drainMult * _dt);
            } else if (!isMoving) {
                stamina = Math.min(maxStamina, stamina + staminaRegenFastPerSec * _dt);
            } else {
                stamina = Math.min(maxStamina, stamina + staminaRegenPerSec * _dt);
            }
            // Update stamina bar directly every frame
            _updateStaminaBar();

            let mdx = 0, mdz = 0;
            if (keys['w']) { mdx += fwdX; mdz += fwdZ; }
            if (keys['s']) { mdx -= fwdX; mdz -= fwdZ; }
            if (keys['a']) { mdx -= rgtX; mdz -= rgtZ; }
            if (keys['d']) { mdx += rgtX; mdz += rgtZ; }

            if (mdx !== 0 || mdz !== 0) {
                const len = Math.sqrt(mdx*mdx + mdz*mdz);
                const nx = tp_playerPos.x + (mdx/len) * spd;
                const nz = tp_playerPos.z + (mdz/len) * spd;
                const testPos = new THREE.Vector3(nx, tp_playerPos.y + 1.7, nz);
                if (!checkPlayerCollision(testPos)) {
                    // River terrain: check if step is too steep to climb
                    const _tpTerrY = _getTerrainY(nx, nz);
                    const _tpTargetY = _tpTerrY; // feet Y at new pos (terrain is at 0 + offset)
                    const _tpDeltaY  = _tpTargetY - tp_playerPos.y;
                    if (_tpDeltaY <= 0.35) { // allow gentle slopes, block steep banks
                        tp_playerPos.x = nx;
                        tp_playerPos.z = nz;
                        tp_playerPos.y = _tpTargetY; // snap feet to terrain
                    }
                }
            }

            // Sync playerY for gravity/jump system, then write back
            playerY = tp_playerPos.y + 1.7;
            camera.position.y = playerY; // let the existing jump physics see this
            tp_playerPos.y = playerY - 1.7;

            // 2. PLACE player model at body position
            playerModel.position.copy(tp_playerPos);
            playerModel.visible = true;

            // Smoothly rotate model toward movement direction
            if (isMoving && (mdx !== 0 || mdz !== 0)) {
                const targetYaw = Math.atan2(mdx, mdz);
                const diff = ((targetYaw - playerModel.rotation.y) + Math.PI * 3) % (Math.PI * 2) - Math.PI;
                playerModel.rotation.y += diff * 0.18;
            }

            // 3. ANIMATIONS
            if (isJumping)     _tpPlayAnim('jump');
            else if (isMoving) _tpPlayAnim(isSprinting ? 'run' : 'walk');
            else               _tpPlayAnim('idle');
            if (playerMixer) playerMixer.update(playerClock.getDelta());

            // 4. ORBIT CAMERA around player head (same pattern as reference code)
            const headPos = new THREE.Vector3(
                tp_playerPos.x,
                tp_playerPos.y + TP_HEAD,
                tp_playerPos.z
            );
            const pitch = Math.max(-0.4, Math.min(0.8, tp_orbitPitch));
            const orbitX = Math.sin(tp_orbitYaw) * Math.cos(pitch) * TP_DIST;
            const orbitY = Math.sin(pitch) * TP_DIST;
            const orbitZ = Math.cos(tp_orbitYaw) * Math.cos(pitch) * TP_DIST;
            camera.position.set(
                headPos.x + orbitX,
                Math.max(headPos.y + orbitY, tp_playerPos.y + 0.3),
                headPos.z + orbitZ
            );
            camera.lookAt(headPos);
            // lookAt sets camera.rotation — that's fine, we use tp_orbitYaw/Pitch not camera.rotation
        }

        // ── Proximity spatial sound update (called every frame) ───────────────
        // Throttled to ~10fps — spatial audio doesn't need 60fps precision
        let _proxThrottle = 0;
        function updateProximitySounds() {
            if (++_proxThrottle < 6) return; // run every 6 frames (~10fps)
            _proxThrottle = 0;
            if (audioContext.state === 'suspended') return;

            // Scan buildings and start sources for newly in-range hives/coops
            for (const b of buildings) {
                if (b.userData.isBeeHive) {
                    const dist = b.position.distanceTo(camera.position);
                    if (dist < HIVE_RANGE && !_hiveSources.has(b)) {
                        _startSpatialSource(_hiveBuffer, b, _hiveSources, HIVE_VOL);
                    }
                } else if (b.userData.isChickenCoop) {
                    const dist = b.position.distanceTo(camera.position);
                    if (dist < COOP_RANGE && !_coopSources.has(b)) {
                        _startSpatialSource(_chickenCoopBuffer, b, _coopSources, COOP_VOL);
                    }
                }
            }
            // Update listener + panner positions and cull out-of-range sources
            if (_hiveSources.size > 0) _updateSpatialSources(_hiveSources, _hiveBuffer, HIVE_RANGE, HIVE_VOL);
            if (_coopSources.size > 0) _updateSpatialSources(_coopSources, _chickenCoopBuffer, COOP_RANGE, COOP_VOL);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Don't update game if paused
            if (!isPaused) {
                _frameTime = performance.now() * 0.001; // compute once, used by all update fns (higher precision than Date.now)
                const _deltaMs = _prevFrameTime > 0 ? Math.min((_frameTime - _prevFrameTime) * 1000, 100) : 16.67; // clamp to 100ms max (tab unfocus etc)
                _prevFrameTime = _frameTime;
                _minimapFrame++;
                _grassFrame++;
                _cloudFrame++;

                updateMovement();
                updateThirdPerson();
                updateDayNight();
                updateEnemies();
                updateAnimals();
                updateSquirrels();
                if (_grassFrame >= 2)  { updateGrass();   _grassFrame = 0;   } // 30 fps ? imperceptible on gentle sway
                if (_cloudFrame >= 3)  { updateClouds();  _cloudFrame = 0;   } // 20 fps ? clouds move slowly
                updateBerryRespawn();
                updateWildPlantRespawn();
                updateResourceRespawns();
                updateBuildPreview();
                updateTrees();
                // River biome water animators
                if (window._customAnimators) { for (const fn of window._customAnimators) fn(_deltaMs / 1000); }
                // Distance culling — runs every 3 frames (~20fps), enough for static world objects
                if ((_minimapFrame % 3) === 0) { updateDistanceCulling(); }
                if (_minimapFrame >= 6) { updateMinimap(); _minimapFrame = 0; } // 10 fps ? map doesn't need 60
                updateToolAnimation();
                // Tick FPS arm animation mixer
                if (_fpsArmMixer && fpsArmHolder.visible) _fpsArmMixer.update(_fpsArmClock.getDelta());
                // Hide arm in 3rd person
                if (isThirdPerson && fpsArmHolder.visible) fpsArmHolder.visible = false;
                updateArrows();
                updateBullets();
                updatePistolReload();
                updateMachineGunFire();
                updateMachineGunReload();
                updateSmelting();
                updateCookingProcess();
                updateRecycling(_deltaMs);
                updateWaterCatcher(_deltaMs);
                updatePlayerTemperature();
                updateProximitySounds();
                _tickOpenHiveMenus();
                updateFishingSystem();
                // Fishing proximity hint
                {
                    if (!_cachedFishingHint)    _cachedFishingHint    = document.getElementById('fishing-hint');
                    if (!_cachedFishingOverlay) _cachedFishingOverlay = document.getElementById('fishing-overlay');
                    const _fhint = _cachedFishingHint;
                    const _foverlay = _cachedFishingOverlay;
                    if (_fhint && _foverlay && !fishingState.active) {
                        const heldItem = hotbar[selectedHotbarSlot]?.item;
                        const hasRodInHotbar = hotbar.some(s => s.item === 'fishing_rod');
                        const hasRodAnywhere = heldItem === 'fishing_rod' || hasRodInHotbar || (inventory['fishing_rod'] || 0) > 0;
                        if (hasRodAnywhere && _isNearRiver()) {
                            _foverlay.classList.add('visible');
                            _fhint.textContent = '🎣 Press E to fish';
                        } else if (!fishingState.active) {
                            _foverlay.classList.remove('visible');
                        }
                    }
                }
                // Smooth door animation lerp
                for (const b of buildings) {
                    if (!b.userData.isDoor) continue;
                    const lerpSpeed = 0.12;
                    if (b.userData.doorType === 'single' && b.userData.doorGroup) {
                        const tgt = b.userData.doorTargetY !== undefined ? b.userData.doorTargetY : (b.userData.isOpen ? -Math.PI/2 : 0);
                        const prev = b.userData.doorGroup.rotation.y;
                        // Skip lerp if door is already essentially at target (saves CPU when doors are idle)
                        if (Math.abs(tgt - prev) < 0.001) {
                            b.userData.doorGroup.rotation.y = tgt;
                        } else {
                        b.userData.doorGroup.rotation.y += (tgt - b.userData.doorGroup.rotation.y) * lerpSpeed;
                        // Play close sound when door finishes closing (target=0, crosses threshold)
                        if (!b.userData.isOpen && tgt === 0 && Math.abs(prev) > 0.05 && Math.abs(b.userData.doorGroup.rotation.y) <= 0.05 && !b.userData._closeSoundPlayed) {
                            b.userData._closeSoundPlayed = true;
                            playDoorCloseSound();
                        }
                        }
                        if (b.userData.isOpen) b.userData._closeSoundPlayed = false;
                    } else if (b.userData.doorType === 'double') {
                        if (b.userData.leftDoorGroup) {
                            const tL = b.userData.leftTargetY  !== undefined ? b.userData.leftTargetY  : (b.userData.isOpen ?  Math.PI/2 : 0);
                            const tR = b.userData.rightTargetY !== undefined ? b.userData.rightTargetY : (b.userData.isOpen ? -Math.PI/2 : 0);
                            const prevL = b.userData.leftDoorGroup.rotation.y;
                            // Skip lerp if double door is already at target
                            if (Math.abs(tL - prevL) < 0.001) {
                                b.userData.leftDoorGroup.rotation.y  = tL;
                                b.userData.rightDoorGroup.rotation.y = tR;
                            } else {
                            b.userData.leftDoorGroup.rotation.y  += (tL - b.userData.leftDoorGroup.rotation.y)  * lerpSpeed;
                            b.userData.rightDoorGroup.rotation.y += (tR - b.userData.rightDoorGroup.rotation.y) * lerpSpeed;
                            // Play close sound when double door finishes closing
                            if (!b.userData.isOpen && tL === 0 && Math.abs(prevL) > 0.05 && Math.abs(b.userData.leftDoorGroup.rotation.y) <= 0.05 && !b.userData._closeSoundPlayed) {
                                b.userData._closeSoundPlayed = true;
                                playDoorCloseSound();
                            }
                            }
                            if (b.userData.isOpen) b.userData._closeSoundPlayed = false;
                        }
                    }
                }
                updateHealing();
                updateParticles();
                updateBees();
                updateSandParticles();
                updateSnowFlourish();
                updateLocalSnow();
                // Snow biome: animate falling snowflakes
                if (window._snowFlakeMesh && window._snowFlakePos) {
                    const fp   = window._snowFlakePos;
                    const fwX  = window._snowFlakeWindX;
                    const fwZ  = window._snowFlakeWindZ;
                    const camX = camera.position.x, camZ = camera.position.z;
                    const inSnowBiome = Math.abs(camX - SB_CX) < SB_SIZE * 0.7 && Math.abs(camZ - SB_CZ) < SB_SIZE * 0.7;
                    window._snowFlakeMesh.visible = inSnowBiome;
                    if (inSnowBiome) {
                        // Gust pulse: a slow sine wave that strengthens/weakens the wind over time
                        const gustMult = 1.0 + Math.sin(_frameTime * 0.35) * 0.5 + Math.sin(_frameTime * 0.91) * 0.25;
                        for (let i = 0, fi = 0; i < fp.length; i += 3, fi++) {
                            // Fall speed varies per flake via sine on X position
                            fp[i + 1] -= 0.028 + Math.sin(fp[i] * 0.3 + _frameTime) * 0.008;
                            // Horizontal wind drift — strong sideways blow
                            fp[i]     += fwX[fi] * gustMult;
                            fp[i + 2] += fwZ[fi] * gustMult;
                            // Turbulent swirl on top of the base wind
                            fp[i]     += Math.sin(_frameTime * 1.1 + fp[i + 2] * 0.15) * 0.018;
                            fp[i + 2] += Math.cos(_frameTime * 0.9 + fp[i]     * 0.12) * 0.010;
                            const baseH = snowTerrainY(fp[i], fp[i+2]);
                            if (fp[i + 1] < baseH) {
                                // Respawn ahead in the wind direction so flakes stream continuously
                                fp[i]     = camX + (Math.random() - 0.5) * SB_SIZE * 0.9;
                                fp[i + 1] = 18 + Math.random() * 6;
                                fp[i + 2] = camZ + (Math.random() - 0.5) * SB_SIZE * 0.9;
                            }
                        }
                        window._snowFlakeGeo.attributes.position.needsUpdate = true;
                    }
                }
                updateDeathBackpacks();
                tickBuffs();
                updateBuffHUD();
                updateScorpions();
                spawnScorpions();
                updateCoyotes();
                spawnCoyotes();
                _tickAutoSave(_deltaMs / 1000); // autosave every 2 minutes
            }

            // Weather always updates regardless of pause so rain fades out correctly
            updateRain();
            updateLightning();
            updateSplashParticles();
            if (window._updateRippleRings) window._updateRippleRings(1/60);
            updateWetGround();
            
            const activeCamera = isDead && deathCamera ? deathCamera : camera;

            // --- Post-processing pipeline (wet ground screen effect) ---
            updateHeatHaze();
            if (_wetness > 0.03) { // skip double-render for nearly-dry ground (saves GPU during long dry-out)
                renderer.setRenderTarget(_hazeRT);
                renderer.render(scene, activeCamera);
                renderer.setRenderTarget(null);
                renderer.render(_hazeScene, _hazeCamera);
            } else {
                renderer.render(scene, activeCamera);
            }
        } // end animate
        
        // ===== UNIFIED DRAG-AND-DROP SYSTEM =====
        // Covers: inventory, hotbar, storage, furnace, campfire, cooking station,
        //         recycler (input + output), water catcher, backpack.
        // Every slot that has items can be dragged FROM.
        // Every appropriate slot can be dropped TO.

        // ── Shared helpers ──────────────────────────────────────────────────

        /** Deduct `amount` of `item` from whatever source draggedFromType points to. */
        function _deductFromSource(item, amount) {
            if (draggedFromType === 'inventory') {
                inventory[item] = Math.max(0, (inventory[item] || 0) - amount);
                if (inventorySlotCounts[draggedFromSlot] !== null) {
                    inventorySlotCounts[draggedFromSlot] = Math.max(0, inventorySlotCounts[draggedFromSlot] - amount);
                    if (inventorySlotCounts[draggedFromSlot] <= 0) {
                        inventorySlotCounts[draggedFromSlot] = null;
                        inventorySlots[draggedFromSlot] = null;
                    }
                } else if ((inventory[item] || 0) <= 0) {
                    inventorySlots[draggedFromSlot] = null;
                }
            } else if (draggedFromType === 'hotbar') {
                inventory[item] = Math.max(0, (inventory[item] || 0) - amount);
                if ((inventory[item] || 0) <= 0) hotbar[draggedFromSlot].item = null;
            } else if (draggedFromType === 'storage' && currentStorageBox) {
                const si = currentStorageBox.userData.storageInventory;
                if (si[draggedFromSlot]) {
                    si[draggedFromSlot].count -= amount;
                    if (si[draggedFromSlot].count <= 0) si[draggedFromSlot] = null;
                }
            }
        }

        /** Add `amount` of `item` to inventory and sync slots. */
        function _addToInventory(item, amount, preferSlotIndex) {
            // Check if main inventory has room (item already in a slot, or there's a free slot)
            const alreadyInMain = inventorySlots.includes(item);
            const freeMainSlot = inventorySlots.findIndex(s => s === null);
            const mainHasRoom = alreadyInMain || freeMainSlot !== -1;

            if (mainHasRoom) {
                inventory[item] = (inventory[item] || 0) + amount;
                // If preferSlotIndex is empty, use it; else find any empty slot
                if (preferSlotIndex !== undefined && !inventorySlots[preferSlotIndex]) {
                    inventorySlots[preferSlotIndex] = item;
                } else if (!alreadyInMain) {
                    const empty = inventorySlots.findIndex(s => s === null);
                    if (empty !== -1) inventorySlots[empty] = item;
                }
            } else {
                // Main inventory full — try to overflow into equipped backpack
                const freeBpSlot = backpackSlots.findIndex(s => s === null);
                if (freeBpSlot !== -1) {
                    backpackSlots[freeBpSlot] = { item, count: amount };
                    showMessage(`🎒 Inventory full — ${amount}x ${item.replace(/_/g,' ')} added to backpack`);
                    // Still update the inventory count so item data is consistent
                    // but don't add a main-slot entry — backpack is the container
                } else {
                    // Both full — just add to inventory count and warn (legacy behaviour)
                    inventory[item] = (inventory[item] || 0) + amount;
                    showMessage(`⚠️ Inventory & backpack full! ${amount}x ${item.replace(/_/g,' ')} dropped on floor`);
                }
            }
        }

        /** Add `amount` of `item` to storage box. */
        function _addToStorage(item, amount) {
            const si = currentStorageBox.userData.storageInventory;
            for (let i = 0; i < si.length; i++) {
                if (si[i] && si[i].name === item) { si[i].count += amount; return; }
            }
            for (let i = 0; i < si.length; i++) {
                if (!si[i]) { si[i] = { name: item, count: amount }; return; }
            }
        }

        /** Full UI refresh after any drag/drop operation. */
        function _refreshAll() {
            updateInventoryDisplay();
            updateHotbar();
            if (currentStorageBox) updateStorageDisplay();
            playInventoryMoveSound();
        }

        // ── Station slot drag-source setup ──────────────────────────────────
        // Call this any time a station display is rerendered to keep drag current.

        function _bindStationSlotDragSource(el, sourceType, item, count, slotIndex) {
            if (!item || count <= 0) {
                el.removeAttribute('draggable');
                el.ondragstart = null;
                el.ondragend = null;
                return;
            }
            el.setAttribute('draggable', 'true');
            el.ondragstart = (e) => {
                draggedItem = item;
                draggedFromSlot = slotIndex;
                draggedFromType = sourceType;
                draggedCount = e.ctrlKey ? Math.max(1, Math.floor(count / 2)) : count;
                draggedCtrl = e.ctrlKey;
                e.dataTransfer.effectAllowed = 'move';
                el.classList.add('dragging');
            };
            el.ondragend = () => {
                el.classList.remove('dragging');
                draggedItem = null; draggedFromSlot = null;
                draggedFromType = null; draggedCtrl = false; draggedCount = 0;
            };
        }

        // ── Drop target helper ───────────────────────────────────────────────

        function _makeDragTarget(el, onDrop) {
            el.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                el.classList.add('drag-over');
            });
            el.addEventListener('dragleave', () => el.classList.remove('drag-over'));
            el.addEventListener('drop', (e) => {
                e.preventDefault();
                el.classList.remove('drag-over');
                if (!draggedItem) return;
                onDrop(e);
                draggedItem = null; draggedFromSlot = null;
                draggedFromType = null; draggedCtrl = false; draggedCount = 0;
            });
        }

        // ── Generic "drag OUT from station, drop to inv/hotbar/storage" ─────

        function _dropToDestination(item, amount, dropSlotType, dropSlotIndex) {
            if (!item || amount <= 0) return;
            if (dropSlotType === 'inventory') {
                _addToInventory(item, amount, dropSlotIndex);
                updateInventoryDisplay();
            } else if (dropSlotType === 'hotbar') {
                inventory[item] = (inventory[item] || 0) + amount;
                if (!hotbar[dropSlotIndex].item) hotbar[dropSlotIndex].item = item;
                updateHotbar();
            } else if (dropSlotType === 'storage' && currentStorageBox) {
                _addToStorage(item, amount);
                updateStorageDisplay();
            }
            updateUI();
        }

        // ══════════════════════════════════════════════════════════════════════
        //  FURNACE CLICK + DRAG HANDLERS
        // ══════════════════════════════════════════════════════════════════════

        // Input slots click
        for (let i = 0; i < 3; i++) {
            document.getElementById(`furnace-input-slot-${i}`).addEventListener('click', () => addToSmeltingSlot('furnace', 'input', i));
        }
        // Output / waste clicks
        document.getElementById('furnace-fuel-slot').addEventListener('click',       () => addToSmeltingSlot('furnace', 'fuel'));
        document.getElementById('furnace-output-slot-0').addEventListener('click',   () => addToSmeltingSlot('furnace', 'output', 0));
        document.getElementById('furnace-output-slot-1').addEventListener('click',   () => addToSmeltingSlot('furnace', 'output', 1));
        document.getElementById('furnace-waste-slot').addEventListener('click',      () => addToSmeltingSlot('furnace', 'waste'));

        // Fuel slot — drag OUT (to inv/hotbar/storage)
        document.getElementById('furnace-fuel-slot').addEventListener('dragstart', handleDragStart);
        document.getElementById('furnace-fuel-slot').addEventListener('dragend',   handleDragEnd);

        // Furnace input slots — drag IN from inventory / hotbar / storage
        for (let i = 0; i < 3; i++) {
            (function(idx) {
                const slotEl = document.getElementById(`furnace-input-slot-${idx}`);
                _makeDragTarget(slotEl, () => {
                    if (!FURNACE_VALID_ORES.includes(draggedItem)) {
                        showMessage('⚠️ Only ores can go in the furnace!'); return;
                    }
                    const state = currentFurnace && currentFurnace.userData.smeltingState;
                    if (!state) return;
                    const slotData = state.inputSlots[idx];
                    if (slotData && slotData.item !== draggedItem) {
                        showMessage('⚠️ That slot already contains a different ore!'); return;
                    }
                    const amount = draggedCount;
                    if (!slotData) state.inputSlots[idx] = { item: draggedItem, count: 0 };
                    state.inputSlots[idx].count += amount;
                    _deductFromSource(draggedItem, amount);
                    updateSmeltingDisplay('furnace');
                    _refreshAll();
                });
            })(i);
        }

        // Furnace fuel slot — drag IN
        _makeDragTarget(document.getElementById('furnace-fuel-slot'), () => {
            if (!['wood','sticks'].includes(draggedItem)) {
                showMessage('⚠️ Only wood or sticks can be used as fuel!'); return;
            }
            const state = currentFurnace && currentFurnace.userData.smeltingState;
            if (!state) return;
            if (state.fuelItem && state.fuelItem !== draggedItem) {
                showMessage('⚠️ Remove existing fuel first!'); return;
            }
            if (!state.fuelItem) state.fuelItem = draggedItem;
            state.fuelCount += draggedCount;
            _deductFromSource(draggedItem, draggedCount);
            updateSmeltingDisplay('furnace');
            _refreshAll();
        });

        // Furnace output/waste slots — drag OUT to inventory/hotbar/storage
        // (These are set up by updateSmeltingDisplay via _bindStationSlotDragSource)
        // Drop targets so inv/hotbar items can't accidentally land on them:
        ['furnace-output-slot-0','furnace-output-slot-1','furnace-waste-slot'].forEach(id => {
            _makeDragTarget(document.getElementById(id), () => {
                // Output slots are "take only" — ignore drops from other sources
                showMessage('⚠️ You can\'t place items here — click to collect!');
            });
        });

        // ══════════════════════════════════════════════════════════════════════
        //  CAMPFIRE CLICK + DRAG HANDLERS
        // ══════════════════════════════════════════════════════════════════════

        document.getElementById('campfire-input-slot').addEventListener('click', () => addToSmeltingSlot('campfire', 'input'));
        document.getElementById('campfire-fuel-slot').addEventListener('click',  () => addToSmeltingSlot('campfire', 'fuel'));
        document.getElementById('campfire-waste-slot').addEventListener('click', () => addToSmeltingSlot('campfire', 'waste'));
        // 4 campfire output slot click handlers
        for (let i = 0; i < 4; i++) {
            const outEl = document.getElementById(`campfire-output-slot-${i}`);
            if (outEl) {
                const idx = i;
                outEl.addEventListener('click', () => {
                    const state = currentCampfire && currentCampfire.userData.smeltingState;
                    if (!state || !state.campfireOutputSlots) return;
                    const outData = state.campfireOutputSlots[idx];
                    if (outData && outData.count > 0) {
                        inventory[outData.item] = (inventory[outData.item]||0) + outData.count;
                        state.campfireOutputSlots[idx] = null;
                        updateUI(); updateInventoryDisplay(); updateSmeltingDisplay('campfire');
                        playCollectSound();
                    }
                });
                // Drag out support
                outEl.addEventListener('dragstart', (e) => {
                    const state = currentCampfire && currentCampfire.userData.smeltingState;
                    if (!state || !state.campfireOutputSlots) { e.preventDefault(); return; }
                    const outData = state.campfireOutputSlots[idx];
                    if (!outData || outData.count <= 0) { e.preventDefault(); return; }
                    draggedItem = outData.item;
                    draggedFromSlot = idx;
                    draggedFromType = 'campfire-output-new';
                    draggedCount = e.ctrlKey ? Math.max(1, Math.floor(outData.count/2)) : outData.count;
                    draggedCtrl = e.ctrlKey;
                    e.dataTransfer.effectAllowed = 'move';
                    outEl.classList.add('dragging');
                });
                outEl.addEventListener('dragend', () => {
                    outEl.classList.remove('dragging');
                    draggedItem = null; draggedFromSlot = null;
                    draggedFromType = null; draggedCtrl = false; draggedCount = 0;
                });
            }
        }

        // Fuel drag OUT
        document.getElementById('campfire-fuel-slot').addEventListener('dragstart', handleDragStart);
        document.getElementById('campfire-fuel-slot').addEventListener('dragend',   handleDragEnd);

        // Campfire input — drag IN (adds to queue)
        _makeDragTarget(document.getElementById('campfire-input-slot'), () => {
            if (!CAMPFIRE_VALID_FOODS.includes(draggedItem)) {
                showMessage('⚠️ Only food can be placed in the campfire!'); return;
            }
            const state = currentCampfire && currentCampfire.userData.smeltingState;
            if (!state) return;
            if (!state.cookQueue) state.cookQueue = [];
            if (state.cookQueue.length >= 4) {
                showMessage('⚠️ Campfire queue is full! Collect cooked food first.'); return;
            }
            const toAdd = Math.min(draggedCount, 4 - state.cookQueue.length);
            for (let a = 0; a < toAdd; a++) {
                state.cookQueue.push({ item: draggedItem });
            }
            // Prime input slot if idle
            if (!state.inputItem && !state.isProcessing && state.cookQueue.length > 0) {
                const next = state.cookQueue.shift();
                state.inputItem = next.item;
                state.inputCount = 1;
            }
            _deductFromSource(draggedItem, toAdd);
            updateSmeltingDisplay('campfire');
            _refreshAll();
        });

        // Campfire fuel — drag IN
        _makeDragTarget(document.getElementById('campfire-fuel-slot'), () => {
            if (!['wood','sticks'].includes(draggedItem)) {
                showMessage('⚠️ Only wood or sticks can be used as fuel!'); return;
            }
            const state = currentCampfire && currentCampfire.userData.smeltingState;
            if (!state) return;
            if (state.fuelItem && state.fuelItem !== draggedItem) {
                showMessage('⚠️ Remove existing fuel first!'); return;
            }
            if (!state.fuelItem) state.fuelItem = draggedItem;
            state.fuelCount += draggedCount;
            _deductFromSource(draggedItem, draggedCount);
            updateSmeltingDisplay('campfire');
            _refreshAll();
        });

        // Campfire output/waste — take-only drop targets (legacy slot)
        const _legacyCampfireOut = document.getElementById('campfire-output-slot');
        if (_legacyCampfireOut) {
            _makeDragTarget(_legacyCampfireOut, () => {
                showMessage('⚠️ Click to collect from this slot!');
            });
        }
        ['campfire-waste-slot'].forEach(id => {
            _makeDragTarget(document.getElementById(id), () => {
                showMessage('⚠️ Click to collect from this slot!');
            });
        });

        document.getElementById('close-furnace').addEventListener('click',          closeFurnaceMenu);
        document.getElementById('close-campfire').addEventListener('click',         closeCampfireMenu);
        document.getElementById('close-cooking-station').addEventListener('click',  closeCookingStationMenu);

        // ══════════════════════════════════════════════════════════════════════
        //  COOKING STATION CLICK + DRAG HANDLERS
        // ══════════════════════════════════════════════════════════════════════

        for (let i = 0; i < 5; i++) {
            document.getElementById(`cs-input-${i}`).addEventListener('click', () => addToCookingSlot('input', i));
        }
        document.getElementById('cs-output-slot').addEventListener('click', () => addToCookingSlot('output', 0));
        document.getElementById('cs-waste-slot').addEventListener('click',  () => addToCookingSlot('waste',  0));
        for (let i = 0; i < 4; i++) {
            const outEl = document.getElementById(`cs-output-slot-${i}`);
            if (outEl) {
                const idx = i;
                outEl.addEventListener('click', () => addToCookingSlot('output-new', idx));
                // Drag out support
                outEl.addEventListener('dragstart', (e) => {
                    const station = currentCookingStation;
                    const state = station && station.userData.cookingState;
                    if (!state || !state.csOutputSlots) { e.preventDefault(); return; }
                    const outData = state.csOutputSlots[idx];
                    if (!outData || outData.count <= 0) { e.preventDefault(); return; }
                    draggedItem = outData.item;
                    draggedFromSlot = idx;
                    draggedFromType = 'cs-output-new';
                    draggedCount = e.ctrlKey ? Math.max(1, Math.floor(outData.count / 2)) : outData.count;
                    draggedCtrl = e.ctrlKey;
                    e.dataTransfer.effectAllowed = 'move';
                    outEl.classList.add('dragging');
                });
                outEl.addEventListener('dragend', () => {
                    outEl.classList.remove('dragging');
                    draggedItem = null; draggedFromSlot = null;
                    draggedFromType = null; draggedCtrl = false; draggedCount = 0;
                });
            }
        }

        // Cook button removed — recipe cards handle cooking directly.
        // Legacy cook button handler kept as no-op to avoid errors.
        const _csCookBtn = document.getElementById('cs-cook-btn');
        if (_csCookBtn) _csCookBtn.addEventListener('click', () => {
            const station = currentCookingStation;
            if (!station || !station.userData.cookingState) return;
            const state = station.userData.cookingState;
            if (!state.cookQueue) state.cookQueue = [];
            if (!state.csOutputSlots) state.csOutputSlots = [null,null,null,null];
            // Queue can hold up to 4 items
            const totalSlots = 4;
            const occupied = state.cookQueue.length + state.csOutputSlots.filter(s => s).length;
            if (occupied >= totalSlots) {
                showMessage('⚠️ Queue is full! Collect cooked food first.');
                return;
            }
            const recipe = _csMatchRecipe(state);
            if (!recipe) { showMessage('⚠️ No valid recipe in the cooking station!'); return; }
            // Snapshot current ingredient slots and push to queue
            const ingredientSnapshot = state.csInputSlots.map(s => s ? {...s} : null);
            state.cookQueue.push({
                recipe: recipe,
                result: recipe.result,
                ingredientSlots: ingredientSnapshot
            });
            // Clear input slots so player can fill next recipe
            state.csInputSlots = [null,null,null,null,null];
            state.currentRecipe = null;
            const _cookSecs = Math.round((recipe.cookTime||20000) / 1000);
            showMessage(`🍳 Recipe queued! (${_cookSecs}s) — ${state.cookQueue.length} in queue`);
            updateUI();
            updateInventoryDisplay();
            updateCookingStationDisplay();
        });

        // Cooking station input slots — click only (drag removed)
        // No drag-in or drag-out on cs-input slots; click-to-add and recipe auto-fill handle everything.

        // Cooking station output — drag OUT only (click already handles collect)
        (function() {
            const el = document.getElementById('cs-output-slot');
            el.addEventListener('dragstart', (e) => {
                const station = currentCookingStation;
                const state = station && station.userData.cookingState;
                if (!state || !state.outputItem || state.outputCount <= 0) { e.preventDefault(); return; }
                draggedItem = state.outputItem;
                draggedFromSlot = 0;
                draggedFromType = 'cs-output';
                draggedCount = e.ctrlKey ? Math.max(1, Math.floor(state.outputCount / 2)) : state.outputCount;
                draggedCtrl = e.ctrlKey;
                e.dataTransfer.effectAllowed = 'move';
                el.classList.add('dragging');
            });
            el.addEventListener('dragend', () => {
                el.classList.remove('dragging');
                draggedItem = null; draggedFromSlot = null;
                draggedFromType = null; draggedCtrl = false; draggedCount = 0;
            });
        })();

        // Cooking station waste — drag OUT only
        (function() {
            const el = document.getElementById('cs-waste-slot');
            el.addEventListener('dragstart', (e) => {
                const station = currentCookingStation;
                const state = station && station.userData.cookingState;
                if (!state || !state.wasteCount || state.wasteCount <= 0) { e.preventDefault(); return; }
                draggedItem = 'ash';
                draggedFromSlot = 0;
                draggedFromType = 'cs-waste';
                draggedCount = e.ctrlKey ? Math.max(1, Math.floor(state.wasteCount / 2)) : state.wasteCount;
                draggedCtrl = e.ctrlKey;
                e.dataTransfer.effectAllowed = 'move';
                el.classList.add('dragging');
            });
            el.addEventListener('dragend', () => {
                el.classList.remove('dragging');
                draggedItem = null; draggedFromSlot = null;
                draggedFromType = null; draggedCtrl = false; draggedCount = 0;
            });
        })();

        // ══════════════════════════════════════════════════════════════════════
        //  RECYCLER CLICK + DRAG HANDLERS
        // ══════════════════════════════════════════════════════════════════════

        document.getElementById('close-recycler').addEventListener('click', closeRecyclerMenu);
        document.getElementById('recycler-start-btn').addEventListener('click', startRecycling);

        document.querySelectorAll('.recycler-slot').forEach(slot => {
            const slotType  = slot.getAttribute('data-slot');
            const slotIndex = parseInt(slot.getAttribute('data-index'));

            // Click handler (existing behaviour)
            slot.addEventListener('click', () => addToRecyclerSlot(slotType, slotIndex));

            // Drag IN — only for input slots
            if (slotType === 'input') {
                _makeDragTarget(slot, () => {
                    if (!recycleRecipes || !recycleRecipes[draggedItem]) {
                        showMessage('⚠️ This item cannot be recycled!'); return;
                    }
                    const amount = draggedCount;
                    const existing = recyclerState.inputSlots[slotIndex];
                    if (existing && existing.item !== draggedItem) {
                        showMessage('⚠️ Slot already has a different item!'); return;
                    }
                    // Check source has the items
                    let available = 0;
                    if (draggedFromType === 'inventory')      available = inventory[draggedItem] || 0;
                    else if (draggedFromType === 'hotbar')    available = inventory[draggedItem] || 0;
                    else if (draggedFromType === 'storage' && currentStorageBox) {
                        const si = currentStorageBox.userData.storageInventory;
                        const s = si[draggedFromSlot];
                        available = s ? s.count : 0;
                    }
                    const actual = Math.min(amount, available);
                    if (actual <= 0) return;
                    if (!existing) recyclerState.inputSlots[slotIndex] = { item: draggedItem, count: 0 };
                    recyclerState.inputSlots[slotIndex].count += actual;
                    _deductFromSource(draggedItem, actual);
                    updateRecyclerDisplay();
                    _refreshAll();
                });
            }

            // Drag OUT — works for both input and output slots
            slot.setAttribute('draggable', 'true');
            slot.addEventListener('dragstart', (e) => {
                const slotData = slotType === 'input'
                    ? recyclerState.inputSlots[slotIndex]
                    : recyclerState.outputSlots[slotIndex];
                if (!slotData || !slotData.item || slotData.count <= 0) { e.preventDefault(); return; }
                draggedItem     = slotData.item;
                draggedFromSlot = slotIndex;
                draggedFromType = `recycler-${slotType}`;
                draggedCount    = e.ctrlKey ? Math.max(1, Math.floor(slotData.count / 2)) : slotData.count;
                draggedCtrl     = e.ctrlKey;
                e.dataTransfer.effectAllowed = 'move';
                slot.classList.add('dragging');
            });
            slot.addEventListener('dragend', () => {
                slot.classList.remove('dragging');
                draggedItem = null; draggedFromSlot = null;
                draggedFromType = null; draggedCtrl = false; draggedCount = 0;
            });

            // Output slots are also drop targets (collect to wherever dropped)
            if (slotType === 'output') {
                _makeDragTarget(slot, () => showMessage('⚠️ Drag recycler output to your inventory or hotbar!'));
            }
        });

        // ══════════════════════════════════════════════════════════════════════
        //  WATER CATCHER CLICK + DRAG HANDLERS
        // ══════════════════════════════════════════════════════════════════════

        document.getElementById('close-water-catcher').addEventListener('click', closeWaterCatcherMenu);

        document.querySelectorAll('.wc-slot').forEach(slot => {
            const idx = parseInt(slot.getAttribute('data-wc-slot'));

            // Click to collect
            slot.addEventListener('click', () => {
                const slotData = waterCatcherState.outputSlots[idx];
                if (!slotData) return;
                _addToInventory(slotData.item, slotData.count);
                waterCatcherState.outputSlots[idx] = null;
                showMessage(`💧 Collected ${slotData.count} water bottle(s)!`);
                updateInventoryDisplay(); updateWaterCatcherDisplay(); updateUI(); updateHotbar();
            });

            // Drag OUT
            slot.addEventListener('dragstart', (e) => {
                const slotData = waterCatcherState.outputSlots[idx];
                if (!slotData || !slotData.item) { e.preventDefault(); return; }
                draggedItem     = slotData.item;
                draggedFromSlot = idx;
                draggedFromType = 'water-catcher';
                draggedCount    = e.ctrlKey ? Math.max(1, Math.floor(slotData.count / 2)) : slotData.count;
                draggedCtrl     = e.ctrlKey;
                e.dataTransfer.effectAllowed = 'move';
                slot.classList.add('dragging');
            });
            slot.addEventListener('dragend', () => {
                slot.classList.remove('dragging');
                draggedItem = null; draggedFromSlot = null;
                draggedFromType = null; draggedCount = 0;
            });
        });

        // ══════════════════════════════════════════════════════════════════════
        //  PATCH handleDrop — handle ALL station drag-source types
        // ══════════════════════════════════════════════════════════════════════

        const _origHandleDropStation = handleDrop;
        handleDrop = function(e) {
            const stationSourceTypes = new Set([
                'furnace-fuel', 'campfire-fuel',
                'furnace-input', 'furnace-output', 'furnace-waste',
                'campfire-input', 'campfire-output', 'campfire-waste',
                'cs-output', 'cs-waste',
                'recycler-input', 'recycler-output',
                'water-catcher'
            ]);

            if (!stationSourceTypes.has(draggedFromType)) {
                // Normal inventory/hotbar/storage drag — let original handler deal with it
                _origHandleDropStation.call(this, e);
                return;
            }

            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');

            const dropSlotType  = e.currentTarget.dataset.slotType;
            const dropSlotIndex = parseInt(e.currentTarget.dataset.slotIndex);
            const item          = draggedItem;
            const amount        = draggedCount;

            if (!item || amount <= 0) return;

            // ── Recycler input → anywhere ──
            if (draggedFromType === 'recycler-input') {
                const srcSlot = recyclerState.inputSlots[draggedFromSlot];
                if (!srcSlot) return;
                const actual = Math.min(amount, srcSlot.count);
                if (actual <= 0) return;
                _dropToDestination(item, actual, dropSlotType, dropSlotIndex);
                srcSlot.count -= actual;
                if (srcSlot.count <= 0) recyclerState.inputSlots[draggedFromSlot] = null;
                updateRecyclerDisplay();
                return;
            }

            // ── Recycler output → anywhere ──
            if (draggedFromType === 'recycler-output') {
                const srcSlot = recyclerState.outputSlots[draggedFromSlot];
                if (!srcSlot) return;
                const actual = Math.min(amount, srcSlot.count);
                if (actual <= 0) return;
                _dropToDestination(item, actual, dropSlotType, dropSlotIndex);
                srcSlot.count -= actual;
                if (srcSlot.count <= 0) recyclerState.outputSlots[draggedFromSlot] = null;
                updateRecyclerDisplay();
                playCollectSound();
                return;
            }

            // ── Water catcher → anywhere ──
            if (draggedFromType === 'water-catcher') {
                const srcSlot = waterCatcherState.outputSlots[draggedFromSlot];
                if (!srcSlot) return;
                const actual = Math.min(amount, srcSlot.count);
                if (actual <= 0) return;
                _dropToDestination(item, actual, dropSlotType, dropSlotIndex);
                srcSlot.count -= actual;
                if (srcSlot.count <= 0) waterCatcherState.outputSlots[draggedFromSlot] = null;
                showMessage(`💧 Collected ${actual} water bottle(s)!`);
                updateWaterCatcherDisplay();
                return;
            }

            // ── Cooking station new output slots → inventory/hotbar/storage ──
            if (draggedFromType === 'cs-output-new') {
                const station = currentCookingStation;
                const state = station && station.userData.cookingState;
                if (!state || !state.csOutputSlots) return;
                const outData = state.csOutputSlots[draggedFromSlot];
                if (!outData) return;
                const actual = Math.min(amount, outData.count);
                if (actual <= 0) return;
                _dropToDestination(item, actual, dropSlotType, dropSlotIndex);
                outData.count -= actual;
                if (outData.count <= 0) state.csOutputSlots[draggedFromSlot] = null;
                updateCookingStationDisplay();
                playCollectSound();
                return;
            }

            // ── Campfire new output slots → inventory/hotbar/storage ──
            if (draggedFromType === 'campfire-output-new') {
                const state = currentCampfire && currentCampfire.userData.smeltingState;
                if (!state || !state.campfireOutputSlots) return;
                const outData = state.campfireOutputSlots[draggedFromSlot];
                if (!outData) return;
                const actual = Math.min(amount, outData.count);
                if (actual <= 0) return;
                _dropToDestination(item, actual, dropSlotType, dropSlotIndex);
                outData.count -= actual;
                if (outData.count <= 0) state.campfireOutputSlots[draggedFromSlot] = null;
                updateSmeltingDisplay('campfire');
                playCollectSound();
                return;
            }

            // ── Cooking station output → inventory/hotbar/storage ──
            if (draggedFromType === 'cs-output') {
                const station = currentCookingStation;
                const state = station && station.userData.cookingState;
                if (!state || !state.outputItem) return;
                const actual = Math.min(amount, state.outputCount);
                if (actual <= 0) return;
                _dropToDestination(item, actual, dropSlotType, dropSlotIndex);
                state.outputCount -= actual;
                if (state.outputCount <= 0) { state.outputCount = 0; state.outputItem = null; }
                updateCookingStationDisplay();
                return;
            }

            // ── Cooking station waste → inventory/hotbar/storage ──
            if (draggedFromType === 'cs-waste') {
                const station = currentCookingStation;
                const state = station && station.userData.cookingState;
                if (!state) return;
                const actual = Math.min(amount, state.wasteCount || 0);
                if (actual <= 0) return;
                _dropToDestination(item, actual, dropSlotType, dropSlotIndex);
                state.wasteCount = (state.wasteCount || 0) - actual;
                updateCookingStationDisplay();
                return;
            }

            // ── Furnace/campfire fuel → inventory/hotbar/storage ──
            if (draggedFromType === 'furnace-fuel' || draggedFromType === 'campfire-fuel') {
                const stationType = draggedFromType === 'furnace-fuel' ? 'furnace' : 'campfire';
                _returnFuelToSlot(stationType, amount, dropSlotType, dropSlotIndex);
                return;
            }

            // ── Furnace input → inventory/hotbar/storage ──
            if (draggedFromType === 'furnace-input') {
                const state = currentFurnace && currentFurnace.userData.smeltingState;
                if (!state) return;
                const srcSlot = state.inputSlots[draggedFromSlot];
                if (!srcSlot) return;
                const actual = Math.min(amount, srcSlot.count);
                if (actual <= 0) return;
                _dropToDestination(item, actual, dropSlotType, dropSlotIndex);
                srcSlot.count -= actual;
                if (srcSlot.count <= 0) state.inputSlots[draggedFromSlot] = null;
                updateSmeltingDisplay('furnace');
                return;
            }

            // ── Furnace output → inventory/hotbar/storage ──
            if (draggedFromType === 'furnace-output') {
                const state = currentFurnace && currentFurnace.userData.smeltingState;
                if (!state || !state.outputSlots) return;
                const srcSlot = state.outputSlots[draggedFromSlot];
                if (!srcSlot) return;
                const actual = Math.min(amount, srcSlot.count);
                if (actual <= 0) return;
                _dropToDestination(item, actual, dropSlotType, dropSlotIndex);
                srcSlot.count -= actual;
                if (srcSlot.count <= 0) state.outputSlots[draggedFromSlot] = null;
                updateSmeltingDisplay('furnace');
                playCollectSound();
                return;
            }

            // ── Furnace waste → inventory/hotbar/storage ──
            if (draggedFromType === 'furnace-waste') {
                const state = currentFurnace && currentFurnace.userData.smeltingState;
                if (!state) return;
                const actual = Math.min(amount, state.wasteCount || 0);
                if (actual <= 0) return;
                _dropToDestination(item, actual, dropSlotType, dropSlotIndex);
                state.wasteCount = (state.wasteCount || 0) - actual;
                updateSmeltingDisplay('furnace');
                return;
            }

            // ── Campfire input → inventory/hotbar/storage ──
            if (draggedFromType === 'campfire-input') {
                const state = currentCampfire && currentCampfire.userData.smeltingState;
                if (!state) return;
                const actual = Math.min(amount, state.inputCount || 0);
                if (actual <= 0) return;
                _dropToDestination(item, actual, dropSlotType, dropSlotIndex);
                state.inputCount -= actual;
                if (state.inputCount <= 0) { state.inputCount = 0; state.inputItem = null; }
                updateSmeltingDisplay('campfire');
                return;
            }

            // ── Campfire output → inventory/hotbar/storage ──
            if (draggedFromType === 'campfire-output') {
                const state = currentCampfire && currentCampfire.userData.smeltingState;
                if (!state) return;
                const actual = Math.min(amount, state.outputCount || 0);
                if (actual <= 0) return;
                _dropToDestination(item, actual, dropSlotType, dropSlotIndex);
                state.outputCount -= actual;
                if (state.outputCount <= 0) { state.outputCount = 0; state.outputItem = null; }
                updateSmeltingDisplay('campfire');
                playCollectSound();
                return;
            }

            // ── Campfire waste → inventory/hotbar/storage ──
            if (draggedFromType === 'campfire-waste') {
                const state = currentCampfire && currentCampfire.userData.smeltingState;
                if (!state) return;
                const actual = Math.min(amount, state.wasteCount || 0);
                if (actual <= 0) return;
                _dropToDestination(item, actual, dropSlotType, dropSlotIndex);
                state.wasteCount = (state.wasteCount || 0) - actual;
                updateSmeltingDisplay('campfire');
                return;
            }
        };


        
        // ===== ADMIN MENU =====
        let isPaused = false;
        
        function openAdminMenu() {
            document.getElementById('admin-menu').style.display = 'block';
            uiOpen();
            populateAdminItems();
        }
        
        function closeAdminMenu() {
            closeAllUI();
        }
        
        function populateAdminItems() {
            const grid = document.getElementById('admin-items-grid');
            grid.innerHTML = '';
            
            // Auto-collect all items from various sources
            const allItems = new Set();
            
            // Add items from crafting recipes
            Object.keys(craftingRecipes).forEach(item => allItems.add(item));
            
            // Add items from workbench recipes
            Object.keys(workbenchRecipes).forEach(item => allItems.add(item));
            
            // Add items from building bench recipes
            Object.keys(buildingBenchRecipes).forEach(item => allItems.add(item));
            
            // Add items from furnace recipes
            Object.keys(furnaceRecipes).forEach(item => allItems.add(item));
            
            // Add items from buildingTypes
            Object.keys(buildingTypes).forEach(item => allItems.add(item));
            
            // Add base resources and items from inventory
            Object.keys(inventory).forEach(item => allItems.add(item));
            
            // Add any items that have icons but aren't in the above
            Object.keys(itemIcons).forEach(item => allItems.add(item));
            
            // Convert to array and sort for consistent ordering
            const adminItems = Array.from(allItems).sort();
            
            // Organize into categories for better display
            const categories = {
                '🪵 Raw Resources': [
                    'wood', 'stone', 'sticks', 'fiber', 'iron_ore', 'coal',
                    'sulfur_ore', 'crystal_shard', 'ash', 'worms', 'raw_fish',
                ],
                '⚙️ Processed Materials': [
                    'iron_ingot', 'smelted_sulfur', 'gunpowder', 'cloth',
                    'flour', 'hemp_fiber',
                ],
                '🌾 Seeds': [
                    'pumpkin_seed', 'wheat_seed', 'cabbage_seed', 'cucumber_seed',
                    'potato_seed', 'carrot_seed', 'hemp_seed', 'corn_seed',
                    'mushroom_seed', 'red_berry_seed', 'black_berry_seed',
                    'strawberry_seed', 'tomato_seed',
                ],
                '🥕 Produce & Ingredients': [
                    'pumpkin', 'wheat', 'cabbage', 'cucumber', 'potato', 'carrot',
                    'corn', 'mushroom', 'mushroom_crop', 'red_berries', 'black_berries',
                    'strawberry', 'tomato', 'berries', 'meat', 'egg', 'honey',
                    'water_bottle',
                ],
                '🍖 Food & Cooked Meals': [
                    'cooked_meat', 'cooked_fish', 'roasted_mushroom', 'omelette',
                    'scrambled_eggs', 'bread', 'corn_bread', 'toast_jam',
                    'ham_sandwich', 'meat_stew', 'vegetable_stew', 'cabbage_stew',
                    'pumpkin_soup', 'stuffed_pumpkin', 'summer_salad',
                    'grilled_fish_stew', 'hearty_meal', 'honey_cake', 'honey_porridge',
                    'berry_jam', 'red_berry_jam', 'strawberry_jam', 'blackcurrant_jam',
                    'pickled_cabbage',
                ],
                '🛠️ Tools': [
                    'sharp_stone', 'axe', 'pickaxe', 'building_hammer',
                    'fishing_rod', 'code_lock',
                ],
                '⚔️ Weapons & Ammo': [
                    'sword', 'spear', 'bow', 'arrows',
                    'pistol', 'pistol_ammo', 'machine_gun', 'mg_ammo',
                ],
                '🩹 Medical': [
                    'bandage', 'medkit',
                ],
                '🧥 Cloth Armor': [
                    'cloth_helmet', 'cloth_vest', 'cloth_gloves', 'cloth_pants', 'cloth_boots',
                ],
                '🛡️ Bronze Armor': [
                    'bronze_helmet', 'bronze_vest', 'bronze_gloves', 'bronze_pants', 'bronze_boots',
                ],
                '⛏️ Iron Armor': [
                    'iron_helmet', 'iron_vest', 'iron_gloves', 'iron_pants', 'iron_boots',
                ],
                '🧣 Thermal Clothing': [
                    'thermal_hood', 'thermal_jacket', 'thermal_gloves', 'thermal_pants', 'thermal_boots',
                ],
                '🎒 Bags & Equipment': [
                    'small_backpack', 'large_backpack',
                ],
                '🧱 Wooden Structures': [
                    'wall', 'window_wall', 'floor', 'ceiling', 'ladder_ceiling',
                    'stairs', 'corner_stairs_left', 'corner_stairs_right',
                    'ladder', 'door_frame', 'double_door_frame', 'door', 'double_door',
                ],
                '🪨 Stone Structures': [
                    'stone_wall', 'stone_window_wall', 'stone_floor', 'stone_ceiling',
                    'stone_stairs', 'stone_corner_stairs_left', 'stone_corner_stairs_right',
                    'stone_door', 'stone_double_door',
                ],
                '🔩 Metal Structures': [
                    'metal_wall', 'metal_window_wall', 'metal_floor', 'metal_ceiling',
                    'metal_stairs', 'metal_corner_stairs_left', 'metal_corner_stairs_right',
                    'metal_door', 'metal_double_door',
                ],
                '🏗️ Crafting Stations': [
                    'campfire', 'cooking_station', 'workbench', 'building_bench',
                    'sewing_table', 'furnace', 'oil_smelter', 'recycler',
                ],
                '📦 Storage': [
                    'storage_box', 'small_storage_box', 'storage_shelf', 'wall_shelf',
                ],
                '🌱 Farming': [
                    'planter_box', 'large_planter', 'bee_hive', 'chicken_coop',
                    'water_catcher',
                ],
                '🛋️ Furniture': [
                    'sleeping_bag', 'sofa', 'bookcase', 'table', 'chair', 'wall_shelf_b',
                ],
                '🖼️ Decorations': [
                    'floor_rug_red', 'floor_rug_blue', 'floor_rug_green',
                    'curtain_red', 'curtain_blue', 'curtain_green', 'curtain_white', 'curtain_beige',
                    'candle', 'wall_light',
                ],
            };
            
            // Display items by category
            Object.entries(categories).forEach(([categoryName, categoryItems]) => {
                // Add category header
                const header = document.createElement('div');
                header.style.gridColumn = '1 / -1';
                header.style.fontSize = '14px';
                header.style.fontWeight = 'bold';
                header.style.color = '#fff';
                header.style.marginTop = '10px';
                header.style.marginBottom = '5px';
                header.style.borderBottom = '2px solid rgba(255,255,255,0.3)';
                header.style.paddingBottom = '5px';
                header.textContent = categoryName;
                grid.appendChild(header);
                
                // Add items in this category
                categoryItems.forEach(item => {
                    if (allItems.has(item)) {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'admin-item';
                        
                        // Get icon using helper function
                        let icon = getItemIcon(item);
                        let displayName = getItemDisplayName(item);
                        
                        itemDiv.innerHTML = `
                            <div class="admin-item-icon">${icon}</div>
                            <div class="admin-item-name">${displayName}</div>
                        `;
                        itemDiv.onclick = () => {
                            _addToInventory(item, 10);
                            showMessage(`+10 ${displayName || item}`);
                            updateUI();
                            updateHotbar();
                            updateInventoryDisplay();
                        };
                        grid.appendChild(itemDiv);
                    }
                });
            });
            
            // Add "Other Items" category for anything not categorized
            const categorizedItems = new Set();
            Object.values(categories).forEach(items => items.forEach(item => categorizedItems.add(item)));
            const uncategorizedItems = Array.from(allItems).filter(item => !categorizedItems.has(item)).sort();
            
            if (uncategorizedItems.length > 0) {
                const header = document.createElement('div');
                header.style.gridColumn = '1 / -1';
                header.style.fontSize = '14px';
                header.style.fontWeight = 'bold';
                header.style.color = '#fff';
                header.style.marginTop = '10px';
                header.style.marginBottom = '5px';
                header.style.borderBottom = '2px solid rgba(255,255,255,0.3)';
                header.style.paddingBottom = '5px';
                header.textContent = 'Other Items';
                grid.appendChild(header);
                
                uncategorizedItems.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'admin-item';
                    
                    let icon = getItemIcon(item);
                    let displayName = getItemDisplayName(item);
                    
                    itemDiv.innerHTML = `
                        <div class="admin-item-icon">${icon}</div>
                        <div class="admin-item-name">${displayName}</div>
                    `;
                    itemDiv.onclick = () => {
                        _addToInventory(item, 10);
                        showMessage(`+10 ${displayName || item}`);
                        updateUI();
                        updateHotbar();
                        updateInventoryDisplay();
                    };
                    grid.appendChild(itemDiv);
                });
            }
        }
        
        // ===== PAUSE MENU =====
        function togglePause() {
            isPaused = !isPaused;
            const pauseMenu = document.getElementById('pause-menu');
            
            if (isPaused) {
                                pauseMenu.style.display = 'flex';
                _setCrosshairVisible(false);
                uiOpen();
            } else {
                                pauseMenu.style.display = 'none';
                _setCrosshairVisible(true);
                uiClose();
            }
        }
        
        // ===== SAVE/LOAD SYSTEM =====
        // ─────────────────────────────────────────────────────────────────
        // SAVE / LOAD  — versioned, forward-compatible localStorage system
        // Key stays 'crustSaveData' forever.  The `saveVersion` field lets
        // loadGame() migrate older layouts so saves survive updates.
        // ─────────────────────────────────────────────────────────────────
        const SAVE_KEY     = 'crustSaveData';
        const SAVE_VERSION = 3;          // bump this whenever the schema changes

        // ── helpers ──────────────────────────────────────────────────────
        function _safeNum(val, fallback) {
            const n = Number(val);
            return (isFinite(n) ? n : fallback);
        }
        function _safeArr(val, fallback) { return Array.isArray(val) ? val : fallback; }
        function _safeObj(val, fallback) { return (val && typeof val === 'object' && !Array.isArray(val)) ? val : fallback; }

        // Migrate a raw parsed object up to the current SAVE_VERSION.
        // Add a new `case` whenever SAVE_VERSION is bumped.
        function _migrateSave(data) {
            let v = _safeNum(data.saveVersion, 1);

            if (v < 2) {
                // v1 → v2: saveVersion field was called "version" (string "1.0")
                data.saveVersion = 2;
                data.gameTime    = data.gameTime ?? 0;
                data.stamina     = data.stamina  ?? 100;
                v = 2;
            }
            if (v < 3) {
                // v2 → v3: armorSlots may be absent; waterCatcherState may be absent
                data.saveVersion     = 3;
                data.armorSlots      = data.armorSlots ?? {};
                data.waterCatcherState = data.waterCatcherState ?? { outputSlots: [], progress: 0 };
                v = 3;
            }
            // Future migrations go here:
            // if (v < 4) { ... }

            data.saveVersion = SAVE_VERSION;
            return data;
        }

        function _buildSaveData() {
            return {
                saveVersion: SAVE_VERSION,
                timestamp:   Date.now(),

                // ── vitals ──
                health,
                hunger,
                thirst,
                stamina,
                day,
                time,
                gameTime,

                // ── player gear ──
                inventory,
                hotbar,
                selectedHotbarSlot,
                armorSlots,
                backpackSlots: backpackSlots.map(s => s ? { item: s.item, count: s.count } : null),

                // ── equipment state ──
                pistolState: { currentClip: pistolState.currentClip },
                machineGunState: { currentClip: machineGunState.currentClip },
                recyclerState: {
                    inputSlots:    recyclerState.inputSlots  || [null,null,null,null,null],
                    outputSlots:   recyclerState.outputSlots || [null,null,null,null,null],
                    isProcessing:  recyclerState.isProcessing  || false,
                    currentSlot:   recyclerState.currentSlot   || 0,
                    progress:      recyclerState.progress       || 0,
                    isPaused:      recyclerState.isPaused       || false,
                    pauseProgress: recyclerState.pauseProgress  || 0
                },
                waterCatcherState: {
                    outputSlots: waterCatcherState.outputSlots || [],
                    progress:    waterCatcherState.progress    || 0
                },

                // ── world ──
                cameraPosition: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
                cameraRotation: { x: camera.rotation.x, y: camera.rotation.y },

                buildings: buildings.map(b => {
                    const ss = b.userData.smeltingState;
                    const cs = b.userData.cookingState;
                    return {
                        type:            b.userData.buildingType,
                        position:        { x: b.position.x, y: b.position.y, z: b.position.z },
                        rotation:        { x: b.rotation.x, y: b.rotation.y, z: b.rotation.z },
                        isDoor:          b.userData.isDoor          || false,
                        isOpen:          b.userData.isOpen          || false,
                        initialRotation: b.userData.initialRotation || null,
                        hasCodeLock:     b.userData.hasCodeLock     || false,
                        codeLock:        b.userData.codeLock        || null,
                        cornerDir:       b.userData.cornerDir       || null,
                        smeltingState: ss ? {
                            inputSlots:      (ss.inputSlots  || []).map(s => s ? { item: s.item, count: s.count } : null),
                            currentInputSlot: ss.currentInputSlot || 0,
                            inputItem:       ss.inputItem   || null,
                            inputCount:      ss.inputCount  || 0,
                            fuelItem:        ss.fuelItem    || null,
                            fuelCount:       ss.fuelCount   || 0,
                            outputSlots:     (ss.outputSlots || []).map(s => ({ item: s.item, count: s.count || 0 })),
                            outputItem:      ss.outputItem  || null,
                            outputCount:     ss.outputCount || 0,
                            wasteCount:      ss.wasteCount  || 0,
                            progress:        ss.progress    || 0,
                            isProcessing:    ss.isProcessing || false
                        } : null,
                        cookingState: cs ? {
                            csInputSlots:   (cs.csInputSlots || []).map(s => s ? { item: s.item, count: s.count } : null),
                            outputItem:     cs.outputItem   || null,
                            outputCount:    cs.outputCount  || 0,
                            wasteCount:     cs.wasteCount   || 0,
                            progress:       cs.progress     || 0,
                            isProcessing:   cs.isProcessing || false,
                            currentRecipe:  cs.currentRecipe || null
                        } : null,
                        storageInventory: b.userData.storageInventory ? [...b.userData.storageInventory] : null
                    };
                })
            };
        }

        // ── MULTI-SLOT SAVE SYSTEM ─────────────────────────────────────
        const SAVE_KEY_PREFIX  = 'crustSave_slot_';   // keys: crustSave_slot_0 … crustSave_slot_4
        const AUTOSAVE_KEY     = 'crustSave_auto';
        const AUTO_SAVE_INTERVAL = 300; // 5 minutes in seconds
        let _autoSaveTimer = 0;

        function _slotKey(index) { return SAVE_KEY_PREFIX + index; }

        function _saveToKey(storageKey) {
            const payload = JSON.stringify(_buildSaveData());
            localStorage.setItem(storageKey, payload);
        }

        function _loadFromKey(storageKey) {
            const raw = localStorage.getItem(storageKey);
            if (!raw) return null;
            return _migrateSave(JSON.parse(raw));
        }

        function _slotMeta(storageKey) {
            try {
                const raw = localStorage.getItem(storageKey);
                if (!raw) return null;
                const d = JSON.parse(raw);
                return { timestamp: d.timestamp, day: d.day, health: d.health };
            } catch(e) { return null; }
        }

        function _formatSlotMeta(meta) {
            if (!meta) return null;
            const date = new Date(meta.timestamp);
            const dateStr = date.toLocaleDateString([], { month: 'short', day: 'numeric' });
            const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            const hp = Math.round(meta.health ?? 100);
            const day = meta.day ?? 1;
            return `Day ${day} · ❤️ ${hp}% · ${dateStr} ${timeStr}`;
        }

        // ── autosave tick (called from game loop) ────────────────────────
        function _tickAutoSave(dt) {
            if (isPaused) return;
            _autoSaveTimer += dt; // dt already in seconds (1/60 per frame)
            // Update countdown display if modal is open
            const cd = document.getElementById('autosave-countdown');
            if (cd) {
                const remaining = Math.max(0, AUTO_SAVE_INTERVAL - _autoSaveTimer);
                const m = Math.floor(remaining / 60);
                const s = Math.floor(remaining % 60);
                cd.textContent = m + ':' + String(s).padStart(2, '0');
            }
            if (_autoSaveTimer >= AUTO_SAVE_INTERVAL) {
                _autoSaveTimer = 0;
                try {
                    _saveToKey(AUTOSAVE_KEY);
                    console.log('💾 Autosaved to autosave slot');
                    // Refresh modal if open
                    if (document.getElementById('save-slot-modal').classList.contains('open')) {
                        _refreshSlotModal();
                    }
                    // Show brief HUD notification
                    showMessage('🔄 Autosaved');
                } catch(e) {
                    console.warn('💾 Autosave failed:', e);
                }
            }
        }

        // ── slot modal logic ─────────────────────────────────────────────
        function _refreshSlotModal() {
            // Autosave slot
            const autoMeta = _slotMeta(AUTOSAVE_KEY);
            const autoMetaEl = document.getElementById('slot-meta-auto');
            const autoLoadBtn = document.getElementById('slot-load-auto');
            const autoDelBtn  = document.getElementById('slot-delete-auto');
            if (autoMeta) {
                autoMetaEl.textContent = _formatSlotMeta(autoMeta);
                autoMetaEl.classList.add('has-data');
                autoLoadBtn.disabled = false;
                autoDelBtn.disabled  = false;
            } else {
                autoMetaEl.textContent = 'No autosave yet';
                autoMetaEl.classList.remove('has-data');
                autoLoadBtn.disabled = true;
                autoDelBtn.disabled  = true;
            }

            // Manual slots 0-4
            for (let i = 0; i < 5; i++) {
                const meta    = _slotMeta(_slotKey(i));
                const metaEl  = document.getElementById('slot-meta-' + i);
                const loadBtn = document.getElementById('slot-load-' + i);
                const delBtn  = document.getElementById('slot-delete-' + i);
                const icon    = document.querySelector('#slot-row-' + i + ' .save-slot-icon');
                if (meta) {
                    metaEl.textContent = _formatSlotMeta(meta);
                    metaEl.classList.add('has-data');
                    loadBtn.disabled = false;
                    delBtn.disabled  = false;
                    if (icon) icon.textContent = '💾';
                } else {
                    metaEl.textContent = 'Empty';
                    metaEl.classList.remove('has-data');
                    loadBtn.disabled = true;
                    delBtn.disabled  = true;
                    if (icon) icon.textContent = '📁';
                }
            }

            // Update countdown
            const cd = document.getElementById('autosave-countdown');
            if (cd) {
                const remaining = Math.max(0, AUTO_SAVE_INTERVAL - _autoSaveTimer);
                const m = Math.floor(remaining / 60);
                const s = Math.floor(remaining % 60);
                cd.textContent = m + ':' + String(s).padStart(2, '0');
            }
        }

        function _setSlotStatus(msg, color, ms = 3000) {
            const el = document.getElementById('save-slot-status');
            if (!el) return;
            el.textContent = msg;
            el.style.color = color;
            if (ms) setTimeout(() => { if (el.textContent === msg) el.textContent = ''; }, ms);
        }

        function openSaveSlotModal() {
            _refreshSlotModal();
            document.getElementById('save-slot-modal').classList.add('open');
        }

        function closeSaveSlotModal() {
            document.getElementById('save-slot-modal').classList.remove('open');
        }

        function _doSaveSlot(i) {
            try {
                _saveToKey(_slotKey(i));
                _autoSaveTimer = 0;
                _refreshSlotModal();
                _setSlotStatus('✅ Saved to Slot ' + (i + 1) + '!', '#2ecc71');
            } catch(e) {
                console.error('Save error:', e);
                _setSlotStatus('❌ Save failed — storage may be full.', '#e74c3c');
            }
        }

        async function _doLoadSlot(storageKey, label) {
            const raw = localStorage.getItem(storageKey);
            if (!raw) { _setSlotStatus('⚠️ No save data in this slot!', '#e74c3c'); return; }
            try {
                _setSlotStatus('⏳ Loading...', '#aaaaaa', 0);
                const data = _migrateSave(JSON.parse(raw));
                await _applyLoadedData(data);
                // Close the save slot modal
                closeSaveSlotModal();
                // Close pause menu if open
                if (isPaused) togglePause();
                // Close ALL other UI panels and re-lock the pointer so the player is back in-game
                closeAllUI();
            } catch(err) {
                console.error('Load error:', err);
                _setSlotStatus('❌ Error loading — save may be corrupted.', '#e74c3c');
            }
        }

        function _doDeleteSlot(storageKey, label) {
            if (!confirm('Delete ' + label + '? This cannot be undone.')) return;
            localStorage.removeItem(storageKey);
            _refreshSlotModal();
            _setSlotStatus('🗑 ' + label + ' deleted.', '#aaaaaa', 2000);
        }

        // Wire up modal buttons (called once after DOM ready)
        function _initSaveSlotModal() {
            document.getElementById('save-slot-close-btn').addEventListener('click', () => {
                closeSaveSlotModal();
                // If not in a paused/menu state, re-lock the pointer so the player returns to game
                if (!isPaused) {
                    setTimeout(_tryLock, 80);
                }
            });

            // Autosave slot
            document.getElementById('slot-load-auto').addEventListener('click', () => _doLoadSlot(AUTOSAVE_KEY, 'Autosave'));
            document.getElementById('slot-delete-auto').addEventListener('click', () => _doDeleteSlot(AUTOSAVE_KEY, 'Autosave'));

            // Manual slots
            for (let i = 0; i < 5; i++) {
                (function(idx) {
                    document.getElementById('slot-save-' + idx).addEventListener('click', () => _doSaveSlot(idx));
                    document.getElementById('slot-load-' + idx).addEventListener('click', () => _doLoadSlot(_slotKey(idx), 'Slot ' + (idx + 1)));
                    document.getElementById('slot-delete-' + idx).addEventListener('click', () => _doDeleteSlot(_slotKey(idx), 'Slot ' + (idx + 1)));
                })(i);
            }
        }

        // ── extract load logic into shared function ──────────────────────
        async function _applyLoadedData(data) {
                // ── vitals (all guarded so new fields default safely) ──────
                health  = _safeNum(data.health,  100);
                if (!activeBuffs.meat_stew) health = Math.min(100, health);
                hunger  = _safeNum(data.hunger,  100);
                thirst  = _safeNum(data.thirst,  100);
                stamina = _safeNum(data.stamina, 100);
                day     = _safeNum(data.day,       1);
                time    = _safeNum(data.time,      0);
                gameTime= _safeNum(data.gameTime,  0);

                // ── inventory — only restore keys that exist in current game ──
                if (_safeObj(data.inventory, null)) {
                    Object.keys(inventory).forEach(key => {
                        if (key in data.inventory) {
                            inventory[key] = _safeNum(data.inventory[key], 0);
                        }
                    });
                }

                // ── hotbar ─────────────────────────────────────────────────
                if (Array.isArray(data.hotbar)) {
                    hotbar.forEach((slot, i) => {
                        const saved = data.hotbar[i];
                        slot.item = saved?.item ?? null;
                        slot.type = saved?.type ?? null;
                    });
                }
                selectedHotbarSlot = _safeNum(data.selectedHotbarSlot, 0);

                // ── armor ──────────────────────────────────────────────────
                if (_safeObj(data.armorSlots, null)) {
                    Object.keys(armorSlots).forEach(slot => {
                        armorSlots[slot] = data.armorSlots[slot] ?? null;
                    });
                }

                // ── backpack slots ─────────────────────────────────────────
                syncBackpackSlots(); // set size from equipped backpack
                if (Array.isArray(data.backpackSlots)) {
                    data.backpackSlots.forEach((s, i) => {
                        if (i < backpackSlots.length) {
                            backpackSlots[i] = (s && s.item) ? { item: s.item, count: s.count || 1 } : null;
                        }
                    });
                }

                // ── pistol ─────────────────────────────────────────────────
                if (data.pistolState) {
                    pistolState.currentClip = _safeNum(data.pistolState.currentClip, pistolState.currentClip);
                }

                // ── machine gun ────────────────────────────────────────────
                if (data.machineGunState) {
                    machineGunState.currentClip = _safeNum(data.machineGunState.currentClip, machineGunState.currentClip);
                }

                // ── recycler ───────────────────────────────────────────────
                if (data.recyclerState) {
                    const rs = data.recyclerState;
                    recyclerState.inputSlots    = _safeArr(rs.inputSlots,  [null,null,null,null,null]);
                    recyclerState.outputSlots   = _safeArr(rs.outputSlots, [null,null,null,null,null]);
                    recyclerState.isProcessing  = rs.isProcessing  || false;
                    recyclerState.currentSlot   = _safeNum(rs.currentSlot,   0);
                    recyclerState.progress      = _safeNum(rs.progress,      0);
                    recyclerState.isPaused      = rs.isPaused      || false;
                    recyclerState.pauseProgress = _safeNum(rs.pauseProgress, 0);
                    if (recyclerState.isProcessing) startRecyclerSound();
                }

                // ── water catcher ──────────────────────────────────────────
                if (data.waterCatcherState) {
                    waterCatcherState.outputSlots = _safeArr(data.waterCatcherState.outputSlots, []);
                    waterCatcherState.progress    = _safeNum(data.waterCatcherState.progress, 0);
                }

                // ── camera ─────────────────────────────────────────────────
                if (data.cameraPosition) {
                    camera.position.set(
                        _safeNum(data.cameraPosition.x, 0),
                        _safeNum(data.cameraPosition.y, 2),
                        _safeNum(data.cameraPosition.z, 0)
                    );
                }
                if (data.cameraRotation) {
                    camera.rotation.x = _safeNum(data.cameraRotation.x, 0);
                    camera.rotation.y = _safeNum(data.cameraRotation.y, 0);
                }

                // ── buildings ──────────────────────────────────────────────
                if (Array.isArray(data.buildings)) {
                    buildings.forEach(b => scene.remove(b));
                    buildings.length = 0;

                    for (const bd of data.buildings) {
                        if (!buildingTypes[bd.type]) {
                            console.warn('⚠️ Unknown building type in save (skipped):', bd.type);
                            continue;
                        }

                        let building;
                        try { building = await buildAndPlaceModel(bd.type); }
                        catch(e) { console.warn('⚠️ Failed to create building:', bd.type, e); continue; }

                        building.position.set(
                            _safeNum(bd.position?.x, 0),
                            _safeNum(bd.position?.y, 0),
                            _safeNum(bd.position?.z, 0)
                        );
                        building.rotation.set(
                            _safeNum(bd.rotation?.x, 0),
                            _safeNum(bd.rotation?.y, 0),
                            _safeNum(bd.rotation?.z, 0)
                        );
                        building.userData.type         = 'building';
                        building.userData.buildingType = bd.type;
                        building.userData.collisionBox = new THREE.Box3().setFromObject(building);

                        const _restoreSmelt = (ss) => {
                            if (!ss || !building.userData.smeltingState) return;
                            const dst = building.userData.smeltingState;
                            if (Array.isArray(ss.inputSlots)) {
                                dst.inputSlots = ss.inputSlots.map(s => s ? { item: s.item, count: s.count } : null);
                            } else if (ss.inputItem) {
                                dst.inputSlots = dst.inputSlots || [];
                                dst.inputSlots[0] = { item: ss.inputItem, count: ss.inputCount || 0 };
                            }
                            dst.currentInputSlot = _safeNum(ss.currentInputSlot, 0);
                            dst.fuelItem   = ss.fuelItem  ?? null;
                            dst.fuelCount  = _safeNum(ss.fuelCount, 0);
                            if (Array.isArray(ss.outputSlots)) {
                                dst.outputSlots = ss.outputSlots.map(s => ({ item: s.item, count: _safeNum(s.count, 0) }));
                            } else if (ss.outputItem && ss.outputCount > 0) {
                                const oi = ss.outputItem === 'smelted_sulfur' ? 1 : 0;
                                if (dst.outputSlots && dst.outputSlots[oi]) dst.outputSlots[oi].count = ss.outputCount;
                            }
                            dst.wasteCount   = _safeNum(ss.wasteCount, 0);
                            dst.progress     = _safeNum(ss.progress, 0);
                            dst.isProcessing = ss.isProcessing || false;
                        };

                        if (bd.type === 'campfire') {
                            building.userData.isCampfire = true;
                            _restoreSmelt(bd.smeltingState);
                        } else if (bd.type === 'furnace') {
                            building.userData.isFurnace = true;
                            _restoreSmelt(bd.smeltingState);
                        } else if (bd.type === 'cooking_station') {
                            building.userData.isCookingStation = true;
                            if (!building.userData.cookingState) building.userData.cookingState = createCookingStationState();
                            if (bd.cookingState) {
                                const cs = building.userData.cookingState;
                                if (Array.isArray(bd.cookingState.csInputSlots))
                                    cs.csInputSlots = bd.cookingState.csInputSlots.map(s => s ? { item: s.item, count: s.count } : null);
                                cs.outputItem   = bd.cookingState.outputItem   || null;
                                cs.outputCount  = bd.cookingState.outputCount  || 0;
                                cs.wasteCount   = bd.cookingState.wasteCount   || 0;
                                cs.progress     = bd.cookingState.progress     || 0;
                                cs.isProcessing = bd.cookingState.isProcessing || false;
                                cs.currentRecipe= bd.cookingState.currentRecipe|| null;
                            }
                        } else if (bd.type === 'workbench')         { building.userData.isWorkbench    = true; }
                        else if (bd.type === 'building_bench')      { building.userData.isBuildingBench= true; }
                        else if (bd.type === 'sewing_table')        { building.userData.isSewingTable  = true; }
                        else if (bd.type === 'recycler')            { building.userData.isRecycler     = true; }
                        else if (bd.type === 'water_catcher')       { building.userData.isWaterCatcher = true; }
                        else if (bd.type === 'storage_shelf')       { building.userData.isShelf        = true; }
                        else if (bd.type === 'wall_shelf' || bd.type === 'wall_shelf_b') { building.userData.isWallShelf = true; }
                        else if (bd.type === 'sofa' || bd.type === 'bookcase' || bd.type === 'table' || bd.type === 'chair') { building.userData.isFurniture = true; }
                        else if (bd.type === 'candle')              { building.userData.isCandle       = true; }
                        else if (bd.type === 'wall_light')          { building.userData.isWallLight    = true; }
                        else if (bd.type === 'bee_hive')            {
                            building.userData.isBeeHive = true;
                            building.userData.beeHiveData = bd.beeHiveData || { honey: 0, lastCollect: Date.now(), isReady: false };
                        }
                        else if (bd.type === 'chicken_coop')        {
                            building.userData.isChickenCoop = true;
                            building.userData.chickenCoopData = bd.chickenCoopData || { eggs: 0, lastCollect: Date.now(), isReady: false };
                        }
                        else if (bd.type === 'oil_smelter')         {
                            building.userData.isOilSmelter = true;
                            building.userData.oilSmelterData = bd.oilSmelterData || { active: false, fuel: 0, output: 0 };
                        }
                        else if (bd.type === 'planter' || bd.type === 'planter_box' || bd.type === 'large_planter') { building.userData.isPlanter = true; }
                        else if (bd.type === 'ladder')              { building.userData.isLadder       = true; }
                        else if (bd.type === 'ladder_ceiling')      { building.userData.isLadderCeiling= true; }
                        else if (bd.type === 'sleeping_bag')        { building.userData.isSleepingBag  = true; }
                        else if (bd.type === 'stairs' || bd.type === 'stone_stairs' || bd.type === 'metal_stairs') {
                            building.userData.isStairs = true;
                        }
                        else if (bd.type === 'corner_stairs_left'       || bd.type === 'stone_corner_stairs_left'  || bd.type === 'metal_corner_stairs_left' ||
                                 bd.type === 'corner_stairs_right'      || bd.type === 'stone_corner_stairs_right' || bd.type === 'metal_corner_stairs_right') {
                            building.userData.isStairs = true;
                            building.userData.isCornerStairs = true;
                            building.userData.cornerDir = bd.cornerDir || (bd.type.includes('_right') ? 'right' : 'left');
                        }
                        else if (bd.type === 'storage_box' || bd.type === 'small_storage_box') {
                            building.userData.isStorageBox = true;
                            if (bd.type === 'small_storage_box') building.userData.isSmallStorage = true;
                            if (Array.isArray(bd.storageInventory)) building.userData.storageInventory = [...bd.storageInventory];
                        }
                        else if (bd.type === 'door' || bd.type === 'stone_door' || bd.type === 'metal_door') {
                            building.userData.isDoor           = true;
                            building.userData.isOpen           = bd.isOpen || false;
                            building.userData.initialRotation  = bd.initialRotation ?? bd.rotation?.y ?? 0;
                            if (!building.userData.doorType) building.userData.doorType = 'single';
                            if (building.userData.isOpen && building.userData.doorGroup)
                                building.userData.doorGroup.rotation.y = -Math.PI / 2;
                        }
                        else if (bd.type === 'double_door' || bd.type === 'stone_double_door' || bd.type === 'metal_double_door') {
                            building.userData.isDoor   = true;
                            building.userData.isOpen   = bd.isOpen || false;
                            building.userData.doorType = 'double';
                            if (building.userData.isOpen) {
                                if (building.userData.leftDoorGroup)  building.userData.leftDoorGroup.rotation.y  =  Math.PI / 2;
                                if (building.userData.rightDoorGroup) building.userData.rightDoorGroup.rotation.y = -Math.PI / 2;
                            }
                        }
                        else if (bd.type === 'door_frame' || bd.type === 'double_door_frame') {
                            building.userData.isDoorFrame = true;
                        }

                        if (bd.hasCodeLock && bd.codeLock) {
                            building.userData.hasCodeLock = true;
                            building.userData.codeLock    = bd.codeLock;
                            createCodeLockModel(building);
                        }

                        buildings.push(building);
                        scene.add(building);
                        _attachFireLight(building);
                    }

                    if (recyclerState.isProcessing) {
                        const rec = buildings.find(b => b.userData.isRecycler);
                        if (rec) {
                            currentRecycler = rec;
                            if (rec.userData.statusLight) rec.userData.statusLight.visible = true;
                        }
                    }

                    // ── Unstuck: push player out of any building they spawned inside ──
                    // Run after all collision boxes are built so checks are accurate.
                    (function _unstuckPlayer() {
                        const PLAYER_RADIUS = 0.4;
                        const PLAYER_HEIGHT = 1.8;
                        const MAX_ATTEMPTS  = 64;   // search directions
                        const MAX_DIST      = 6;    // max push distance to try

                        function _overlapsBuilding(px, py, pz) {
                            for (const b of buildings) {
                                const box = b.userData.collisionBox;
                                if (!box) continue;
                                // Expand box by player radius for a conservative overlap test
                                if (px + PLAYER_RADIUS > box.min.x && px - PLAYER_RADIUS < box.max.x &&
                                    pz + PLAYER_RADIUS > box.min.z && pz - PLAYER_RADIUS < box.max.z &&
                                    py              < box.max.y  && py + PLAYER_HEIGHT  > box.min.y) {
                                    // Allow floors/ceilings player is standing ON (not inside)
                                    const btype = b.userData.buildingType || '';
                                    if ((btype === 'floor' || btype === 'ceiling' || btype === 'ladder_ceiling') &&
                                        py >= box.max.y - 0.15) continue;
                                    return true;
                                }
                            }
                            return false;
                        }

                        const ox = camera.position.x;
                        const oy = camera.position.y - 1.7; // foot position
                        const oz = camera.position.z;

                        if (!_overlapsBuilding(ox, oy, oz)) return; // already fine

                        console.warn('⚠️ Player spawned inside building — attempting unstuck...');

                        // Try pushing outward in many directions at increasing distances
                        for (let dist = 0.5; dist <= MAX_DIST; dist += 0.25) {
                            for (let a = 0; a < MAX_ATTEMPTS; a++) {
                                const angle = (a / MAX_ATTEMPTS) * Math.PI * 2;
                                const tx = ox + Math.cos(angle) * dist;
                                const tz = oz + Math.sin(angle) * dist;
                                if (!_overlapsBuilding(tx, oy, tz)) {
                                    camera.position.set(tx, oy + 1.7, tz);
                                    console.log(`✅ Unstuck: moved player ${dist.toFixed(2)} units to safety.`);
                                    return;
                                }
                            }
                        }
                        // Last resort — lift player above the tallest overlapping box
                        let maxY = 0;
                        for (const b of buildings) {
                            const box = b.userData.collisionBox;
                            if (box && ox > box.min.x && ox < box.max.x && oz > box.min.z && oz < box.max.z) {
                                if (box.max.y > maxY) maxY = box.max.y;
                            }
                        }
                        if (maxY > 0) {
                            camera.position.y = maxY + 1.8;
                            console.log(`✅ Unstuck: lifted player above geometry to y=${camera.position.y.toFixed(2)}`);
                        }
                    })();
                    // ────────────────────────────────────────────────────────────────

                    _clearWorldObjectsInsideBuildings();
                }

                updateUI();
                updateHotbar();
                updateHeldItem();
        }

        // ── legacy single-slot save/load (kept for backward compat) ─────

        function _clearWorldObjectsInsideBuildings() {
            if (!buildings.length) return;
            const PAD = 3.5;
            function _overlaps(x, z) {
                for (let i = 0; i < buildings.length; i++) {
                    const b = buildings[i];
                    const dx = x - b.position.x, dz = z - b.position.z;
                    if (dx * dx + dz * dz < PAD * PAD) return true;
                    const box = b.userData.collisionBox;
                    if (box && x >= box.min.x - PAD && x <= box.max.x + PAD &&
                        z >= box.min.z - PAD && z <= box.max.z + PAD) return true;
                }
                return false;
            }
            function _purge(arr, getPos) {
                for (let i = arr.length - 1; i >= 0; i--) {
                    const obj = arr[i];
                    const p = getPos(obj);
                    if (_overlaps(p.x, p.z)) {
                        // Also remove from the position/collision array so collidesWithNature
                        // doesn't leave an invisible wall behind
                        if (obj.userData && obj.userData._posEntry && obj.userData._posArray) {
                            const idx = obj.userData._posArray.indexOf(obj.userData._posEntry);
                            if (idx !== -1) obj.userData._posArray.splice(idx, 1);
                        }
                        _markNatureCollidersStale();
                        scene.remove(obj);
                        arr.splice(i, 1);
                    }
                }
            }
            const wp = o => o.position;
            _purge(trees,              wp);
            _purge(rocks,              wp);
            _purge(metalOres,          wp);
            _purge(sulfurOres,         wp);
            _purge(grassBlades,        wp);
            _purge(desertGrassTufts,   wp);
            _purge(cacti,              wp);
            _purge(berryBushes,        wp);
            _purge(foliageBushes,      wp);
            _purge(wildPlants,         o => o.mesh ? o.mesh.position : o.position);
            _purge(groundCollectibles, wp);
            _purge(junkPiles,          wp);
            console.log('🏠 World objects inside buildings cleared (collision entries removed).');
        }

        function saveGame() {
            openSaveSlotModal();
        }
        function loadGame() {
            openSaveSlotModal();
        }
                
        // ===== EVENT LISTENERS FOR MENUS =====
        document.getElementById('close-admin').addEventListener('click', closeAdminMenu);

        document.getElementById('sync-icon-fallbacks').addEventListener('click', () => {
            // Escape helper
            function esc(str) {
                return [...str].map(c => {
                    const cp = c.codePointAt(0);
                    if (cp <= 0x7F) return c;
                    if (cp <= 0xFFFF) return '\\u' + cp.toString(16).padStart(4,'0');
                    const hi = Math.floor((cp - 0x10000) / 0x400) + 0xD800;
                    const lo = ((cp - 0x10000) % 0x400) + 0xDC00;
                    return '\\u' + hi.toString(16).padStart(4,'0') + '\\u' + lo.toString(16).padStart(4,'0');
                }).join('');
            }

            // 1. Merge all current itemIcons into _iconFallbacks in memory
            let updated = 0;
            for (const key in itemIcons) {
                const val = itemIcons[key];
                if (!val || val.includes('\ufffd') || val.trim() === '') continue;
                const escaped = esc(val);
                if (_iconFallbacks[key] !== escaped) {
                    _iconFallbacks[key] = escaped;
                    updated++;
                }
            }

            // 2. Rebuild the _iconFallbacks literal from the now-complete in-memory object
            const entries = Object.entries(_iconFallbacks)
                .map(([k, v]) => "            '" + k + "':'" + v + "'")
                .join(',\n');
            const newBlock = '        const _iconFallbacks = {\n' + entries + '\n        };';

            // 3. Find the script tag that contains _iconFallbacks and patch it in-place
            const scripts = document.querySelectorAll('script');
            let patched = false;
            for (const script of scripts) {
                if (!script.textContent.includes('const _iconFallbacks')) continue;
                const oldSrc = script.textContent;
                const newSrc = oldSrc.replace(
                    /const _iconFallbacks\s*=\s*\{[\s\S]*?\};/,
                    newBlock
                );
                if (newSrc !== oldSrc) {
                    // Replace script content in the DOM — survives Ctrl+S / File→Save
                    script.textContent = newSrc;
                    patched = true;
                }
                break;
            }

            // 4. Auto-download the patched page so it's saved immediately
            if (patched) {
                const blob = new Blob([document.documentElement.outerHTML], { type: 'text/html' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'Crust_v24_haze.html';
                a.click();
                URL.revokeObjectURL(a.href);
            }

            // 5. Show result in the output box
            const output = document.getElementById('icon-sync-output');
            const textarea = document.getElementById('icon-sync-text');
            output.style.display = 'block';

            if (!patched) {
                textarea.value = '\u274c Could not patch source — copy manually:\n\n' + newBlock;
            } else if (updated === 0) {
                textarea.value = '\u2705 All ' + Object.keys(_iconFallbacks).length + ' icons already in sync. No changes needed.';
            } else {
                textarea.value = '\u2705 Done! ' + updated + ' icon(s) added/updated in _iconFallbacks.\n\nThe updated file is downloading automatically.';
                console.log('\ud83d\udee1\ufe0f Icon fallbacks auto-patched: ' + updated + ' updated.');
            }
        });

        document.getElementById('icon-sync-copy').addEventListener('click', () => {
            const textarea = document.getElementById('icon-sync-text');
            textarea.select();
            document.execCommand('copy');
            const btn = document.getElementById('icon-sync-copy');
            btn.textContent = '\u2705 Copied!';
            setTimeout(() => { btn.textContent = '\ud83d\udccb Copy to Clipboard'; }, 1500);
        });
        
        // Set to day instantly
        document.getElementById('set-day').addEventListener('click', () => {
            time = 12; // Set to noon (12:00)
            timeIsPaused = false; // Unfreeze if it was frozen
            document.getElementById('freeze-time').textContent = '\u2744\ufe0f Freeze Time';
        });
        
        // Set to night instantly
        document.getElementById('set-night').addEventListener('click', () => {
            time = 0; // Set to midnight (00:00)
            timeIsPaused = false; // Unfreeze if it was frozen
            document.getElementById('freeze-time').textContent = '\u2744\ufe0f Freeze Time';
        });
        
        // Freeze/unfreeze time
        let timeIsPaused = false;
        let savedTime = 12;
        document.getElementById('freeze-time').addEventListener('click', () => {
            timeIsPaused = !timeIsPaused;
            if (timeIsPaused) {
                savedTime = time; // Save current time
                document.getElementById('freeze-time').textContent = '\u25b6\ufe0f Unfreeze Time';
            } else {
                time = savedTime; // Restore time and resume cycle
                document.getElementById('freeze-time').textContent = '\u2744\ufe0f Freeze Time';
            }
        });
        
        // Toggle rain on/off
        document.getElementById('toggle-rain').addEventListener('click', () => {
            if (isRaining) {
                stopRain();
                document.getElementById('toggle-rain').textContent = '\ud83c\udf27\ufe0f Toggle Rain (OFF)';
            } else {
                startRain();
                document.getElementById('toggle-rain').textContent = '\ud83c\udf27\ufe0f Toggle Rain (ON)';
            }
        });
        
        document.getElementById('resume-button').addEventListener('click', togglePause);
        document.getElementById('save-button').addEventListener('click', openSaveSlotModal);
        document.getElementById('load-button').addEventListener('click', openSaveSlotModal);

        document.getElementById('unstuck-button').addEventListener('click', () => {
            const PLAYER_RADIUS = 0.4;
            const PLAYER_HEIGHT = 1.8;
            const MAX_ATTEMPTS  = 72;
            const MAX_DIST      = 8;

            // Foot position
            const ox = camera.position.x;
            const oy = camera.position.y - 1.7;
            const oz = camera.position.z;

            function _inBuilding(px, py, pz) {
                for (const b of buildings) {
                    const box = b.userData.collisionBox;
                    if (!box) continue;
                    if (px + PLAYER_RADIUS > box.min.x && px - PLAYER_RADIUS < box.max.x &&
                        pz + PLAYER_RADIUS > box.min.z && pz - PLAYER_RADIUS < box.max.z &&
                        py < box.max.y && py + PLAYER_HEIGHT > box.min.y) {
                        const btype = b.userData.buildingType || '';
                        if ((btype === 'floor' || btype === 'ceiling' || btype === 'ladder_ceiling') && py >= box.max.y - 0.15) continue;
                        return true;
                    }
                }
                return false;
            }

            // Check terrain height at a position
            function _terrainY(px, pz) {
                if (typeof getTerrainHeight === 'function') return getTerrainHeight(px, pz);
                return 0;
            }

            function _isSafe(px, py, pz) {
                if (_inBuilding(px, py, pz)) return false;
                const ty = _terrainY(px, pz);
                // Must be at or above terrain
                if (py < ty - 0.5) return false;
                return true;
            }

            // Already fine — nudge upward slightly in case clipped into terrain
            if (!_inBuilding(ox, oy, oz)) {
                const ty = _terrainY(ox, oz);
                if (oy < ty) {
                    camera.position.y = ty + 1.7 + 0.1;
                    showMessage('✅ Unstuck! Lifted out of terrain.');
                } else {
                    showMessage('✅ You don\'t appear to be stuck!');
                }
                togglePause();
                return;
            }

            // Radial sweep at increasing distances
            for (let dist = 0.5; dist <= MAX_DIST; dist += 0.3) {
                for (let a = 0; a < MAX_ATTEMPTS; a++) {
                    const angle = (a / MAX_ATTEMPTS) * Math.PI * 2;
                    const tx = ox + Math.cos(angle) * dist;
                    const tz = oz + Math.sin(angle) * dist;
                    const ty = _terrainY(tx, tz);
                    const testY = Math.max(oy, ty);
                    if (_isSafe(tx, testY, tz)) {
                        camera.position.set(tx, testY + 1.7, tz);
                        showMessage(`✅ Unstuck! Moved to safety.`);
                        togglePause();
                        return;
                    }
                }
            }

            // Last resort — lift above tallest overlapping box
            let maxY = 0;
            for (const b of buildings) {
                const box = b.userData.collisionBox;
                if (box && ox > box.min.x && ox < box.max.x && oz > box.min.z && oz < box.max.z) {
                    if (box.max.y > maxY) maxY = box.max.y;
                }
            }
            camera.position.y = Math.max(maxY, _terrainY(ox, oz)) + 1.9;
            showMessage('✅ Unstuck! Lifted above geometry.');
            togglePause();
        });
        _initSaveSlotModal();
        document.getElementById('controls-button').addEventListener('click', () => {
            document.getElementById('instructions').style.display = 'block';
            document.getElementById('pause-menu').style.display = 'none';
        });
        document.getElementById('close-controls').addEventListener('click', () => {
            document.getElementById('instructions').style.display = 'none';
            document.getElementById('pause-menu').style.display = 'flex';
        });
        document.getElementById('settings-button').addEventListener('click', () => {
            document.getElementById('settings-menu').style.display = 'block';
            document.getElementById('pause-menu').style.display = 'none';
        });
        
        document.getElementById('close-settings').addEventListener('click', () => {
            const sm = document.getElementById('settings-menu');
            sm.style.display = 'none';
            // If settings was opened from the pre-game main menu, return there
            if (sm.dataset.calledFromMenu === '1') {
                sm.dataset.calledFromMenu = '';
                const menuOverlay = document.getElementById('crust-main-overlay');
                if (menuOverlay) menuOverlay.style.display = 'flex';
            } else {
                document.getElementById('pause-menu').style.display = 'flex';
            }
        });
        
        // Volume slider handlers
        // Save volume settings to localStorage
        function saveVolumeSettings() {
            localStorage.setItem('crustVolumeSettings', JSON.stringify({
                forest: volumeSettings.forest,
                wind: volumeSettings.wind,
                animals: volumeSettings.animals,
                enemies: volumeSettings.enemies,
                rain: volumeSettings.rain,
                footsteps: volumeSettings.footsteps,
                renderDistance: volumeSettings.renderDistance
            }));
        }

        // Load saved volume settings
        (function loadVolumeSettings() {
            const saved = localStorage.getItem('crustVolumeSettings');
            if (!saved) return;
            try {
                const s = JSON.parse(saved);
                if (s.forest    !== undefined) { volumeSettings.forest    = s.forest;    document.getElementById('forest-volume').value    = Math.round(s.forest * 100);    document.getElementById('forest-value').textContent    = Math.round(s.forest * 100) + '%'; }
                if (s.wind      !== undefined) { volumeSettings.wind      = s.wind;      document.getElementById('wind-volume').value      = Math.round(s.wind * 100);      document.getElementById('wind-value').textContent      = Math.round(s.wind * 100) + '%'; }
                if (s.rain      !== undefined) { volumeSettings.rain      = s.rain;      document.getElementById('rain-volume').value      = Math.round(s.rain * 100);      document.getElementById('rain-value').textContent      = Math.round(s.rain * 100) + '%'; }
                if (s.animals   !== undefined) { volumeSettings.animals   = s.animals;   document.getElementById('animal-volume').value    = Math.round(s.animals * 100);   document.getElementById('animal-value').textContent    = Math.round(s.animals * 100) + '%'; }
                if (s.enemies   !== undefined) { volumeSettings.enemies   = s.enemies;   document.getElementById('enemy-volume').value     = Math.round(s.enemies * 100);   document.getElementById('enemy-value').textContent     = Math.round(s.enemies * 100) + '%'; }
                if (s.footsteps !== undefined) { volumeSettings.footsteps = s.footsteps; document.getElementById('footstep-volume').value  = Math.round(s.footsteps * 100); document.getElementById('footstep-value').textContent  = Math.round(s.footsteps * 100) + '%'; }
                if (s.renderDistance !== undefined) {
                    applyRenderDistance(s.renderDistance);
                    document.getElementById('render-distance').value = s.renderDistance;
                    document.getElementById('render-distance-value').textContent = s.renderDistance + ' units';
                }
            } catch(e) {}
        })();

        document.getElementById('forest-volume').addEventListener('input', (e) => {
            const value = e.target.value;
            volumeSettings.forest = value / 100;
            document.getElementById('forest-value').textContent = value + '%';
            updateAmbientVolume();
            saveVolumeSettings();
        });

        document.getElementById('wind-volume').addEventListener('input', (e) => {
            const value = e.target.value;
            volumeSettings.wind = value / 100;
            document.getElementById('wind-value').textContent = value + '%';
            updateAmbientVolume();
            saveVolumeSettings();
        });
        
        document.getElementById('animal-volume').addEventListener('input', (e) => {
            const value = e.target.value;
            volumeSettings.animals = value / 100;
            document.getElementById('animal-value').textContent = value + '%';
            saveVolumeSettings();
        });
        
        document.getElementById('enemy-volume').addEventListener('input', (e) => {
            const value = e.target.value;
            volumeSettings.enemies = value / 100;
            document.getElementById('enemy-value').textContent = value + '%';
            saveVolumeSettings();
        });

        document.getElementById('footstep-volume').addEventListener('input', (e) => {
            const value = e.target.value;
            volumeSettings.footsteps = value / 100;
            document.getElementById('footstep-value').textContent = value + '%';
            saveVolumeSettings();
        });

        document.getElementById('rain-volume').addEventListener('input', (e) => {
            const value = e.target.value;
            volumeSettings.rain = value / 100;
            document.getElementById('rain-value').textContent = value + '%';
            if (rainGainNode && isRaining) rainGainNode.gain.setValueAtTime(volumeSettings.rain, audioContext.currentTime);
            saveVolumeSettings();
        });

        document.getElementById('render-distance').addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            document.getElementById('render-distance-value').textContent = value + ' units';
            applyRenderDistance(value);
            updateDistanceCulling(); // immediate cull pass so changes feel instant
            saveVolumeSettings();
        });
        
        // Code lock UI event listeners
        document.querySelectorAll('.code-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const digit = btn.getAttribute('data-num');
                handleCodeEntry(digit);
            });
        });
        
        document.getElementById('code-clear').addEventListener('click', clearCode);
        document.getElementById('code-enter').addEventListener('click', submitCode);
        document.getElementById('code-cancel').addEventListener('click', closeCodeLockUI);
        
        // ===== INITIALIZATION =====
        // ═══════════════════════════════════════════════════════════════
        // PERFORMANCE SYSTEM — Material Cache · Geometry Cache · Model Cache · Shader Compiler
        // ═══════════════════════════════════════════════════════════════

        // ── 1. MATERIAL CACHE ──────────────────────────────────────────
        // Every unique material is created ONCE and reused forever.
        // This is the #1 cause of placement stalls: each new MeshStandardMaterial
        // with unique params triggers a GLSL shader compile on the GPU (~20-80ms each).
        const _matCache = new Map();

        function cachedMat(params) {
            // Build a stable string key from the params object
            const key = JSON.stringify(params, (k, v) =>
                (v && v.isTexture) ? ('tex_' + (v.uuid || v.id)) : v
            );
            if (_matCache.has(key)) return _matCache.get(key);
            let mat;
            if (params._basic) {
                const p = Object.assign({}, params); delete p._basic;
                mat = new THREE.MeshBasicMaterial(p);
            } else {
                const p = Object.assign({}, params);
                mat = new THREE.MeshStandardMaterial(p);
            }
            _matCache.set(key, mat);
            return mat;
        }

        // ── 2. GEOMETRY CACHE ──────────────────────────────────────────
        // Shared BufferGeometry instances — zero extra GPU memory per placement.
        const _geoCache = new Map();

        function cachedGeo(type, ...args) {
            const key = type + '|' + args.join(',');
            if (_geoCache.has(key)) return _geoCache.get(key);
            let geo;
            switch(type) {
                case 'Box':      geo = new THREE.BoxGeometry(...args); break;
                case 'Cylinder': geo = new THREE.CylinderGeometry(...args); break;
                case 'Sphere':   geo = new THREE.SphereGeometry(...args); break;
                case 'Plane':    geo = new THREE.PlaneGeometry(...args); break;
                case 'Torus':    geo = new THREE.TorusGeometry(...args); break;
                case 'Cone':     geo = new THREE.ConeGeometry(...args); break;
                case 'Dodeca':   geo = new THREE.DodecahedronGeometry(...args); break;
                default:         geo = new THREE.BoxGeometry(...args);
            }
            _geoCache.set(key, geo);
            return geo;
        }

        // ── 3. MODEL CACHE ─────────────────────────────────────────────
        // Stores one fully-built Group per placeable type.
        // Placement calls _cloneModel() which does clone(true) — this shares the
        // exact same geometry and material objects, so the GPU never recompiles.
        const _modelCache = new Map();

        function _tagUserDataRefs(group) {
            // Tag object refs in userData so they can be reconnected after clone
            // Also snapshot original material colours so upgrade/reset can restore them
            group.traverse(child => {
                if (child.userData._refKey) return;
                for (const [k, v] of Object.entries(group.userData)) {
                    if (v === child) {
                        child.userData._refKey = k;
                    }
                }
                if (child.isMesh && child.material) {
                    const mats = Array.isArray(child.material) ? child.material : [child.material];
                    mats.forEach(mat => {
                        if (mat && mat.userData._origColor === undefined) {
                            mat.userData._origColor      = mat.color ? mat.color.getHex() : 0xffffff;
                            mat.userData._origTransparent = mat.transparent;
                            mat.userData._origOpacity    = mat.opacity;
                        }
                    });
                }
            });
        }

        function _cloneModel(type) {
            if (!_modelCache.has(type)) return null;
            const src   = _modelCache.get(type);
            const clone = src.clone(true);

            // Copy primitive userData values
            for (const [k, v] of Object.entries(src.userData)) {
                if (v === null || typeof v !== 'object') clone.userData[k] = v;
            }

            // Reconnect object refs (lights, glows, mesh refs) by matching _refKey tags
            clone.traverse(child => {
                if (child.userData._refKey) {
                    clone.userData[child.userData._refKey] = child;
                }
            });

            // smeltingState must be a fresh instance per furnace/campfire
            if (typeof createSmeltingState === 'function') {
                if (src.userData._smeltMs) {
                    clone.userData.smeltingState = createSmeltingState(src.userData._smeltMs);
                }
            }
            return clone;
        }

        async function _buildAndCache(type) {
            if (_modelCache.has(type) || !buildingTypes[type]) return;
            try {
                const group = await buildingTypes[type].create();
                _tagUserDataRefs(group);
                _modelCache.set(type, group);
            } catch(e) {
                console.warn(`Model cache build failed for ${type}:`, e);
            }
        }

        // ── 4. SHADER COMPILER ─────────────────────────────────────────
        // Forces the GPU to compile every shader variant BEFORE the player
        // can place anything, during the loading bar.
        // Builds a dummy offscreen scene with one mesh per cached material,
        // calls renderer.compile() which blocks until all GLSL programs are linked.
        function compileShaders() {
            if (_matCache.size === 0) return;
            console.log(`🔧 Compiling ${_matCache.size} shader variants...`);
            const dummyScene  = new THREE.Scene();
            const dummyGeo    = new THREE.BoxGeometry(0.01, 0.01, 0.01);
            for (const mat of _matCache.values()) {
                const mesh = new THREE.Mesh(dummyGeo, mat);
                mesh.position.set(0, -9999, 0);
                dummyScene.add(mesh);
            }
            // Pre-compile Points materials (not in _matCache)
            [_fireMat, _smokeMat, _sandMat, _doorFireMat].forEach(mat => {
                const g = new THREE.BufferGeometry();
                g.setAttribute('position', new THREE.BufferAttribute(new Float32Array(3), 3));
                const p = new THREE.Points(g, mat);
                p.position.set(0, -9999, 0);
                dummyScene.add(p);
            });
            try {
                renderer.compile(dummyScene, camera);
                console.log(`✅ Shaders compiled — ${_matCache.size} programs ready`);
            } catch(e) {
                console.warn('Shader compile step failed (non-fatal):', e);
            }
            dummyScene.clear();
        }

        // ── 5. PREWARM ─────────────────────────────────────────────────
        async function prewarmModels() {
            const types = [
                'workbench','campfire','furnace','cooking_station','building_bench','sewing_table',
                'sleeping_bag','storage_box','small_storage_box','storage_shelf','wall_shelf','recycler','water_catcher','planter_box','large_planter',
                'bookcase','table','chair','wall_shelf_b','candle','bee_hive','chicken_coop'
            ];
            const labels = {
                workbench:'Building workbench...', campfire:'Building campfire...',
                furnace:'Building furnace...', building_bench:'Building construction bench...',
                sewing_table:'Building sewing table...', sleeping_bag:'Building sleeping bag...',
                storage_box:'Building storage box...', small_storage_box:'Building small storage...',
                storage_shelf:'Building storage shelf...', wall_shelf:'Building wall shelf...', recycler:'Building recycler...', planter_box:'Building planter box...', large_planter:'Building large planter...',
                bookcase:'Building bookcase...', table:'Building table...', chair:'Building chair...', wall_shelf_b:'Building wall shelf B...', candle:'Building candle...', bee_hive:'Building bee hive...', chicken_coop:'Building chicken coop...'
            };
            const modelShare = 75;
            const total = types.length;
            console.log('🔥 Pre-warming models...');
            for (let i = 0; i < types.length; i++) {
                const type = types[i];
                if (_modelCache.has(type) || !buildingTypes[type]) continue;
                setLoadingProgress(10 + Math.round((i / total) * modelShare), labels[type] || `Building ${type}...`);
                // Yield to let the progress bar repaint, then build synchronously
                await new Promise(r => setTimeout(r, 0));
                await _buildAndCache(type);
            }
            setLoadingProgress(88, 'Compiling shaders...');
            await new Promise(r => setTimeout(r, 0));
            compileShaders();
            console.log('✅ Pre-warm complete — placement will be instant');
        }

        // ── 6. PLACEMENT ───────────────────────────────────────────────
        // Returns a model instantly from cache (clone), or builds fresh if not cached.
        async function buildAndPlaceModel(type) {
            const cached = _cloneModel(type);
            if (cached) return cached;
            // Not cached yet — build fresh, cache for next time, yield first
            await new Promise(r => setTimeout(r, 0));
            const group = await buildingTypes[type].create();
            _tagUserDataRefs(group);
            _modelCache.set(type, group);
            compileShaders(); // compile any new shaders from this build
            // Return a clone so the cached template stays clean
            return _cloneModel(type) || group;
        }

        // ═══════════════════════════════════════════════════════════════════
        // FISHING MINIGAME SYSTEM
        // ═══════════════════════════════════════════════════════════════════
        var fishingState = { active: false, phase: 'idle', holdingE: false };

        function _isNearRiver() {
            const px = camera.position.x, pz = camera.position.z;
            const lx = px - RB_CX, lz = pz - RB_CZ;
            if (Math.abs(lx) > RB_SIZE / 2 + 10 || Math.abs(lz) > RB_SIZE / 2 + 10) return false;
            let minD = Infinity;
            for (const pt of _rbPathPts) {
                const dx = lx - pt.x, dz = lz - pt.z;
                const d = Math.sqrt(dx*dx + dz*dz);
                if (d < minD) minD = d;
            }
            return minD < RIVER_WIDTH / 2 + 4;
        }

        // ── Stub helpers so any legacy code doesn't crash ─────────────────
        function _fishingOverlay()      { return document.getElementById('fishing-overlay'); }
        function _fishingStatusEl()     { return { textContent:'', style:{} }; }
        function _fishingBiteEl()       { return { classList:{ add:()=>{}, remove:()=>{} } }; }
        function _fishingBobberEl()     { return { classList:{ add:()=>{}, remove:()=>{} }, style:{} }; }
        function _fishingProgressWrap() { return { classList:{ add:()=>{}, remove:()=>{} } }; }
        function _fishingProgressFill() { return { style:{ width:'0%' } }; }
        function _fishingHintEl()       { return document.getElementById('fishing-hint') || { textContent:'' }; }

        // ── Main entry point ──────────────────────────────────────────────
        function startFishing() {
            if (fishingState.active) return;
            const held = hotbar[selectedHotbarSlot]?.item;
            const rodInHotbar = hotbar.findIndex(s => s.item === 'fishing_rod');
            const hasRod = held === 'fishing_rod' || rodInHotbar !== -1 || (inventory['fishing_rod'] || 0) > 0;
            if (!hasRod) { showMessage('🎣 Equip a Fishing Rod to fish!'); return; }
            if (!_isNearRiver()) { showMessage('🌊 You need to be near the river!'); return; }
            fishingState.active = true;
            fishingState.phase  = 'minigame';
            if (document.pointerLockElement) document.exitPointerLock();
            _fpOpen();
        }

        function stopFishing() {
            fishingState.active = false;
            fishingState.phase  = 'idle';
            fishingState.holdingE = false;
            _fpClose();
            document.getElementById('fishing-overlay').classList.remove('visible');
            setTimeout(_tryLock, 200);
        }

        function onFishingEPress() {
            if (fishingState.active) stopFishing();
        }

        function updateFishingSystem() {}

        // ── NEW FISHING MINIGAME ──────────────────────────────────────────────
        (function() {
            var FISH_TYPES = [
                { name:'Salmon',      emoji:'🐟', item:'raw_fish',      min:1, max:2, speed:1.0, window:0.26, speedVar:0.4, hasTail:true  },
                { name:'Trout',       emoji:'🐠', item:'raw_fish',      min:1, max:1, speed:1.5, window:0.22, speedVar:0.5, hasTail:true  },
                { name:'Perch',       emoji:'🐡', item:'raw_fish',      min:1, max:2, speed:1.8, window:0.18, speedVar:0.6, hasTail:true  },
                { name:'Pike',        emoji:'🦈', item:'raw_fish',      min:2, max:3, speed:2.1, window:0.10, speedVar:0.7, hasTail:true  },
                { name:'Crystal Fish',emoji:'💎', item:'crystal_shard', min:1, max:1, speed:2.4, window:0.06, speedVar:0.8, hasTail:false },
                { name:'Iron Fish',   emoji:'⚙️', item:'iron_ore',      min:1, max:1, speed:1.9, window:0.07, speedVar:0.7, hasTail:false },
            ];
            var _fpPhase='idle', _fpCaught=0, _fpFish=null;
            var _fpNeedle=0, _fpDir=1, _fpSpeed=0;
            var _fpZoneL=0, _fpZoneW=0;
            var _fpRAF=null, _fpWaitTimer=null, _fpPasses=0;

            // ── Sounds ──────────────────────────────────────────────────────────
            var _fpSoundBase = 'https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/';
            var _fpCastAudio = new Audio(_fpSoundBase + 'Cast.mp3');
            var _fpPlopAudio = new Audio(_fpSoundBase + 'Plop.mp3');
            var _fpReelAudio = new Audio(_fpSoundBase + 'Reel.mp3');
            _fpReelAudio.loop = true;
            var _fpReelFadeTimer = null;

            // Define _playCastSound globally so the keydown handler that calls it doesn't crash
            window._playCastSound = function() { _fpPlayCast(); };

            function _fpPlayCast() {
                try { _fpCastAudio.currentTime=0; _fpCastAudio.play().catch(function(){}); } catch(e){}
                setTimeout(function(){ try { _fpPlopAudio.currentTime=0; _fpPlopAudio.play().catch(function(){}); } catch(e){} }, 1200);
            }
            function _fpPlayReel() {
                if (_fpReelFadeTimer) { clearTimeout(_fpReelFadeTimer); _fpReelFadeTimer=null; }
                try {
                    _fpReelAudio.volume=0; _fpReelAudio.currentTime=0;
                    _fpReelAudio.play().catch(function(){});
                    var vol=0, fadeIn=setInterval(function(){
                        vol=Math.min(1,vol+0.05); _fpReelAudio.volume=vol;
                        if(vol>=1) clearInterval(fadeIn);
                    },25);
                    _fpReelFadeTimer=setTimeout(function(){
                        var fadeOut=setInterval(function(){
                            _fpReelAudio.volume=Math.max(0,_fpReelAudio.volume-0.05);
                            if(_fpReelAudio.volume<=0){ clearInterval(fadeOut); _fpReelAudio.pause(); }
                        },25);
                    },3000);
                } catch(e){}
            }
            function _fpStopReel() {
                if(_fpReelFadeTimer){ clearTimeout(_fpReelFadeTimer); _fpReelFadeTimer=null; }
                try { _fpReelAudio.pause(); _fpReelAudio.volume=0; } catch(e){}
            }

            // ── Helpers ─────────────────────────────────────────────────────────
            function _fpEl(id){ return document.getElementById(id); }
            function _fpSetStatus(t){ var e=_fpEl('fp-status'); if(e) e.textContent=t; }
            function _fpSetResult(t,c){ var e=_fpEl('fp-result'); if(e){e.textContent=t;e.style.color=c||'#fff';} }

            function _fpShowFish(f){
                var bob=_fpEl('fp-bobber'); if(bob) bob.style.display='none';
                var bfloat=_fpEl('fp-bobber-float'); if(bfloat) bfloat.style.animation='fp-bob-bite 0.5s ease-in-out 3';
                var wrap=_fpEl('fp-fish-wrap'); if(wrap) wrap.style.display='flex';
                var ee=_fpEl('fp-fish-emoji'); if(ee) ee.textContent=f.emoji;
                var en=_fpEl('fp-fish-name'); if(en) en.textContent=f.name;
                var tail=_fpEl('fp-fish-tail');
                if(tail){
                    if(f.hasTail){
                        tail.textContent='〰️';
                        tail.style.display='inline-block';
                        tail.style.animation='fp-tail-wag 0.35s ease-in-out infinite';
                    } else {
                        tail.textContent=''; tail.style.display='none';
                    }
                }
                var body=_fpEl('fp-fish-body'); if(body) body.style.animation='fp-fish-swim 1.4s ease-in-out infinite';
            }
            function _fpHideFish(){
                var bob=_fpEl('fp-bobber'); if(bob) bob.style.display='flex';
                var bfloat=_fpEl('fp-bobber-float'); if(bfloat) bfloat.style.animation='fp-bob-wait 1.8s ease-in-out infinite';
                var wrap=_fpEl('fp-fish-wrap'); if(wrap) wrap.style.display='none';
            }

            // ── Wave animation ──────────────────────────────────────────────────
            var _fpWaveRAF=null, _fpWaveT=0;
            function _fpAnimWaves(){
                _fpWaveT+=0.016; var t=_fpWaveT;
                var w1=_fpEl('fp-wave1'),w2=_fpEl('fp-wave2'),w3=_fpEl('fp-wave3'),w4=_fpEl('fp-wave4');
                if(w1){ var a=Math.sin(t*0.9)*14; w1.setAttribute('d','M0,'+(36+a)+' Q100,'+(16-a)+' 200,'+(36+a)+' Q300,'+(56-a)+' 400,'+(36+a)+' L400,110 L0,110 Z'); }
                if(w2){ var b=Math.sin(t*1.1+0.8)*11; w2.setAttribute('d','M0,'+(42+b)+' Q100,'+(24-b)+' 200,'+(42+b)+' Q300,'+(60-b)+' 400,'+(42+b)+' L400,110 L0,110 Z'); }
                if(w3){ var c=Math.sin(t*1.5+0.3)*8; w3.setAttribute('d','M0,'+(38+c)+' Q100,'+(20-c)+' 200,'+(38+c)+' Q300,'+(56-c)+' 400,'+(38+c)+' L400,'+(44+c)+' Q300,'+(62-c)+' 200,'+(44+c)+' Q100,'+(26-c)+' 0,'+(44+c)+' Z'); }
                if(w4){ var d=Math.sin(t*2.0+1.1)*5; w4.setAttribute('d','M0,'+(37+d)+' Q50,'+(30-d)+' 100,'+(37+d)+' Q150,'+(44-d)+' 200,'+(37+d)+' Q250,'+(30-d)+' 300,'+(37+d)+' Q350,'+(44-d)+' 400,'+(37+d)+' L400,'+(39+d)+' Q350,'+(46-d)+' 300,'+(39+d)+' Q250,'+(32-d)+' 200,'+(39+d)+' Q150,'+(46-d)+' 100,'+(39+d)+' Q50,'+(32-d)+' 0,'+(39+d)+' Z'); }
                _fpWaveRAF=requestAnimationFrame(_fpAnimWaves);
            }
            function _fpStartWaveAnim(){ if(!_fpWaveRAF) _fpAnimWaves(); }
            function _fpStopWaveAnim(){ if(_fpWaveRAF){cancelAnimationFrame(_fpWaveRAF);_fpWaveRAF=null;} }

            // ── Core logic ──────────────────────────────────────────────────────
            function _fpStartWait(){
                if (!(inventory.worms > 0)) {
                    _fpSetStatus('🪱 No worms! Harvest bushes to find some.');
                    _fpSetResult('Need worms to fish!', '#ffaa44');
                    return;
                }
                inventory.worms--;
                updateUI(); updateInventoryDisplay(); updateHotbar();
                _fpPhase='waiting'; _fpHideFish(); _fpSetResult('',''); _fpSetStatus('🎣 Line in the water...');
                _fpEl('fp-bar-section').style.display='none';
                var btn=_fpEl('fp-cast-btn'); if(btn){btn.disabled=true;btn.textContent='⏳ Waiting...';}
                _fpPlayCast();
                _fpWaitTimer=setTimeout(_fpBite, 1500+Math.random()*3500);
            }
            function _fpBite(){
                if(_fpPhase!=='waiting') return;
                _fpPhase='reacting'; _fpPasses=0;
                _fpFish=FISH_TYPES[Math.floor(Math.random()*FISH_TYPES.length)];
                _fpShowFish(_fpFish); _fpSetStatus('⚡ BITE! Press SPACE in the green zone!');
                _fpZoneW=_fpFish.window; _fpZoneL=Math.random()*(1-_fpZoneW);
                var speedMult=1+(Math.random()*2-1)*_fpFish.speedVar;
                _fpNeedle=0; _fpDir=1; _fpSpeed=_fpFish.speed*speedMult*0.008;
                var z=_fpEl('fp-zone'); if(z){z.style.left=(_fpZoneL*100)+'%';z.style.width=(_fpZoneW*100)+'%';}
                _fpEl('fp-bar-section').style.display='block';
                _fpAnimBar();
            }
            function _fpAnimBar(){
                if(_fpPhase!=='reacting') return;
                _fpRAF=requestAnimationFrame(_fpAnimBar);
                _fpNeedle+=_fpDir*_fpSpeed;
                if(_fpNeedle>=1){ _fpNeedle=1; _fpDir=-1; _fpPasses++; }
                if(_fpNeedle<=0){ _fpNeedle=0; _fpDir=1;  _fpPasses++; }
                if(_fpPasses>=2){
                    _fpStopAnim(); _fpPhase='idle'; _fpEl('fp-bar-section').style.display='none';
                    _fpSetResult('🐟 Too slow! Fish got away.','#ffaa66'); _fpHideFish();
                    var btn=_fpEl('fp-cast-btn'); if(btn){btn.disabled=false;btn.textContent='🎣 Cast Again';}
                    _fpSetStatus(''); return;
                }
                var el=_fpEl('fp-needle'); if(el) el.style.left='calc('+(_fpNeedle*100)+'% - 2px)';
            }
            function _fpStopAnim(){ if(_fpRAF){cancelAnimationFrame(_fpRAF);_fpRAF=null;} }
            function _fpReact(){
                if(_fpPhase!=='reacting') return;
                _fpStopAnim(); _fpPhase='idle'; _fpEl('fp-bar-section').style.display='none';
                var hit=(_fpNeedle>=_fpZoneL && _fpNeedle<=(_fpZoneL+_fpZoneW));
                if(hit){
                    var f=_fpFish, count=f.min+Math.floor(Math.random()*(f.max-f.min+1));
                    var name=(typeof itemDisplayNames!=='undefined'&&itemDisplayNames[f.item])||f.item;
                    inventory[f.item]=(inventory[f.item]||0)+count;
                    updateUI(); updateInventoryDisplay(); updateHotbar();
                    _fpCaught++; var sc=_fpEl('fp-caught-label'); if(sc) sc.textContent='Caught: '+_fpCaught;
                    _fpSetResult('🎣 Caught '+count+'× '+name+'!','#7dff9a'); _fpShowFish(f);
                    var body=_fpEl('fp-fish-body');
                    if(body){ body.style.animation='fp-fish-pop 0.4s ease-out'; setTimeout(function(){ if(body) body.style.animation='fp-fish-swim 1.4s ease-in-out infinite'; },400); }
                    _fpPlayReel();
                } else {
                    _fpSetResult('❌ Missed! Fish got away.','#ffaa66'); _fpHideFish();
                }
                var btn=_fpEl('fp-cast-btn'); if(btn){btn.disabled=false;btn.textContent='🎣 Cast Again';}
                _fpSetStatus('');
            }
            window._fpOpen = function(){
                _fpCaught=0; _fpPhase='idle';
                var sc=_fpEl('fp-caught-label'); if(sc) sc.textContent='Caught: 0';
                var btn=_fpEl('fp-cast-btn'); if(btn){btn.disabled=false;btn.textContent='🎣 Cast Line';}
                _fpHideFish();
                _fpSetStatus((inventory.worms > 0)
                    ? `Press SPACE or "Cast Line" to begin. (🪱 ${inventory.worms} worm${inventory.worms !== 1 ? 's' : ''})`
                    : '🪱 No worms! Harvest bushes to find some.');
                _fpSetResult('','');
                _fpEl('fp-bar-section').style.display='none';
                _fpEl('fishing-panel').style.display='block';
                _fpStartWaveAnim();
            };
            window._fpClose = function(){
                if(_fpWaitTimer){clearTimeout(_fpWaitTimer);_fpWaitTimer=null;}
                _fpStopAnim(); _fpStopReel(); _fpPhase='idle';
                _fpStopWaveAnim();
                _fpEl('fishing-panel').style.display='none';
            };
            // Fishing panel buttons are rendered after the script tag, so defer binding
            setTimeout(() => {
                const _fpCloseBtn = document.getElementById('fp-close');
                const _fpCastBtn  = document.getElementById('fp-cast-btn');
                if (_fpCloseBtn) _fpCloseBtn.addEventListener('click', function(){ stopFishing(); });
                if (_fpCastBtn)  _fpCastBtn.addEventListener('click', function(){
                    if(_fpPhase==='idle'){ _fpStopReel(); _fpStartWait(); }
                });
            }, 0);
            document.addEventListener('keydown', function(ev){
                if(!fishingState.active) return;
                if(ev.code==='Space'||ev.key===' '){
                    ev.preventDefault();
                    if(_fpPhase==='reacting') _fpReact();
                    else if(_fpPhase==='idle'){ _fpStopReel(); _fpStartWait(); }
                }
            });
        })();

        // ─── END FISHING MINIGAME ──────────────────────────────────────────

        async function init() {
            setLoadingProgress(2, 'Initializing...');
            console.log('\u2699\ufe0f Initializing texture cache...');
            await textureCache.init();
            setLoadingProgress(8, 'Starting engine...');
            updateUI();
            animate();
            // startAmbientSounds deferred to click-to-play to avoid AudioContext suspension issues
            validateAllItemsHaveIcons();
            await prewarmModels();
            const stats = textureCache.getStats();
            console.log('\ud83d\udcca Texture Cache Stats:', stats);
            if (stats.hits > 0) console.log(`\u26a1 Speed boost! ${stats.hits} textures loaded from cache instantly!`);
            if (stats.generated > 0) console.log(`\u2705 ${stats.generated} textures generated and cached for next time.`);
            finishLoading();
            _loadFpsArm(); // load after _ASSET_GLB_BASE is defined
        }

        // Wait for THREE.js to be available then init
        init();
        } // end startGame
    </script>

    <div id="fishing-panel" style="display:none;">
        <div id="fishing-panel-header">
            <span style="font-weight:bold;font-size:18px;">🎣 FISHING</span>
            <span id="fp-caught-label" style="font-size:13px;color:rgba(120,255,180,0.9);">Caught: 0</span>
            <button id="fp-close" style="background:rgba(255,0,0,0.8);border:none;color:white;padding:5px 10px;border-radius:4px;cursor:pointer;font-weight:bold;">✕</button>
        </div>
        <div style="padding:20px 24px 18px;">
            <!-- Water scene -->
            <div id="fp-water-scene" style="position:relative;width:100%;height:110px;border-radius:10px;overflow:hidden;margin-bottom:10px;background:linear-gradient(180deg,#87ceeb 0%,#5ab0d8 28%,#0d2d50 28%,#0a1f3a 100%);">
                <svg style="position:absolute;bottom:0;left:0;width:100%;height:100%;" preserveAspectRatio="none" viewBox="0 0 400 110" xmlns="http://www.w3.org/2000/svg">
                    <!-- Sky above water -->
                    <rect width="400" height="31" fill="transparent"/>
                    <!-- Deep water -->
                    <rect y="31" width="400" height="79" fill="#0a1828"/>
                    <!-- Caustic light shafts under water -->
                    <g opacity="0.09">
                        <polygon points="160,31 175,110 145,110" fill="#7dd4fc"/>
                        <polygon points="220,31 240,110 200,110" fill="#7dd4fc"/>
                        <polygon points="130,31 142,110 118,110" fill="#7dd4fc"/>
                        <polygon points="275,31 288,110 262,110" fill="#7dd4fc"/>
                    </g>
                    <!-- Bubbles rising from bottom -->
                    <circle cx="60"  cy="95" r="2.5" fill="rgba(150,220,255,0.4)" style="animation:fp-bubble-rise 3.1s ease-in infinite 0.2s"/>
                    <circle cx="140" cy="100" r="1.8" fill="rgba(150,220,255,0.35)" style="animation:fp-bubble-rise 2.6s ease-in infinite 1.1s"/>
                    <circle cx="220" cy="92" r="3.0" fill="rgba(150,220,255,0.3)" style="animation:fp-bubble-rise 3.8s ease-in infinite 0.5s"/>
                    <circle cx="310" cy="98" r="2.0" fill="rgba(150,220,255,0.35)" style="animation:fp-bubble-rise 2.9s ease-in infinite 1.7s"/>
                    <circle cx="360" cy="90" r="1.5" fill="rgba(150,220,255,0.3)" style="animation:fp-bubble-rise 3.4s ease-in infinite 0.9s"/>
                    <circle cx="90"  cy="88" r="1.2" fill="rgba(150,220,255,0.25)" style="animation:fp-bubble-rise 4.1s ease-in infinite 2.3s"/>
                    <circle cx="260" cy="96" r="2.2" fill="rgba(150,220,255,0.3)" style="animation:fp-bubble-rise 3.0s ease-in infinite 0.7s"/>
                    <!-- Wave surface layers - dramatic, placed at y≈28 (about 25% down) -->
                    <path id="fp-wave1" fill="rgba(8,45,90,0.92)"   d="M0,36 Q100,16 200,36 Q300,56 400,36 L400,110 L0,110 Z"/>
                    <path id="fp-wave2" fill="rgba(10,55,110,0.95)" d="M0,42 Q100,24 200,42 Q300,60 400,42 L400,110 L0,110 Z"/>
                    <path id="fp-wave3" fill="rgba(100,200,255,0.15)" d="M0,38 Q100,20 200,38 Q300,56 400,38 L400,44 Q300,62 200,44 Q100,26 0,44 Z"/>
                    <!-- Surface glint/highlight -->
                    <path id="fp-wave4" fill="rgba(180,230,255,0.25)" d="M0,37 Q50,30 100,37 Q150,44 200,37 Q250,30 300,37 Q350,44 400,37 L400,39 Q350,46 300,39 Q250,32 200,39 Q150,46 100,39 Q50,32 0,39 Z"/>
                </svg>
                <!-- Waiting bobber - sits at water surface -->
                <div id="fp-bobber" style="position:absolute;left:50%;top:4px;transform:translateX(-50%);display:flex;flex-direction:column;align-items:center;pointer-events:none;">
                    <div style="width:1.5px;height:28px;background:rgba(200,200,200,0.6);"></div>
                    <div id="fp-bobber-float" style="font-size:22px;line-height:1;">🪝</div>
                </div>
                <!-- Fish display - positioned in the underwater zone -->
                <div id="fp-fish-wrap" style="position:absolute;left:50%;top:62%;transform:translate(-50%,-50%);display:none;flex-direction:column;align-items:center;gap:2px;">
                    <div id="fp-fish-body" style="display:flex;align-items:center;">
                        <div id="fp-fish-emoji" style="font-size:46px;line-height:1;display:inline-block;filter:brightness(0.85) saturate(1.2);"></div>
                        <div id="fp-fish-tail"  style="font-size:24px;line-height:1;display:none;transform-origin:left center;filter:brightness(0.85);"></div>
                    </div>
                    <div id="fp-fish-name" style="font-size:10px;letter-spacing:1px;color:rgba(140,200,255,0.9);text-transform:uppercase;text-shadow:0 0 6px rgba(0,80,180,0.9);font-weight:600;"></div>
                </div>
            </div>
            <div id="fp-status" style="text-align:center;font-size:14px;color:rgba(200,230,255,0.85);margin:10px 0 14px;min-height:22px;font-weight:500;">Press "Cast Line" to begin.</div>
            <div id="fp-bar-section" style="display:none;margin-bottom:14px;">
                <div style="position:relative;height:38px;background:rgba(0,0,0,0.45);border:1px solid rgba(255,255,255,0.15);border-radius:8px;overflow:hidden;">
                    <div id="fp-zone" style="position:absolute;top:0;height:100%;background:rgba(80,220,120,0.3);border-left:2px solid rgba(80,220,120,0.9);border-right:2px solid rgba(80,220,120,0.9);box-sizing:border-box;"></div>
                    <div id="fp-needle" style="position:absolute;top:4px;bottom:4px;width:5px;background:#fff;border-radius:3px;box-shadow:0 0 8px rgba(255,255,255,0.9);"></div>
                </div>
                <div style="text-align:center;margin-top:8px;font-size:12px;color:rgba(180,210,255,0.65);">Press <strong style="color:#fff;">SPACE</strong> when the needle is in the green — you have <strong style="color:#fff;">2 passes</strong>!</div>
            </div>
            <div id="fp-result" style="text-align:center;font-size:19px;font-weight:900;min-height:28px;margin-bottom:14px;text-shadow:0 0 16px currentColor;"></div>
            <div style="text-align:center;">
                <button id="fp-cast-btn" style="background:linear-gradient(135deg,rgba(52,152,219,0.5),rgba(41,128,185,0.5));border:2px solid rgba(52,152,219,0.6);color:white;font-size:15px;font-weight:bold;padding:11px 40px;border-radius:8px;cursor:pointer;letter-spacing:0.5px;width:100%;">🎣 Cast Line</button>
            </div>
        </div>
        <div style="text-align:center;padding:8px;background:rgba(0,0,0,0.2);border-top:1px solid rgba(255,255,255,0.08);font-size:11px;color:rgba(255,255,255,0.35);">
            Press <kbd style="background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);border-radius:3px;padding:1px 5px;">E</kbd> or <kbd style="background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);border-radius:3px;padding:1px 5px;">Esc</kbd> to stop fishing
        </div>
    </div>
</body>
</html>
