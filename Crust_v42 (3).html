<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>html,body{background:#000;margin:0;padding:0}</style>
    <title>Crust</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
        }
        
        canvas {
            display: block;
            image-rendering: auto;
        }
        
        #ui {
            position: absolute;
            top: 15px;
            left: 15px;
            color: white;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.85), rgba(20, 20, 40, 0.9));
            padding: 20px;
            border-radius: 12px;
            font-size: 16px;
            pointer-events: none;
            min-width: 250px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat-container {
            margin: 12px 0;
        }
        
        .stat-label {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.9;
        }
        
        .stat-bar {
            position: relative;
            background: rgba(0, 0, 0, 0.5);
            height: 24px;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .stat-fill {
            height: 100%;
            transition: width 0.3s ease-out;
            position: relative;
            overflow: hidden;
        }
        
        .stat-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.3), transparent);
        }
        
        .stat-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 11px;
            font-weight: bold;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
            z-index: 1;
        }
        
        .health-bar {
            background: linear-gradient(90deg, #c0392b, #e74c3c);
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.5);
        }
        
        .hunger-bar {
            background: linear-gradient(90deg, #d68910, #f39c12);
            box-shadow: 0 0 15px rgba(243, 156, 18, 0.5);
        }
        
        .thirst-bar {
            background: linear-gradient(90deg, #2874a6, #3498db);
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.5);
        }
        
        .stamina-bar {
            background: linear-gradient(90deg, #16a085, #1abc9c);
            box-shadow: 0 0 15px rgba(26, 188, 156, 0.5);
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            pointer-events: none;
            opacity: 0.8;
        }
        
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.8), 0 0 8px rgba(255, 255, 255, 0.3);
        }
        
        #crosshair::before {
            width: 2px;
            height: 24px;
            left: 11px;
        }
        
        #crosshair::after {
            width: 24px;
            height: 2px;
            top: 11px;
        }
        
        #pistol-crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 3px;
            height: 3px;
            background: red;
            border-radius: 50%;
            pointer-events: none;
            opacity: 0.9;
            box-shadow: 0 0 4px rgba(255, 0, 0, 0.8), 0 0 8px rgba(255, 0, 0, 0.5);
        }
        
        #pistol-crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 0, 0, 0.6);
            border-radius: 50%;
            box-shadow: 0 0 6px rgba(255, 0, 0, 0.4);
        }
        
        #ammo-counter {
            position: absolute;
            bottom: 140px;
            right: 40px;
            color: white;
            font-size: 32px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.9), 0 0 20px rgba(255, 0, 0, 0.5);
            pointer-events: none;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.7), rgba(40, 0, 0, 0.8));
            padding: 15px 25px;
            border-radius: 10px;
            border: 2px solid rgba(255, 0, 0, 0.4);
            backdrop-filter: blur(5px);
        }
        
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 40, 0.95));
            padding: 25px 40px;
            border-radius: 15px;
            text-align: center;
            max-width: 900px;
            font-size: 14px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.7);
            z-index: 10000;
        }
        
        #crafting-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(10, 10, 30, 0.98), rgba(20, 20, 40, 0.98));
            color: white;
            padding: 25px;
            border-radius: 15px;
            display: none;
            width: 850px;
            max-height: 85vh;
            overflow-y: auto;
            pointer-events: auto;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.8);
        }
        
        #workbench-menu, #furnace-menu, #recycler-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(10, 10, 30, 0.98), rgba(20, 20, 40, 0.98));
            color: white;
            padding: 25px;
            border-radius: 12px;
            display: none;
            width: 750px;
            max-height: 85vh;
            overflow-y: auto;
            pointer-events: auto;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.8);
            z-index: 2000;
        }
        
        #crafting-menu::-webkit-scrollbar, #workbench-menu::-webkit-scrollbar, #furnace-menu::-webkit-scrollbar, #recycler-menu::-webkit-scrollbar {
            width: 8px;
        }
        
        #crafting-menu::-webkit-scrollbar-track, #workbench-menu::-webkit-scrollbar-track, #furnace-menu::-webkit-scrollbar-track, #recycler-menu::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        
        #crafting-menu::-webkit-scrollbar-thumb, #workbench-menu::-webkit-scrollbar-thumb, #furnace-menu::-webkit-scrollbar-thumb, #recycler-menu::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }
        
        .menu-title {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 20px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        #workbench-menu .menu-title,
        #furnace-menu .menu-title {
            font-size: 20px;
            margin-bottom: 15px;
        }
        
        .craft-item, .build-item {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.05));
            padding: 15px;
            margin: 12px 0;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        .craft-item::before, .build-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }
        
        .craft-item:hover::before, .build-item:hover::before {
            left: 100%;
        }
        
        .craft-item:hover, .build-item:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.1));
            transform: translateX(5px);
            box-shadow: 0 4px 20px rgba(52, 152, 219, 0.3);
        }
        
        .craft-item.disabled, .build-item.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }
        
        .craft-item.disabled:hover, .build-item.disabled:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.05));
            box-shadow: none;
        }
        
        /* Category Grid Layout */
        .menu-category {
            margin-bottom: 25px;
        }
        
        .category-title {
            font-size: 16px;
            font-weight: bold;
            color: #3498db;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid rgba(52, 152, 219, 0.3);
        }
        
        .category-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 12px;
        }
        
        .grid-item {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.05));
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.1);
            text-align: center;
            position: relative;
            overflow: hidden;
            min-height: 90px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .grid-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }
        
        .grid-item:hover::before {
            left: 100%;
        }
        
        .grid-item:hover {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.3), rgba(41, 128, 185, 0.3));
            transform: translateY(-2px);
            border-color: rgba(52, 152, 219, 0.6);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }
        
        .grid-item.disabled {
            opacity: 0.35;
            cursor: not-allowed;
        }
        
        .grid-item.disabled:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.05));
            transform: none;
            border-color: rgba(255, 255, 255, 0.1);
            box-shadow: none;
        }
        
        .grid-item-icon {
            font-size: 32px;
            margin-bottom: 6px;
        }
        
        .grid-item-name {
            font-weight: bold;
            font-size: 13px;
            margin-bottom: 4px;
            color: #fff;
        }
        
        .grid-item-cost {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.3;
        }
        
        .time-display {
            position: absolute;
            top: 15px;
            right: 15px;
            color: white;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.85), rgba(20, 20, 40, 0.9));
            padding: 15px 20px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        #message {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.95), rgba(192, 57, 43, 0.95));
            padding: 12px 24px;
            border-radius: 10px;
            display: none;
            z-index: 1000;
            font-weight: 600;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            animation: slideDown 0.3s ease-out;
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translate(-50%, -20px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }
        
        #build-info {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(20, 20, 40, 0.95));
            padding: 15px 25px;
            border-radius: 10px;
            display: none;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .menu-button {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            margin-top: 15px;
            cursor: pointer;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .menu-button:hover {
            background: linear-gradient(135deg, #34495e, #2c3e50);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
            transform: translateY(-2px);
        }
        
        #death-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.9), rgba(192, 57, 43, 0.85));
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }
        
        #death-screen h1 {
            color: white;
            font-size: 84px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.8), 0 0 40px rgba(255, 0, 0, 0.5);
            animation: pulse 2s infinite;
            text-transform: uppercase;
            letter-spacing: 4px;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        #death-screen p {
            color: white;
            font-size: 24px;
            margin-bottom: 40px;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
        }
        
        #respawn-button {
            padding: 20px 60px;
            font-size: 24px;
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6);
            transition: all 0.3s ease;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        #respawn-button:hover {
            background: linear-gradient(135deg, #c0392b, #a93226);
            transform: scale(1.1) translateY(-5px);
            box-shadow: 0 12px 40px rgba(231, 76, 60, 0.6);
        }
        
        #hotbar {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.85), rgba(20, 20, 40, 0.9));
            padding: 15px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
        }
        
        .hotbar-slot {
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.03));
            border: 2px solid rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 11px;
            position: relative;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .hotbar-slot:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.08));
            transform: translateY(-5px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }
        
        .hotbar-slot.selected {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.4), rgba(41, 128, 185, 0.4));
            border-color: #3498db;
            box-shadow: 0 0 20px rgba(52, 152, 219, 0.6), inset 0 0 10px rgba(52, 152, 219, 0.3);
            transform: translateY(-5px);
        }
        
        .hotbar-slot-number {
            position: absolute;
            top: 3px;
            left: 5px;
            font-size: 10px;
            font-weight: bold;
            opacity: 0.7;
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        .hotbar-slot-icon {
            font-size: 24px;
            margin-bottom: 4px;
        }
        
        .hotbar-slot-count {
            font-size: 12px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 6px;
            border-radius: 4px;
            margin-top: 2px;
        }
        
        #hotbar-tooltip {
            position: fixed;
            bottom: 130px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 40, 0.95));
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
            z-index: 1000;
            white-space: nowrap;
        }
        
        #hotbar-tooltip.visible {
            opacity: 1;
        }
        
        #inventory-ui {
            position: fixed;
            bottom: 120px;
            right: 20px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.85), rgba(20, 20, 40, 0.9));
            padding: 20px;
            border-radius: 12px;
            color: white;
            max-width: 300px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        #inventory-ui h3 {
            margin: 0 0 15px 0;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            border-bottom: 2px solid rgba(52, 152, 219, 0.5);
            padding-bottom: 8px;
        }
        
        .inventory-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 10px;
            margin: 6px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.2s ease;
        }
        
        .inventory-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }
        
        .inventory-item-name {
            font-weight: 500;
        }
        
        .inventory-item-count {
            font-weight: bold;
            color: #3498db;
        }
        
        #minimap {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 180px;
            height: 180px;
            background: rgba(0, 0, 0, 0.85);
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            margin-top: 50px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
        }
        
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a1e, #1a1a2e);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            opacity: 1;
            transition: opacity 1s ease-out;
        }
        
        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-title {
            font-size: 48px;
            color: white;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 4px;
            text-shadow: 0 0 20px rgba(52, 152, 219, 0.8);
        }
        
        .loading-bar {
            width: 400px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        
        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 20px rgba(52, 152, 219, 0.8);
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        
        #inventory-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            /* Responsive width: scales from 98vw on tiny screens up to 850px max */
            width: clamp(320px, 90vw, 850px);
            max-height: 90vh;
            overflow: auto;
            background: linear-gradient(135deg, rgba(10, 10, 30, 0.98), rgba(20, 20, 40, 0.98));
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 0;
            backdrop-filter: blur(15px);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.8);
            z-index: 1500;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
        }
        
        #inventory-content {
            display: flex;
            position: relative;
        }
        
        #storage-panel {
            position: fixed;
            top: 50%;
            left: 25%;
            transform: translate(-50%, -50%);
            width: 520px;
            background: linear-gradient(135deg, rgba(40, 30, 10, 0.98), rgba(60, 45, 20, 0.98));
            border: 2px solid rgba(255, 200, 100, 0.3);
            border-radius: 12px;
            padding: 0;
            backdrop-filter: blur(15px);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.8);
            z-index: 1500;
            pointer-events: auto;
        }
        #backpack-panel {
            position: fixed;
            top: 50%;
            left: 25%;
            transform: translate(-50%, -50%);
            width: 520px;
            background: linear-gradient(135deg, rgba(15, 8, 3, 0.98), rgba(40, 20, 8, 0.98));
            border: 2px solid rgba(200, 100, 30, 0.7);
            border-radius: 12px;
            padding: 0;
            backdrop-filter: blur(15px);
            box-shadow: 0 12px 48px rgba(0,0,0,0.9), 0 0 30px rgba(200,80,20,0.25);
            z-index: 1500;
            pointer-events: auto;
            display: none;
        }
        #backpack-header {
            background: linear-gradient(135deg, rgba(120, 55, 10, 0.6), rgba(160, 80, 20, 0.6));
            padding: 15px 20px;
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            border-bottom: 2px solid rgba(200, 100, 30, 0.5);
        }
        #backpack-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 6px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        #inventory-header {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.3), rgba(41, 128, 185, 0.3));
            padding: 15px 20px;
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            cursor: move;
            user-select: none;
            border-bottom: 2px solid rgba(52, 152, 219, 0.5);
        }
        
        #storage-header {
            background: linear-gradient(135deg, rgba(139, 105, 20, 0.4), rgba(184, 134, 11, 0.4));
            padding: 15px 20px;
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            cursor: move;
            user-select: none;
            border-bottom: 2px solid rgba(218, 165, 32, 0.5);
        }
        
        /* Furnace and Campfire Menus */
        #furnace-menu, #campfire-menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 560px;
            background: linear-gradient(135deg, rgba(60, 30, 10, 0.98), rgba(80, 40, 20, 0.98));
            border: 3px solid rgba(255, 140, 0, 0.5);
            border-radius: 12px;
            padding: 0;
            backdrop-filter: blur(15px);
            box-shadow: 0 12px 48px rgba(255, 100, 0, 0.6);
            z-index: 1500;
            pointer-events: auto;
        }
        
        #furnace-header, #campfire-header {
            background: linear-gradient(135deg, rgba(255, 100, 0, 0.4), rgba(255, 140, 0, 0.4));
            padding: 15px 20px;
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            border-bottom: 2px solid rgba(255, 140, 0, 0.7);
        }
        
        #furnace-content, #campfire-content {
            padding: 25px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            align-items: center;
        }
        
        .smelting-slot-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        
        .smelting-label {
            font-size: 13px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
        }
        
        .smelting-slot {
            width: 80px;
            height: 80px;
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid rgba(255, 140, 0, 0.4);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .smelting-slot:hover {
            border-color: rgba(255, 140, 0, 0.8);
            background: rgba(255, 140, 0, 0.1);
            transform: scale(1.05);
        }
        
        .smelting-slot.output-slot {
            border-color: rgba(0, 255, 100, 0.4);
            cursor: default;
        }
        
        .smelting-slot.output-slot:hover {
            border-color: rgba(0, 255, 100, 0.6);
        }
        
        .smelting-slot-count {
            position: absolute;
            bottom: 4px;
            right: 6px;
            font-size: 14px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 4px black, 0 0 2px black;
        }
        
        .smelting-progress-container {
            grid-column: 1 / -1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }
        
        .smelting-progress-bar {
            width: 100%;
            height: 30px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 140, 0, 0.5);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }
        
        .smelting-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6600, #ffaa00);
            width: 0%;
            transition: width 0.1s linear;
            box-shadow: 0 0 20px rgba(255, 140, 0, 0.8);
            position: relative;
        }
        
        .smelting-progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: progressShine 1.5s infinite;
        }
        
        @keyframes progressShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .smelting-progress-text {
            font-size: 16px;
            font-weight: bold;
            color: #ffaa00;
            text-shadow: 0 0 10px rgba(255, 140, 0, 0.8);
        }
        
        #close-furnace, #close-campfire {
            transition: all 0.2s ease;
        }
        
        #close-furnace:hover, #close-campfire:hover {
            background: rgba(255, 0, 0, 1) !important;
            transform: scale(1.1);
        }
        
        #cooking-station-menu {
            position: fixed;
            top: 50%;
            left: 28%;
            transform: translate(-50%, -50%);
            width: 560px;
            max-height: 88vh;
            overflow-y: auto;
            background: linear-gradient(135deg, rgba(40, 20, 5, 0.98), rgba(70, 35, 10, 0.98));
            border: 3px solid rgba(255, 160, 50, 0.5);
            border-radius: 12px;
            padding: 0;
            backdrop-filter: blur(15px);
            box-shadow: 0 12px 48px rgba(255, 120, 0, 0.6);
            z-index: 1500;
            pointer-events: auto;
        }
        #cooking-station-menu::-webkit-scrollbar { width: 6px; }
        #cooking-station-menu::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); }
        #cooking-station-menu::-webkit-scrollbar-thumb { background: rgba(255,140,0,0.5); border-radius: 3px; }
        #cooking-station-header {
            background: linear-gradient(135deg, rgba(200, 80, 0, 0.4), rgba(255, 140, 0, 0.4));
            padding: 15px 20px;
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            border-bottom: 2px solid rgba(255, 140, 0, 0.7);
            position: sticky; top: 0; z-index: 2;
        }
        #cooking-station-content {
            padding: 16px 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        /* Recipe book panel */
        #cs-recipe-book {
            background: rgba(0,0,0,0.35);
            border: 1px solid rgba(255,140,0,0.25);
            border-radius: 8px;
            padding: 10px 14px;
            max-height: 200px;
            overflow-y: auto;
        }
        #cs-recipe-book::-webkit-scrollbar { width: 5px; }
        #cs-recipe-book::-webkit-scrollbar-thumb { background: rgba(255,140,0,0.4); border-radius:3px; }
        .cs-recipe-book-title {
            font-size: 12px; font-weight: bold; color: rgba(255,200,100,0.9);
            text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;
        }
        .cs-recipe-entry {
            display: flex; align-items: center; gap: 8px;
            padding: 5px 0; border-bottom: 1px solid rgba(255,140,0,0.1);
            font-size: 12px; color: rgba(255,255,255,0.8);
            cursor: pointer; border-radius: 4px; padding: 4px 6px;
            transition: background 0.15s;
        }
        .cs-recipe-entry:last-child { border-bottom: none; }
        .cs-recipe-entry:hover { background: rgba(255,140,0,0.12); }
        .cs-recipe-entry:hover .cs-recipe-tip { display: block; }
        .cs-recipe-ings { color: rgba(255,200,100,0.85); font-size: 11px; }
        .cs-recipe-arrow { color: rgba(255,140,0,0.7); margin: 0 2px; }
        .cs-recipe-result { font-weight: bold; color: rgba(100,255,130,0.9); }
        .cs-recipe-tip {
            display: none;
            position: absolute;
            left: 50%; top: calc(100% + 6px);
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(10,30,10,0.98), rgba(20,50,20,0.98));
            border: 1px solid rgba(80,220,80,0.45);
            border-radius: 8px;
            padding: 10px 14px;
            min-width: 220px;
            max-width: 300px;
            z-index: 9999;
            pointer-events: none;
            box-shadow: 0 6px 24px rgba(0,0,0,0.7);
        }
        .cs-recipe-tip-title {
            font-size: 12px; font-weight: bold;
            color: #55ff88; margin-bottom: 6px;
            text-transform: uppercase; letter-spacing: 0.8px;
        }
        .cs-recipe-tip-buff {
            font-size: 12px; color: #aaffcc; line-height: 1.5;
        }
        .cs-recipe-tip-duration {
            font-size: 11px; color: rgba(180,255,180,0.6); margin-top: 4px;
        }
        .cs-buff-chevron {
            font-size: 10px; color: #44ff88;
            vertical-align: super; margin-left: 2px;
            text-shadow: 0 0 6px rgba(0,255,100,0.8);
            font-style: normal;
        }
        /* Active buff HUD indicator */
        #buff-hud {
            position: absolute;
            top: 15px; right: 15px;
            display: flex; flex-direction: column; gap: 6px;
            pointer-events: none; z-index: 500;
        }
        .buff-indicator {
            background: linear-gradient(135deg, rgba(10,40,10,0.92), rgba(20,60,20,0.92));
            border: 1px solid rgba(80,220,80,0.5);
            border-radius: 8px; padding: 6px 12px;
            font-size: 12px; font-weight: bold; color: #66ff99;
            display: flex; align-items: center; gap: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.5);
            backdrop-filter: blur(6px);
        }
        .buff-indicator-timer { color: rgba(180,255,180,0.7); font-size: 11px; font-weight: normal; }
        /* Ingredient grid */
        .cs-row {
            display: flex; gap: 10px; align-items: flex-end; justify-content: center;
        }
        .cs-ingredient-grid { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }
        .cs-slot-container { display: flex; flex-direction: column; align-items: center; gap: 5px; }
        .cs-label {
            font-size: 11px; font-weight: 600; color: rgba(255,255,255,0.75);
            text-transform: uppercase; letter-spacing: 0.8px; text-align: center;
        }
        .cs-slot {
            width: 68px; height: 68px;
            background: rgba(0,0,0,0.55);
            border: 3px solid rgba(255,140,0,0.35);
            border-radius: 8px; display: flex; align-items: center; justify-content: center;
            font-size: 28px; cursor: pointer; transition: all 0.2s ease; position: relative;
        }
        .cs-slot:hover { border-color: rgba(255,140,0,0.75); background: rgba(255,140,0,0.1); transform: scale(1.05); }
        .cs-slot.cs-output { border-color: rgba(0,255,100,0.4); cursor: pointer; width: 84px; height: 84px; font-size: 34px; }
        .cs-slot.cs-output:hover { border-color: rgba(0,255,100,0.7); background: rgba(0,255,100,0.1); transform: scale(1.05); }
        .cs-slot.cs-waste { border-color: rgba(160,160,160,0.35); cursor: pointer; }
        .cs-slot.cs-waste:hover { border-color: rgba(160,160,160,0.6); background: rgba(160,160,160,0.08); }
        .cs-slot.drag-over { border-color: rgba(255,220,0,1) !important; background: rgba(255,220,0,0.2) !important; transform: scale(1.08); }
        .cs-slot-count {
            position: absolute; bottom: 4px; right: 6px;
            font-size: 13px; font-weight: bold; color: white;
            text-shadow: 0 0 4px black, 0 0 2px black;
        }
        #cs-recipe-hint {
            text-align: center; font-size: 13px;
            color: rgba(255,200,100,0.9); font-style: italic; min-height: 18px;
        }
        #cs-cook-btn {
            display: block; width: 100%;
            background: linear-gradient(135deg, #e67e22, #d35400);
            border: none; color: white; padding: 12px; border-radius: 8px;
            cursor: pointer; font-size: 15px; font-weight: bold;
            text-transform: uppercase; letter-spacing: 1px;
            transition: all 0.2s ease; box-shadow: 0 4px 15px rgba(230,126,34,0.4);
        }
        #cs-cook-btn:hover:not(:disabled) { background: linear-gradient(135deg, #f39c12, #e67e22); transform: scale(1.02); }
        #cs-cook-btn:disabled { opacity: 0.45; cursor: not-allowed; transform: none; }
        #close-cooking-station {
            background: rgba(255,0,0,0.8); border: none; color: white;
            padding: 5px 10px; border-radius: 4px; cursor: pointer; font-weight: bold;
            transition: all 0.2s ease;
        }
        #close-cooking-station:hover { background: rgba(255,0,0,1) !important; transform: scale(1.1); }
        
        .smelting-slot.drag-over {
            border-color: rgba(255, 220, 0, 1) !important;
            background: rgba(255, 220, 0, 0.2) !important;
            transform: scale(1.08);
        }
        
        .furnace-input-slot.active-smelt {
            border-color: rgba(255, 100, 0, 0.9) !important;
            box-shadow: 0 0 12px rgba(255, 100, 0, 0.7);
        }
        
        #close-inventory:hover {
            background: rgba(255, 0, 0, 1);
            transform: scale(1.1);
        }
        
        /* Recycler Menu */
        #recycler-menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 550px;
            background: linear-gradient(135deg, rgba(20, 40, 30, 0.98), rgba(30, 60, 40, 0.98));
            border: 3px solid rgba(76, 187, 23, 0.5);
            border-radius: 12px;
            padding: 0;
            backdrop-filter: blur(15px);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.8);
            z-index: 2001;
            pointer-events: auto;
        }
        
        #recycler-header {
            background: linear-gradient(135deg, rgba(76, 187, 23, 0.3), rgba(46, 125, 50, 0.3));
            padding: 15px 20px;
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            border-bottom: 2px solid rgba(76, 187, 23, 0.5);
        }
        
        #recycler-content {
            padding: 20px;
        }
        
        .recycler-section {
            margin-bottom: 15px;
        }
        
        .recycler-label {
            font-size: 14px;
            font-weight: bold;
            color: #4caf50;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .recycler-slots-container {
            display: flex;
            gap: 8px;
            justify-content: center;
        }
        
        .recycler-slot {
            width: 70px;
            height: 70px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(76, 187, 23, 0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
        }
        
        .recycler-slot:hover {
            border-color: rgba(76, 187, 23, 0.6);
            background: rgba(76, 187, 23, 0.1);
        }
        
        .recycler-slot.filled {
            background: rgba(76, 187, 23, 0.2);
            border-color: rgba(76, 187, 23, 0.5);
        }
        
        .recycler-slot-icon {
            font-size: 36px;
        }
        
        .recycler-slot-count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 12px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 4px black;
        }
        
        .recycler-controls {
            text-align: center;
            margin: 20px 0;
        }
        
        #recycler-start-btn {
            background: linear-gradient(135deg, #4caf50, #2e7d32);
            border: none;
            color: white;
            padding: 12px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #recycler-start-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #66bb6a, #43a047);
            transform: scale(1.05);
        }
        
        #recycler-start-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .recycler-progress-container {
            margin: 15px 0;
        }
        
        .recycler-progress-bar {
            position: relative;
            height: 24px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(76, 187, 23, 0.3);
        }
        
        .recycler-progress-fill {
            position: relative;
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            transition: width 0.1s linear;
            box-shadow: 0 0 15px rgba(76, 187, 23, 0.7);
        }
        
        .recycler-progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 8px black;
            z-index: 1;
        }
        
        #close-recycler {
            background: rgba(255, 0, 0, 0.8);
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
        }
        
        #close-recycler:hover {
            background: rgba(255, 0, 0, 1);
            transform: scale(1.1);
        }
        
        /* Well Menu */
        #water-catcher-menu {
            position: fixed;
            top: 50%;
            left: 28%;
            transform: translate(-50%, -50%);
            width: 420px;
            background: linear-gradient(135deg, rgba(10, 30, 50, 0.98), rgba(15, 45, 70, 0.98));
            border: 3px solid rgba(52, 152, 219, 0.5);
            border-radius: 12px;
            padding: 0;
            backdrop-filter: blur(15px);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.8), 0 0 30px rgba(52, 152, 219, 0.2);
            z-index: 2001;
            pointer-events: auto;
        }
        #water-catcher-header {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.3), rgba(41, 128, 185, 0.3));
            padding: 15px 20px;
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            border-bottom: 2px solid rgba(52, 152, 219, 0.5);
        }
        #water-catcher-content {
            padding: 20px;
        }
        .wc-label {
            font-size: 13px;
            font-weight: bold;
            color: #3498db;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .wc-slots-container {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        .wc-slot {
            width: 70px;
            height: 70px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(52, 152, 219, 0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
        }
        .wc-slot:hover {
            border-color: rgba(52, 152, 219, 0.7);
            background: rgba(52, 152, 219, 0.1);
        }
        .wc-slot.filled {
            background: rgba(52, 152, 219, 0.2);
            border-color: rgba(52, 152, 219, 0.6);
        }
        .wc-slot-icon { font-size: 36px; }
        .wc-slot-count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 12px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 4px black;
        }
        .wc-progress-container { margin: 15px 0; }
        .wc-progress-bar {
            position: relative;
            height: 28px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 14px;
            overflow: hidden;
            border: 2px solid rgba(52, 152, 219, 0.3);
        }
        .wc-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #2980b9, #3498db, #74b9ff);
            transition: width 0.5s linear;
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.7);
        }
        .wc-progress-text {
            display: block;
            margin-top: 6px;
            text-align: center;
            font-size: 13px;
            font-weight: bold;
            color: #74b9ff;
            text-shadow: 0 0 8px rgba(0,0,0,0.8);
            white-space: nowrap;
        }
        .wc-rain-status {
            text-align: center;
            font-size: 13px;
            font-weight: bold;
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 12px;
        }
        .wc-rain-active {
            background: rgba(52, 152, 219, 0.2);
            color: #74b9ff;
            border: 1px solid rgba(52, 152, 219, 0.4);
        }
        .wc-rain-inactive {
            background: rgba(100, 100, 100, 0.2);
            color: #aaa;
            border: 1px solid rgba(100, 100, 100, 0.3);
        }
        #close-water-catcher {
            background: rgba(255, 0, 0, 0.8);
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
        }
        #close-water-catcher:hover {
            background: rgba(255, 0, 0, 1);
            transform: scale(1.1);
        }
        
        #inventory-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        #storage-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 6px;
            padding: 16px;
            overflow: visible;
        }
        
        #inventory-grid::-webkit-scrollbar, #storage-grid::-webkit-scrollbar {
            width: 8px;
        }
        
        #inventory-grid::-webkit-scrollbar-track, #storage-grid::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        
        #inventory-grid::-webkit-scrollbar-thumb, #storage-grid::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }
        
        .inventory-slot {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.03));
            border: 2px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: grab;
            transition: all 0.2s ease;
        }
        
        .inventory-slot:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.08));
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
        }
        
        .inventory-slot.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        
        .inventory-slot.drag-over {
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.3), rgba(39, 174, 96, 0.3));
            border-color: #2ecc71;
        }
        
        .inventory-slot-icon {
            font-size: 32px;
            margin-bottom: 5px;
        }
        
        .inventory-slot-name {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.9);
            text-align: center;
            font-weight: 500;
        }
        
        .inventory-slot-count {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .inventory-slot-empty {
            color: rgba(255, 255, 255, 0.2);
            font-size: 24px;
        }
        
        /* Clothing/Armor Panel */
        #clothing-panel {
            width: 240px;
            padding: 20px;
            border-right: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        #clothing-panel h3 {
            text-align: center;
            color: #3498db;
            font-size: 14px;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }
        
        #armor-slots-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .armor-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .armor-label {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            min-width: 50px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .armor-slot {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.03));
            border: 2px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .armor-slot:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.08));
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
        }
        
        .armor-slot.equipped {
            border-color: #2ecc71;
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.2), rgba(39, 174, 96, 0.15));
        }
        
        .armor-slot-icon {
            font-size: 28px;
            opacity: 0.4;
        }
        
        .armor-slot.equipped .armor-slot-icon {
            opacity: 1;
        }
        
        #inventory-grid-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        #admin-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(10, 10, 30, 0.98), rgba(20, 20, 40, 0.98));
            color: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 800px;
            max-height: 85vh;
            overflow-y: auto;
            pointer-events: auto;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.8);
            z-index: 3000;
        }
        
        #admin-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        #admin-content {
            padding: 10px 0;
        }
        
        .admin-section h3 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #3498db;
        }
        
        #admin-items-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }
        
        .admin-item {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .admin-item:hover {
            background: rgba(52, 152, 219, 0.2);
            border-color: rgba(52, 152, 219, 0.5);
            transform: scale(1.05);
        }
        
        .admin-item-icon {
            font-size: 32px;
            margin-bottom: 8px;
        }
        
        .admin-item-name {
            font-size: 12px;
            font-weight: bold;
        }
        
        #pause-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 4000;
            pointer-events: auto;
        }
        
        #pause-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .pause-button {
            padding: 20px 60px;
            font-size: 20px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 8px 30px rgba(52, 152, 219, 0.3);
        }
        
        .pause-button:hover {
            background: linear-gradient(135deg, #2980b9, #21618c);
            transform: scale(1.05) translateY(-5px);
            box-shadow: 0 12px 40px rgba(52, 152, 219, 0.5);
        }
        
        #save-status {
            text-align: center;
            font-weight: bold;
        }

        /* ===== RESPONSIVE UI SCALING ===== */
        :root {
            --ui-scale: 1;
            --hotbar-slot: 70px;
            --inv-width: 850px;
        }
        @media (max-width: 1400px) {
            :root { --ui-scale: 0.88; --hotbar-slot: 62px; --inv-width: 748px; }
        }
        @media (max-width: 1100px) {
            :root { --ui-scale: 0.76; --hotbar-slot: 54px; --inv-width: 646px; }
        }
        @media (max-width: 800px) {
            :root { --ui-scale: 0.62; --hotbar-slot: 46px; --inv-width: 527px; }
        }
        @media (max-width: 550px) {
            :root { --ui-scale: 0.50; --hotbar-slot: 40px; --inv-width: 425px; }
        }
        #ui {
            transform-origin: top left;
            transform: scale(var(--ui-scale));
        }
        #hotbar {
            transform-origin: bottom center;
            transform: translateX(-50%) scale(var(--ui-scale));
        }
        .hotbar-slot {
            width: var(--hotbar-slot) !important;
            height: var(--hotbar-slot) !important;
        }
        /* inventory-panel sizing handled by clamp() in base rule above */
        #ammo-counter {
            transform-origin: bottom right;
            transform: scale(var(--ui-scale));
        }
        /* Edge-drag handles */
        #inventory-panel .drag-edge {
            position: absolute;
            z-index: 10;
            cursor: move;
        }
        #inventory-panel .drag-edge.top    { top: 0;    left: 8px;  right: 8px;  height: 8px; }
        #inventory-panel .drag-edge.bottom { bottom: 0; left: 8px;  right: 8px;  height: 8px; }
        #inventory-panel .drag-edge.left   { left: 0;   top: 8px;   bottom: 8px; width: 8px; }
        #inventory-panel .drag-edge.right  { right: 0;  top: 8px;   bottom: 8px; width: 8px; }
        #inventory-panel .drag-edge.corner { width: 12px; height: 12px; }
        #inventory-panel .drag-edge.tl { top: 0; left: 0; }
        #inventory-panel .drag-edge.tr { top: 0; right: 0; }
        #inventory-panel .drag-edge.bl { bottom: 0; left: 0; }
        #inventory-panel .drag-edge.br { bottom: 0; right: 0; }

    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-title" id="loading-title-text">CRUST</div>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
        <div id="loading-status" style="color:rgba(255,255,255,0.6);font-size:13px;margin-top:16px;letter-spacing:1px;">Loading 3D engine...</div>
    </div>

    <div id="ui">
        <div class="stat-container">
            <div class="stat-label">Health</div>
            <div class="stat-bar">
                <div class="stat-fill health-bar" id="health-bar"></div>
                <div class="stat-text" id="health-text">100 / 100</div>
            </div>
        </div>
        <div class="stat-container">
            <div class="stat-label">Hunger</div>
            <div class="stat-bar">
                <div class="stat-fill hunger-bar" id="hunger-bar"></div>
                <div class="stat-text" id="hunger-text">100 / 100</div>
            </div>
        </div>
        <div class="stat-container">
            <div class="stat-label">Thirst</div>
            <div class="stat-bar">
                <div class="stat-fill thirst-bar" id="thirst-bar"></div>
                <div class="stat-text" id="thirst-text">100 / 100</div>
            </div>
        </div>
        <div class="stat-container">
            <div class="stat-label">Stamina</div>
            <div class="stat-bar">
                <div class="stat-fill stamina-bar" id="stamina-bar"></div>
                <div class="stat-text" id="stamina-text">100 / 100</div>
            </div>
        </div>
        <div style="margin-top: 20px; font-size: 14px; opacity: 0.9;">
            <div>Day: <span id="day">1</span></div>
        </div>
    </div>

    <div class="time-display">
        <span id="time"> 06:00</span>
    </div>

    <canvas id="minimap"></canvas>
    
    <div id="crosshair"></div>
    
    <div id="pistol-crosshair" style="display: none;"></div>
    
    <div id="ammo-counter" style="display: none;"></div>
    <div id="buff-hud"></div>
    
    <div id="instructions" style="display: none;">
        <strong> REMASTERED CONTROLS</strong><br>
        WASD: Move | Shift: Sprint | Space: Jump | Mouse: Look | Wheel: Switch Items | Left Click: Gather/Attack/Place | Right Click: Remove Building (with ) | E: Use/Open | R: Reload/Rotate | TAB: Inventory | C: Craft | F: Flashlight | P: Pause<br>
        <strong> Camera:</strong> P: Toggle Third-Person<br>
            <strong> Building:</strong> G: Toggle Snapping (ON by default) | Snapping auto-aligns walls/floors like Rust! Walls snap to walls & floor edges, floors snap to floors, stairs snap to floor edges<br>
        <strong> Pistol:</strong> Craft at Workbench (20 ingots) | R to reload | 8 shots per clip<br>
        <strong> Sleeping Bag:</strong> Press E to set spawn point!<br>
        <strong> Ladder:</strong> Climb with E, descend with S | Stacks vertically for multi-story access<br>
        <button id="close-controls" style="margin-top: 10px; background: rgba(231, 76, 60, 0.9); border: none; color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: bold;">Close</button>
    </div>
    
    <div id="message"></div>
    <div id="build-info"></div>
    
    <div id="hotbar-tooltip"></div>
    <div id="hotbar"></div>
    
    <div id="inventory-panel" style="display: none;">
        <div class="drag-edge top"></div>
        <div class="drag-edge bottom"></div>
        <div class="drag-edge left"></div>
        <div class="drag-edge right"></div>
        <div class="drag-edge corner tl"></div>
        <div class="drag-edge corner tr"></div>
        <div class="drag-edge corner bl"></div>
        <div class="drag-edge corner br"></div>
        <div id="inventory-header">
            <span style="font-weight: bold; font-size: 18px;"> INVENTORY</span>
            <button id="close-inventory" style="background: rgba(255,0,0,0.8); border: none; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-weight: bold;"></button>
        </div>
        <div id="inventory-content">
            <div id="clothing-panel">
                <h3> ARMOR</h3>
                <div id="armor-slots-container">
                    <div class="armor-row">
                        <div class="armor-label">Head</div>
                        <div class="armor-slot" id="armor-head" data-slot="head" title="Helmet">
                            <div class="armor-slot-icon"></div>
                        </div>
                    </div>
                    <div class="armor-row">
                        <div class="armor-label">Chest</div>
                        <div class="armor-slot" id="armor-chest" data-slot="chest" title="Chest Armor">
                            <div class="armor-slot-icon"></div>
                        </div>
                    </div>
                    <div class="armor-row">
                        <div class="armor-label">Hands</div>
                        <div class="armor-slot" id="armor-hands" data-slot="hands" title="Gloves">
                            <div class="armor-slot-icon"></div>
                        </div>
                    </div>
                    <div class="armor-row">
                        <div class="armor-label">Legs</div>
                        <div class="armor-slot" id="armor-legs" data-slot="legs" title="Leg Armor">
                            <div class="armor-slot-icon"></div>
                        </div>
                    </div>
                    <div class="armor-row">
                        <div class="armor-label">Feet</div>
                        <div class="armor-slot" id="armor-feet" data-slot="feet" title="Boots">
                            <div class="armor-slot-icon"></div>
                        </div>
                    </div>
                </div>
                <div id="damage-reduction-display" style="margin-top: 15px; padding: 10px; background: linear-gradient(135deg, rgba(46, 204, 113, 0.15), rgba(39, 174, 96, 0.1)); border: 2px solid rgba(46, 204, 113, 0.3); border-radius: 8px; text-align: center;">
                    <div style="font-size: 11px; color: rgba(255,255,255,0.7); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 5px;">Damage Reduction</div>
                    <div id="damage-reduction-value" style="font-size: 24px; font-weight: bold; color: #2ecc71;">0%</div>
                </div>
                <div style="text-align: center; font-size: 10px; color: rgba(255,255,255,0.5); margin-top: 15px; line-height: 1.4;">
                    Double-click to equip<br>Click to remove
                </div>
            </div>
            <div id="inventory-grid-container">
                <div id="inventory-grid"></div>
            </div>
        </div>
    </div>
    
    <div id="storage-panel" style="display: none;">
        <div id="storage-header">
            <span style="font-weight: bold; font-size: 18px;"> STORAGE BOX</span>
            <button id="close-storage" style="background: rgba(255,0,0,0.8); border: none; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-weight: bold;"></button>
        </div>
        <div id="storage-grid"></div>
    </div>

    <!-- PLANTER BOX UI -->
    <div id="planter-panel" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:linear-gradient(135deg,rgba(20,40,20,0.97),rgba(10,30,10,0.95)); border:2px solid rgba(80,180,80,0.35); border-radius:14px; padding:22px 28px; z-index:5000; min-width:380px; max-width:520px; box-shadow:0 8px 32px rgba(0,0,0,0.6); font-family:'Segoe UI',sans-serif; color:white; backdrop-filter:blur(10px);">
        <div id="planter-header" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px; cursor:move; user-select:none;">
            <span id="planter-title" style="font-weight:bold; font-size:18px;"> Planter Box</span>
            <button id="close-planter" style="background:rgba(255,0,0,0.8); border:none; color:white; padding:5px 10px; border-radius:4px; cursor:pointer; font-weight:bold;"></button>
        </div>
        <div style="font-size:12px; color:rgba(255,255,255,0.55); margin-bottom:14px; letter-spacing:0.5px;">Place seeds in slots. Rain waters them and starts growth. Press E or click grown slot to harvest.</div>
        <div id="planter-slots" style="display:grid; grid-template-columns:repeat(4,1fr); gap:8px; margin-bottom:16px;"></div>
        <div id="planter-status" style="font-size:13px; color:rgba(180,255,140,0.85); min-height:18px; text-align:center;"></div>
    </div>

    <div id="backpack-panel">
        <div id="backpack-header">
            <span style="font-weight: bold; font-size: 18px;"> DEATH BACKPACK</span>
            <button id="close-backpack" style="background: rgba(255,0,0,0.8); border: none; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-weight: bold;"></button>
        </div>
        <div id="backpack-grid"></div>
    </div>
    
    <div id="crafting-menu">
        <div class="menu-title"> Crafting</div>
        <div id="crafting-list"></div>
        <button class="menu-button" onclick="toggleCraftingMenu()">Close (C)</button>
    </div>
    
    <div id="workbench-menu">
        <div class="menu-title"> Workbench</div>
        <div id="workbench-list"></div>
        <button class="menu-button" onclick="closeAllUI()">Close (ESC)</button>
    </div>
    
    <div id="furnace-menu" style="display: none;">
        <div id="furnace-header">
            <span style="font-weight: bold; font-size: 18px;"> FURNACE</span>
            <button id="close-furnace" style="background: rgba(255,0,0,0.8); border: none; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-weight: bold;"></button>
        </div>
        <div id="furnace-content">
            <div class="smelting-slot-container" style="grid-column: 1 / -1;">
                <div class="smelting-label">Ore Input Slots (drag ores here)</div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <div class="smelting-slot furnace-input-slot" id="furnace-input-slot-0" data-slot-type="furnace-input" data-slot-index="0"></div>
                    <div class="smelting-slot furnace-input-slot" id="furnace-input-slot-1" data-slot-type="furnace-input" data-slot-index="1"></div>
                    <div class="smelting-slot furnace-input-slot" id="furnace-input-slot-2" data-slot-type="furnace-input" data-slot-index="2"></div>
                </div>
            </div>
            <div class="smelting-slot-container">
                <div class="smelting-label">Fuel (Wood/Sticks)</div>
                <div class="smelting-slot" id="furnace-fuel-slot"></div>
            </div>
            <div class="smelting-progress-container" style="grid-column: unset;">
                <div class="smelting-label" id="furnace-active-label" style="font-size:11px; color:#ffaa00; margin-bottom:4px;"></div>
                <div class="smelting-progress-bar">
                    <div class="smelting-progress-fill" id="furnace-progress"></div>
                </div>
                <div class="smelting-progress-text" id="furnace-progress-text">0%</div>
            </div>
            <div class="smelting-slot-container">
                <div class="smelting-label">Output 1 (Iron Ingot)</div>
                <div class="smelting-slot output-slot" id="furnace-output-slot-0"></div>
            </div>
            <div class="smelting-slot-container">
                <div class="smelting-label">Output 2 (Smelted Sulfur)</div>
                <div class="smelting-slot output-slot" id="furnace-output-slot-1"></div>
            </div>
            <div class="smelting-slot-container" style="grid-column: 1 / -1; align-items: center;">
                <div class="smelting-label">Waste (Coal)</div>
                <div class="smelting-slot output-slot" id="furnace-waste-slot" style="width:60px;height:60px;font-size:28px;"></div>
            </div>
        </div>
    </div>
    
    <div id="campfire-menu" style="display: none;">
        <div id="campfire-header">
            <span style="font-weight: bold; font-size: 18px;"> CAMPFIRE</span>
            <button id="close-campfire" style="background: rgba(255,0,0,0.8); border: none; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-weight: bold;"></button>
        </div>
        <div id="campfire-content">
            <div class="smelting-slot-container">
                <div class="smelting-label">Raw Meat (drag food here)</div>
                <div class="smelting-slot" id="campfire-input-slot" data-slot-type="campfire-input" data-slot-index="0"></div>
            </div>
            <div class="smelting-slot-container">
                <div class="smelting-label">Fuel (Wood/Sticks)</div>
                <div class="smelting-slot" id="campfire-fuel-slot"></div>
            </div>
            <div class="smelting-progress-container">
                <div class="smelting-progress-bar">
                    <div class="smelting-progress-fill" id="campfire-progress"></div>
                </div>
                <div class="smelting-progress-text" id="campfire-progress-text">0%</div>
            </div>
            <div class="smelting-slot-container">
                <div class="smelting-label">Cooked Meat</div>
                <div class="smelting-slot output-slot" id="campfire-output-slot"></div>
            </div>
            <div class="smelting-slot-container">
                <div class="smelting-label">Waste (Ash)</div>
                <div class="smelting-slot output-slot" id="campfire-waste-slot"></div>
            </div>
        </div>
    </div>
    
    <div id="cooking-station-menu" style="display: none;">
        <div id="cooking-station-header">
            <span style="font-weight: bold; font-size: 18px;"> COOKING STATION</span>
            <button id="close-cooking-station"></button>
        </div>
        <div id="cooking-station-content">
            <!-- Recipe book -->
            <div id="cs-recipe-book">
                <div class="cs-recipe-book-title"> Recipes (click to auto-fill)</div>
                <div id="cs-recipe-list"></div>
            </div>
            <!-- 5 ingredient slots -->
            <div>
                <div class="cs-label" style="margin-bottom:8px; text-align:center;">Ingredients (drag from inventory or click recipe)</div>
                <div class="cs-ingredient-grid">
                    <div class="cs-slot-container">
                        <div class="cs-slot" id="cs-input-0" data-cs-slot="input" data-cs-index="0">+</div>
                    </div>
                    <div class="cs-slot-container">
                        <div class="cs-slot" id="cs-input-1" data-cs-slot="input" data-cs-index="1">+</div>
                    </div>
                    <div class="cs-slot-container">
                        <div class="cs-slot" id="cs-input-2" data-cs-slot="input" data-cs-index="2">+</div>
                    </div>
                    <div class="cs-slot-container">
                        <div class="cs-slot" id="cs-input-3" data-cs-slot="input" data-cs-index="3">+</div>
                    </div>
                    <div class="cs-slot-container">
                        <div class="cs-slot" id="cs-input-4" data-cs-slot="input" data-cs-index="4">+</div>
                    </div>
                </div>
            </div>
            <!-- Recipe hint -->
            <div id="cs-recipe-hint">Place ingredients to see recipe...</div>
            <!-- Cook button -->
            <button id="cs-cook-btn" disabled> COOK (20s)</button>
            <!-- Progress bar -->
            <div class="smelting-progress-container" style="margin:0;">
                <div class="smelting-progress-bar">
                    <div class="smelting-progress-fill" id="cs-progress" style="width:0%"></div>
                </div>
                <div class="smelting-progress-text" id="cs-progress-text">0%</div>
            </div>
            <!-- Output -->
            <div class="cs-row" style="justify-content:center; gap:40px; align-items:flex-end;">
                <div class="cs-slot-container">
                    <div class="cs-label">Result (click to collect)</div>
                    <div class="cs-slot cs-output" id="cs-output-slot"></div>
                </div>
                <div class="cs-slot-container">
                    <div class="cs-label">Ash (click to collect)</div>
                    <div class="cs-slot cs-waste" id="cs-waste-slot"></div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="recycler-menu" style="display: none;">
        <div id="recycler-header">
            <span style="font-weight: bold; font-size: 18px;"> RECYCLER</span>
            <button id="close-recycler"></button>
        </div>
        <div id="recycler-content">
            <div class="recycler-section">
                <div class="recycler-label">Input Slots</div>
                <div style="font-size: 11px; color: rgba(255,255,255,0.6); margin-bottom: 5px; text-align: center;">Double-click items in your inventory to add them</div>
                <div class="recycler-slots-container">
                    <div class="recycler-slot" data-slot="input" data-index="0"></div>
                    <div class="recycler-slot" data-slot="input" data-index="1"></div>
                    <div class="recycler-slot" data-slot="input" data-index="2"></div>
                    <div class="recycler-slot" data-slot="input" data-index="3"></div>
                    <div class="recycler-slot" data-slot="input" data-index="4"></div>
                </div>
            </div>
            
            <div class="recycler-controls">
                <button id="recycler-start-btn"> START RECYCLING</button>
            </div>
            
            <div class="recycler-progress-container">
                <div class="recycler-progress-bar">
                    <div class="recycler-progress-fill" id="recycler-progress"></div>
                </div>
                <div class="recycler-progress-text" id="recycler-progress-text">0%</div>
            </div>
            
            <div class="recycler-section">
                <div class="recycler-label">Output Slots</div>
                <div style="font-size: 11px; color: rgba(255,255,255,0.6); margin-bottom: 5px; text-align: center;">Click to collect recycled materials</div>
                <div class="recycler-slots-container">
                    <div class="recycler-slot" data-slot="output" data-index="0"></div>
                    <div class="recycler-slot" data-slot="output" data-index="1"></div>
                    <div class="recycler-slot" data-slot="output" data-index="2"></div>
                    <div class="recycler-slot" data-slot="output" data-index="3"></div>
                    <div class="recycler-slot" data-slot="output" data-index="4"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Well Menu -->
    <div id="water-catcher-menu" style="display: none;">
        <div id="water-catcher-header">
            <span style="font-weight: bold; font-size: 18px;"> WELL</span>
            <button id="close-water-catcher"></button>
        </div>
        <div id="water-catcher-content">
            <div id="wc-rain-status" class="wc-rain-status wc-rain-inactive"> Not raining  waiting for rain...</div>
            <div class="wc-label">Filling Progress</div>
            <div class="wc-progress-container">
                <div class="wc-progress-bar">
                    <div class="wc-progress-fill" id="wc-progress-fill" style="width:0%"></div>
                </div>
            </div>
            <div class="wc-progress-text" id="wc-progress-text">Waiting for rain...</div>
            <div class="wc-label" style="margin-top:15px;">Water Bottles (drag to inventory)</div>
            <div class="wc-slots-container" id="wc-output-slots">
                <div class="wc-slot" data-wc-slot="0" draggable="true"></div>
                <div class="wc-slot" data-wc-slot="1" draggable="true"></div>
                <div class="wc-slot" data-wc-slot="2" draggable="true"></div>
                <div class="wc-slot" data-wc-slot="3" draggable="true"></div>
                <div class="wc-slot" data-wc-slot="4" draggable="true"></div>
            </div>
        </div>
    </div>
    
    <div id="death-screen">
        <h1> YOU DIED </h1>
        <p>You survived <span id="survival-time">0</span> days</p>
        <button id="respawn-button" onclick="respawn()">Respawn</button>
    </div>
    
    <div id="admin-menu" style="display: none;">
        <div id="admin-header">
            <span style="font-weight: bold; font-size: 20px;"> ADMIN MENU</span>
            <button id="close-admin" style="background: rgba(255,0,0,0.8); border: none; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-weight: bold;"></button>
        </div>
        <div id="admin-content">
            <div class="admin-section">
                <h3>Add Items</h3>
                <div id="admin-items-grid"></div>
            </div>
            <div class="admin-section" style="margin-top: 20px;">
                <h3>\ud83d\udee0\ufe0f Developer Tools</h3>
                <button id="sync-icon-fallbacks" style="width: 100%; padding: 12px; margin-bottom: 10px; background: linear-gradient(135deg, #27ae60, #2ecc71); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 15px; font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.3);">\ud83d\udee1\ufe0f Sync Icon Fallbacks</button>
                <div id="icon-sync-output" style="display:none; margin-top: 8px; background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.15); border-radius: 6px; padding: 10px;">
                    <div style="font-size: 12px; color: #aaa; margin-bottom: 6px;">Copy the lines below into <code>_iconFallbacks</code>:</div>
                    <textarea id="icon-sync-text" readonly style="width:100%; height: 120px; background: transparent; border: none; color: #2ecc71; font-family: monospace; font-size: 11px; resize: vertical; outline: none;"></textarea>
                    <button id="icon-sync-copy" style="margin-top: 6px; padding: 6px 14px; background: rgba(52,152,219,0.8); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">\ud83d\udccb Copy to Clipboard</button>
                </div>
            </div>
            <div class="admin-section" style="margin-top: 20px;">
                <h3>Environment Controls</h3>
                <button id="set-day" style="width: 100%; padding: 12px; margin-bottom: 10px; background: linear-gradient(135deg, #f39c12, #e67e22); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.3);"> Set Day (Noon)</button>
                <button id="set-night" style="width: 100%; padding: 12px; margin-bottom: 10px; background: linear-gradient(135deg, #34495e, #2c3e50); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.3);"> Set Night (Midnight)</button>
                <button id="freeze-time" style="width: 100%; padding: 12px; margin-bottom: 10px; background: linear-gradient(135deg, #9b59b6, #8e44ad); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.3);"> Freeze Time</button>
                <button id="toggle-rain" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #3498db, #2980b9); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.3);"> Toggle Rain</button>
            </div>
        </div>
    </div>
    
    <div id="pause-menu" style="display: none;">
        <div id="pause-header">
            <h1 style="font-size: 48px; margin-bottom: 30px; text-shadow: 0 0 20px rgba(52, 152, 219, 0.5);"> PAUSED</h1>
        </div>
        <div id="pause-content">
            <button class="pause-button" id="resume-button"> Resume</button>
            <button class="pause-button" id="save-button"> Save Game</button>
            <button class="pause-button" id="load-button"> Load Game</button>
            <button class="pause-button" id="controls-button"> Controls</button>
            <button class="pause-button" id="settings-button"> Settings</button>
        </div>
        <div id="save-status" style="margin-top: 20px; color: #2ecc71; font-size: 14px;"></div>
    </div>
    
    <div id="settings-menu" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 40, 0.95)); padding: 40px; border-radius: 20px; border: 2px solid rgba(52, 152, 219, 0.5); box-shadow: 0 0 50px rgba(0, 0, 0, 0.8); z-index: 10000; min-width: 500px;">
        <h2 style="color: white; margin-bottom: 30px; text-align: center; font-size: 32px;"> Audio Settings</h2>
        
        <div style="margin-bottom: 25px;">
            <label style="color: white; display: block; margin-bottom: 10px; font-size: 18px;"> Forest Ambience</label>
            <input type="range" id="forest-volume" min="0" max="100" value="30" style="width: 100%; height: 8px; border-radius: 5px; background: #444; outline: none; cursor: pointer;">
            <div style="color: #3498db; font-size: 14px; margin-top: 5px;" id="forest-value">30%</div>
        </div>
        
        <div style="margin-bottom: 25px;">
            <label style="color: white; display: block; margin-bottom: 10px; font-size: 18px;"> Wind</label>
            <input type="range" id="wind-volume" min="0" max="100" value="10" style="width: 100%; height: 8px; border-radius: 5px; background: #444; outline: none; cursor: pointer;">
            <div style="color: #3498db; font-size: 14px; margin-top: 5px;" id="wind-value">10%</div>
        </div>
        
        <div style="margin-bottom: 25px;">
            <label style="color: white; display: block; margin-bottom: 10px; font-size: 18px;"> Animal Sounds</label>
            <input type="range" id="animal-volume" min="0" max="100" value="50" style="width: 100%; height: 8px; border-radius: 5px; background: #444; outline: none; cursor: pointer;">
            <div style="color: #3498db; font-size: 14px; margin-top: 5px;" id="animal-value">50%</div>
        </div>
        
        <div style="margin-bottom: 25px;">
            <label style="color: white; display: block; margin-bottom: 10px; font-size: 18px;"> Enemy Sounds</label>
            <input type="range" id="enemy-volume" min="0" max="100" value="50" style="width: 100%; height: 8px; border-radius: 5px; background: #444; outline: none; cursor: pointer;">
            <div style="color: #3498db; font-size: 14px; margin-top: 5px;" id="enemy-value">50%</div>
        </div>
        
        <div style="margin-bottom: 25px;">
            <label style="color: white; display: block; margin-bottom: 10px; font-size: 18px;"> Footstep Sounds</label>
            <input type="range" id="footstep-volume" min="0" max="100" value="50" style="width: 100%; height: 8px; border-radius: 5px; background: #444; outline: none; cursor: pointer;">
            <div style="color: #3498db; font-size: 14px; margin-top: 5px;" id="footstep-value">50%</div>
        </div>
        
        <div style="margin-bottom: 25px;">
            <label style="color: white; display: block; margin-bottom: 10px; font-size: 18px;"> Rain</label>
            <input type="range" id="rain-volume" min="0" max="100" value="50" style="width: 100%; height: 8px; border-radius: 5px; background: #444; outline: none; cursor: pointer;">
            <div style="color: #3498db; font-size: 14px; margin-top: 5px;" id="rain-value">50%</div>
        </div>
        
        <button id="close-settings" style="width: 100%; padding: 15px; font-size: 18px; background: linear-gradient(135deg, #3498db, #2980b9); color: white; border: none; border-radius: 10px; cursor: pointer; margin-top: 20px; font-weight: bold; box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);"> Done</button>
    </div>
    
    <!-- Code Lock UI -->
    <div id="code-lock-menu" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(20, 30, 40, 0.98), rgba(10, 20, 30, 0.98)); padding: 40px; border-radius: 20px; border: 3px solid rgba(52, 152, 219, 0.6); box-shadow: 0 0 60px rgba(0, 0, 0, 0.9); z-index: 10001; min-width: 400px;">
        <h2 id="code-lock-title" style="color: white; margin-bottom: 20px; text-align: center; font-size: 28px;"> Set Door Code</h2>
        
        <!-- Status Light -->
        <div style="text-align: center; margin-bottom: 20px;">
            <div id="code-lock-light" style="width: 60px; height: 60px; border-radius: 50%; margin: 0 auto; background: #2ecc71; box-shadow: 0 0 30px rgba(46, 204, 113, 0.8); transition: all 0.3s ease;"></div>
        </div>
        
        <!-- Code Display -->
        <div style="background: rgba(0, 0, 0, 0.6); padding: 20px; border-radius: 10px; margin-bottom: 20px; text-align: center;">
            <div id="code-display" style="font-size: 36px; color: #3498db; letter-spacing: 10px; font-family: 'Courier New', monospace; min-height: 50px;">----</div>
        </div>
        
        <!-- Number Pad -->
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 20px;">
            <button class="code-btn" data-num="1" style="padding: 20px; font-size: 24px; background: linear-gradient(135deg, #34495e, #2c3e50); color: white; border: 2px solid rgba(52, 152, 219, 0.4); border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.2s;">1</button>
            <button class="code-btn" data-num="2" style="padding: 20px; font-size: 24px; background: linear-gradient(135deg, #34495e, #2c3e50); color: white; border: 2px solid rgba(52, 152, 219, 0.4); border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.2s;">2</button>
            <button class="code-btn" data-num="3" style="padding: 20px; font-size: 24px; background: linear-gradient(135deg, #34495e, #2c3e50); color: white; border: 2px solid rgba(52, 152, 219, 0.4); border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.2s;">3</button>
            <button class="code-btn" data-num="4" style="padding: 20px; font-size: 24px; background: linear-gradient(135deg, #34495e, #2c3e50); color: white; border: 2px solid rgba(52, 152, 219, 0.4); border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.2s;">4</button>
            <button class="code-btn" data-num="5" style="padding: 20px; font-size: 24px; background: linear-gradient(135deg, #34495e, #2c3e50); color: white; border: 2px solid rgba(52, 152, 219, 0.4); border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.2s;">5</button>
            <button class="code-btn" data-num="6" style="padding: 20px; font-size: 24px; background: linear-gradient(135deg, #34495e, #2c3e50); color: white; border: 2px solid rgba(52, 152, 219, 0.4); border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.2s;">6</button>
            <button class="code-btn" data-num="7" style="padding: 20px; font-size: 24px; background: linear-gradient(135deg, #34495e, #2c3e50); color: white; border: 2px solid rgba(52, 152, 219, 0.4); border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.2s;">7</button>
            <button class="code-btn" data-num="8" style="padding: 20px; font-size: 24px; background: linear-gradient(135deg, #34495e, #2c3e50); color: white; border: 2px solid rgba(52, 152, 219, 0.4); border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.2s;">8</button>
            <button class="code-btn" data-num="9" style="padding: 20px; font-size: 24px; background: linear-gradient(135deg, #34495e, #2c3e50); color: white; border: 2px solid rgba(52, 152, 219, 0.4); border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.2s;">9</button>
            <button id="code-clear" style="padding: 20px; font-size: 20px; background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; border: 2px solid rgba(231, 76, 60, 0.4); border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.2s;">CLR</button>
            <button class="code-btn" data-num="0" style="padding: 20px; font-size: 24px; background: linear-gradient(135deg, #34495e, #2c3e50); color: white; border: 2px solid rgba(52, 152, 219, 0.4); border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.2s;">0</button>
            <button id="code-enter" style="padding: 20px; font-size: 20px; background: linear-gradient(135deg, #2ecc71, #27ae60); color: white; border: 2px solid rgba(46, 204, 113, 0.4); border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.2s;">ENT</button>
        </div>
        
        <button id="code-cancel" style="width: 100%; padding: 15px; font-size: 18px; background: linear-gradient(135deg, #95a5a6, #7f8c8d); color: white; border: none; border-radius: 10px; cursor: pointer; font-weight: bold; box-shadow: 0 4px 15px rgba(127, 140, 141, 0.4);">Cancel</button>
    </div>

    <script>
        (function() {
            const cdns = [
                'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js',
                'https://unpkg.com/three@0.128.0/build/three.min.js',
                'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js'
            ];

            const statusEl = () => document.getElementById('loading-status');
            const progressEl = () => document.getElementById('loadingProgress');
            let gameStarted = false;

            // Animate progress bar 0-8% while waiting for THREE.js CDN
            let fakeProgress = 0;
            const progressInterval = setInterval(() => {
                fakeProgress = Math.min(fakeProgress + (7 - fakeProgress) * 0.05, 7);
                const p = progressEl();
                if (p) p.style.width = fakeProgress + '%';
            }, 100);

            function onThreeLoaded() {
                if (gameStarted) return;
                gameStarted = true;
                clearInterval(progressInterval);
                if (statusEl()) statusEl().textContent = 'Loading models...';

                // Load GLTFLoader AFTER Three.js is confirmed ready, then start game
                window._gltfLoaderReady = false;
                window._gltfLoaderPromise = new Promise(resolve => {
                    const gltfUrls = [
                        'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js',
                        'https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js'
                    ];
                    function tryGLTF(i) {
                        if (i >= gltfUrls.length) { console.warn('GLTFLoader failed all CDNs'); resolve(false); return; }
                        const gs = document.createElement('script');
                        gs.src = gltfUrls[i];
                        gs.onload = () => { window._gltfLoaderReady = true; console.log('GLTFLoader ready'); resolve(true); };
                        gs.onerror = () => tryGLTF(i + 1);
                        document.head.appendChild(gs);
                    }
                    tryGLTF(0);
                });

                // Also load DRACOLoader for Draco-compressed GLBs.
                // _dracoLoaderPromise resolves when the script is ready.
                // _glbLoadersReady() waits for both this AND GLTFLoader before any parse.
                const dracoScript = document.createElement('script');
                dracoScript.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js';
                window._dracoLoaderPromise = new Promise(res => {
                    dracoScript.onload  = () => {
                        // Invalidate shared loader so next _getGLTFLoader() attaches Draco
                        if (window._sharedGLTFLoader) { window._sharedGLTFLoader = null; }
                        console.log('DRACOLoader ready');
                        res(true);
                    };
                    dracoScript.onerror = () => { console.warn('DRACOLoader failed to load'); res(false); };
                });
                document.head.appendChild(dracoScript);

                window._gltfLoaderPromise.then(() => {
                    if (statusEl()) statusEl().textContent = 'Initializing...';
                    try {
                        if (typeof startGame === 'function') startGame();
                    } catch(e) {
                        const el = document.getElementById('loading-status');
                        if (el) el.textContent = '\u274c ' + e.message;
                        console.error('startGame crashed:', e);
                        setTimeout(() => {
                            const ls = document.getElementById('loadingScreen');
                            if (ls) ls.classList.add('hidden');
                        }, 2000);
                    }
                });
            }

            function showError() {
                clearInterval(progressInterval);
                const title = document.getElementById('loading-title-text');
                const bar = document.querySelector('.loading-bar');
                const s = statusEl();
                if (title) {
                    title.style.fontSize = '26px';
                    title.textContent = 'CRUST';
                }
                if (bar) bar.style.display = 'none';
                if (s) {
                    s.style.fontSize = '14px';
                    s.style.lineHeight = '1.8';
                    s.style.color = 'rgba(255,255,255,0.8)';
                    s.innerHTML = '\u26a0\ufe0f Network access required for the 3D engine.<br>Please <b>download</b> the file and open it in Chrome, Firefox, or Edge.';
                }
            }

            function tryLoad(idx) {
                if (idx >= cdns.length) { showError(); return; }
                if (statusEl()) statusEl().textContent = 'Loading 3D engine... (attempt ' + (idx+1) + '/' + cdns.length + ')';

                // Try script tag
                const s = document.createElement('script');
                s.src = cdns[idx];
                s.onload = onThreeLoaded;
                s.onerror = function() {
                    // Try fetch+blob as fallback
                    fetch(cdns[idx])
                        .then(r => { if (!r.ok) throw 0; return r.text(); })
                        .then(code => {
                            const url = URL.createObjectURL(new Blob([code], {type:'application/javascript'}));
                            const s2 = document.createElement('script');
                            s2.src = url;
                            s2.onload = () => { URL.revokeObjectURL(url); onThreeLoaded(); };
                            s2.onerror = () => { URL.revokeObjectURL(url); tryLoad(idx + 1); };
                            document.head.appendChild(s2);
                        })
                        .catch(() => tryLoad(idx + 1));
                };
                document.head.appendChild(s);
            }

            tryLoad(0);
        })();
    </script>
    <!-- GLTFLoader is now loaded inside onThreeLoaded, after THREE.js is ready -->
    <script>
        window.onerror = function(msg, src, line, col, err) {
            const el = document.getElementById('loading-status');
            if (el) el.textContent = '\u274c ' + msg + ' (line ' + line + ')';
            console.error('Game error:', msg, 'line:', line, err);
            // Dismiss loading screen after a moment so error is visible
            setTimeout(() => {
                const ls = document.getElementById('loadingScreen');
                if (ls) ls.classList.add('hidden');
            }, 3000);
        };
        function startGame() {
        // ===== TEXTURE CACHE SYSTEM (IndexedDB) =====
        const TEXTURE_CACHE_VERSION = 2;
        const TEXTURE_DB_NAME = 'CrustTextureCache';
        const TEXTURE_STORE_NAME = 'textures';

        class TextureCache {
            constructor() {
                this.db = null;
                this.ready = false;
                this.cacheStats = { hits: 0, misses: 0, generated: 0 };
            }
            
            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(TEXTURE_DB_NAME, TEXTURE_CACHE_VERSION);
                    
                    request.onerror = () => {
                        console.warn('\u26a0\ufe0f IndexedDB not available, caching disabled');
                        resolve();
                    };
                    
                    request.onsuccess = () => {
                        this.db = request.result;
                        this.ready = true;
                        console.log('\u2705 Texture cache initialized');
                        resolve();
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(TEXTURE_STORE_NAME)) {
                            db.createObjectStore(TEXTURE_STORE_NAME, { keyPath: 'id' });
                            console.log('\u2705 Texture cache database created');
                        }
                    };
                });
            }
            
            async saveTexture(id, canvas) {
                if (!this.ready || !canvas) return;
                
                try {
                    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                    const transaction = this.db.transaction([TEXTURE_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(TEXTURE_STORE_NAME);
                    
                    await new Promise((resolve, reject) => {
                        const request = store.put({ 
                            id, 
                            blob, 
                            timestamp: Date.now(),
                            version: TEXTURE_CACHE_VERSION
                        });
                        request.onsuccess = resolve;
                        request.onerror = () => reject(request.error);
                    });
                    
                    console.log(`\ud83d\udcbe Cached texture: ${id}`);
                } catch (error) {
                    console.warn(`Failed to cache texture ${id}:`, error);
                }
            }
            
            async loadTexture(id) {
                if (!this.ready) return null;
                
                try {
                    const transaction = this.db.transaction([TEXTURE_STORE_NAME], 'readonly');
                    const store = transaction.objectStore(TEXTURE_STORE_NAME);
                    
                    const result = await new Promise((resolve, reject) => {
                        const request = store.get(id);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    if (result && result.blob && result.version === TEXTURE_CACHE_VERSION) {
                        const canvas = await this.blobToCanvas(result.blob);
                        this.cacheStats.hits++;
                        console.log(`\u26a1 Loaded from cache: ${id}`);
                        return canvas;
                    } else {
                        this.cacheStats.misses++;
                        return null;
                    }
                } catch (error) {
                    this.cacheStats.misses++;
                    return null;
                }
            }
            
            async blobToCanvas(blob) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    const url = URL.createObjectURL(blob);
                    
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        URL.revokeObjectURL(url);
                        resolve(canvas);
                    };
                    
                    img.onerror = () => {
                        URL.revokeObjectURL(url);
                        reject(new Error('Failed to load image from blob'));
                    };
                    
                    img.src = url;
                });
            }
            
            async clearCache() {
                if (!this.ready) return;
                
                try {
                    const transaction = this.db.transaction([TEXTURE_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(TEXTURE_STORE_NAME);
                    await new Promise((resolve, reject) => {
                        const request = store.clear();
                        request.onsuccess = resolve;
                        request.onerror = () => reject(request.error);
                    });
                    console.log('\u2705 Texture cache cleared');
                    if (typeof showMessage !== 'undefined') {
                        showMessage('\u2705 Texture cache cleared! Reload to regenerate.');
                    }
                } catch (error) {
                    console.warn('Failed to clear cache:', error);
                }
            }
            
            getStats() {
                const total = this.cacheStats.hits + this.cacheStats.misses;
                const hitRate = total > 0 ? ((this.cacheStats.hits / total) * 100).toFixed(1) : 0;
                return {
                    ...this.cacheStats,
                    total,
                    hitRate: hitRate + '%'
                };
            }
        }

        // Initialize global texture cache
        const textureCache = new TextureCache();
        
        // ===== PROCEDURAL SOUND SYSTEM =====
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // ===== THEME MUSIC (Web Audio API  plays on click-to-play overlay only) =====
        let _themeBuffer = null;
        let _themeSource = null;
        let _themeGain = null;

        // Pre-fetch the theme during loading so it's ready to play instantly when the overlay appears
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/theme.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => {
                _themeBuffer = buf;
                console.log('Theme loaded OK');
            })
            .catch(e => { console.error('Theme fetch error:', e); });

        function startTheme() {
            if (!_themeBuffer || _themeSource) return;
            audioContext.resume().then(() => {
                if (_themeSource) return;
                _themeGain = audioContext.createGain();
                _themeGain.gain.value = 0.7;
                _themeGain.connect(audioContext.destination);
                _themeSource = audioContext.createBufferSource();
                _themeSource.buffer = _themeBuffer;
                _themeSource.loop = true;
                _themeSource.connect(_themeGain);
                _themeSource.start();
                console.log(' Theme music started');
            }).catch(() => {});
        }

        function stopTheme() {
            if (!_themeGain || !_themeSource) return;
            const gain = _themeGain;
            const src = _themeSource;
            _themeSource = null;
            _themeGain = null;
            const now = audioContext.currentTime;
            gain.gain.setValueAtTime(gain.gain.value, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.6);
            src.stop(now + 0.65);
        }
        
        // ===== AMBIENT SOUNDS \u2014 BIOME-AWARE WITH SMOOTH CROSSFADE =====
        let ambientWindOscillator = null;
        let ambientWindGain       = null;
        let ambientWindFilter     = null;

        // biomeBlend: 0 = fully forest, 1 = fully desert
        // Crossfade zone: 40 units wide centred on biome boundary z = -100
        // NOTE: groundSize is defined later, so these are computed lazily in getBiomeBlend()
        let _biomeBlend = 0;

        function getBiomeBlend() {
            const edgeZ    = -(groundSize / 2);   // -100 once groundSize=200
            const fadeHalf = 40;                  // wider fade zone \u2014 smoother biome transition
            const raw = (edgeZ - camera.position.z) / fadeHalf;
            return Math.max(0, Math.min(1, raw));
        }
        function isInDesert() { return _biomeBlend > 0.5; }

        // Per-layer master gain nodes (created inside startAmbientSounds)
        let _forestGain = null;
        let _desertGain = null;
        let _forestAmbienceGain = null;
        let _windLPF    = null;   // shared wind low-pass \u2014 tuned per biome

        function startAmbientSounds() {
            // \u2500\u2500 Shared looping wind noise \u2500\u2500
            const wBuf  = audioContext.createBuffer(1, audioContext.sampleRate * 10, audioContext.sampleRate);
            const wData = wBuf.getChannelData(0);
            for (let i = 0; i < wData.length; i++) wData[i] = Math.random() * 2 - 1;

            const wSrc = audioContext.createBufferSource();
            wSrc.buffer = wBuf; wSrc.loop = true;
            _windLPF = audioContext.createBiquadFilter(); _windLPF.type = 'lowpass';  _windLPF.frequency.value = 900;
            const wHP = audioContext.createBiquadFilter(); wHP.type = 'highpass'; wHP.frequency.value = 180;
            const wN  = audioContext.createBiquadFilter(); wN.type  = 'notch';    wN.frequency.value  = 400; wN.Q.value = 1.2;
            ambientWindGain = audioContext.createGain();
            ambientWindGain.gain.value = volumeSettings.ambient * 0.03;
            wSrc.connect(_windLPF); _windLPF.connect(wHP); wHP.connect(wN); wN.connect(ambientWindGain);
            ambientWindGain.connect(audioContext.destination);
            wSrc.start();
            ambientWindOscillator = wSrc;

            // Gust variance
            (function gustLoop() {
                setTimeout(() => {
                    if (ambientWindGain && !isPaused)
                        ambientWindGain.gain.linearRampToValueAtTime(
                            volumeSettings.wind * (0.01 + Math.random() * 0.02),
                            audioContext.currentTime + 2 + Math.random() * 5);
                    gustLoop();
                }, (4 + Math.random() * 8) * 1000);
            })();

            // Real forest ambience track via Web Audio API
            let forestAmbienceSource = null;
            _forestAmbienceGain = audioContext.createGain();
            _forestAmbienceGain.gain.value = volumeSettings.forest;
            _forestAmbienceGain.connect(audioContext.destination);
            fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/forestambience.mp3')
                .then(r => r.arrayBuffer())
                .then(ab => audioContext.decodeAudioData(ab))
                .then(buffer => {
                    console.log('Forest ambience loaded OK');
                    forestAmbienceSource = audioContext.createBufferSource();
                    forestAmbienceSource.buffer = buffer;
                    forestAmbienceSource.loop = true;
                    forestAmbienceSource.connect(_forestAmbienceGain);
                    forestAmbienceSource.start();
                })
                .catch(e => { console.error('Forest ambience fetch error:', e); });

            // Load enemy attack sound after user interaction
            _enemyAttackAudio = new Audio('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/enemynoise.mp3');
            _enemyAttackAudio.preload = 'auto';

            // \u2500\u2500 Forest layer gain \u2500\u2500
            _forestGain = audioContext.createGain();
            _forestGain.gain.value = 1.0;
            _forestGain.connect(audioContext.destination);

            // \u2500\u2500 Desert layer gain \u2500\u2500
            _desertGain = audioContext.createGain();
            _desertGain.gain.value = 0.0;
            _desertGain.connect(audioContext.destination);

            // Crossfade poll: 200 ms resolution gives silky smooth fade
            setInterval(() => {
                if (isPaused) return;
                _biomeBlend = getBiomeBlend();
                const now = audioContext.currentTime;
                const fadeT = 0.4;
                _forestGain.gain.linearRampToValueAtTime((1 - _biomeBlend) * volumeSettings.ambient, now + fadeT);
                _desertGain.gain.linearRampToValueAtTime(      _biomeBlend  * volumeSettings.ambient, now + fadeT);
                if (_forestAmbienceGain) _forestAmbienceGain.gain.linearRampToValueAtTime((1 - _biomeBlend) * volumeSettings.forest, now + fadeT);
                _windLPF.frequency.linearRampToValueAtTime(600 + _biomeBlend * 1600, now + fadeT);
                // Stop rain if player crosses into desert
                if (_biomeBlend > 0.5 && isRaining) stopRain();
            }, 200);

            // \u2500\u2500 Start all ambient loops \u2500\u2500
            scheduleDesertCicada();
            scheduleDesertHawk();
        }

        // \u2500\u2500 Desert sounds \u2500\u2500
        function scheduleDesertCicada() {
            setTimeout(() => {
                if (!isPaused && _biomeBlend > 0.15) playDesertCicadaTo(_desertGain);
                scheduleDesertCicada();
            }, 2500 + Math.random() * 6000);
        }
        function scheduleDesertHawk() {
            setTimeout(() => {
                if (!isPaused && _biomeBlend > 0.15 && Math.random() < 0.4) playDesertHawkTo(_desertGain);
                scheduleDesertHawk();
            }, 10000 + Math.random() * 18000);
        }

        // \u2500\u2500 Sound emitters routed to a destination node \u2500\u2500
        function playBirdChirpTo(dest) {
            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator(), g = audioContext.createGain();
            osc.type = 'sine';
            const bf = 1400 + Math.random() * 1200;
            osc.frequency.setValueAtTime(bf, now);
            osc.frequency.setValueAtTime(bf * 1.25, now + 0.05);
            osc.frequency.setValueAtTime(bf * 0.85, now + 0.12);
            g.gain.setValueAtTime(0.08, now);
            g.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
            osc.connect(g); g.connect(dest || audioContext.destination);
            osc.start(now); osc.stop(now + 0.18);
        }
        function playRustleTo(dest) {
            const now = audioContext.currentTime;
            const buf = audioContext.createBuffer(1, ~~(audioContext.sampleRate * 0.3), audioContext.sampleRate);
            const d = buf.getChannelData(0);
            for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * 0.3;
            const src = audioContext.createBufferSource(); src.buffer = buf;
            const f = audioContext.createBiquadFilter(); f.type = 'highpass'; f.frequency.value = 800;
            const g = audioContext.createGain();
            g.gain.setValueAtTime(0.06, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
            src.connect(f); f.connect(g); g.connect(dest || audioContext.destination);
            src.start(now);
        }
        function playDesertCicadaTo(dest) {
            const now = audioContext.currentTime;
            const buf = audioContext.createBuffer(1, ~~(audioContext.sampleRate * 1.6), audioContext.sampleRate);
            const d = buf.getChannelData(0);
            for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * 0.4;
            const src = audioContext.createBufferSource(); src.buffer = buf;
            const bp = audioContext.createBiquadFilter(); bp.type = 'bandpass';
            bp.frequency.value = 4000 + Math.random() * 1000; bp.Q.value = 9;
            const g = audioContext.createGain();
            g.gain.setValueAtTime(0, now);
            g.gain.linearRampToValueAtTime(0.07, now + 0.25);
            g.gain.linearRampToValueAtTime(0.04, now + 0.9);
            g.gain.linearRampToValueAtTime(0, now + 1.6);
            src.connect(bp); bp.connect(g); g.connect(dest || audioContext.destination);
            src.start(now);
        }
        function playDesertHawkTo(dest) {
            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const f = audioContext.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = 1400; f.Q.value = 2;
            const g = audioContext.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(950, now);
            osc.frequency.exponentialRampToValueAtTime(460, now + 0.6);
            osc.frequency.exponentialRampToValueAtTime(300, now + 1.2);
            g.gain.setValueAtTime(0, now);
            g.gain.linearRampToValueAtTime(0.07, now + 0.09);
            g.gain.exponentialRampToValueAtTime(0.001, now + 1.25);
            osc.connect(f); f.connect(g); g.connect(dest || audioContext.destination);
            osc.start(now); osc.stop(now + 1.3);
        }

        // \u2500\u2500 Sand-gust whoosh (called by particle system) \u2500\u2500
        function playSandGustSound(intensity) {
            if (!_desertGain || _biomeBlend < 0.25 || isPaused) return;
            const now = audioContext.currentTime;
            const dur = 1.6 + Math.random() * 1.4;
            const buf = audioContext.createBuffer(1, ~~(audioContext.sampleRate * dur), audioContext.sampleRate);
            const d = buf.getChannelData(0);
            for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
            const src = audioContext.createBufferSource(); src.buffer = buf;
            const bp1 = audioContext.createBiquadFilter(); bp1.type = 'bandpass'; bp1.frequency.value = 1100; bp1.Q.value = 1.4;
            const bp2 = audioContext.createBiquadFilter(); bp2.type = 'bandpass'; bp2.frequency.value = 3600; bp2.Q.value = 2.2;
            const mix = audioContext.createGain(); mix.gain.value = 0.5;
            const g   = audioContext.createGain();
            const vol = intensity * _biomeBlend * 0.20;
            g.gain.setValueAtTime(0, now);
            g.gain.linearRampToValueAtTime(vol,       now + 0.35);
            g.gain.linearRampToValueAtTime(vol * 0.5, now + dur * 0.65);
            g.gain.linearRampToValueAtTime(0,         now + dur);
            src.connect(bp1); src.connect(bp2);
            bp1.connect(mix); bp2.connect(mix);
            mix.connect(g); g.connect(_desertGain);
            src.start(now);
        }

        // Legacy aliases so existing call-sites still work
        function playBirdChirp()   { playBirdChirpTo(_forestGain); }
        function playRustleSound() { playRustleTo(_forestGain); }

        function updateAmbientVolume() {
            if (ambientWindGain) ambientWindGain.gain.value = volumeSettings.wind * 0.03;
            if (_forestAmbienceGain) _forestAmbienceGain.gain.value = (1 - _biomeBlend) * volumeSettings.forest;
            if (_forestGain) _forestGain.gain.value = (1 - _biomeBlend) * volumeSettings.ambient;
            if (_desertGain) _desertGain.gain.value = _biomeBlend * volumeSettings.ambient;
        }

        // ===== SAND GUST PARTICLE SYSTEM =====
        const SAND_MAX = 800;
        const _sandPx = new Float32Array(SAND_MAX), _sandPy = new Float32Array(SAND_MAX), _sandPz = new Float32Array(SAND_MAX);
        const _sandVx = new Float32Array(SAND_MAX), _sandVy = new Float32Array(SAND_MAX), _sandVz = new Float32Array(SAND_MAX);
        const _sandLife = new Float32Array(SAND_MAX), _sandMaxLife = new Float32Array(SAND_MAX);
        // Turbulence per-particle: angular spin rate and phase offset for swirling
        const _sandSpin  = new Float32Array(SAND_MAX); // radians/sec angular drift
        const _sandPhase = new Float32Array(SAND_MAX); // random phase offset

        const _sandGeo     = new THREE.BufferGeometry();
        const _sandPosAttr = new THREE.BufferAttribute(new Float32Array(SAND_MAX * 3), 3);
        _sandGeo.setAttribute('position', _sandPosAttr);
        for (let i = 0; i < SAND_MAX; i++) _sandPosAttr.setXYZ(i, 0, -9999, 0);
        _sandPosAttr.needsUpdate = true;

        const _sandMat = new THREE.PointsMaterial({
            color: 0xc8a060,
            size: 0.5,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.55,
            depthWrite: false,
        });
        const _sandPoints = new THREE.Points(_sandGeo, _sandMat);
        _sandPoints.renderOrder = 2;
        _sandPoints.frustumCulled = false;  // bounding sphere is stale (parked verts) \u2014 skip culling
        // scene.add deferred \u2014 called after scene is ready

        let _sandGustTimer    = 0;
        let _sandGustInterval = 4 + Math.random() * 6;  // first gust within 4-10s
        let _sandGustActive   = false;
        let _sandGustDur      = 0;
        let _sandGustAge      = 0;
        let _sandGustWind     = new THREE.Vector3(1, 0, 0);
        let _sandPrevTime     = -1;   // -1 signals first frame

        function _spawnSandParticle(cx, cz, wind, speed) {
            for (let i = 0; i < SAND_MAX; i++) {
                if (_sandLife[i] <= 0) {
                    const spread = 20;
                    _sandPx[i] = cx + (Math.random() - 0.5) * spread;
                    _sandPy[i] = 0.04 + Math.random() * 1.8;
                    _sandPz[i] = cz + (Math.random() - 0.5) * spread;
                    const s = speed * (0.5 + Math.random() * 0.9);
                    // Give each particle a random sideways deviation so they don't travel in straight lines
                    const lateralAngle = (Math.random() - 0.5) * 1.8; // \u00b1~103\u00b0
                    const perpX =  wind.z, perpZ = -wind.x; // perpendicular to wind
                    const lateral = Math.sin(lateralAngle) * s * 0.7;
                    _sandVx[i] = wind.x * s * Math.cos(lateralAngle) + perpX * lateral + (Math.random() - 0.5) * 0.05;
                    _sandVy[i] = 0.006 + Math.random() * 0.025;
                    _sandVz[i] = wind.z * s * Math.cos(lateralAngle) + perpZ * lateral + (Math.random() - 0.5) * 0.05;
                    // Spin rate: some particles curl tightly, others drift wide
                    _sandSpin[i]  = (Math.random() - 0.5) * 4.0; // radians/sec
                    _sandPhase[i] = Math.random() * Math.PI * 2;
                    _sandMaxLife[i] = 1.8 + Math.random() * 2.5;
                    _sandLife[i]    = _sandMaxLife[i];
                    return;
                }
            }
        }

        function updateSandParticles() {
            const now = _frameTime;
            if (_sandPrevTime < 0) { _sandPrevTime = now; return; }  // skip first frame
            const dt = Math.min(now - _sandPrevTime, 0.05);
            _sandPrevTime = now;
            if (dt <= 0) return;

            _biomeBlend = getBiomeBlend();

            if (_biomeBlend < 0.01) {
                // hide everything when fully in forest
                _sandMat.opacity = 0;
                for (let i = 0; i < SAND_MAX; i++) {
                    _sandLife[i] = 0;
                    _sandPosAttr.setXYZ(i, 0, -9999, 0);
                }
                _sandPosAttr.needsUpdate = true;
                return;
            }

            // \u2500\u2500 Gust scheduling \u2500\u2500
            _sandGustTimer += dt;
            if (!_sandGustActive && _sandGustTimer >= _sandGustInterval) {
                _sandGustActive   = true;
                _sandGustAge      = 0;
                _sandGustDur      = 3.0 + Math.random() * 4.0;
                const ga          = Math.random() * Math.PI * 2;
                _sandGustWind.set(Math.cos(ga), 0, Math.sin(ga));
                _sandGustTimer    = 0;
                _sandGustInterval = 4 + Math.random() * 10;
                playSandGustSound(0.7 + Math.random() * 0.5);
            }

            // \u2500\u2500 Spawn particles during active gust \u2500\u2500
            if (_sandGustActive) {
                _sandGustAge += dt;

                // envelope: 0.6s attack, sustain, 1.0s release
                let env;
                if      (_sandGustAge < 0.6)                          env = _sandGustAge / 0.6;
                else if (_sandGustAge < _sandGustDur - 1.0)           env = 1.0;
                else                                                   env = Math.max(0, (_sandGustDur - _sandGustAge) / 1.0);

                // Spawn ~120 particles/sec at peak \u2014 integer count via accumulator
                const toSpawn = Math.round(env * _biomeBlend * 55 * dt);
                const cx = camera.position.x, cz = camera.position.z;
                for (let s = 0; s < toSpawn; s++) {
                    _spawnSandParticle(cx, cz, _sandGustWind, 0.18 + env * 0.22);
                }

                if (_sandGustAge >= _sandGustDur) _sandGustActive = false;
            }

            // \u2500\u2500 Simulate live particles with turbulent whispy curl \u2500\u2500
            for (let i = 0; i < SAND_MAX; i++) {
                if (_sandLife[i] <= 0) {
                    _sandPosAttr.setXYZ(i, 0, -9999, 0);
                    continue;
                }
                _sandLife[i] -= dt;
                const age = _sandMaxLife[i] - _sandLife[i];

                // Angular turbulence: each particle curls in a sinusoidal swirl
                const curl = Math.sin(age * _sandSpin[i] + _sandPhase[i]) * 0.04;
                _sandVx[i] += curl * _sandGustWind.z;   // perpendicular push
                _sandVz[i] -= curl * _sandGustWind.x;

                _sandVy[i] -= 0.010 * dt;               // gravity
                _sandVx[i] *= 1 - 0.35 * dt;            // drag
                _sandVz[i] *= 1 - 0.35 * dt;
                _sandPx[i] += _sandVx[i];
                _sandPy[i] += _sandVy[i];
                _sandPz[i] += _sandVz[i];
                if (_sandPy[i] < 0.02) { _sandPy[i] = 0.02; _sandVy[i] = Math.abs(_sandVy[i]) * 0.12; }
                _sandPosAttr.setXYZ(i, _sandPx[i], _sandPy[i], _sandPz[i]);
            }
            _sandPosAttr.needsUpdate = true;

            // fade opacity with biome blend
            _sandMat.opacity = 0.52 * _biomeBlend;
        }
        
        // Wood chop sound
        let _woodChopAudioBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/wood chop.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _woodChopAudioBuffer = buf; console.log('Wood chop sound loaded OK'); })
            .catch(e => { console.error('Wood chop sound fetch error:', e); });

        function playTreeChopSound() {
            if (!_woodChopAudioBuffer) { console.log('Wood chop buffer not ready yet'); return; }
            const src = audioContext.createBufferSource();
            src.buffer = _woodChopAudioBuffer;
            const gain = audioContext.createGain();
            gain.gain.value = volumeSettings.sfx !== undefined ? volumeSettings.sfx : 1.0;
            src.connect(gain);
            gain.connect(audioContext.destination);
            src.start();
        }
        
        // Tree fall sound
        let _treeFallAudioBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/treefall.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _treeFallAudioBuffer = buf; console.log('Tree fall sound loaded OK'); })
            .catch(e => { console.error('Tree fall sound fetch error:', e); });

        function playTreeFallSound() {
            if (!_treeFallAudioBuffer) { console.log('Tree fall buffer not ready yet'); return; }
            const src = audioContext.createBufferSource();
            src.buffer = _treeFallAudioBuffer;
            const gain = audioContext.createGain();
            gain.gain.value = volumeSettings.sfx !== undefined ? volumeSettings.sfx : 1.0;
            src.connect(gain);
            gain.connect(audioContext.destination);
            src.start(0, 0.6); // skip first 0.6 seconds
        }

        // Inventory move sound
        let _inventoryMoveAudioBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/inventorymove.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _inventoryMoveAudioBuffer = buf; console.log('Inventory move sound loaded OK'); })
            .catch(e => { console.error('Inventory move sound fetch error:', e); });

        function playInventoryMoveSound() {
            if (!_inventoryMoveAudioBuffer) return;
            const src = audioContext.createBufferSource();
            src.buffer = _inventoryMoveAudioBuffer;
            const gain = audioContext.createGain();
            gain.gain.value = volumeSettings.sfx !== undefined ? volumeSettings.sfx : 1.0;
            src.connect(gain);
            gain.connect(audioContext.destination);
            src.start();
        }

        // Bench/workbench interaction sound
        let _benchAudioBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/bench.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _benchAudioBuffer = buf; console.log('Bench sound loaded OK'); })
            .catch(e => { console.error('Bench sound fetch error:', e); });

        function playBenchSound() {
            if (!_benchAudioBuffer) return;
            const src = audioContext.createBufferSource();
            src.buffer = _benchAudioBuffer;
            const gain = audioContext.createGain();
            gain.gain.value = volumeSettings.sfx !== undefined ? volumeSettings.sfx : 1.0;
            src.connect(gain);
            gain.connect(audioContext.destination);
            src.start();
        }

        // Furnace/fire interaction sound
        let _furnaceInteractAudioBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/furnaceinteract.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _furnaceInteractAudioBuffer = buf; console.log('Furnace interact sound loaded OK'); })
            .catch(e => { console.error('Furnace interact sound fetch error:', e); });

        function playFurnaceInteractSound() {
            if (!_furnaceInteractAudioBuffer) return;
            const src = audioContext.createBufferSource();
            src.buffer = _furnaceInteractAudioBuffer;
            const gain = audioContext.createGain();
            gain.gain.value = volumeSettings.sfx !== undefined ? volumeSettings.sfx : 1.0;
            src.connect(gain);
            gain.connect(audioContext.destination);
            src.start();
        }
        
        // Stone/ore mining sound
        let _stoneMineAudioBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/stonemine.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _stoneMineAudioBuffer = buf; console.log('Stone mine sound loaded OK'); })
            .catch(e => { console.error('Stone mine sound fetch error:', e); });

        function playStoneMineSound() {
            if (!_stoneMineAudioBuffer) { console.log('Stone mine buffer not ready yet'); return; }
            const src = audioContext.createBufferSource();
            src.buffer = _stoneMineAudioBuffer;
            const gain = audioContext.createGain();
            gain.gain.value = volumeSettings.sfx !== undefined ? volumeSettings.sfx : 1.0;
            src.connect(gain);
            gain.connect(audioContext.destination);
            src.start();
        }

        function playRockMineSound() { playStoneMineSound(); }
        
        function playOreMineSound() { playStoneMineSound(); }
        
        function playBerryPickSound() { /* replaced by plant MP3 */ }
        
        // Door opening sound
        let _doorOpenAudioBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/opendoor.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _doorOpenAudioBuffer = buf; console.log('Door open sound loaded OK'); })
            .catch(e => { console.error('Door open sound fetch error:', e); });

        function playDoorOpenSound() {
            if (!_doorOpenAudioBuffer) { console.log('Door open buffer not ready yet'); return; }
            const src = audioContext.createBufferSource();
            src.buffer = _doorOpenAudioBuffer;
            const gain = audioContext.createGain();
            gain.gain.value = volumeSettings.sfx !== undefined ? volumeSettings.sfx : 1.0;
            src.connect(gain);
            gain.connect(audioContext.destination);
            src.start();
        }
        
        // Door closing sound - hard slam shut
        // Door closing sound
        let _doorCloseAudioBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/doorclose.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _doorCloseAudioBuffer = buf; console.log('Door close sound loaded OK'); })
            .catch(e => { console.error('Door close sound fetch error:', e); });

        function playDoorCloseSound() {
            if (!_doorCloseAudioBuffer) { console.log('Door close buffer not ready yet'); return; }
            const src = audioContext.createBufferSource();
            src.buffer = _doorCloseAudioBuffer;
            const gain = audioContext.createGain();
            gain.gain.value = volumeSettings.sfx !== undefined ? volumeSettings.sfx : 1.0;
            src.connect(gain);
            gain.connect(audioContext.destination);
            src.start();
        }
        
        // Code lock beep sound
        function playCodeLockBeep() {
            const now = audioContext.currentTime;
            
            const beep = audioContext.createOscillator();
            const beepGain = audioContext.createGain();
            beep.connect(beepGain);
            beepGain.connect(audioContext.destination);
            beep.type = 'square';
            beep.frequency.setValueAtTime(800, now);
            beepGain.gain.setValueAtTime(0.3, now);
            beepGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            beep.start(now);
            beep.stop(now + 0.12);
        }
        
        // Open code lock UI to set code
        function openCodeLockSetUI(door) {
            uiOpen();
            currentCodeLockDoor = door;
            codeLockMode = 'set';
            currentCode = '';
            
            document.getElementById('code-lock-menu').style.display = 'block';
            document.getElementById('code-lock-title').textContent = '\ud83d\udd12 Set Door Code';
            document.getElementById('code-display').textContent = '----';
            document.getElementById('code-lock-light').style.background = '#2ecc71';
            document.getElementById('code-lock-light').style.boxShadow = '0 0 30px rgba(46, 204, 113, 0.8)';
        }
        
        // Open code lock UI to enter code
        function openCodeLockEnterUI(door) {
            uiOpen();
            currentCodeLockDoor = door;
            codeLockMode = 'enter';
            currentCode = '';
            
            document.getElementById('code-lock-menu').style.display = 'block';
            document.getElementById('code-lock-title').textContent = '\ud83d\udd12 Enter Door Code';
            document.getElementById('code-display').textContent = '----';
            document.getElementById('code-lock-light').style.background = '#e74c3c';
            document.getElementById('code-lock-light').style.boxShadow = '0 0 30px rgba(231, 76, 60, 0.8)';
            
            // pointer lock handled by uiOpen()
        }
        
        // Close code lock UI
        function closeCodeLockUI() {
            currentCodeLockDoor = null;
            codeLockMode = null;
            currentCode = '';
            closeAllUI();
        }
        
        // Handle code entry
        function handleCodeEntry(digit) {
            if (currentCode.length < 4) {
                currentCode += digit;
                playCodeLockBeep();
                updateCodeDisplay();
            }
        }
        
        // Update code display
        function updateCodeDisplay() {
            let display = '';
            for (let i = 0; i < 4; i++) {
                display += i < currentCode.length ? currentCode[i] : '-';
            }
            document.getElementById('code-display').textContent = display;
        }
        
        // Clear code
        function clearCode() {
            currentCode = '';
            updateCodeDisplay();
        }
        
        // Submit code
        function submitCode() {
            if (currentCode.length !== 4) {
                showMessage('\u26a0\ufe0f Code must be 4 digits!');
                return;
            }
            
            if (codeLockMode === 'set') {
                // Set the code on the door
                currentCodeLockDoor.userData.codeLock = currentCode;
                currentCodeLockDoor.userData.hasCodeLock = true;
                
                // Create and attach visual code lock model to the door
                createCodeLockModel(currentCodeLockDoor);
                
                // Turn light red (locked)
                document.getElementById('code-lock-light').style.background = '#e74c3c';
                document.getElementById('code-lock-light').style.boxShadow = '0 0 30px rgba(231, 76, 60, 0.8)';
                
                playCodeLockBeep();
                showMessage('\ud83d\udd12 Code set! Door is now locked.');
                
                setTimeout(() => {
                    closeCodeLockUI();
                }, 1000);
            } else if (codeLockMode === 'enter') {
                // Check if code is correct
                if (currentCode === currentCodeLockDoor.userData.codeLock) {
                    // Correct code! Open the door
                    playCodeLockBeep();
                    
                    // Turn light green
                    document.getElementById('code-lock-light').style.background = '#2ecc71';
                    document.getElementById('code-lock-light').style.boxShadow = '0 0 30px rgba(46, 204, 113, 0.8)';
                    
                    showMessage('\u2705 Code correct! Door unlocked.');
                    
                    // Update code lock light on door to green
                    if (currentCodeLockDoor.userData.codeLockModel) {
                        currentCodeLockDoor.userData.codeLockModel.children.forEach(child => {
                            if (child.userData.isStatusLight) {
                                child.material.color.setHex(0x2ecc71);
                                child.material.emissive.setHex(0x2ecc71);
                            }
                        });
                    }
                    
                    // Open the door
                    currentCodeLockDoor.userData.isOpen = true;
                    
                    if (currentCodeLockDoor.userData.doorType === 'single') {
                        currentCodeLockDoor.userData.doorGroup.rotation.y = -Math.PI / 2;
                    } else if (currentCodeLockDoor.userData.doorType === 'double') {
                        currentCodeLockDoor.userData.leftDoorGroup.rotation.y = -Math.PI / 2;
                        currentCodeLockDoor.userData.rightDoorGroup.rotation.y = Math.PI / 2;
                    } else {
                        const initialRotation = currentCodeLockDoor.userData.initialRotation || 0;
                        currentCodeLockDoor.rotation.y = initialRotation + Math.PI / 2;
                    }
                    
                    playDoorOpenSound();
                    
                    setTimeout(() => {
                        closeCodeLockUI();
                        
                        // Reset light back to red after 2 seconds
                        setTimeout(() => {
                            if (currentCodeLockDoor.userData.codeLockModel) {
                                currentCodeLockDoor.userData.codeLockModel.children.forEach(child => {
                                    if (child.userData.isStatusLight) {
                                        child.material.color.setHex(0xe74c3c);
                                        child.material.emissive.setHex(0xe74c3c);
                                    }
                                });
                            }
                        }, 2000);
                    }, 1000);
                } else {
                    // Wrong code! Deal damage
                    showMessage('\u274c Wrong code! Taking damage!');
                    
                    // Start damage over time
                    let damageCount = 0;
                    wrongCodeDamageTimer = setInterval(() => {
                        applyDamage(20);
                        damageCount++;
                        
                        if (damageCount >= 2 || health <= 0) {
                            clearInterval(wrongCodeDamageTimer);
                            wrongCodeDamageTimer = null;
                            
                            if (health <= 0) {
                                die();
                            }
                            
                            clearCode();
                            closeCodeLockUI();
                        }
                    }, 1000);
                }
            }
        }
        
        // Create code lock 3D model and attach to door frame
        // Code lock model removed - keeping UI-based system only
        function createCodeLockModel(door) {
            // Physical model disabled - code lock is now UI-only
            // All functionality remains through the code lock UI interface
        }
        
        // ===== ARMOR SYSTEM =====
        // Mapping of armor items to body slots
        const armorSlotMapping = {
            'iron_helmet': 'head',
            'iron_vest': 'chest',
            'iron_gloves': 'hands',
            'iron_pants': 'legs',
            'iron_boots': 'feet',
            'bronze_helmet': 'head',
            'bronze_vest': 'chest',
            'bronze_gloves': 'hands',
            'bronze_pants': 'legs',
            'bronze_boots': 'feet'
        };
        
        // Armor damage reduction values
        const armorReduction = {
            'iron_helmet': 0.05,
            'iron_vest': 0.05,
            'iron_gloves': 0.05,
            'iron_pants': 0.05,
            'iron_boots': 0.05,
            'bronze_helmet': 0.02,
            'bronze_vest': 0.02,
            'bronze_gloves': 0.02,
            'bronze_pants': 0.02,
            'bronze_boots': 0.02
        };
        
        // Calculate total damage reduction from equipped armor
        function calculateDamageReduction() {
            let reduction = 0;
            Object.values(armorSlots).forEach(armorPiece => {
                if (armorPiece && armorReduction[armorPiece]) {
                    reduction += armorReduction[armorPiece];
                }
            });
            return Math.min(reduction, 1.0); // Cap at 100% (though max is 25% with 5 pieces)
        }
        
        // Apply damage with armor reduction
        function applyDamage(damage) {
            const reduction = calculateDamageReduction();
            const actualDamage = damage * (1 - reduction);
            health -= actualDamage;
            if (health < 0) health = 0;
            updateUI();
            return actualDamage;
        }
        
        // Equip armor piece
        function equipArmor(itemName) {
            const slot = armorSlotMapping[itemName];
            if (!slot) return false;
            
            // If slot already has armor, unequip it first
            if (armorSlots[slot]) {
                unequipArmor(slot);
            }
            
            // Remove from inventory and equip
            if (inventory[itemName] > 0) {
                inventory[itemName]--;
                armorSlots[slot] = itemName;
                updateUI();
                updateInventoryDisplay();
                updateArmorDisplay();
                showMessage(`\u2705 Equipped ${getItemDisplayName(itemName)}`);
                return true;
            }
            return false;
        }
        
        // Unequip armor piece from slot
        function unequipArmor(slot) {
            const itemName = armorSlots[slot];
            if (itemName) {
                inventory[itemName]++;
                armorSlots[slot] = null;
                updateUI();
                updateInventoryDisplay();
                updateArmorDisplay();
                showMessage(`\ud83d\udd04 Unequipped ${getItemDisplayName(itemName)}`);
                return true;
            }
            return false;
        }
        
        // Update armor display in clothing panel
        function updateArmorDisplay() {
            Object.keys(armorSlots).forEach(slot => {
                const slotElement = document.querySelector(`[data-slot="${slot}"]`);
                if (slotElement) {
                    const itemName = armorSlots[slot];
                    const iconElement = slotElement.querySelector('.armor-slot-icon');
                    
                    if (itemName) {
                        slotElement.classList.add('equipped');
                        const icon = itemIcons[itemName] || '\u2753';
                        
                        // Apply color filter based on armor type
                        if (itemName.startsWith('iron_')) {
                            iconElement.style.filter = 'grayscale(1) brightness(0.8)';
                        } else if (itemName.startsWith('bronze_')) {
                            iconElement.style.filter = 'sepia(1) saturate(3) hue-rotate(10deg) brightness(0.9)';
                        }
                        
                        iconElement.textContent = icon;
                    } else {
                        slotElement.classList.remove('equipped');
                        // Reset to default icon and remove filter
                        iconElement.style.filter = '';
                        const defaultIcons = {
                            'head': '\u26d1\ufe0f',
                            'chest': '\ud83e\uddba',
                            'hands': '\ud83e\udde4',
                            'legs': '\ud83d\udc56',
                            'feet': '\ud83d\udc62'
                        };
                        iconElement.textContent = defaultIcons[slot];
                    }
                }
            });
            
            // Update damage reduction display
            const reduction = calculateDamageReduction();
            const reductionPercent = Math.round(reduction * 100);
            const reductionDisplay = document.getElementById('damage-reduction-value');
            if (reductionDisplay) {
                reductionDisplay.textContent = `${reductionPercent}%`;
                // Change color based on amount
                if (reductionPercent >= 20) {
                    reductionDisplay.style.color = '#2ecc71'; // Green for good protection
                } else if (reductionPercent >= 10) {
                    reductionDisplay.style.color = '#f39c12'; // Orange for medium
                } else if (reductionPercent > 0) {
                    reductionDisplay.style.color = '#e67e22'; // Light orange for low
                } else {
                    reductionDisplay.style.color = '#95a5a6'; // Gray for none
                }
            }
        }
        
        // Preload thunder sound
        let _thunderBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/Thunder.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _thunderBuffer = buf; console.log('Thunder sound loaded OK'); })
            .catch(e => { console.error('Thunder sound fetch error:', e); });

        function playThunderSound() {
            if (!_thunderBuffer) return;
            let volumeMultiplier = 0.6 + Math.random() * 0.4;
            const underRoof = isPlayerUnderRoof();
            if (underRoof) volumeMultiplier *= 0.2;
            const source = audioContext.createBufferSource();
            source.buffer = _thunderBuffer;
            source.playbackRate.value = 0.5 + Math.random() * 1.0; // pitch variation 0.5x to 1.5x
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(volumeMultiplier, audioContext.currentTime);
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);
            source.start();
        }
        
        // ===== CORE SETUP =====
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x87CEEB, 0.008);
        scene.add(_sandPoints); // deferred from sand particle setup above
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.set(0, 1.7, 5);
        camera.rotation.order = 'YXZ';

        const heldItemGroup = new THREE.Group();
        heldItemGroup.position.set(0.28, -0.22, -0.42);
        heldItemGroup.scale.setScalar(1.45);
        camera.add(heldItemGroup);

        //  FPS Arm: right arm/hand visible when holding a tool 
        const fpsArmGroup = new THREE.Group();
        // Bottom-right of camera view: pushed right, down, and forward into view
        fpsArmGroup.position.set(0.35, -0.30, -0.45);
        // Tilt so it looks like a natural arm hold: rotated to show from elbow down
        fpsArmGroup.rotation.set(-0.3, -0.4, 0.1);
        fpsArmGroup.scale.setScalar(1.0);
        fpsArmGroup.visible = false;
        camera.add(fpsArmGroup);

        // Load the rigged arm GLB asynchronously and attach it
        let _fpsArmMixer  = null;
        let _fpsArmClock  = new THREE.Clock();
        let _fpsArmLoaded = false;

        (async function _loadFpsArm() {
            await _loadAssetGLB('Rigged Fps Arms.glb');
            const tmpl = _assetGLBCache['Rigged Fps Arms.glb'];
            if (!tmpl) { console.warn(' Rigged Fps Arms.glb not found in cache'); return; }

            const armInner = tmpl.clone(true);
            _glbFixTextures(armInner);

            // Log what we got
            let meshCount = 0;
            armInner.traverse(c => {
                c.visible = true;
                c.frustumCulled = false;
                if (c.isMesh) {
                    meshCount++;
                    c.castShadow = false;
                    c.receiveShadow = false;
                    c.renderOrder = 999;
                    if (c.material) {
                        const mats = Array.isArray(c.material) ? c.material : [c.material];
                        mats.forEach(m => {
                            if (m) {
                                m.depthTest = false;
                                m.depthWrite = false;
                                m.needsUpdate = true;
                            }
                        });
                    }
                }
            });

            const bbox = new THREE.Box3().setFromObject(armInner);
            const size = new THREE.Vector3();
            bbox.getSize(size);
            console.log(' Arm GLB meshes:', meshCount, 'size:', size.x.toFixed(2), size.y.toFixed(2), size.z.toFixed(2));

            // Scale so the arm fills the lower-right corner naturally (~0.6 units tall)
            const maxDim = Math.max(size.x, size.y, size.z);
            if (maxDim > 0) armInner.scale.setScalar(0.6 / maxDim);

            // Shift so top of arm is at y=0 of the group (arm hangs downward)
            armInner.updateMatrixWorld(true);
            const b2 = new THREE.Box3().setFromObject(armInner);
            armInner.position.y -= b2.max.y; // align top of arm to group origin

            fpsArmGroup.add(armInner);

            // Animations
            if (tmpl.userData._animClips && Object.keys(tmpl.userData._animClips).length) {
                _fpsArmMixer = new THREE.AnimationMixer(armInner);
                const clips = Object.values(tmpl.userData._animClips);
                console.log(' Arm clips:', Object.keys(tmpl.userData._animClips).join(', '));
                const firstClip = clips[0];
                if (firstClip) {
                    const action = _fpsArmMixer.clipAction(firstClip);
                    action.setLoop(THREE.LoopRepeat, Infinity);
                    action.play();
                }
            }

            // If GLB had no meshes, build a simple procedural arm as fallback
            if (meshCount === 0) {
                console.warn(' GLB had no meshes  using procedural arm fallback');
                _buildProceduralArm(fpsArmGroup);
            }

            _fpsArmLoaded = true;
            console.log(' FPS arm ready, meshes=' + meshCount);
        })();

        function _buildProceduralArm(group) {
            // Simple skin-coloured forearm + hand so something is always visible
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xc68642, roughness: 0.8 });
            const sleeveMat = new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.9 });

            // Forearm (lower arm cylinder)
            const forearm = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.055, 0.38, 8), sleeveMat);
            forearm.position.set(0, -0.19, 0);
            forearm.renderOrder = 999;
            forearm.material.depthTest = false;
            group.add(forearm);

            // Wrist
            const wrist = new THREE.Mesh(new THREE.CylinderGeometry(0.038, 0.045, 0.07, 8), skinMat);
            wrist.position.set(0, -0.42, 0);
            wrist.renderOrder = 999;
            wrist.material.depthTest = false;
            group.add(wrist);

            // Hand (palm box)
            const hand = new THREE.Mesh(new THREE.BoxGeometry(0.09, 0.11, 0.055), skinMat.clone());
            hand.position.set(0, -0.53, 0.01);
            hand.renderOrder = 999;
            hand.material.depthTest = false;
            group.add(hand);

            // Four fingers (simple boxes)
            for (let i = 0; i < 4; i++) {
                const finger = new THREE.Mesh(new THREE.BoxGeometry(0.018, 0.075, 0.018), skinMat.clone());
                finger.position.set(-0.033 + i * 0.022, -0.62, 0.01);
                finger.renderOrder = 999;
                finger.material.depthTest = false;
                group.add(finger);
            }

            // Thumb
            const thumb = new THREE.Mesh(new THREE.BoxGeometry(0.018, 0.055, 0.018), skinMat.clone());
            thumb.position.set(0.055, -0.54, 0.01);
            thumb.rotation.z = -0.4;
            thumb.renderOrder = 999;
            thumb.material.depthTest = false;
            group.add(thumb);
        }

        scene.add(camera);
        
        let currentHeldItem = null;
        let toolAnimation = {
            active: false,
            time: 0,
            duration: 0.3
        };
        
        // Create Sharp Stone model - Detailed handheld version
        async function createSharpStoneModel() {
            const stone = new THREE.Group();
            
            // Main stone body - more irregular/angular shape
            const stoneGeo = new THREE.DodecahedronGeometry(0.12, 0);
            const stoneMat = await createStoneMaterial(0x888888, 0.9);
            const stoneBody = new THREE.Mesh(stoneGeo, stoneMat);
            stoneBody.scale.set(1.5, 1.2, 0.8); // Flatter, wider
            stoneBody.castShadow = true;
            stone.add(stoneBody);
            
            // Sharp edge pieces (knapped edges)
            const edgePositions = [
                { x: 0.15, y: 0, z: 0, rot: 0 },
                { x: 0.12, y: 0.05, z: 0, rot: 0.3 },
                { x: 0.12, y: -0.05, z: 0, rot: -0.3 }
            ];
            
            edgePositions.forEach(pos => {
                const edgeGeo = new THREE.TetrahedronGeometry(0.04, 0);
                const edgeMat = new THREE.MeshStandardMaterial({ 
                    color: 0xaaaaaa,
                    roughness: 0.4,
                    metalness: 0.3,
                    flatShading: true
                });
                const edge = new THREE.Mesh(edgeGeo, edgeMat);
                edge.position.set(pos.x, pos.y, pos.z);
                edge.rotation.z = pos.rot;
                edge.scale.set(1.5, 0.8, 0.5);
                stone.add(edge);
            });
            
            // Knapping flakes (texture detail)
            for (let i = 0; i < 8; i++) {
                const flakeGeo = new THREE.BoxGeometry(0.04, 0.02, 0.01);
                const flakeMat = new THREE.MeshStandardMaterial({
                    color: 0x666666,
                    roughness: 0.7,
                    flatShading: true
                });
                const flake = new THREE.Mesh(flakeGeo, flakeMat);
                
                const angle = (i / 8) * Math.PI * 2;
                const radius = 0.08 + Math.random() * 0.04;
                flake.position.set(
                    Math.cos(angle) * radius,
                    (Math.random() - 0.5) * 0.12,
                    Math.sin(angle) * radius * 0.6
                );
                flake.rotation.set(
                    Math.random() - 0.5,
                    Math.random() - 0.5,
                    angle
                );
                stone.add(flake);
            }
            
            // Position for proper hand holding in FPS view
            stone.position.set(0.2, -0.25, -0.35);
            stone.rotation.set(0.5, 0.4, -0.4);
            
            return stone;
        }

        //  ASSET GLB LOADER 
        // Shared loader for weapon/tool held-item models AND world-object spawns.
        // 
        // GLB ENGINE  unified, hardened loader & instantiator
        // All GLB loading in the game funnels through _glbLoad() and _glbSpawn().
        // Adding a new model never requires touching loading/safety code again 
        // just call _glbLoad(url) and _glbSpawn(filename, size) and it all works.
        //
        // Fixes baked in permanently:
        //   1. DRACOLoader race   waits for both GLTFLoader AND DRACOLoader scripts
        //      before parsing any file, so Draco-compressed meshes never silently
        //      decode to empty geometry.
        //   2. NaN position guard  if bounding box is infinite/empty (Draco failure),
        //      position.y subtraction is skipped instead of writing -Infinity  NaN.
        //   3. Shared-material bug (Three.js r128)  every clone gets independent
        //      material instances so GPU upload state can't bleed between instances.
        //   4. Texture encoding fix  sRGB/Linear encoding set on all texture slots
        //      after parse, preventing black/invisible materials.
        //   5. Geometry always visible  frustumCulled=false, visible=true, shadows
        //      enabled on every mesh, bounding volumes computed.
        // 

        const _ASSET_GLB_BASE   = 'https://jam110uk.github.io/Crust-Sounds/';
        const _assetGLBCache    = {};   // url-key AND bare-filename  THREE.Object3D template (or null)
        const _assetGLBPromises = {};   // url-key  Promise<template|null>

        //  Shared Draco loader instance (created once after DRACOLoader script loads)
        let _sharedDracoLoader = null;

        //  Loader-ready promise: resolves true only when BOTH scripts are loaded.
        //    _gltfLoaderPromise is set by the script-loading block above.
        //    _dracoLoaderPromise is set in the DRACOLoader <script> onload below.
        //    Using Promise.all means every _glbLoad call automatically waits for both.
        function _glbLoadersReady() {
            return Promise.all([
                window._gltfLoaderPromise  || Promise.resolve(typeof THREE.GLTFLoader  !== 'undefined'),
                window._dracoLoaderPromise || Promise.resolve(typeof THREE.DRACOLoader !== 'undefined'),
            ]).then(([gltfOk]) => gltfOk);
        }

        //  Single shared GLTFLoader with Draco attached (created lazily after ready)
        let _sharedGLTFLoader = null;
        function _getGLTFLoader() {
            if (_sharedGLTFLoader) return _sharedGLTFLoader;
            _sharedGLTFLoader = new THREE.GLTFLoader();
            if (typeof THREE.DRACOLoader !== 'undefined') {
                if (!_sharedDracoLoader) {
                    _sharedDracoLoader = new THREE.DRACOLoader();
                    _sharedDracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/draco/');
                    _sharedDracoLoader.setDecoderConfig({ type: 'js' });
                }
                _sharedGLTFLoader.setDRACOLoader(_sharedDracoLoader);
            }
            return _sharedGLTFLoader;
        }

        //  _glbLoad(filename, baseUrl?)
        //    Fetches + parses a GLB file exactly once; returns a Promise<template|null>.
        //    Safe to call many times  deduplicates via _assetGLBCache/_assetGLBPromises.
        //    baseUrl defaults to _ASSET_GLB_BASE if omitted.
        function _glbLoad(filename, baseUrl) {
            const key = (baseUrl || _ASSET_GLB_BASE) + filename;
            if (key in _assetGLBCache)    return Promise.resolve(_assetGLBCache[key]);
            if (_assetGLBPromises[key])   return _assetGLBPromises[key];

            const url = (baseUrl || _ASSET_GLB_BASE) + encodeURIComponent(filename);
            console.log(` [GLB] Loading: ${url}`);

            _assetGLBPromises[key] = _glbLoadersReady().then(ok => {
                if (!ok || typeof THREE.GLTFLoader === 'undefined') {
                    console.error(` [GLB] GLTFLoader unavailable for ${filename}`);
                    return (_assetGLBCache[key] = null);
                }
                return fetch(url)
                    .then(r => {
                        if (!r.ok) throw new Error(`HTTP ${r.status}`);
                        console.log(` [GLB] ${filename}  ${r.status}, reading buffer`);
                        return r.arrayBuffer();
                    })
                    .then(buf => new Promise((resolve, reject) => {
                        console.log(` [GLB] ${filename}  ${buf.byteLength} bytes, parsing`);
                        _getGLTFLoader().parse(buf, '', gltf => {
                            const tmpl = gltf.scene;
                            // Store animation clips on the template for animated models
                            if (gltf.animations && gltf.animations.length) {
                                tmpl.userData._animClips = {};
                                gltf.animations.forEach(c => { tmpl.userData._animClips[c.name.toLowerCase()] = c; });
                            }
                            // Validate: Draco failure produces 0 meshes silently
                            let meshCount = 0;
                            tmpl.traverse(c => {
                                c.visible = true; c.frustumCulled = false;
                                if (c.isMesh) {
                                    meshCount++;
                                    c.castShadow = true; c.receiveShadow = true;
                                    if (c.geometry) { c.geometry.computeBoundingBox(); c.geometry.computeBoundingSphere(); }
                                }
                            });
                            const bbox = new THREE.Box3().setFromObject(tmpl);
                            const bs = new THREE.Vector3(); bbox.getSize(bs);
                            console.log(` [GLB] ${filename}  meshes=${meshCount} size=${bs.x.toFixed(2)}${bs.y.toFixed(2)}${bs.z.toFixed(2)}`);
                            if (meshCount === 0) console.warn(` [GLB]  ${filename} has 0 meshes  Draco decode failure or empty file!`);
                            _glbFixTextures(tmpl);
                            _assetGLBCache[key] = tmpl;
                            _assetGLBCache[filename] = tmpl;  // bare-filename alias for legacy lookups
                            resolve(tmpl);
                        }, err => {
                            console.error(` [GLB] parse FAILED for ${filename}:`, err);
                            resolve(_assetGLBCache[key] = _assetGLBCache[filename] = null);
                        });
                    }))
                    .catch(err => {
                        console.error(` [GLB] fetch FAILED for ${filename}:`, err);
                        return (_assetGLBCache[key] = _assetGLBCache[filename] = null);
                    });
            });
            return _assetGLBPromises[key];
        }

        //  Backwards-compat alias used throughout the codebase
        function _loadAssetGLB(filename) { return _glbLoad(filename); }

        //  _glbSpawn(filename, targetSize, positionOffset?, baseUrl?)
        //    Deep-clones the cached template, scales it to targetSize (largest axis, metres),
        //    grounds it (bottom of bbox sits at y=0), optionally offsets, and returns the
        //    instance ready to scene.add(). Returns null if template not loaded yet.
        //
        //    All the one-time fixes are here so no spawn site needs to repeat them:
        //       Per-instance material clone  (shared-material r128 bug)
        //       Texture encoding fix
        //       NaN guard on bbox grounding
        //       frustumCulled=false, shadows, bounding volumes
        function _glbSpawn(filename, targetSize, positionOffset, baseUrl) {
            const key  = (baseUrl || _ASSET_GLB_BASE) + filename;
            const tmpl = _assetGLBCache[key];
            if (!tmpl) { console.warn(` [GLB] _glbSpawn: "${filename}" not loaded yet`); return null; }

            const inst = tmpl.clone(true);

            // Per-instance material clone  prevents GPU-upload state bleeding between instances
            inst.traverse(c => {
                if (!c.isMesh) return;
                if (Array.isArray(c.material)) {
                    c.material = c.material.map(m => { const mc = m ? m.clone() : m; if (mc) mc.needsUpdate = true; return mc; });
                } else if (c.material) {
                    c.material = c.material.clone();
                    c.material.needsUpdate = true;
                }
            });

            // Scale to target size
            const box = new THREE.Box3().setFromObject(inst);
            const sz  = new THREE.Vector3(); box.getSize(sz);
            const maxDim = Math.max(sz.x, sz.y, sz.z);
            if (maxDim === 0) {
                console.error(` [GLB]  ${filename} has zero bounding box  geometry empty, skipping spawn`);
                return null;   // Return null instead of adding an invisible ghost object
            }
            inst.scale.setScalar(targetSize / maxDim);

            // Ground: shift so bbox bottom sits at y=0.
            // NaN guard: if bbox is infinite (empty geometry slipped through), skip
            // rather than writing -Infinity into position.y which produces NaN matrix.
            inst.updateMatrixWorld(true);
            const b2 = new THREE.Box3().setFromObject(inst);
            if (isFinite(b2.min.y)) {
                inst.position.y -= b2.min.y;
            } else {
                console.error(` [GLB]  ${filename} grounding skipped  b2.min.y=${b2.min.y}`);
            }

            if (positionOffset) inst.position.add(positionOffset);

            // Ensure every mesh is renderable
            inst.traverse(c => {
                c.visible = true; c.frustumCulled = false;
                if (c.isMesh) {
                    c.castShadow = true; c.receiveShadow = true;
                    if (c.geometry) { c.geometry.computeBoundingBox(); c.geometry.computeBoundingSphere(); }
                }
            });

            _glbFixTextures(inst);
            return inst;
        }

        //  Backwards-compat alias  old call sites use _instantiateGLB
        function _instantiateGLB(filename, targetSize, positionOffset) {
            return _glbSpawn(filename, targetSize, positionOffset);
        }

        //  Texture-encoding fix: Three.js r128 bug  GLBs loaded via parse(ArrayBuffer)
        //    don't reliably have sRGB/Linear encoding set, causing black/invisible surfaces.
        //    Called on every template at load time AND on every instance at spawn time.
        function _glbFixTextures(root) {
            root.traverse(c => {
                if (!c.isMesh || !c.material) return;
                const mats = Array.isArray(c.material) ? c.material : [c.material];
                mats.forEach(mat => {
                    if (!mat) return;
                    ['map','emissiveMap'].forEach(k => {
                        if (mat[k]) { mat[k].encoding = THREE.sRGBEncoding; mat[k].needsUpdate = true; }
                    });
                    ['normalMap','roughnessMap','metalnessMap','aoMap','displacementMap','alphaMap','lightMap'].forEach(k => {
                        if (mat[k]) { mat[k].encoding = THREE.LinearEncoding; mat[k].needsUpdate = true; }
                    });
                    mat.needsUpdate = true;
                });
            });
        }
        // Backwards-compat alias
        const _fixGLBTextures = _glbFixTextures;

        //  _makeGLTFLoader kept for any legacy call sites (Wolf loader etc.)
        //    Returns the shared loader so Draco is always attached.
        function _makeGLTFLoader() { return _getGLTFLoader(); }

        // Pre-load all new asset GLBs immediately
        const _ALL_ASSET_GLBS = [
            'Spear.glb', 'Pistol.glb', 'Sword.glb', 'Simple Pickaxe.glb', 'Hatchet.glb',
            'Prickly pear cactus.glb', 'Cactus.glb', 'Rock Medium.glb', 'Palm Tree.glb', 'Tree.glb',
            'Rigged Fps Arms.glb'
        ];
        _ALL_ASSET_GLBS.forEach(f => _loadAssetGLB(f));

        //  Weapon / tool held-item model builders 
        // Each returns a Promise<THREE.Group>  same API as the old async functions.
        // Falls back to the original procedural model if GLB hasn't loaded yet.

        async function createAxeModel() {
            await _loadAssetGLB('Hatchet.glb');
            const glb = _instantiateGLB('Hatchet.glb', 0.55, new THREE.Vector3(0.08, -0.25, -0.35));
            if (glb) { glb.rotation.set(-0.5, 0.4, 0.15); return glb; }

            const axe = new THREE.Group();
            
            // Wooden handle with texture
            const handleGeo = new THREE.CylinderGeometry(0.035, 0.04, 1, 8);
            const handleMat = await createWoodMaterial(0x8B4513, 0.85);
            const handle = new THREE.Mesh(handleGeo, handleMat);
            handle.position.y = -0.4;
            handle.castShadow = true;
            axe.add(handle);
            
            // Handle grip wrapping
            const gripGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.25, 8);
            const gripMat = new THREE.MeshStandardMaterial({
                color: 0x3d2817,
                roughness: 0.9
            });
            const grip = new THREE.Mesh(gripGeo, gripMat);
            grip.position.y = -0.65;
            axe.add(grip);
            
            // Metal blade with realistic shape
            const bladeShape = new THREE.Shape();
            bladeShape.moveTo(0, 0);
            bladeShape.lineTo(0.35, 0.1);
            bladeShape.quadraticCurveTo(0.38, 0.05, 0.35, -0.1);
            bladeShape.lineTo(0, 0);
            
            const bladeGeo = new THREE.ExtrudeGeometry(bladeShape, {
                depth: 0.06,
                bevelEnabled: true,
                bevelThickness: 0.01,
                bevelSize: 0.01,
                bevelSegments: 2
            });
            
            const bladeMat = await createMetalMaterial(0x888888, 0.4);
            const blade = new THREE.Mesh(bladeGeo, bladeMat);
            blade.position.set(-0.03, 0.15, -0.03);
            blade.rotation.x = Math.PI / 2;
            blade.rotation.y = Math.PI / 2; // Rotate 90 degrees so edge faces forward
            blade.castShadow = true;
            axe.add(blade);
            
            // Blade edge highlight
            const edgeGeo = new THREE.BoxGeometry(0.02, 0.35, 0.04);
            const edgeMat = new THREE.MeshStandardMaterial({
                color: 0xcccccc,
                roughness: 0.2,
                metalness: 0.9
            });
            const edge = new THREE.Mesh(edgeGeo, edgeMat);
            edge.position.set(0, 0.15, 0.145); // Adjusted for rotated blade
            edge.rotation.y = Math.PI / 2;
            edge.castShadow = true;
            axe.add(edge);
            
            // Metal head socket
            const socketGeo = new THREE.CylinderGeometry(0.05, 0.045, 0.15, 8);
            const socket = new THREE.Mesh(socketGeo, bladeMat.clone());
            socket.position.y = 0.05;
            axe.add(socket);
            
            // Position for FPS view - handle vertical, blade at top pointing forward/up
            axe.rotation.set(-0.3, -0.1, 0); // Slight tilt forward
            axe.position.set(0.25, -0.35, -0.45);
            
            return axe;
        }
        
        async function createPickaxeModel() {
            await _loadAssetGLB('Simple Pickaxe.glb');
            const glb = _instantiateGLB('Simple Pickaxe.glb', 0.60, new THREE.Vector3(0.12, -0.18, -0.30));
            if (glb) { glb.rotation.set(-0.3, 0.2 + Math.PI / 2, 0.15); return glb; }

            const pickaxe = new THREE.Group();
            
            // Wooden handle with texture
            const handleGeo = new THREE.CylinderGeometry(0.035, 0.04, 1.1, 8);
            const handleMat = await createWoodMaterial(0x8B4513, 0.85);
            const handle = new THREE.Mesh(handleGeo, handleMat);
            handle.position.y = -0.45;
            handle.castShadow = true;
            pickaxe.add(handle);
            
            // Handle grip
            const gripGeo = new THREE.CylinderGeometry(0.042, 0.042, 0.3, 8);
            const gripMat = new THREE.MeshStandardMaterial({
                color: 0x654321,
                roughness: 0.95
            });
            const grip = new THREE.Mesh(gripGeo, gripMat);
            grip.position.y = -0.7;
            pickaxe.add(grip);
            
            // Metal pick head base
            const headBaseGeo = new THREE.BoxGeometry(0.5, 0.12, 0.1);
            const metalMat = await createMetalMaterial(0x666666, 0.4);
            const headBase = new THREE.Mesh(headBaseGeo, metalMat);
            headBase.position.y = 0.1;
            headBase.rotation.y = Math.PI / 2; // Rotate so pick points forward
            headBase.castShadow = true;
            pickaxe.add(headBase);
            
            // Pick point (main working end)
            const pickPointGeo = new THREE.ConeGeometry(0.05, 0.25, 6);
            const pickPoint = new THREE.Mesh(pickPointGeo, metalMat.clone());
            pickPoint.rotation.z = -Math.PI / 2;
            pickPoint.rotation.x = Math.PI / 2; // Point forward
            pickPoint.position.set(0, 0.1, 0.32);
            pickPoint.castShadow = true;
            pickaxe.add(pickPoint);
            
            // Sharp edge highlight on point
            const pointEdgeGeo = new THREE.ConeGeometry(0.03, 0.1, 4);
            const edgeMat = new THREE.MeshStandardMaterial({
                color: 0xaaaaaa,
                roughness: 0.2,
                metalness: 0.9
            });
            const pointEdge = new THREE.Mesh(pointEdgeGeo, edgeMat);
            pointEdge.rotation.z = -Math.PI / 2;
            pointEdge.rotation.x = Math.PI / 2; // Match pick rotation
            pointEdge.position.set(0, 0.1, 0.4);
            pickaxe.add(pointEdge);
            
            // Flat hammer end (opposite side)
            const hammerGeo = new THREE.BoxGeometry(0.12, 0.12, 0.1);
            const hammer = new THREE.Mesh(hammerGeo, metalMat.clone());
            hammer.position.set(0, 0.1, -0.25); // Behind handle
            hammer.castShadow = true;
            pickaxe.add(hammer);
            
            // Socket connecting head to handle
            const socketGeo = new THREE.CylinderGeometry(0.055, 0.05, 0.15, 8);
            const socket = new THREE.Mesh(socketGeo, metalMat.clone());
            socket.position.y = 0.02;
            pickaxe.add(socket);
            
            // Position for FPS view - handle diagonal, pick pointing down-forward
            pickaxe.rotation.set(0.8, 0.3, 0.2); // Diagonal grip
            pickaxe.position.set(0.3, -0.4, -0.5);
            
            return pickaxe;
        }
        
        async function createSwordModel() {
            await _loadAssetGLB('Sword.glb');
            const glb = _instantiateGLB('Sword.glb', 0.75, new THREE.Vector3(0.10, -0.18, -0.28));
            if (glb) { glb.rotation.set(-0.15, -0.05, 0); return glb; }

            const sword = new THREE.Group();
            
            // Blade - medieval longsword style
            const bladeLength = 0.75;
            const bladeShape = new THREE.Shape();
            bladeShape.moveTo(0, 0);
            bladeShape.lineTo(0.04, 0.05);
            bladeShape.lineTo(0.04, bladeLength - 0.08);
            bladeShape.lineTo(0, bladeLength);
            bladeShape.lineTo(-0.04, bladeLength - 0.08);
            bladeShape.lineTo(-0.04, 0.05);
            bladeShape.lineTo(0, 0);
            
            const bladeGeo = new THREE.ExtrudeGeometry(bladeShape, {
                depth: 0.008,
                bevelEnabled: true,
                bevelThickness: 0.003,
                bevelSize: 0.003,
                bevelSegments: 3
            });
            
            const bladeMat = await createMetalMaterial(0xcccccc, 0.3);
            const blade = new THREE.Mesh(bladeGeo, bladeMat);
            blade.position.set(0, bladeLength * 0.3, -0.004);
            blade.castShadow = true;
            sword.add(blade);
            
            // Fuller (blood groove) down center of blade
            const fullerGeo = new THREE.BoxGeometry(0.015, bladeLength * 0.7, 0.004);
            const fullerMat = new THREE.MeshStandardMaterial({
                color: 0x999999,
                roughness: 0.4,
                metalness: 0.8
            });
            const fuller = new THREE.Mesh(fullerGeo, fullerMat);
            fuller.position.y = bladeLength * 0.35;
            sword.add(fuller);
            
            // Sharp edge highlights
            const edge1Geo = new THREE.BoxGeometry(0.003, bladeLength * 0.8, 0.01);
            const edgeMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.1,
                metalness: 1,
                emissive: 0xaaaaaa,
                emissiveIntensity: 0.2
            });
            const edge1 = new THREE.Mesh(edge1Geo, edgeMat);
            edge1.position.set(0.04, bladeLength * 0.35, 0);
            sword.add(edge1);
            
            const edge2 = new THREE.Mesh(edge1Geo, edgeMat.clone());
            edge2.position.set(-0.04, bladeLength * 0.35, 0);
            sword.add(edge2);
            
            // Crossguard
            const guardGeo = new THREE.BoxGeometry(0.25, 0.04, 0.04);
            const guardMat = await createMetalMaterial(0x888888, 0.5);
            const guard = new THREE.Mesh(guardGeo, guardMat);
            guard.position.y = -0.02;
            guard.castShadow = true;
            sword.add(guard);
            
            // Guard decorations
            const guardTipGeo = new THREE.SphereGeometry(0.025, 8, 8);
            const guardTip1 = new THREE.Mesh(guardTipGeo, guardMat.clone());
            guardTip1.position.set(0.125, -0.02, 0);
            sword.add(guardTip1);
            
            const guardTip2 = new THREE.Mesh(guardTipGeo, guardMat.clone());
            guardTip2.position.set(-0.125, -0.02, 0);
            sword.add(guardTip2);
            
            // Grip/Handle wrapped in leather
            const gripGeo = new THREE.CylinderGeometry(0.022, 0.025, 0.22, 8);
            const gripMat = await createFabricMaterial(0x3d2817, 0.95);
            const grip = new THREE.Mesh(gripGeo, gripMat);
            grip.position.y = -0.13;
            grip.rotation.x = Math.PI / 2;
            grip.castShadow = true;
            sword.add(grip);
            
            // Grip wire wrapping detail
            for (let i = 0; i < 8; i++) {
                const wireGeo = new THREE.TorusGeometry(0.024, 0.004, 4, 8);
                const wireMat = new THREE.MeshStandardMaterial({
                    color: 0x4a4a4a,
                    roughness: 0.4,
                    metalness: 0.7
                });
                const wire = new THREE.Mesh(wireGeo, wireMat);
                wire.position.y = -0.05 - (i * 0.025);
                wire.rotation.x = Math.PI / 2;
                sword.add(wire);
            }
            
            // Pommel
            const pommelGeo = new THREE.SphereGeometry(0.04, 8, 8);
            const pommel = new THREE.Mesh(pommelGeo, guardMat.clone());
            pommel.scale.set(1, 0.7, 1);
            pommel.position.y = -0.26;
            pommel.castShadow = true;
            sword.add(pommel);
            
            // Position for proper hand holding in FPS view (diagonal grip)
            sword.rotation.set(-0.4, 0.2, -0.1);
            sword.position.set(0.18, -0.15, -0.3);
            
            return sword;
        }
        
        async function createSpearModel() {
            await _loadAssetGLB('Spear.glb');
            const glb = _instantiateGLB('Spear.glb', 1.0, new THREE.Vector3(0.10, -0.18, -0.28));
            if (glb) { glb.rotation.set(-0.15, -0.05, 0); return glb; }

            const spear = new THREE.Group();
            
            // Long wooden shaft
            const shaftGeo = new THREE.CylinderGeometry(0.025, 0.03, 1.8, 8);
            const shaftMat = await createWoodMaterial(0x8B4513, 0.85);
            const shaft = new THREE.Mesh(shaftGeo, shaftMat);
            shaft.castShadow = true;
            spear.add(shaft);
            
            // Grip area (wrapped leather)
            const gripGeo = new THREE.CylinderGeometry(0.032, 0.032, 0.35, 8);
            const gripMat = new THREE.MeshStandardMaterial({
                color: 0x3d2817,
                roughness: 0.95
            });
            const grip = new THREE.Mesh(gripGeo, gripMat);
            grip.position.y = -0.5;
            spear.add(grip);
            
            // Metal spear head - diamond shaped blade
            const headLength = 0.35;
            const headWidth = 0.08;
            
            // Create blade shape
            const bladeShape = new THREE.Shape();
            bladeShape.moveTo(0, headLength / 2); // Tip
            bladeShape.lineTo(headWidth / 2, 0); // Right side
            bladeShape.lineTo(0, -headLength / 2); // Base
            bladeShape.lineTo(-headWidth / 2, 0); // Left side
            bladeShape.lineTo(0, headLength / 2); // Back to tip
            
            const bladeGeo = new THREE.ExtrudeGeometry(bladeShape, {
                depth: 0.015,
                bevelEnabled: true,
                bevelThickness: 0.005,
                bevelSize: 0.005,
                bevelSegments: 2
            });
            
            const bladeMat = await createMetalMaterial(0x888888, 0.3);
            const blade = new THREE.Mesh(bladeGeo, bladeMat);
            blade.rotation.x = Math.PI / 2;
            blade.position.y = 0.9 + headLength / 2;
            blade.castShadow = true;
            spear.add(blade);
            
            // Sharp edge highlights
            const edgeGeo = new THREE.PlaneGeometry(headWidth - 0.01, 0.005);
            const edgeMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.1,
                metalness: 1,
                emissive: 0xaaaaaa,
                emissiveIntensity: 0.3,
                side: THREE.DoubleSide
            });
            const edge1 = new THREE.Mesh(edgeGeo, edgeMat);
            edge1.rotation.x = Math.PI / 2;
            edge1.position.set(0, 0.9 + headLength / 2, 0.01);
            spear.add(edge1);
            
            const edge2 = new THREE.Mesh(edgeGeo, edgeMat.clone());
            edge2.rotation.x = Math.PI / 2;
            edge2.position.set(0, 0.9 + headLength / 2, -0.01);
            spear.add(edge2);
            
            // Socket/collar where blade meets shaft
            const socketGeo = new THREE.CylinderGeometry(0.04, 0.035, 0.12, 8);
            const socket = new THREE.Mesh(socketGeo, bladeMat.clone());
            socket.position.y = 0.85;
            socket.castShadow = true;
            spear.add(socket);
            
            // Decorative bands on shaft
            for (let i = 0; i < 3; i++) {
                const bandGeo = new THREE.CylinderGeometry(0.028, 0.028, 0.02, 8);
                const bandMat = new THREE.MeshStandardMaterial({
                    color: 0x2a2a2a,
                    roughness: 0.6,
                    metalness: 0.4
                });
                const band = new THREE.Mesh(bandGeo, bandMat);
                band.position.y = 0.6 - (i * 0.15);
                spear.add(band);
            }
            
            // Butt cap (metal end cap at bottom)
            const capGeo = new THREE.ConeGeometry(0.035, 0.08, 8);
            const cap = new THREE.Mesh(capGeo, bladeMat.clone());
            cap.position.y = -0.95;
            cap.castShadow = true;
            spear.add(cap);
            
            // Position for FPS view - spear held low and forward like image 3
            spear.rotation.set(1.3, 0, 0); // Angled forward and down
            spear.position.set(0.25, -0.5, -0.6);
            
            return spear;
        }
        
        async function createBowModel() {
            const bow = new THREE.Group();
            
            // Bow riser (central grip)
            const riserGeo = new THREE.BoxGeometry(0.06, 0.35, 0.04);
            const riserMat = await createWoodMaterial(0x654321, 0.8);
            const riser = new THREE.Mesh(riserGeo, riserMat);
            riser.castShadow = true;
            bow.add(riser);
            
            // Grip wrap in middle
            const gripGeo = new THREE.BoxGeometry(0.07, 0.12, 0.045);
            const gripMat = new THREE.MeshStandardMaterial({
                color: 0x3d2817,
                roughness: 0.95
            });
            const grip = new THREE.Mesh(gripGeo, gripMat);
            bow.add(grip);
            
            // Upper limb (curved)
            const upperLimbCurve = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(0, 0.18, 0),
                new THREE.Vector3(-0.08, 0.35, 0),
                new THREE.Vector3(-0.05, 0.5, 0)
            );
            const upperLimbGeo = new THREE.TubeGeometry(upperLimbCurve, 20, 0.018, 8, false);
            const limbMat = await createWoodMaterial(0x8B4513, 0.85);
            const upperLimb = new THREE.Mesh(upperLimbGeo, limbMat);
            upperLimb.castShadow = true;
            bow.add(upperLimb);
            
            // Lower limb (curved)
            const lowerLimbCurve = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(0, -0.18, 0),
                new THREE.Vector3(-0.08, -0.35, 0),
                new THREE.Vector3(-0.05, -0.5, 0)
            );
            const lowerLimbGeo = new THREE.TubeGeometry(lowerLimbCurve, 20, 0.018, 8, false);
            const lowerLimb = new THREE.Mesh(lowerLimbGeo, limbMat.clone());
            lowerLimb.castShadow = true;
            bow.add(lowerLimb);
            
            // Bowstring
            const stringPoints = [
                new THREE.Vector3(-0.05, 0.5, 0),
                new THREE.Vector3(0.12, 0, 0),
                new THREE.Vector3(-0.05, -0.5, 0)
            ];
            const stringCurve = new THREE.CatmullRomCurve3(stringPoints);
            const stringGeo = new THREE.TubeGeometry(stringCurve, 20, 0.003, 4, false);
            const stringMat = new THREE.MeshStandardMaterial({
                color: 0xdddddd,
                roughness: 0.6,
                metalness: 0.1
            });
            const bowstring = new THREE.Mesh(stringGeo, stringMat);
            bow.add(bowstring);
            
            // Nocking point (small marker on string)
            const nockGeo = new THREE.SphereGeometry(0.008, 6, 6);
            const nockMat = new THREE.MeshStandardMaterial({
                color: 0xff3300,
                roughness: 0.7
            });
            const nock = new THREE.Mesh(nockGeo, nockMat);
            nock.position.set(0.12, 0, 0);
            bow.add(nock);
            
            // Arrow rest (small shelf on riser)
            const restGeo = new THREE.BoxGeometry(0.04, 0.02, 0.015);
            const rest = new THREE.Mesh(restGeo, riserMat.clone());
            rest.position.set(0.03, 0, 0);
            bow.add(rest);
            
            // Create nocked arrow (visible when holding bow)
            const arrowGroup = new THREE.Group();
            
            // Arrow shaft
            const shaftGeo = new THREE.CylinderGeometry(0.005, 0.005, 0.6, 6);
            const shaftMat = await createWoodMaterial(0x8B6914, 0.7);
            const shaft = new THREE.Mesh(shaftGeo, shaftMat);
            shaft.rotation.z = Math.PI / 2;
            arrowGroup.add(shaft);
            
            // Arrow head (pointed)
            const headGeo = new THREE.ConeGeometry(0.012, 0.04, 6);
            const headMat = await createMetalMaterial(0x666666, 0.4);
            const head = new THREE.Mesh(headGeo, headMat);
            head.rotation.z = -Math.PI / 2;
            head.position.x = 0.32;
            arrowGroup.add(head);
            
            // Fletching (feathers)
            for (let i = 0; i < 3; i++) {
                const fletchGeo = new THREE.PlaneGeometry(0.03, 0.08);
                const fletchMat = new THREE.MeshStandardMaterial({
                    color: 0xff3300,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8
                });
                const fletch = new THREE.Mesh(fletchGeo, fletchMat);
                fletch.position.x = -0.28;
                fletch.rotation.y = (i * Math.PI * 2 / 3);
                arrowGroup.add(fletch);
            }
            
            // Nock (back of arrow)
            const nockEndGeo = new THREE.CylinderGeometry(0.006, 0.003, 0.015, 6);
            const nockEnd = new THREE.Mesh(nockEndGeo, shaftMat.clone());
            nockEnd.rotation.z = Math.PI / 2;
            nockEnd.position.x = -0.3;
            arrowGroup.add(nockEnd);
            
            // Position arrow on the bow (on the string)
            arrowGroup.position.set(0.12, 0, 0);
            arrowGroup.rotation.set(0, 0, 0);
            bow.add(arrowGroup);
            bow.userData.arrow = arrowGroup; // Store reference for shooting
            
            // Position for FPS view - bow vertical, string toward player
            bow.rotation.set(0, Math.PI / 2, 0);
            bow.position.set(0.15, -0.2, -0.4);
            
            return bow;
        }
        
        async function createPistolModel() {
            await _loadAssetGLB('Pistol.glb');
            const glb = _instantiateGLB('Pistol.glb', 0.28, new THREE.Vector3(0.08, -0.12, -0.22));
            if (glb) { glb.rotation.set(-0.05, -0.05, 0); return glb; }

            const pistol = new THREE.Group();
            
            // Slide (top part) - detailed with texture
            const slideGeo = new THREE.BoxGeometry(0.09, 0.08, 0.38);
            const slideMat = await createMetalMaterial(0x1a1a1a, 0.3);
            const slide = new THREE.Mesh(slideGeo, slideMat);
            slide.position.set(0, 0.025, -0.4);
            slide.castShadow = true;
            pistol.add(slide);
            
            // Slide serrations (grip lines on top)
            for (let i = 0; i < 6; i++) {
                const serrationGeo = new THREE.BoxGeometry(0.092, 0.015, 0.02);
                const serrationMat = new THREE.MeshStandardMaterial({
                    color: 0x0a0a0a,
                    roughness: 0.9,
                    metalness: 0.3
                });
                const serration = new THREE.Mesh(serrationGeo, serrationMat);
                serration.position.set(0, 0.06, -0.3 - (i * 0.04));
                pistol.add(serration);
            }
            
            // Ejection port
            const portGeo = new THREE.BoxGeometry(0.03, 0.02, 0.08);
            const portMat = new THREE.MeshStandardMaterial({
                color: 0x000000,
                roughness: 0.8
            });
            const port = new THREE.Mesh(portGeo, portMat);
            port.position.set(0.048, 0.04, -0.35);
            pistol.add(port);
            
            // Barrel - detailed
            const barrelGeo = new THREE.CylinderGeometry(0.018, 0.018, 0.18, 12);
            const barrelMat = await createMetalMaterial(0x0a0a0a, 0.2);
            const barrel = new THREE.Mesh(barrelGeo, barrelMat);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.set(0, 0.02, -0.68);
            barrel.castShadow = true;
            pistol.add(barrel);
            
            // Barrel crown (muzzle)
            const crownGeo = new THREE.CylinderGeometry(0.022, 0.018, 0.02, 12);
            const crown = new THREE.Mesh(crownGeo, barrelMat.clone());
            crown.rotation.x = Math.PI / 2;
            crown.position.set(0, 0.02, -0.77);
            pistol.add(crown);
            
            // Frame/Receiver - textured
            const frameGeo = new THREE.BoxGeometry(0.085, 0.16, 0.14);
            const frameMat = await createMetalMaterial(0x2a2a2a, 0.4);
            const frame = new THREE.Mesh(frameGeo, frameMat);
            frame.position.set(0, -0.055, -0.26);
            frame.castShadow = true;
            pistol.add(frame);
            
            // Grip - textured with checkering
            const gripGeo = new THREE.BoxGeometry(0.078, 0.11, 0.105);
            const gripMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                roughness: 0.95,
                metalness: 0.1
            });
            const grip = new THREE.Mesh(gripGeo, gripMat);
            grip.position.set(0, -0.11, -0.26);
            grip.castShadow = true;
            pistol.add(grip);
            
            // Grip texture panels (checkering simulation)
            const panelGeo = new THREE.PlaneGeometry(0.06, 0.08);
            const panelMat = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,
                roughness: 1,
                side: THREE.DoubleSide
            });
            const leftPanel = new THREE.Mesh(panelGeo, panelMat);
            leftPanel.position.set(-0.04, -0.11, -0.26);
            leftPanel.rotation.y = Math.PI / 2;
            pistol.add(leftPanel);
            
            const rightPanel = new THREE.Mesh(panelGeo, panelMat.clone());
            rightPanel.position.set(0.04, -0.11, -0.26);
            rightPanel.rotation.y = -Math.PI / 2;
            pistol.add(rightPanel);
            
            // Trigger guard - curved
            const guardGeo = new THREE.TorusGeometry(0.035, 0.008, 8, 16, Math.PI);
            const guardMat = await createMetalMaterial(0x333333, 0.35);
            const triggerGuard = new THREE.Mesh(guardGeo, guardMat);
            triggerGuard.rotation.x = Math.PI / 2;
            triggerGuard.position.set(0, -0.025, -0.29);
            triggerGuard.castShadow = true;
            pistol.add(triggerGuard);
            
            // Trigger - detailed
            const triggerGeo = new THREE.BoxGeometry(0.018, 0.035, 0.012);
            const triggerMat = await createMetalMaterial(0x1a1a1a, 0.4);
            const trigger = new THREE.Mesh(triggerGeo, triggerMat);
            trigger.position.set(0, -0.015, -0.29);
            trigger.castShadow = true;
            pistol.add(trigger);
            
            // Trigger shoe (curved part)
            const shoeGeo = new THREE.SphereGeometry(0.012, 8, 8);
            const shoe = new THREE.Mesh(shoeGeo, triggerMat.clone());
            shoe.position.set(0, -0.03, -0.29);
            shoe.scale.set(1, 1.5, 0.8);
            pistol.add(shoe);
            
            // Sights - fiber optic style
            const rearSightGeo = new THREE.BoxGeometry(0.035, 0.025, 0.015);
            const sightMat = await createMetalMaterial(0x2a2a2a, 0.5);
            const rearSight = new THREE.Mesh(rearSightGeo, sightMat);
            rearSight.position.set(0, 0.07, -0.25);
            rearSight.castShadow = true;
            pistol.add(rearSight);
            
            // Rear sight dot (luminescent)
            const rearDotGeo = new THREE.SphereGeometry(0.006, 6, 6);
            const dotMat = new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 0.6,
                roughness: 0.3
            });
            const rearDotL = new THREE.Mesh(rearDotGeo, dotMat);
            rearDotL.position.set(-0.01, 0.08, -0.25);
            pistol.add(rearDotL);
            
            const rearDotR = new THREE.Mesh(rearDotGeo, dotMat.clone());
            rearDotR.position.set(0.01, 0.08, -0.25);
            pistol.add(rearDotR);
            
            // Front sight
            const frontSightGeo = new THREE.BoxGeometry(0.02, 0.03, 0.012);
            const frontSight = new THREE.Mesh(frontSightGeo, sightMat.clone());
            frontSight.position.set(0, 0.07, -0.62);
            frontSight.castShadow = true;
            pistol.add(frontSight);
            
            // Front sight fiber optic
            const frontDotGeo = new THREE.CylinderGeometry(0.004, 0.004, 0.015, 6);
            const frontDotMat = new THREE.MeshStandardMaterial({
                color: 0xff3300,
                emissive: 0xff3300,
                emissiveIntensity: 0.8,
                roughness: 0.2,
                transparent: true,
                opacity: 0.9
            });
            const frontDot = new THREE.Mesh(frontDotGeo, frontDotMat);
            frontDot.position.set(0, 0.08, -0.62);
            pistol.add(frontDot);
            
            // Magazine (clip) - detailed
            const magGeo = new THREE.BoxGeometry(0.065, 0.14, 0.09);
            const magMat = await createMetalMaterial(0x1a1a1a, 0.4);
            const magazine = new THREE.Mesh(magGeo, magMat);
            magazine.position.set(0, -0.15, -0.26);
            magazine.castShadow = true;
            pistol.add(magazine);
            
            // Magazine base plate
            const basePlateGeo = new THREE.BoxGeometry(0.07, 0.015, 0.095);
            const basePlate = new THREE.Mesh(basePlateGeo, magMat.clone());
            basePlate.position.set(0, -0.22, -0.26);
            pistol.add(basePlate);
            
            // Magazine release button
            const releaseGeo = new THREE.CylinderGeometry(0.008, 0.008, 0.015, 8);
            const releaseMat = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.6,
                metalness: 0.7
            });
            const release = new THREE.Mesh(releaseGeo, releaseMat);
            release.rotation.z = Math.PI / 2;
            release.position.set(-0.048, -0.02, -0.26);
            pistol.add(release);
            
            // Rail system (tactical rail)
            const railGeo = new THREE.BoxGeometry(0.025, 0.008, 0.15);
            const railMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                roughness: 0.7,
                metalness: 0.5
            });
            const rail = new THREE.Mesh(railGeo, railMat);
            rail.position.set(0, -0.01, -0.35);
            pistol.add(rail);
            
            pistol.userData.magazine = magazine; // Store reference for reload animation
            
            // Position and rotate for proper FPS view
            pistol.rotation.x = 0.1;
            pistol.rotation.y = -0.05;
            pistol.rotation.z = 0;
            pistol.position.set(0.12, -0.15, -0.35);
            
            return pistol;
        }
        
        async function updateHeldItem() {
            // Clear current held item
            while (heldItemGroup.children.length > 0) {
                heldItemGroup.remove(heldItemGroup.children[0]);
            }
            
            const selectedItem = hotbar[selectedHotbarSlot].item;
            
            if (!selectedItem || inventory[selectedItem] <= 0) {
                currentHeldItem = null;
                if (fpsArmGroup) fpsArmGroup.visible = false;
                // Hide pistol crosshair
                const pistolCrosshair = document.getElementById('pistol-crosshair');
                if (pistolCrosshair) pistolCrosshair.style.display = 'none';
                return;
            }
            
            currentHeldItem = selectedItem;
            
            let model = null;
            
            if (selectedItem === 'sharp_stone') {
                model = await createSharpStoneModel();
            } else if (selectedItem === 'axe') {
                model = await createAxeModel();
            } else if (selectedItem === 'pickaxe') {
                model = await createPickaxeModel();
            } else if (selectedItem === 'sword') {
                model = await createSwordModel();
            } else if (selectedItem === 'spear') {
                model = await createSpearModel();
            } else if (selectedItem === 'bow') {
                model = await createBowModel();
            } else if (selectedItem === 'pistol') {
                model = await createPistolModel();
            }
            
            if (model) {
                heldItemGroup.add(model);
            }

            // Show the FPS arm when any tool/weapon is equipped
            if (fpsArmGroup) {
                const toolItems = ['axe','stone_axe','pickaxe','stone_pickaxe','sword','spear','bow','pistol','hammer','sharp_stone'];
                fpsArmGroup.visible = toolItems.includes(selectedItem) && !isThirdPerson;
            }

            // Show/hide pistol crosshair and ammo counter
            const pistolCrosshair = document.getElementById('pistol-crosshair');
            const ammoCounter = document.getElementById('ammo-counter');
            if (selectedItem === 'pistol') {
                if (pistolCrosshair) pistolCrosshair.style.display = 'block';
                if (ammoCounter) {
                    ammoCounter.style.display = 'block';
                    ammoCounter.textContent = `${pistolState.currentClip} / ${inventory.pistol_ammo}`;
                }
            } else {
                if (pistolCrosshair) pistolCrosshair.style.display = 'none';
                if (ammoCounter) ammoCounter.style.display = 'none';
            }
        }
        
        function animateTool(toolType) {
            toolAnimation.active = true;
            toolAnimation.time = 0;
            toolAnimation.toolType = toolType || 'default';
            
            // Play appropriate swing sound based on tool
            const heldItem = hotbar[selectedHotbarSlot].item;
            if (heldItem === 'axe' || heldItem === 'stone_axe') {
                playAxeSwingSound();
            } else if (heldItem === 'pickaxe' || heldItem === 'stone_pickaxe') {
                playPickaxeSwingSound();
            } else if (heldItem === 'sword') {
                playSwordSwingSound();
            } else if (heldItem === 'hammer') {
                playHammerSwingSound();
            }
        }
        
        function updateToolAnimation() {
            if (!toolAnimation.active) return;
            
            toolAnimation.time += 0.016; // ~60fps
            
            if (toolAnimation.time >= toolAnimation.duration) {
                toolAnimation.active = false;
                heldItemGroup.rotation.set(0, 0, 0);
                heldItemGroup.position.set(0.28, -0.22, -0.42);
                return;
            }
            
            const progress = toolAnimation.time / toolAnimation.duration;
            const heldItem = hotbar[selectedHotbarSlot].item;
            
            // Tool-specific animations with realistic arcs
            if (heldItem === 'sword') {
                // SWORD: Fast horizontal slash with weight
                if (progress < 0.3) {
                    // Wind up
                    const windUp = progress / 0.3;
                    heldItemGroup.rotation.x = -0.4 + windUp * 0.3;
                    heldItemGroup.rotation.y = -0.8 - windUp * 0.4;
                    heldItemGroup.rotation.z = 0.2;
                    heldItemGroup.position.x = 0.3 - windUp * 0.2;
                    heldItemGroup.position.y = -0.2;
                    heldItemGroup.position.z = -0.4;
                } else if (progress < 0.7) {
                    // Fast slash
                    const slash = (progress - 0.3) / 0.4;
                    const curve = Math.sin(slash * Math.PI);
                    heldItemGroup.rotation.x = -0.1 - curve * 0.3;
                    heldItemGroup.rotation.y = -1.2 + slash * 2.4;
                    heldItemGroup.rotation.z = 0.2 + curve * 0.4;
                    heldItemGroup.position.x = 0.1 + slash * 0.6;
                    heldItemGroup.position.y = -0.2 + curve * 0.15;
                    heldItemGroup.position.z = -0.4 - curve * 0.2;
                } else {
                    // Follow through
                    const follow = (progress - 0.7) / 0.3;
                    heldItemGroup.rotation.x = -0.4 + follow * 0.4;
                    heldItemGroup.rotation.y = 1.2 - follow * 0.4;
                    heldItemGroup.rotation.z = 0.6 - follow * 0.4;
                    heldItemGroup.position.x = 0.7 - follow * 0.4;
                    heldItemGroup.position.y = -0.2;
                    heldItemGroup.position.z = -0.5;
                }
            } else if (heldItem === 'spear') {
                // SPEAR: Forward thrust like image 3
                if (progress < 0.25) {
                    // Pull back
                    const pullBack = progress / 0.25;
                    heldItemGroup.rotation.x = 1.3 - pullBack * 0.2;
                    heldItemGroup.rotation.y = 0;
                    heldItemGroup.rotation.z = 0;
                    heldItemGroup.position.x = 0.25 - pullBack * 0.1;
                    heldItemGroup.position.y = -0.5 + pullBack * 0.1;
                    heldItemGroup.position.z = -0.6 + pullBack * 0.25;
                } else if (progress < 0.6) {
                    // Fast thrust forward
                    const thrust = (progress - 0.25) / 0.35;
                    heldItemGroup.rotation.x = 1.1 + thrust * 0.3;
                    heldItemGroup.rotation.y = 0;
                    heldItemGroup.rotation.z = 0;
                    heldItemGroup.position.x = 0.15 + thrust * 0.05;
                    heldItemGroup.position.y = -0.4 - thrust * 0.15;
                    heldItemGroup.position.z = -0.35 - thrust * 0.9;
                } else {
                    // Return
                    const ret = (progress - 0.6) / 0.4;
                    heldItemGroup.rotation.x = 1.4 - ret * 0.1;
                    heldItemGroup.rotation.y = 0;
                    heldItemGroup.rotation.z = 0;
                    heldItemGroup.position.x = 0.2 + ret * 0.05;
                    heldItemGroup.position.y = -0.55 + ret * 0.05;
                    heldItemGroup.position.z = -1.25 + ret * 0.65;
                }
            } else if (heldItem === 'axe' || heldItem === 'stone_axe') {
                // AXE: Overhead chop with power
                if (progress < 0.4) {
                    // Raise overhead
                    const raise = progress / 0.4;
                    const curve = Math.sin(raise * Math.PI * 0.5);
                    heldItemGroup.rotation.x = -curve * 2.0;
                    heldItemGroup.rotation.y = 0;
                    heldItemGroup.rotation.z = curve * 0.2;
                    heldItemGroup.position.x = 0.3;
                    heldItemGroup.position.y = -0.3 + curve * 0.8;
                    heldItemGroup.position.z = -0.5 + curve * 0.3;
                } else if (progress < 0.8) {
                    // Fast downward chop
                    const chop = (progress - 0.4) / 0.4;
                    const curve = Math.sin(chop * Math.PI);
                    heldItemGroup.rotation.x = -2.0 + chop * 1.6;
                    heldItemGroup.rotation.y = 0;
                    heldItemGroup.rotation.z = 0.2 - curve * 0.3;
                    heldItemGroup.position.x = 0.3;
                    heldItemGroup.position.y = 0.5 - chop * 0.9;
                    heldItemGroup.position.z = -0.2 - chop * 0.5;
                } else {
                    // Recovery
                    const recover = (progress - 0.8) / 0.2;
                    heldItemGroup.rotation.x = -0.4 + recover * 0.4;
                    heldItemGroup.rotation.y = 0;
                    heldItemGroup.rotation.z = -0.1 + recover * 0.1;
                    heldItemGroup.position.x = 0.3;
                    heldItemGroup.position.y = -0.4 + recover * 0.1;
                    heldItemGroup.position.z = -0.7 + recover * 0.2;
                }
            } else if (heldItem === 'pickaxe' || heldItem === 'stone_pickaxe') {
                // PICKAXE: Angled overhead strike
                if (progress < 0.35) {
                    // Wind up high and to the side
                    const windUp = progress / 0.35;
                    const curve = Math.sin(windUp * Math.PI * 0.5);
                    heldItemGroup.rotation.x = -curve * 1.8;
                    heldItemGroup.rotation.y = curve * 0.4;
                    heldItemGroup.rotation.z = curve * 0.3;
                    heldItemGroup.position.x = 0.3 + curve * 0.1;
                    heldItemGroup.position.y = -0.3 + curve * 0.7;
                    heldItemGroup.position.z = -0.5 + curve * 0.2;
                } else if (progress < 0.75) {
                    // Powerful downward strike
                    const strike = (progress - 0.35) / 0.4;
                    const curve = Math.sin(strike * Math.PI);
                    heldItemGroup.rotation.x = -1.8 + strike * 1.4;
                    heldItemGroup.rotation.y = 0.4 - curve * 0.3;
                    heldItemGroup.rotation.z = 0.3;
                    heldItemGroup.position.x = 0.4;
                    heldItemGroup.position.y = 0.4 - strike * 0.8;
                    heldItemGroup.position.z = -0.3 - strike * 0.6;
                } else {
                    // Return
                    const ret = (progress - 0.75) / 0.25;
                    heldItemGroup.rotation.x = -0.4 + ret * 0.4;
                    heldItemGroup.rotation.y = 0.1 - ret * 0.1;
                    heldItemGroup.rotation.z = 0.3 - ret * 0.3;
                    heldItemGroup.position.x = 0.4 - ret * 0.1;
                    heldItemGroup.position.y = -0.4 + ret * 0.1;
                    heldItemGroup.position.z = -0.9 + ret * 0.4;
                }
            } else if (heldItem === 'sharp_stone') {
                // SHARP STONE: Quick stabbing motion
                if (progress < 0.25) {
                    // Pull back
                    const pullBack = progress / 0.25;
                    heldItemGroup.rotation.x = -0.3 - pullBack * 0.3;
                    heldItemGroup.rotation.y = 0;
                    heldItemGroup.rotation.z = -0.2;
                    heldItemGroup.position.x = 0.3 - pullBack * 0.15;
                    heldItemGroup.position.y = -0.25;
                    heldItemGroup.position.z = -0.4 + pullBack * 0.2;
                } else if (progress < 0.6) {
                    // Fast stab forward
                    const stab = (progress - 0.25) / 0.35;
                    heldItemGroup.rotation.x = -0.6 + stab * 0.4;
                    heldItemGroup.rotation.y = 0;
                    heldItemGroup.rotation.z = -0.2;
                    heldItemGroup.position.x = 0.15 + stab * 0.1;
                    heldItemGroup.position.y = -0.25 - stab * 0.1;
                    heldItemGroup.position.z = -0.2 - stab * 0.7;
                } else {
                    // Return
                    const ret = (progress - 0.6) / 0.4;
                    heldItemGroup.rotation.x = -0.2 - ret * 0.1;
                    heldItemGroup.rotation.y = 0;
                    heldItemGroup.rotation.z = -0.2 + ret * 0.2;
                    heldItemGroup.position.x = 0.25 + ret * 0.05;
                    heldItemGroup.position.y = -0.35 + ret * 0.05;
                    heldItemGroup.position.z = -0.9 + ret * 0.4;
                }
            } else {
                // Default swing animation for other tools
                const swing = Math.sin(progress * Math.PI);
                heldItemGroup.rotation.x = -swing * 0.8;
                heldItemGroup.rotation.y = swing * 0.3;
                heldItemGroup.position.x = 0.3 + swing * 0.2;
                heldItemGroup.position.y = -0.3 - swing * 0.15;
                heldItemGroup.position.z = -0.5 - swing * 0.2;
            }
        }
        
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: false, 
            powerPreference: 'high-performance'
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Higher quality
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
        renderer.toneMapping = THREE.ACESFilmicToneMapping; // Cinematic look
        renderer.toneMappingExposure = 0.9; // Reduced brightness
        renderer.outputEncoding = THREE.sRGBEncoding; // Better colors
        renderer.sortObjects = true;
        document.body.appendChild(renderer.domElement);

        // ===== POST-PROCESSING PIPELINE =====
        // Renders the scene into a WebGLRenderTarget, then applies:
        //   1. Ore shimmer  \u2014 screen-space specular highlight boost on bright metallic pixels
        //   2. Wet ground   \u2014 darkens / blue-shifts the lower screen while raining, with
        //                     a gentle ripple distortion; fades out slowly after rain stops.

        let _ppTime    = 0;
        let _hazeAlpha = 0;   // drives pipeline bypass check

        // Render target for the main scene
        const _hazeRT = new THREE.WebGLRenderTarget(
            window.innerWidth, window.innerHeight,
            { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat }
        );

        // Composite shader
        const _hazeMaterial = new THREE.ShaderMaterial({
            uniforms: {
                tDiffuse:  { value: _hazeRT.texture },
                uTime:     { value: 0.0 },
                uWetness:  { value: 0.0 },   // 0=dry, 1=soaked
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = vec4(position.xy, 0.0, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float uTime;
                uniform float uWetness;
                varying vec2 vUv;

                // Luminance helper
                float luma(vec3 c) { return dot(c, vec3(0.299, 0.587, 0.114)); }

                void main() {
                    vec2 uv = vUv;

                    // \u2500\u2500 WET GROUND: ripple distortion in lower 40% of screen \u2500\u2500
                    // groundZone: 1 at very bottom, 0 at the horizon line (uv.y=0.6)
                    float groundZone = clamp((0.6 - uv.y) / 0.6, 0.0, 1.0);
                    groundZone = groundZone * groundZone; // ease off toward horizon

                    if (uWetness > 0.001 && groundZone > 0.0) {
                        float w   = uWetness * groundZone;
                        float amp = w * 0.0018;
                        // Two overlapping ripple frequencies
                        float rx = sin(uTime * 1.8 + uv.y * 38.0 + uv.x * 12.0) * amp
                                 + sin(uTime * 3.1 + uv.y * 72.0 - uv.x * 20.0) * amp * 0.45;
                        float ry = cos(uTime * 2.2 + uv.x * 31.0 + uv.y * 15.0) * amp * 0.6;
                        uv += vec2(rx, ry);
                    }

                    vec4 col = texture2D(tDiffuse, uv);

                    // \u2500\u2500 WET GROUND: colour grade the lower screen \u2500\u2500
                    if (uWetness > 0.001 && groundZone > 0.0) {
                        float w = uWetness * groundZone;
                        // Darken (wet surfaces absorb more light)
                        col.rgb *= 1.0 - w * 0.28;
                        // Slight blue/cool tint \u2014 standing water reflects the sky
                        col.rgb += vec3(-0.02, -0.01, 0.06) * w;
                        // Desaturate a little toward a reflective grey
                        float lum = luma(col.rgb);
                        col.rgb   = mix(col.rgb, vec3(lum), w * 0.18);
                    }

                    gl_FragColor = col;
                }
            `,
            depthTest: false,
            depthWrite: false
        });

        // Fullscreen triangle (covers NDC -1..1, no quad diagonal seam)
        const _hazeGeo = new THREE.BufferGeometry();
        _hazeGeo.setAttribute('position', new THREE.BufferAttribute(
            new Float32Array([-1,-1,0,  3,-1,0,  -1,3,0]), 3));
        _hazeGeo.setAttribute('uv', new THREE.BufferAttribute(
            new Float32Array([0,0,  2,0,  0,2]), 2));
        const _hazeMesh = new THREE.Mesh(_hazeGeo, _hazeMaterial);
        _hazeMesh.frustumCulled = false;

        // Minimal composite scene + orthographic camera
        const _hazeScene  = new THREE.Scene();
        _hazeScene.add(_hazeMesh);
        const _hazeCamera = new THREE.OrthographicCamera(-1,1,1,-1,0,1);

        // Resize render target with window
        window.addEventListener('resize', () => {
            _hazeRT.setSize(window.innerWidth, window.innerHeight);
        });

        function updateHeatHaze() {
            _ppTime += 0.016;

            // Wetness driven by the same _wetness scalar as groundMaterial
            _hazeMaterial.uniforms.uTime.value    = _ppTime;
            _hazeMaterial.uniforms.uWetness.value = _wetness;
        }
        
        // ===== ENHANCED LIGHTING =====
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3); // Back to white, reduced brightness
        scene.add(ambientLight);
        
        const sun = new THREE.DirectionalLight(0xffffff, 1.5); // Back to white, moderate brightness
        sun.position.set(50, 100, 50);
        sun.castShadow = true;
        sun.shadow.camera.left = -60;
        sun.shadow.camera.right = 60;
        sun.shadow.camera.top = 60;
        sun.shadow.camera.bottom = -60;
        sun.shadow.camera.near = 0.5;
        sun.shadow.camera.far = 200;
        sun.shadow.mapSize.width = 2048; // Keep higher quality shadows
        sun.shadow.mapSize.height = 2048;
        sun.shadow.bias = -0.0001;
        sun.shadow.radius = 2; // Keep softer shadow edges
        scene.add(sun);
        
        const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x8B7355, 0.4); // Original colors, reduced
        scene.add(hemiLight);
        
        // Add atmospheric fog for depth
        scene.fog = new THREE.Fog(0x87CEEB, 60, 170);
        
        // Flashlight
        const flashlight = new THREE.SpotLight(0xffd700, 1.5, 30, Math.PI / 6, 0.5, 2);
        flashlight.position.copy(camera.position);
        flashlight.target.position.set(0, 0, -1);
        flashlight.castShadow = true;
        flashlight.shadow.mapSize.width = 1024;
        flashlight.shadow.mapSize.height = 1024;
        scene.add(flashlight);
        scene.add(flashlight.target);
        let flashlightOn = false;
        
        // Lightning flash light - very bright white floodlight
        const lightningLight = new THREE.PointLight(0xffffff, 0, 150);
        lightningLight.position.set(0, 50, 0);
        scene.add(lightningLight);
        let lightningActive = false;
        let lightningStartTime = 0;
        let lightningDuration = 0;
        
        // ===== ENHANCED TERRAIN (FLATTENED) =====
        const groundSize = 200;
        // Simple single-quad \ufffd all variation handled in the shader, no vertex seams
        const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize, 1, 1);
        groundGeometry.computeVertexNormals();
        
        // ===== PROCEDURAL GRASS TEXTURE =====
        const rng = (min, max) => Math.random() * (max - min) + min;

        const grassCanvas = document.createElement('canvas');
        grassCanvas.width = 256;
        grassCanvas.height = 256;
        const grassCtx = grassCanvas.getContext('2d');

        // Seamless tiling integer-hash value noise using periodic lattice
        function vnoise(x, y, freq, seed) {
            const period = freq; // lattice wraps at period
            const ix = Math.floor(x * freq), iy = Math.floor(y * freq);
            const fx = x * freq - ix, fy = y * freq - iy;
            const ux = fx * fx * (3 - 2 * fx), uy = fy * fy * (3 - 2 * fy);
            // Wrap lattice coords so texture tiles perfectly
            const ih = (px, py) => {
                const wx = ((px % period) + period) % period;
                const wy = ((py % period) + period) % period;
                let n = ((wx * 1619 + wy * 31337 + seed * 351) | 0) * 1540483477;
                n = (n ^ (n >>> 13)) * 1540483477;
                return ((n >>> 0) & 0xffff) / 65535;
            };
            return ih(ix,iy)*(1-ux)*(1-uy) + ih(ix+1,iy)*ux*(1-uy) +
                   ih(ix,iy+1)*(1-ux)*uy   + ih(ix+1,iy+1)*ux*uy;
        }

        // 256\ufffd256 pixel-by-pixel FBM \ufffd ~65k iterations, fast
        const imgData = grassCtx.createImageData(256, 256);
        const pix = imgData.data;
        for (let gy = 0; gy < 256; gy++) {
            for (let gx = 0; gx < 256; gx++) {
                const nx = gx / 256, ny = gy / 256;
                const n1 = vnoise(nx, ny, 3,  1);
                const n2 = vnoise(nx, ny, 8,  42);
                const n3 = vnoise(nx, ny, 20, 77);
                const n4 = vnoise(nx, ny, 50, 13);
                const fbm = n1*0.50 + n2*0.28 + n3*0.14 + n4*0.08;

                let pr, pg, pb;
                if (fbm < 0.30) {
                    const t = fbm / 0.30;
                    pr = 4 + t * 6 | 0;   pg = 10 + t * 10 | 0;  pb = 3 + t * 4 | 0;
                } else if (fbm < 0.55) {
                    const t = (fbm - 0.30) / 0.25;
                    pr = 10 + t * 10 | 0;  pg = 20 + t * 18 | 0;  pb = 7 + t * 4 | 0;
                } else if (fbm < 0.75) {
                    const t = (fbm - 0.55) / 0.20;
                    pr = 20 + t * 12 | 0;  pg = 38 + t * 12 | 0;  pb = 11 - t * 3 | 0;
                } else {
                    const t = (fbm - 0.75) / 0.25;
                    pr = 32 + t * 12 | 0;  pg = 50 + t * 10 | 0;  pb = 8 + t * 6 | 0;
                }
                if (n4 > 0.88) { pr = pr*0.50|0; pg = pg*0.50|0; pb = pb*0.50|0; }
                if (n3 > 0.91 && n4 > 0.6) { pr = Math.min(255,pr+18); pg = Math.min(255,pg+16); pb = Math.min(255,pb+5); }

                const idx = (gy * 256 + gx) * 4;
                pix[idx]   = pr < 0 ? 0 : pr > 255 ? 255 : pr;
                pix[idx+1] = pg < 0 ? 0 : pg > 255 ? 255 : pg;
                pix[idx+2] = pb < 0 ? 0 : pb > 255 ? 255 : pb;
                pix[idx+3] = 255;
            }
        }
        grassCtx.putImageData(imgData, 0, 0);

        // Fine blade strokes over the base \ufffd seamlessly tiled by wrapping strokes at edges
        for (let i = 0; i < 600; i++) {
            const bx = Math.random() * 256, by = Math.random() * 256;
            const bh = 3 + Math.random() * 9;
            const hue = 88 + (Math.random() - 0.5) * 30;
            const sat = 28 + Math.random() * 35;
            const lit = 4 + Math.random() * 8;
            const cpx = bx + (Math.random()-0.5)*4;
            const cpy = by - bh*0.6;
            const epx = bx + (Math.random()-0.5)*5;
            const epy = by - bh;
            grassCtx.strokeStyle = `hsla(${hue|0},${sat|0}%,${lit|0}%,${0.30 + Math.random()*0.45})`;
            grassCtx.lineWidth = 0.4 + Math.random() * 0.8;
            // Draw the blade stroke tiled across all 4 quadrant wraps so edges match
            for (let ox = -256; ox <= 256; ox += 256) {
                for (let oy = -256; oy <= 256; oy += 256) {
                    grassCtx.beginPath();
                    grassCtx.moveTo(bx + ox, by + oy);
                    grassCtx.quadraticCurveTo(cpx + ox, cpy + oy, epx + ox, epy + oy);
                    grassCtx.stroke();
                }
            }
        }

        const groundTexture = new THREE.CanvasTexture(grassCanvas);
        groundTexture.wrapS = THREE.RepeatWrapping;
        groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set(24, 24);
        groundTexture.anisotropy = 4;

        // Dirt / mud texture for decals under trees & nodes - MUCH MORE VISIBLE
        const dirtCanvas = document.createElement('canvas');
        dirtCanvas.width = 128;
        dirtCanvas.height = 128;
        const dirtCtx = dirtCanvas.getContext('2d');
        dirtCtx.fillStyle = '#3d2510'; // Much darker brown for high contrast
        dirtCtx.fillRect(0, 0, 128, 128);
        for (let i = 0; i < 60; i++) {
            const px = rng(0, 128), py = rng(0, 128), r = rng(4, 18);
            const g = dirtCtx.createRadialGradient(px, py, 0, px, py, r);
            g.addColorStop(0, 'rgba(50,30,10,0.9)'); // Very dark and opaque
            g.addColorStop(1, 'rgba(40,25,8,0)');
            dirtCtx.fillStyle = g;
            dirtCtx.beginPath();
            dirtCtx.ellipse(px, py, r * 1.5, r * 0.8, rng(0, Math.PI), 0, Math.PI * 2);
            dirtCtx.fill();
        }
        for (let i = 0; i < 200; i++) {
            const px = rng(0, 128), py = rng(0, 128);
            dirtCtx.fillStyle = `rgba(${60+Math.random()*30|0},${40+Math.random()*15|0},${10+Math.random()*10|0},0.6)`; // Dark specks
            dirtCtx.fillRect(px, py, 1, 1);
        }
        const dirtTexture = new THREE.CanvasTexture(dirtCanvas);
        dirtTexture.wrapS = THREE.ClampToEdgeWrapping;
        dirtTexture.wrapT = THREE.ClampToEdgeWrapping;

        // Helper: place a round dirt decal at (x, z) with given radius
        function spawnDirtPatch(x, z, radius, darkness = 1.0) {
            // Geometry built directly in the XZ plane ? no rotation needed.
            const spokeCount = 18 + Math.floor(Math.random() * 10);
            const angleOffset = Math.random() * Math.PI * 2;
            const positions = [];
            const uvs = [];
            const indices = [];

            positions.push(0, 0, 0);
            uvs.push(0.5, 0.5);

            for (let i = 0; i < spokeCount; i++) {
                const angle = angleOffset + (i / spokeCount) * Math.PI * 2;
                const coarse = 1.0 + Math.sin(angle * (2 + Math.random() * 2)) * 0.22;
                const fine   = 1.0 + (Math.random() - 0.5) * 0.28;
                const lump   = Math.random() < 0.3 ? 1.0 + Math.random() * 0.25 : 1.0;
                const r = radius * coarse * fine * lump;
                positions.push(Math.cos(angle) * r, 0, Math.sin(angle) * r);
                uvs.push(0.5 + Math.cos(angle) * 0.5 * lump,
                         0.5 + Math.sin(angle) * 0.5 * lump);
            }

            for (let i = 1; i <= spokeCount; i++) {
                indices.push(0, i, i < spokeCount ? i + 1 : 1);
            }

            const decalGeo = new THREE.BufferGeometry();
            decalGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            decalGeo.setAttribute('uv',       new THREE.Float32BufferAttribute(uvs, 2));
            decalGeo.setIndex(indices);
            decalGeo.computeVertexNormals();

            // Create a detailed dirt texture procedurally
            const texSize = 256;
            const canvas = document.createElement('canvas');
            canvas.width = texSize;
            canvas.height = texSize;
            const ctx = canvas.getContext('2d');
            
            // Base dirt color
            const baseR = Math.round(0x3a * darkness);
            const baseG = Math.round(0x23 * darkness);
            const baseB = Math.round(0x10 * darkness);
            ctx.fillStyle = `rgb(${baseR},${baseG},${baseB})`;
            ctx.fillRect(0, 0, texSize, texSize);
            
            // Add dirt clumps and variation
            for (let i = 0; i < 150; i++) {
                const px = Math.random() * texSize;
                const py = Math.random() * texSize;
                const size = 5 + Math.random() * 20;
                const brightness = (30 + Math.random() * 40) * darkness;
                
                const gradient = ctx.createRadialGradient(px, py, 0, px, py, size);
                gradient.addColorStop(0, `rgba(${brightness + 20}, ${brightness}, ${brightness * 0.4}, 0.8)`);
                gradient.addColorStop(1, `rgba(${brightness}, ${brightness * 0.7}, ${brightness * 0.3}, 0)`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(px, py, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Add small pebbles and texture detail
            for (let i = 0; i < 400; i++) {
                const px = Math.random() * texSize;
                const py = Math.random() * texSize;
                const r = Math.random() * 3;
                const shade = (20 + Math.random() * 50) * darkness;
                ctx.fillStyle = `rgba(${shade}, ${shade * 0.8}, ${shade * 0.5}, ${0.5 + Math.random() * 0.5})`;
                ctx.beginPath();
                ctx.arc(px, py, r, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Add fine grain noise
            const imageData = ctx.getImageData(0, 0, texSize, texSize);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const noise = (Math.random() - 0.5) * 30;
                data[i] += noise;     // R
                data[i + 1] += noise * 0.8; // G
                data[i + 2] += noise * 0.6; // B
            }
            ctx.putImageData(imageData, 0, 0);
            
            const dirtTexture = new THREE.CanvasTexture(canvas);
            dirtTexture.wrapS = THREE.RepeatWrapping;
            dirtTexture.wrapT = THREE.RepeatWrapping;

            // MeshStandardMaterial with new detailed texture
            const decalMat = new THREE.MeshStandardMaterial({
                map: dirtTexture,
                roughness: 0.95,
                metalness: 0,
                side: THREE.DoubleSide,
                polygonOffset: true,
                polygonOffsetFactor: -10,
                polygonOffsetUnits: -10,
            });

            const decal = new THREE.Mesh(decalGeo, decalMat);
            decal.position.set(x, -0.01, z);
            decal.renderOrder = 2;
            decal.receiveShadow = true;
            return decal;
        }

        // Second seamless grass texture with different seeds for variety \ufffd no rotation artifacts
        const grassCanvas2 = document.createElement('canvas');
        grassCanvas2.width = 256; grassCanvas2.height = 256;
        const gc2 = grassCanvas2.getContext('2d');
        const imgData2 = gc2.createImageData(256, 256);
        const pix2 = imgData2.data;
        for (let gy = 0; gy < 256; gy++) {
            for (let gx = 0; gx < 256; gx++) {
                const nx = gx / 256, ny = gy / 256;
                const n1 = vnoise(nx, ny, 3,  99);
                const n2 = vnoise(nx, ny, 8,  17);
                const n3 = vnoise(nx, ny, 20, 55);
                const n4 = vnoise(nx, ny, 50, 88);
                const fbm = n1*0.50 + n2*0.28 + n3*0.14 + n4*0.08;
                let pr, pg, pb;
                if (fbm < 0.30) {
                    const t = fbm / 0.30;
                    pr = 4 + t * 5 | 0;   pg = 9 + t * 9 | 0;   pb = 3 + t * 3 | 0;
                } else if (fbm < 0.55) {
                    const t = (fbm - 0.30) / 0.25;
                    pr = 9 + t * 10 | 0;  pg = 18 + t * 18 | 0;  pb = 6 + t * 4 | 0;
                } else if (fbm < 0.75) {
                    const t = (fbm - 0.55) / 0.20;
                    pr = 19 + t * 12 | 0; pg = 36 + t * 12 | 0;  pb = 10 - t * 3 | 0;
                } else {
                    const t = (fbm - 0.75) / 0.25;
                    pr = 31 + t * 12 | 0; pg = 48 + t * 10 | 0;  pb = 7 + t * 5 | 0;
                }
                if (n4 > 0.88) { pr = pr*0.50|0; pg = pg*0.50|0; pb = pb*0.50|0; }
                if (n3 > 0.91 && n4 > 0.6) { pr = Math.min(255,pr+16); pg = Math.min(255,pg+14); pb = Math.min(255,pb+4); }
                const idx2 = (gy * 256 + gx) * 4;
                pix2[idx2]   = pr < 0 ? 0 : pr > 255 ? 255 : pr;
                pix2[idx2+1] = pg < 0 ? 0 : pg > 255 ? 255 : pg;
                pix2[idx2+2] = pb < 0 ? 0 : pb > 255 ? 255 : pb;
                pix2[idx2+3] = 255;
            }
        }
        gc2.putImageData(imgData2, 0, 0);
        for (let i = 0; i < 600; i++) {
            const bx = Math.random() * 256, by = Math.random() * 256;
            const bh = 3 + Math.random() * 9;
            const hue = 85 + (Math.random() - 0.5) * 28;
            const sat = 25 + Math.random() * 38;
            const lit = 3 + Math.random() * 8;
            const cpx = bx + (Math.random()-0.5)*4, cpy = by - bh*0.6;
            const epx = bx + (Math.random()-0.5)*5, epy = by - bh;
            gc2.strokeStyle = `hsla(${hue|0},${sat|0}%,${lit|0}%,${0.28 + Math.random()*0.45})`;
            gc2.lineWidth = 0.4 + Math.random() * 0.8;
            for (let ox = -256; ox <= 256; ox += 256) {
                for (let oy = -256; oy <= 256; oy += 256) {
                    gc2.beginPath();
                    gc2.moveTo(bx + ox, by + oy);
                    gc2.quadraticCurveTo(cpx + ox, cpy + oy, epx + ox, epy + oy);
                    gc2.stroke();
                }
            }
        }
        const groundTexture2 = new THREE.CanvasTexture(grassCanvas2);
        groundTexture2.wrapS = groundTexture2.wrapT = THREE.RepeatWrapping;
        groundTexture2.repeat.set(16, 16);
        groundTexture2.anisotropy = 4;

        const groundMaterial = new THREE.MeshStandardMaterial({
            map: groundTexture,
            roughness: 0.92,
            metalness: 0.0,
            color: 0xffffff,
        });
        // Use alphaMap trick: blend two textures via UV offset so seams never align
        groundTexture.repeat.set(18, 18);
        groundTexture.offset.set(0.13, 0.27); // offset breaks symmetry
        
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        ground.renderOrder = 0;
        scene.add(ground);

        // ===== DESERT BIOME TERRAIN =====
        // Placed adjacent to the grass biome, offset by groundSize along Z axis
        const desertOffset = groundSize; // sits directly north of the grass biome

        // ===== DESERT SAND TEXTURE \ufffd complete rebuild =====
        // 512px for crisp detail. Uses same seamless vnoise as grass.
        const SAND_SZ = 512;

        // Helper: clamp to [0,255]
        const clamp8 = v => v < 0 ? 0 : v > 255 ? 255 : v | 0;

        // ---- Base sand pixel layer ----
        // Three FBM octave sets at different frequencies build:
        //   large dune-scale colour swells, medium ripple bands, fine grain speckle
        const sandCanvas = document.createElement('canvas');
        sandCanvas.width = SAND_SZ; sandCanvas.height = SAND_SZ;
        const sandCtx = sandCanvas.getContext('2d');
        const sandImgData = sandCtx.createImageData(SAND_SZ, SAND_SZ);
        const sandPix = sandImgData.data;

        for (let gy = 0; gy < SAND_SZ; gy++) {
            for (let gx = 0; gx < SAND_SZ; gx++) {
                const nx = gx / SAND_SZ, ny = gy / SAND_SZ;

                // Large dune swells \ufffd very low frequency
                const dune  = vnoise(nx, ny, 2, 301) * 0.6 + vnoise(nx, ny, 4, 177) * 0.4;

                // Wind-ripple bands \ufffd directional, predominantly along X axis
                // Use anisotropic sampling: stretch Y coordinate to create horizontal banding
                const ripA  = vnoise(nx * 0.6, ny * 3.5, 6,  119);  // coarse ripples
                const ripB  = vnoise(nx * 0.5, ny * 6.0, 12, 83);   // fine ripples
                const rip   = ripA * 0.55 + ripB * 0.45;

                // Fine grain noise
                const grain1 = vnoise(nx, ny, 28, 251);
                const grain2 = vnoise(nx, ny, 60, 193);
                const grain  = grain1 * 0.6 + grain2 * 0.4;

                // Composite \ufffd dune shape dominates colour, ripple modulates mid, grain adds texture
                const composite = dune * 0.45 + rip * 0.35 + grain * 0.20;

                // Sand colour palette:
                //   shadow troughs  ? deep amber-brown  (r?140 g?108 b?58)
                //   mid tone        ? warm golden sand   (r?196 g?162 b?88)
                //   sun-bleached crest ? pale ivory      (r?232 g?210 b?152)
                let sr, sg, sb;
                if (composite < 0.28) {
                    const t = composite / 0.28;
                    sr = 118 + t * 36 | 0;  sg = 88  + t * 30 | 0;  sb = 44 + t * 20 | 0;
                } else if (composite < 0.52) {
                    const t = (composite - 0.28) / 0.24;
                    sr = 154 + t * 42 | 0;  sg = 118 + t * 38 | 0;  sb = 64 + t * 24 | 0;
                } else if (composite < 0.72) {
                    const t = (composite - 0.52) / 0.20;
                    sr = 196 + t * 28 | 0;  sg = 156 + t * 30 | 0;  sb = 88 + t * 22 | 0;
                } else {
                    const t = (composite - 0.72) / 0.28;
                    sr = 224 + t * 18 | 0;  sg = 186 + t * 24 | 0;  sb = 110 + t * 30 | 0;
                }

                // Ripple shadow: where ripple troughs are deep, darken sharply
                if (ripA < 0.22) {
                    const shadow = (0.22 - ripA) / 0.22;
                    sr = sr * (1 - shadow * 0.38) | 0;
                    sg = sg * (1 - shadow * 0.40) | 0;
                    sb = sb * (1 - shadow * 0.35) | 0;
                }

                // Ripple highlight: crest catches light
                if (ripA > 0.80 && ripB > 0.60) {
                    const highlight = (ripA - 0.80) / 0.20;
                    sr = Math.min(255, sr + (highlight * 28 | 0));
                    sg = Math.min(255, sg + (highlight * 22 | 0));
                    sb = Math.min(255, sb + (highlight * 14 | 0));
                }

                // Occasional dark mineral specks (iron oxide, tiny pebbles)
                if (grain2 > 0.91 && grain1 < 0.45) {
                    sr = sr * 0.58 | 0;  sg = sg * 0.52 | 0;  sb = sb * 0.44 | 0;
                }

                // Occasional pale quartz glints
                if (grain1 > 0.93 && grain2 > 0.70) {
                    sr = Math.min(255, sr + 34);  sg = Math.min(255, sg + 28);  sb = Math.min(255, sb + 18);
                }

                const sidx = (gy * SAND_SZ + gx) * 4;
                sandPix[sidx]   = clamp8(sr);
                sandPix[sidx+1] = clamp8(sg);
                sandPix[sidx+2] = clamp8(sb);
                sandPix[sidx+3] = 255;
            }
        }
        sandCtx.putImageData(sandImgData, 0, 0);

        // ---- Drawn ripple strokes \ufffd long, nearly-horizontal, low opacity ----
        // These mimic the fine parallel wind-scour lines visible on real desert sand
        for (let i = 0; i < 900; i++) {
            const bx = Math.random() * SAND_SZ;
            const by = Math.random() * SAND_SZ;
            // Mostly horizontal ripples with slight wave
            const len   = 18 + Math.random() * 40;
            const wave  = (Math.random() - 0.5) * 6;
            const cpx   = bx + len * 0.5 + wave;
            const cpy   = by + (Math.random() - 0.5) * 4;
            const epx   = bx + len;
            const epy   = by + (Math.random() - 0.5) * 5;
            const hue   = 34 + (Math.random() - 0.5) * 10;
            const sat   = 28 + Math.random() * 22;
            // Alternate between shadow lines (dark) and highlight lines (light)
            const isHighlight = Math.random() < 0.35;
            const lit   = isHighlight ? 72 + Math.random() * 18 : 24 + Math.random() * 16;
            const alpha = isHighlight ? 0.10 + Math.random() * 0.18 : 0.14 + Math.random() * 0.22;
            sandCtx.strokeStyle = `hsla(${hue|0},${sat|0}%,${lit|0}%,${alpha.toFixed(2)})`;
            sandCtx.lineWidth   = 0.4 + Math.random() * 1.0;
            for (let ox = -SAND_SZ; ox <= SAND_SZ; ox += SAND_SZ) {
                for (let oy = -SAND_SZ; oy <= SAND_SZ; oy += SAND_SZ) {
                    sandCtx.beginPath();
                    sandCtx.moveTo(bx + ox, by + oy);
                    sandCtx.quadraticCurveTo(cpx + ox, cpy + oy, epx + ox, epy + oy);
                    sandCtx.stroke();
                }
            }
        }

        // ---- Tiny grain speckles drawn on top ----
        for (let i = 0; i < 1200; i++) {
            const px  = Math.random() * SAND_SZ;
            const py  = Math.random() * SAND_SZ;
            const r   = 0.4 + Math.random() * 1.1;
            const dark = Math.random() < 0.5;
            const lit2 = dark ? 18 + Math.random() * 20 : 70 + Math.random() * 25;
            const a2   = 0.12 + Math.random() * 0.28;
            sandCtx.fillStyle = `hsla(34,${25 + Math.random()*20 | 0}%,${lit2 | 0}%,${a2.toFixed(2)})`;
            sandCtx.beginPath();
            sandCtx.arc(px, py, r, 0, Math.PI * 2);
            sandCtx.fill();
        }

        const sandTexture = new THREE.CanvasTexture(sandCanvas);
        sandTexture.wrapS = THREE.RepeatWrapping;
        sandTexture.wrapT = THREE.RepeatWrapping;
        sandTexture.repeat.set(14, 14);
        sandTexture.offset.set(0.07, 0.19);
        sandTexture.anisotropy = 16;

        // ---- Second sand texture \ufffd different dune phase + cross-ripple direction ----
        // Ripples run diagonally to break up any repeat pattern when both layers tile
        const sandCanvas2 = document.createElement('canvas');
        sandCanvas2.width = SAND_SZ; sandCanvas2.height = SAND_SZ;
        const sc2 = sandCanvas2.getContext('2d');
        const sandImgData2 = sc2.createImageData(SAND_SZ, SAND_SZ);
        const sandPix2 = sandImgData2.data;

        for (let gy = 0; gy < SAND_SZ; gy++) {
            for (let gx = 0; gx < SAND_SZ; gx++) {
                const nx = gx / SAND_SZ, ny = gy / SAND_SZ;

                const dune  = vnoise(nx, ny, 2, 409) * 0.6 + vnoise(nx, ny, 4, 317) * 0.4;
                // Cross-diagonal ripples
                const diag  = (nx + ny) * 0.5;
                const ripA  = vnoise(diag * 0.7, ny * 2.5, 7,  53);
                const ripB  = vnoise(diag * 0.5, ny * 5.0, 14, 167);
                const rip   = ripA * 0.55 + ripB * 0.45;
                const grain1 = vnoise(nx, ny, 30, 277);
                const grain2 = vnoise(nx, ny, 65, 331);
                const grain  = grain1 * 0.6 + grain2 * 0.4;

                const composite = dune * 0.45 + rip * 0.35 + grain * 0.20;

                let sr, sg, sb;
                if (composite < 0.28) {
                    const t = composite / 0.28;
                    sr = 122 + t * 34 | 0;  sg = 90  + t * 28 | 0;  sb = 46 + t * 18 | 0;
                } else if (composite < 0.52) {
                    const t = (composite - 0.28) / 0.24;
                    sr = 156 + t * 40 | 0;  sg = 118 + t * 38 | 0;  sb = 64 + t * 24 | 0;
                } else if (composite < 0.72) {
                    const t = (composite - 0.52) / 0.20;
                    sr = 196 + t * 26 | 0;  sg = 156 + t * 28 | 0;  sb = 88 + t * 20 | 0;
                } else {
                    const t = (composite - 0.72) / 0.28;
                    sr = 222 + t * 20 | 0;  sg = 184 + t * 26 | 0;  sb = 108 + t * 32 | 0;
                }

                if (ripA < 0.22) {
                    const shadow = (0.22 - ripA) / 0.22;
                    sr = sr * (1 - shadow * 0.36) | 0;
                    sg = sg * (1 - shadow * 0.38) | 0;
                    sb = sb * (1 - shadow * 0.33) | 0;
                }
                if (ripA > 0.80 && ripB > 0.60) {
                    const highlight = (ripA - 0.80) / 0.20;
                    sr = Math.min(255, sr + (highlight * 26 | 0));
                    sg = Math.min(255, sg + (highlight * 20 | 0));
                    sb = Math.min(255, sb + (highlight * 12 | 0));
                }
                if (grain2 > 0.91 && grain1 < 0.45) {
                    sr = sr * 0.58 | 0;  sg = sg * 0.52 | 0;  sb = sb * 0.44 | 0;
                }
                if (grain1 > 0.93 && grain2 > 0.70) {
                    sr = Math.min(255, sr + 32);  sg = Math.min(255, sg + 26);  sb = Math.min(255, sb + 16);
                }

                const sidx2 = (gy * SAND_SZ + gx) * 4;
                sandPix2[sidx2]   = clamp8(sr);
                sandPix2[sidx2+1] = clamp8(sg);
                sandPix2[sidx2+2] = clamp8(sb);
                sandPix2[sidx2+3] = 255;
            }
        }
        sc2.putImageData(sandImgData2, 0, 0);

        for (let i = 0; i < 900; i++) {
            const bx = Math.random() * SAND_SZ, by = Math.random() * SAND_SZ;
            const len = 18 + Math.random() * 40;
            const ang = 0.35 + Math.random() * 0.3; // slight diagonal
            const epx = bx + Math.cos(ang) * len, epy = by + Math.sin(ang) * len;
            const cpx = bx + Math.cos(ang) * len * 0.5 + (Math.random()-0.5)*5;
            const cpy = by + Math.sin(ang) * len * 0.5 + (Math.random()-0.5)*5;
            const isH = Math.random() < 0.35;
            const lit = isH ? 70 + Math.random() * 20 : 22 + Math.random() * 18;
            const alpha = isH ? 0.09 + Math.random() * 0.16 : 0.13 + Math.random() * 0.20;
            sc2.strokeStyle = `hsla(34,${22 + Math.random()*22 | 0}%,${lit | 0}%,${alpha.toFixed(2)})`;
            sc2.lineWidth = 0.4 + Math.random() * 1.0;
            for (let ox = -SAND_SZ; ox <= SAND_SZ; ox += SAND_SZ) {
                for (let oy = -SAND_SZ; oy <= SAND_SZ; oy += SAND_SZ) {
                    sc2.beginPath();
                    sc2.moveTo(bx + ox, by + oy);
                    sc2.quadraticCurveTo(cpx + ox, cpy + oy, epx + ox, epy + oy);
                    sc2.stroke();
                }
            }
        }
        for (let i = 0; i < 1200; i++) {
            const px = Math.random() * SAND_SZ, py = Math.random() * SAND_SZ;
            const r  = 0.4 + Math.random() * 1.1;
            const dk = Math.random() < 0.5;
            const l2 = dk ? 18 + Math.random() * 20 : 68 + Math.random() * 26;
            const a2 = 0.10 + Math.random() * 0.26;
            sc2.fillStyle = `hsla(34,${24 + Math.random()*20 | 0}%,${l2 | 0}%,${a2.toFixed(2)})`;
            sc2.beginPath();
            sc2.arc(px, py, r, 0, Math.PI * 2);
            sc2.fill();
        }

        const sandTexture2 = new THREE.CanvasTexture(sandCanvas2);
        sandTexture2.wrapS = sandTexture2.wrapT = THREE.RepeatWrapping;
        sandTexture2.repeat.set(11, 11);
        sandTexture2.anisotropy = 16;

        // Desert ground mesh
        const desertGeometry = new THREE.PlaneGeometry(groundSize, groundSize, 1, 1);
        desertGeometry.computeVertexNormals();
        const desertMaterial = new THREE.MeshStandardMaterial({
            map: sandTexture,
            roughness: 0.88,
            metalness: 0.0,
            color: 0xffffff,
            polygonOffset: true,
            polygonOffsetFactor: -1,
            polygonOffsetUnits: -1,
        });
        const desertGround = new THREE.Mesh(desertGeometry, desertMaterial);
        desertGround.rotation.x = -Math.PI / 2;
        desertGround.position.set(0, 0.002, -desertOffset + 0.5); // raised 2mm above grass to prevent Z-fighting
        desertGround.receiveShadow = true;
        desertGround.renderOrder = 0;
        scene.add(desertGround);

        // Large angular sandstone formations inspired by desert landscapes
        // Desert formation collision radii - populated as formations are created
        const desertFormationColliders = []; // { x, z, r }

        function createDesertFormation(x, z) {
            const group = new THREE.Group();
            const formationType = Math.floor(Math.random() * 4);

            function makeDesertRockTexture() {
                const tc = document.createElement('canvas');
                tc.width = 512; tc.height = 512;
                const tx = tc.getContext('2d');
                tx.fillStyle = '#b8905a';
                tx.fillRect(0, 0, 512, 512);
                for (let i = 0; i < 40; i++) {
                    const px = Math.random() * 512, py = Math.random() * 512;
                    const r = 40 + Math.random() * 100;
                    const grd = tx.createRadialGradient(px, py, 0, px, py, r);
                    if (Math.random() > 0.45) {
                        grd.addColorStop(0, `rgba(210,175,115,${0.30 + Math.random()*0.30})`);
                    } else {
                        grd.addColorStop(0, `rgba(110,75,38,${0.22 + (py/512)*0.28})`);
                    }
                    grd.addColorStop(1, 'rgba(0,0,0,0)');
                    tx.fillStyle = grd;
                    tx.fillRect(0, 0, 512, 512);
                }
                for (let i = 0; i < 18; i++) {
                    const y = Math.random() * 512;
                    tx.save();
                    tx.strokeStyle = `rgba(${Math.random()>0.5?'90,60,25':'195,162,108'},${0.18+Math.random()*0.25})`;
                    tx.lineWidth = 1 + Math.random() * 3;
                    tx.beginPath(); tx.moveTo(0, y);
                    for (let sx = 0; sx < 512; sx += 40) tx.lineTo(sx + 40, y + (Math.random()-0.5) * 8);
                    tx.stroke(); tx.restore();
                }
                for (let i = 0; i < 10; i++) {
                    tx.save();
                    tx.strokeStyle = `rgba(40,25,10,${0.45+Math.random()*0.35})`;
                    tx.lineWidth = 0.8 + Math.random() * 2;
                    let cx = Math.random()*512, cy = Math.random()*512;
                    tx.beginPath(); tx.moveTo(cx, cy);
                    for (let j = 0; j < 5; j++) { cx += (Math.random()-0.5)*70; cy += (Math.random()-0.5)*70; tx.lineTo(cx, cy); }
                    tx.stroke(); tx.restore();
                }
                for (let i = 0; i < 6000; i++) {
                    const px = Math.random()*512, py = Math.random()*512;
                    tx.fillStyle = Math.random() > 0.55
                        ? `rgba(210,178,120,${0.06+Math.random()*0.14})`
                        : `rgba(30,18,8,${0.06+Math.random()*0.14})`;
                    tx.fillRect(px, py, 1+Math.random(), 1+Math.random());
                }
                const t = new THREE.CanvasTexture(tc);
                t.wrapS = t.wrapT = THREE.RepeatWrapping;
                t.anisotropy = 8;
                return t;
            }

            // Sandstone rock: shared-vertex lattice so no corner gaps.
            // Deformation is purely RADIAL (outward from centre axis) so no
            // overhangs or spikes - just natural rounded-but-angular desert rock.
            function makeRockMesh(w, h, d, sinkDepth) {
                sinkDepth = sinkDepth !== undefined ? sinkDepth : h * 0.28;
                const totalH = h + sinkDepth;
                const nx = 6, ny = 8, nz = 6;

                // Per-rock random seeds for smooth variation
                const freq1 = 1.8 + Math.random() * 1.4;
                const freq2 = 3.2 + Math.random() * 1.6;
                const ph1   = Math.random() * 6.28;
                const ph2   = Math.random() * 6.28;
                const ph3   = Math.random() * 6.28;

                // Smooth angular perturbation around the circumference (no overhangs)
                function radialNoise(angle, t) {
                    return Math.sin(angle * freq1 + ph1) * 0.5
                         + Math.sin(angle * freq2 + ph2) * 0.25
                         + Math.sin(angle * 1.0  + ph3) * 0.25;
                }

                // Slight random lean per rock
                const leanX = (Math.random()-0.5) * 0.12;
                const leanZ = (Math.random()-0.5) * 0.12;

                const pts = [];
                for (let iy = 0; iy <= ny; iy++) {
                    for (let iz = 0; iz <= nz; iz++) {
                        for (let ix = 0; ix <= nx; ix++) {
                            const u = ix/nx - 0.5;   // -0.5..0.5
                            const v = iy/ny;          // 0..1 bottom to top
                            const s = iz/nz - 0.5;

                            let px = u * w;
                            let py = (v - 0.5) * totalH;
                            let pz = s * d;

                            const aboveGround = py > (-totalH*0.5 + sinkDepth);

                            if (aboveGround) {
                                // t: 0=ground level, 1=peak
                                const t = (py - (-totalH*0.5 + sinkDepth)) / h;

                                // Profile: wider at base, tapers cleanly to top
                                // sin curve gives a natural bulge in lower-middle
                                const taper = 1.0
                                    + 0.12 * Math.sin(t * Math.PI * 0.9)  // gentle belly
                                    - 0.40 * Math.pow(t, 1.6);             // clean top taper

                                // Angle around vertical axis - used for smooth radial noise
                                const angle = Math.atan2(s, u);
                                const radialDist = Math.sqrt(u*u + s*s); // 0 at centre, ~0.7 at corner

                                // Radial scale: noise only pushes/pulls along the radius,
                                // never inward past centre so no overhangs
                                const noiseMag = radialNoise(angle, t) * 0.18 * (0.4 + 0.6 * radialDist);
                                const scaledTaper = Math.max(0.25, taper + noiseMag);

                                px *= scaledTaper;
                                pz *= scaledTaper;

                                // Lean: shift top of rock sideways
                                px += leanX * t * h * 0.4;
                                pz += leanZ * t * h * 0.4;

                                // Small y jitter for height variation (sediment layers look)
                                // Only on the outer shell verts, keep centre clean
                                py += (Math.random()-0.5) * h * 0.045;

                                // Subtle XZ facet jitter - keeps angular character
                                // but capped so it never creates spikes
                                const jitter = 0.032 + t * 0.055;
                                px += (Math.random()-0.5) * w * jitter;
                                pz += (Math.random()-0.5) * d * jitter;
                            }

                            pts.push([px, py, pz]);
                        }
                    }
                }

                const idxF = (ix,iy,iz) => iy*(nx+1)*(nz+1) + iz*(nx+1) + ix;
                const positions = [], normals = [], uvs = [], indices = [];

                function addQuad(a,b,c,dd) {
                    const base = positions.length / 3;
                    [a,b,c,dd].forEach(i => positions.push(...pts[i]));
                    const ax=pts[b][0]-pts[a][0], ay=pts[b][1]-pts[a][1], az=pts[b][2]-pts[a][2];
                    const bx=pts[c][0]-pts[a][0], by=pts[c][1]-pts[a][1], bz=pts[c][2]-pts[a][2];
                    const nx2=ay*bz-az*by, ny2=az*bx-ax*bz, nz2=ax*by-ay*bx;
                    const nl=Math.sqrt(nx2*nx2+ny2*ny2+nz2*nz2)||1;
                    for(let k=0;k<4;k++) normals.push(nx2/nl,ny2/nl,nz2/nl);
                    uvs.push(0,0,1,0,1,1,0,1);
                    indices.push(base,base+1,base+2, base,base+2,base+3);
                }

                for (let iy=0; iy<ny; iy++) {
                    for (let iz=0; iz<nz; iz++) {
                        for (let ix=0; ix<nx; ix++) {
                            const a=idxF(ix,iy,iz),    b=idxF(ix+1,iy,iz);
                            const c=idxF(ix+1,iy,iz+1), dd=idxF(ix,iy,iz+1);
                            const e=idxF(ix,iy+1,iz),   f=idxF(ix+1,iy+1,iz);
                            const g=idxF(ix+1,iy+1,iz+1), hh=idxF(ix,iy+1,iz+1);
                            if (iy===ny-1) addQuad(e,f,g,hh);
                            if (iy===0)    addQuad(dd,c,b,a);
                            if (iz===0)    addQuad(b,a,e,f);
                            if (iz===nz-1) addQuad(dd,c,g,hh);
                            if (ix===0)    addQuad(a,dd,hh,e);
                            if (ix===nx-1) addQuad(c,b,f,g);
                        }
                    }
                }

                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geo.setAttribute('normal',   new THREE.Float32BufferAttribute(normals,   3));
                geo.setAttribute('uv',       new THREE.Float32BufferAttribute(uvs,       2));
                geo.setIndex(indices);

                const mat = new THREE.MeshStandardMaterial({
                    map: makeDesertRockTexture(),
                    roughness: 0.93,
                    metalness: 0.02,
                    flatShading: true,
                    color: new THREE.Color(
                        0.82 + Math.random()*0.12,
                        0.72 + Math.random()*0.10,
                        0.52 + Math.random()*0.08
                    )
                });
                return new THREE.Mesh(geo, mat);
            }

            let collisionRadius = 3;

            if (formationType === 0) {
                // Tall narrow monolith - single angular column sunk into the sand
                const h = 6 + Math.random() * 5;
                const w = 1.8 + Math.random() * 1.2;
                const sink = h * 0.28;
                const m = makeRockMesh(w, h, w * (0.7 + Math.random()*0.5), sink);
                m.position.y = h/2 - sink * 0.5; // centre accounting for sink
                m.rotation.y = Math.random() * Math.PI;
                m.castShadow = m.receiveShadow = true;
                group.add(m);
                if (Math.random() > 0.4) {
                    const h2 = 3 + Math.random() * 3;
                    const sink2 = h2 * 0.25;
                    const m2 = makeRockMesh(w*0.6, h2, w*0.5, sink2);
                    m2.position.set(w*0.85, h2/2 - sink2*0.5, (Math.random()-0.5)*w*0.8);
                    m2.rotation.y = Math.random() * Math.PI;
                    m2.rotation.z = (Math.random()-0.5) * 0.22;
                    m2.castShadow = m2.receiveShadow = true;
                    group.add(m2);
                }
                collisionRadius = w * 1.1 + 1.0;

            } else if (formationType === 1) {
                // Cluster of 3-4 angular boulders, tight spacing, all sunk into sand
                const heights = [
                    4 + Math.random()*4,
                    3 + Math.random()*3,
                    5 + Math.random()*4,
                    3 + Math.random()*3
                ];
                const count = 3 + (Math.random() > 0.5 ? 1 : 0);
                const offsets = [
                    {x: 0,    z: 0},
                    {x: 2.0,  z: 0.6},
                    {x:-1.6,  z: 1.2},
                    {x: 0.4,  z: -1.8}
                ];
                for (let i = 0; i < count; i++) {
                    const h = heights[i];
                    const w = 1.5 + Math.random() * 1.4;
                    const sink = h * 0.25;
                    const m = makeRockMesh(w, h, w*(0.8+Math.random()*0.4), sink);
                    m.position.set(offsets[i].x, h/2 - sink*0.5, offsets[i].z);
                    m.rotation.y = Math.random() * Math.PI;
                    m.rotation.z = (Math.random()-0.5)*0.15;
                    m.castShadow = m.receiveShadow = true;
                    group.add(m);
                }
                collisionRadius = 3.5;

            } else if (formationType === 2) {
                // Flat-topped mesa: wide heavy base with a narrower slab on top
                const w = 5 + Math.random() * 4;
                const h = 2.5 + Math.random() * 2;
                const d = 4 + Math.random() * 3;
                const sink = h * 0.3;
                const m = makeRockMesh(w, h, d, sink);
                m.position.y = h/2 - sink*0.5;
                m.rotation.y = Math.random() * Math.PI;
                m.castShadow = m.receiveShadow = true;
                group.add(m);
                const capH = h * 0.55;
                const capSink = capH * 0.15;
                const m2 = makeRockMesh(w*0.65, capH, d*0.6, capSink);
                m2.position.y = h - sink*0.5 + capH/2 - capSink*0.5 - 0.15;
                m2.rotation.y = m.rotation.y + (Math.random()-0.5)*0.4;
                m2.castShadow = m2.receiveShadow = true;
                group.add(m2);
                collisionRadius = (w * 0.5) + 1.2;

            } else {
                // Two tall pillars - gap sealed by buried base rock so nothing walks through
                const h1 = 5 + Math.random() * 4, h2 = 4 + Math.random() * 4;
                const w = 1.6 + Math.random() * 0.8;
                const gap = 2.2 + Math.random() * 1.2;
                const sink1 = h1 * 0.28, sink2 = h2 * 0.28;
                const m1 = makeRockMesh(w, h1, w*0.9, sink1);
                m1.position.set(-gap/2, h1/2 - sink1*0.5, 0);
                m1.rotation.y = Math.random()*Math.PI;
                m1.castShadow = m1.receiveShadow = true;
                group.add(m1);
                const m2 = makeRockMesh(w*0.9, h2, w*0.85, sink2);
                m2.position.set(gap/2, h2/2 - sink2*0.5, 0.3);
                m2.rotation.y = Math.random()*Math.PI;
                m2.castShadow = m2.receiveShadow = true;
                group.add(m2);
                // Wide rubble base that fills the gap between the pillars
                const baseW = gap + w * 2.0;
                const baseH = 1.4 + Math.random() * 0.8;
                const baseRock = makeRockMesh(baseW, baseH, w * 1.6, baseH * 0.6);
                baseRock.position.y = baseH * 0.3;
                baseRock.castShadow = baseRock.receiveShadow = true;
                group.add(baseRock);
                if (h1 > 6 && h2 > 6) {
                    const lintel = makeRockMesh(gap + w, 0.9, w*0.7, 0);
                    lintel.position.set(0, Math.min(h1,h2) - 0.6, 0.15);
                    lintel.castShadow = lintel.receiveShadow = true;
                    group.add(lintel);
                }
                collisionRadius = gap/2 + w + 0.8;
            }

            group.position.set(x, 0, z);
            group.rotation.y = Math.random() * Math.PI * 2;
            scene.add(group);

            // Register collision footprint
            desertFormationColliders.push({ x, z, r: collisionRadius });
        }

        // Spawn formations across the full desert biome
        // Desert ground center is at z = -desertOffset + 0.5, size = groundSize x groundSize
        // So desert spans: x = [-groundSize/2, groundSize/2], z = [-desertOffset - groundSize/2, -desertOffset + groundSize/2]
        const desertFormationPositions = [];
        const margin = 12; // keep rocks away from edges so they don't float in the void
        const desertCenterZ = -desertOffset + 0.5;
        const desertHalf = groundSize / 2 - margin;
        const desertXMin = -groundSize / 2 + margin;
        const desertXMax =  groundSize / 2 - margin;
        const desertZMin = desertCenterZ - desertHalf;
        const desertZMax = desertCenterZ + desertHalf - 18; // leave a small buffer at the grass-edge seam

        // Grid-based placement to guarantee even coverage across the entire desert
        const gridCols = 5;
        const gridRows = 6;
        const cellW = (desertXMax - desertXMin) / gridCols;
        const cellH = (desertZMax - desertZMin) / gridRows;

        for (let row = 0; row < gridRows; row++) {
            for (let col = 0; col < gridCols; col++) {
                // Skip ~20% of cells randomly so it doesn't look too uniform
                if (Math.random() < 0.20) continue;
                let fx, fz, valid;
                let attempts = 0;
                do {
                    valid = true;
                    fx = desertXMin + col * cellW + (cellW * 0.1) + Math.random() * (cellW * 0.8);
                    fz = desertZMin + row * cellH + (cellH * 0.1) + Math.random() * (cellH * 0.8);
                    for (const p of desertFormationPositions) {
                        if (Math.sqrt((fx - p.x) ** 2 + (fz - p.z) ** 2) < 12) { valid = false; break; }
                    }
                    attempts++;
                } while (!valid && attempts < 40);
                if (valid) {
                    createDesertFormation(fx, fz);
                    desertFormationPositions.push({x: fx, z: fz});
                }
            }
        }


        // ===== SMALL DESERT ROCK CLUSTERS =====
        // Each cluster is ONE merged mesh per material group \u2013 very cheap to render
        (function spawnSmallRockClusters() {
            // Shared sandstone-pebble canvas texture (generated once, reused)
            function makeSmallRockTex() {
                const tc = document.createElement('canvas');
                tc.width = 128; tc.height = 128;
                const tx = tc.getContext('2d');
                // warm sandstone base
                tx.fillStyle = '#c09660';
                tx.fillRect(0, 0, 128, 128);
                // subtle blotchy variation
                for (let i = 0; i < 18; i++) {
                    const px = Math.random()*128, py = Math.random()*128;
                    const r  = 18 + Math.random()*42;
                    const g  = tx.createRadialGradient(px, py, 0, px, py, r);
                    g.addColorStop(0, Math.random() > 0.5
                        ? `rgba(220,188,130,${0.28+Math.random()*0.22})`
                        : `rgba(100,68,32,${0.18+Math.random()*0.18})`);
                    g.addColorStop(1, 'rgba(0,0,0,0)');
                    tx.fillStyle = g;
                    tx.fillRect(0, 0, 128, 128);
                }
                // fine grit
                for (let i = 0; i < 2000; i++) {
                    tx.fillStyle = Math.random() > 0.5
                        ? `rgba(230,198,142,${0.05+Math.random()*0.12})`
                        : `rgba(28,16,6,${0.05+Math.random()*0.10})`;
                    tx.fillRect(Math.random()*128, Math.random()*128, 1, 1);
                }
                const t = new THREE.CanvasTexture(tc);
                t.wrapS = t.wrapT = THREE.RepeatWrapping;
                t.anisotropy = 4;
                return t;
            }

            const sharedTex = makeSmallRockTex();
            const sharedMat = new THREE.MeshStandardMaterial({
                map: sharedTex, roughness: 0.92, metalness: 0.01,
                flatShading: true,
                color: new THREE.Color(0.88, 0.76, 0.56)
            });

            // Build a single rounded, squashed rock geometry in local space
            // Uses icosphere-like deformation for organic feel
            function makeSmallRockGeo(w, h, d) {
                const geo = new THREE.SphereGeometry(1, 6, 5);
                // squash to desired dimensions and deform vertices
                const pos = geo.attributes.position;
                const seed = Math.random() * 100;
                for (let i = 0; i < pos.count; i++) {
                    let vx = pos.getX(i), vy = pos.getY(i), vz = pos.getZ(i);
                    // gentle random noise on each vertex for angularity
                    const n = 0.82 + Math.sin((vx + seed) * 4.1) * 0.10
                                   + Math.cos((vz + seed) * 5.3) * 0.08;
                    vx *= w * n;
                    vy *= h * (0.88 + Math.random() * 0.24);
                    vz *= d * n;
                    // flatten the underside so it sits flush on the ground
                    if (vy < -h * 0.25) vy = -h * 0.25;
                    pos.setXYZ(i, vx, vy, vz);
                }
                geo.computeVertexNormals();
                return geo;
            }

            // Cluster types
            const clusterDefs = [
                // [count, radiusSpread, wRange, hRange, dRange]
                { count: [3,5],  spread: 0.9,  w:[0.25,0.55], h:[0.18,0.38], d:[0.22,0.50] }, // small scatter
                { count: [2,4],  spread: 0.7,  w:[0.40,0.80], h:[0.28,0.55], d:[0.38,0.72] }, // medium cluster
                { count: [5,8],  spread: 1.2,  w:[0.15,0.38], h:[0.10,0.24], d:[0.14,0.36] }, // pebble scatter
                { count: [2,3],  spread: 0.5,  w:[0.60,1.00], h:[0.40,0.70], d:[0.55,0.90] }, // 2-3 bigger boulders
            ];

            const _d2 = new THREE.Object3D();

            function createSmallRockCluster(cx, cz) {
                const def = clusterDefs[Math.floor(Math.random() * clusterDefs.length)];
                const count = def.count[0] + Math.floor(Math.random() * (def.count[1] - def.count[0] + 1));
                const pieces = [];

                for (let i = 0; i < count; i++) {
                    const angle  = (i / count) * Math.PI * 2 + Math.random() * 0.8;
                    const dist   = Math.random() * def.spread;
                    const rx     = cx + Math.cos(angle) * dist;
                    const rz     = cz + Math.sin(angle) * dist;
                    const w      = def.w[0] + Math.random() * (def.w[1] - def.w[0]);
                    const h      = def.h[0] + Math.random() * (def.h[1] - def.h[0]);
                    const d      = def.d[0] + Math.random() * (def.d[1] - def.d[0]);
                    const geo    = makeSmallRockGeo(w, h, d);
                    _d2.position.set(rx - cx, h * 0.25 - h * 0.25, rz - cz); // sit on ground (y\u22480)
                    _d2.rotation.set(
                        (Math.random() - 0.5) * 0.30,
                        Math.random() * Math.PI * 2,
                        (Math.random() - 0.5) * 0.22
                    );
                    _d2.scale.set(1, 1, 1);
                    _d2.updateMatrix();
                    pieces.push({ geo, matrix: _d2.matrix.clone() });
                }

                const merged = mergeGeometries(pieces);
                merged.computeVertexNormals();
                const mesh = new THREE.Mesh(merged, sharedMat);
                mesh.position.set(cx, 0, cz);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
            }

            // Scatter ~60-80 clusters across the desert, avoiding large formation spots
            const clusterCount = 65 + Math.floor(Math.random() * 20);
            const placed = [];
            let attempts2 = 0;
            while (placed.length < clusterCount && attempts2 < clusterCount * 10) {
                attempts2++;
                const cx = desertXMin + Math.random() * (desertXMax - desertXMin);
                const cz = desertZMin + Math.random() * (desertZMax - desertZMin);
                // Keep away from large formations
                let tooClose = false;
                for (const p of desertFormationPositions) {
                    if (Math.sqrt((cx - p.x) ** 2 + (cz - p.z) ** 2) < 5) { tooClose = true; break; }
                }
                if (tooClose) continue;
                // Minimum spacing between clusters
                for (const p of placed) {
                    if (Math.sqrt((cx - p.x) ** 2 + (cz - p.z) ** 2) < 3.5) { tooClose = true; break; }
                }
                if (tooClose) continue;
                createSmallRockCluster(cx, cz);
                placed.push({ x: cx, z: cz });
            }
        })();

        // No transition strip \ufffd desert ground overlaps grass edge to avoid seam

        // ===== DESERT GRASS TUFTS =====
        const desertGrassTufts = [];

        const desertGrassMat = new THREE.MeshStandardMaterial({
            side: THREE.DoubleSide,
            roughness: 0.98,
            metalness: 0,
            vertexColors: true,
        });

        function createDesertGrassTuft(x, z) {
            const numBlades = 6 + Math.floor(Math.random() * 5);
            const allPos = [], allNorm = [], allUV = [], allCol = [], allIdx = [];
            let vertOffset = 0;

            // Dry desert palette: tans, ochres, russets, bleached straw
            const palettes = [
                { h: 0.10, sMin: 0.38, sMax: 0.55, lMin: 0.28, lMax: 0.40 },
                { h: 0.08, sMin: 0.42, sMax: 0.60, lMin: 0.20, lMax: 0.33 },
                { h: 0.12, sMin: 0.30, sMax: 0.50, lMin: 0.36, lMax: 0.50 },
                { h: 0.09, sMin: 0.25, sMax: 0.42, lMin: 0.32, lMax: 0.45 },
                { h: 0.06, sMin: 0.35, sMax: 0.52, lMin: 0.18, lMax: 0.30 },
            ];

            for (let b = 0; b < numBlades; b++) {
                const bladeHeight = 0.45 + Math.random() * 0.55;
                const bladeWidth  = 0.05 + Math.random() * 0.05;
                const bx = (Math.random() - 0.5) * 0.26;
                const bz = (Math.random() - 0.5) * 0.26;
                const ry = Math.random() * Math.PI * 2;
                const cosR = Math.cos(ry), sinR = Math.sin(ry);
                const segsY = 4;
                const cols = 2, rows = segsY + 1;

                const pal = palettes[Math.floor(Math.random() * palettes.length)];
                const hue = pal.h + (Math.random() - 0.5) * 0.03;
                const sat = pal.sMin + Math.random() * (pal.sMax - pal.sMin);
                const lit = pal.lMin + Math.random() * (pal.lMax - pal.lMin);
                const baseCol = new THREE.Color().setHSL(hue, sat, lit);
                const tipCol  = new THREE.Color().setHSL(hue + 0.02, sat * 0.65, Math.min(lit + 0.18, 0.68));

                for (let row = 0; row < rows; row++) {
                    for (let col2 = 0; col2 < cols; col2++) {
                        const u = col2 / (cols - 1);
                        const v = row  / (rows - 1);
                        const lx = (u - 0.5) * bladeWidth;
                        const ly = v * bladeHeight - bladeHeight * 0.5;
                        const bendFactor = (v + 0.5) ** 2;
                        const bendX = bendFactor * (0.14 + Math.random() * 0.10);
                        const wx = cosR * (lx + bendX) + bx;
                        const wz = sinR * (lx + bendX) + bz;
                        allPos.push(wx, ly + bladeHeight * 0.5, wz);
                        allNorm.push(0, 1, 0);
                        allUV.push(u, v);
                        const c = baseCol.clone().lerp(tipCol, v * v);
                        allCol.push(c.r, c.g, c.b);
                    }
                }
                for (let row = 0; row < segsY; row++) {
                    const a = vertOffset + row * cols;
                    const b2 = a + 1, c2 = a + cols, d = c2 + 1;
                    allIdx.push(a, c2, b2,  b2, c2, d);
                }
                vertOffset += rows * cols;
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(allPos,  3));
            geo.setAttribute('normal',   new THREE.Float32BufferAttribute(allNorm, 3));
            geo.setAttribute('uv',       new THREE.Float32BufferAttribute(allUV,   2));
            geo.setAttribute('color',    new THREE.Float32BufferAttribute(allCol,  3));
            geo.setIndex(allIdx);
            geo.computeVertexNormals();

            const tuft = new THREE.Mesh(geo, desertGrassMat);
            tuft.position.set(x, 0, z);
            tuft.userData.type      = 'desert_grass';
            tuft.userData.windSpeed = 0.5 + Math.random() * 0.35;
            tuft.userData.windPhase = Math.random() * Math.PI * 2;
            desertGrassTufts.push(tuft);
            scene.add(tuft);
        }

        // Spread ~150 tufts across the desert, avoiding rock formations
        {
            const dgMargin  = 6;
            const dgCenterZ = -desertOffset + 0.5;
            const dgHalf    = groundSize / 2 - dgMargin;
            const dgXMin    = -groundSize / 2 + dgMargin;
            const dgXMax    =  groundSize / 2 - dgMargin;
            const dgZMin    = dgCenterZ - dgHalf;
            const dgZMax    = dgCenterZ + dgHalf - 18;

            const dgCols = 12, dgRows = 15;
            const dgCellW = (dgXMax - dgXMin) / dgCols;
            const dgCellH = (dgZMax - dgZMin) / dgRows;

            for (let row = 0; row < dgRows; row++) {
                for (let col = 0; col < dgCols; col++) {
                    if (Math.random() < 0.15) continue; // ~85% fill for natural patchiness
                    const fx = dgXMin + col * dgCellW + dgCellW * 0.1 + Math.random() * dgCellW * 0.8;
                    const fz = dgZMin + row * dgCellH + dgCellH * 0.1 + Math.random() * dgCellH * 0.8;
                    // Skip if too close to a rock formation
                    let tooClose = false;
                    for (const p of desertFormationPositions) {
                        if (Math.sqrt((fx - p.x) ** 2 + (fz - p.z) ** 2) < 5) { tooClose = true; break; }
                    }
                    if (!tooClose) createDesertGrassTuft(fx, fz);
                }
            }
        }


        // ===== OPTIMIZED SKY (INVISIBLE BACKDROP) =====
        // Ultra-light sky with minimal geometry - should never be visible
        const skyGeometry = new THREE.SphereGeometry(5000, 64, 32); // Huge radius, many segments ? edges never visible
        const skyMaterial = new THREE.ShaderMaterial({
            uniforms: {
                topColor: { value: new THREE.Color(0x0077ff) },
                bottomColor: { value: new THREE.Color(0xffffff) },
                offset: { value: 33 },
                exponent: { value: 0.6 }
            },
            vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    vec4 pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    gl_Position = pos.xyww;
                }
            `,
            fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize(vWorldPosition + offset).y;
                    gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                }
            `,
            side: THREE.BackSide,
            depthWrite: false,
            depthTest: false,
            fog: false
        });
        
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        sky.renderOrder = -1; // Render first
        sky.frustumCulled = false; // Always render even when not in frustum
        // Sky follows camera so it never appears to move as the player looks around
        sky.onBeforeRender = function(renderer, scene, camera) {
            sky.position.copy(camera.position);
        };
        scene.add(sky);

        // ===== STAR FIELD =====
        const STAR_COUNT = 1800;
        const starPositions = new Float32Array(STAR_COUNT * 3);
        const starColors    = new Float32Array(STAR_COUNT * 3);
        for (let i = 0; i < STAR_COUNT; i++) {
            // Distribute on upper hemisphere of a large sphere
            const theta = Math.random() * Math.PI * 2;
            const phi   = Math.acos(Math.random() * 0.92); // 0..~67? from top pole
            const r     = 4500;
            starPositions[i * 3]     = r * Math.sin(phi) * Math.cos(theta);
            starPositions[i * 3 + 1] = r * Math.cos(phi);
            starPositions[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
            // Slight colour variation: white/blue-white/warm white
            const warm = Math.random();
            starColors[i * 3]     = warm > 0.7 ? 1.0 : 0.85 + Math.random() * 0.15;
            starColors[i * 3 + 1] = warm > 0.7 ? 0.9 + Math.random() * 0.1 : 0.88 + Math.random() * 0.12;
            starColors[i * 3 + 2] = warm > 0.7 ? 0.7 + Math.random() * 0.2 : 1.0;
        }
        const starGeo = new THREE.BufferGeometry();
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
        starGeo.setAttribute('color',    new THREE.Float32BufferAttribute(starColors, 3));
        const starMat = new THREE.PointsMaterial({
            size: 3.5,
            sizeAttenuation: false, // screen-space size ? always visible regardless of distance
            vertexColors: true,
            transparent: true,
            opacity: 0,             // starts invisible, fades in at night
            depthWrite: false,
        });
        const stars = new THREE.Points(starGeo, starMat);
        stars.frustumCulled = false;
        stars.onBeforeRender = function(renderer, scene, camera) {
            stars.position.copy(camera.position); // follow camera like the sky
        };
        scene.add(stars);

        // Star twinkle state
        const starBaseOpacity = new Float32Array(STAR_COUNT); // per-star brightness base
        const starTwinklePhase = new Float32Array(STAR_COUNT);
        const starTwinkleSpeed = new Float32Array(STAR_COUNT);
        for (let i = 0; i < STAR_COUNT; i++) {
            starBaseOpacity[i]  = 0.5 + Math.random() * 0.5;
            starTwinklePhase[i] = Math.random() * Math.PI * 2;
            starTwinkleSpeed[i] = 0.02 + Math.random() * 0.06;
        }
        
        // ===== OPTIMIZED CLOUDS =====
        const clouds = [];
        function createCloud(x, y, z) {
            // Merge all puff spheres into one BufferGeometry ? 1 draw call per cloud vs 8
            const particleCount = 8;
            const mergedPositions = [];
            const mergedNormals   = [];
            const mergedUVs       = [];
            const mergedIndices   = [];
            let vertexOffset = 0;

            for (let i = 0; i < particleCount; i++) {
                const size = 3 + Math.random() * 4;
                const px   = (Math.random() - 0.5) * 15;
                const py   = (Math.random() - 0.5) * 3;
                const pz   = (Math.random() - 0.5) * 8;

                // Build a low-poly sphere manually (6 lat ? 5 lon)
                const latSegs = 5, lonSegs = 6;
                for (let lat = 0; lat <= latSegs; lat++) {
                    const theta = (lat / latSegs) * Math.PI;
                    for (let lon = 0; lon <= lonSegs; lon++) {
                        const phi = (lon / lonSegs) * Math.PI * 2;
                        const sx = Math.sin(theta) * Math.cos(phi);
                        const sy = Math.cos(theta);
                        const sz = Math.sin(theta) * Math.sin(phi);
                        mergedPositions.push(px + sx * size, py + sy * size, pz + sz * size);
                        mergedNormals.push(sx, sy, sz);
                        mergedUVs.push(lon / lonSegs, lat / latSegs);
                    }
                }
                // Indices
                for (let lat = 0; lat < latSegs; lat++) {
                    for (let lon = 0; lon < lonSegs; lon++) {
                        const a = vertexOffset + lat * (lonSegs + 1) + lon;
                        const b = a + lonSegs + 1;
                        mergedIndices.push(a, b, a + 1,  a + 1, b, b + 1);
                    }
                }
                vertexOffset += (latSegs + 1) * (lonSegs + 1);
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(mergedPositions, 3));
            geo.setAttribute('normal',   new THREE.Float32BufferAttribute(mergedNormals,   3));
            geo.setAttribute('uv',       new THREE.Float32BufferAttribute(mergedUVs,       2));
            geo.setIndex(mergedIndices);

            const mat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.18 + Math.random() * 0.12,
                roughness: 1,
                metalness: 0,
                emissive: 0xffffff,
                emissiveIntensity: 0.2,
                depthWrite: false,
            });

            const cloudMesh = new THREE.Mesh(geo, mat);
            cloudMesh.position.set(x, y, z);
            cloudMesh.frustumCulled = true;

            // Keep per-cloud drift data
            cloudMesh.userData.speed       = 0.005 + Math.random() * 0.01;
            cloudMesh.userData.floatSpeed  = 0.15 + Math.random() * 0.2;
            cloudMesh.userData.floatPhase  = Math.random() * Math.PI * 2;
            cloudMesh.userData.baseY       = y;
            cloudMesh.userData.baseOpacity = mat.opacity;

            clouds.push(cloudMesh);
            scene.add(cloudMesh);
        }
        
        // Spread clouds across entire sky - reduced count
        for (let i = 0; i < 10; i++) { // Reduced by 60% (was 25, now 10)
            createCloud(
                (Math.random() - 0.5) * 400, // Wider spread (was 160, now 400)
                35 + Math.random() * 40, // Higher range (35-75 instead of 40-70)
                (Math.random() - 0.5) * 400  // Wider spread (was 160, now 400)
            );
        }
        
        // ===== GAME STATE =====
        let health = 100;
        let hunger = 100;
        let thirst = 100;
        let day = 1;
        let time = 6; // 0-24 hour format
        let isDead = false;
        let gameTime = 0;
        let deathCamera = null;
        
        // Volume settings
        const volumeSettings = {
            ambient: 0.3,    // Legacy (used by desert/biome gain)
            forest: 0.3,     // Forest ambience track
            wind: 0.1,       // Wind sounds
            rain: 0.5,       // Rain sounds
            animals: 0.5,    // Animal sounds
            enemies: 0.5,    // Enemy sounds
            footsteps: 0.5   // Footstep sounds
        };
        
        const inventory = {
            sharp_stone: 1,  // START WITH SHARP STONE!
            wood: 0,
            stone: 0,
            berries: 0,
            mushroom: 0,
            roasted_mushroom: 0,
            meat: 0,
            sticks: 0,
            fiber: 0,
            iron_ore: 0,
            iron_ingot: 0,
            coal: 0,
            sulfur_ore: 0,
            smelted_sulfur: 0,
            gunpowder: 0,
            arrows: 0,
            pistol: 0,
            pistol_ammo: 0,
            building_hammer: 0,
            sleeping_bag: 0,
            bandage: 0,
            medkit: 0,
            cloth: 0,
            floor_rug_red: 0,
            floor_rug_blue: 0,
            floor_rug_green: 0,
            small_storage_box: 0,
            storage_shelf: 0,
            wall_shelf: 0,
            planter_box: 0,
            large_planter: 0,
            // Seeds (found in world, not crafted)
            pumpkin_seed: 0,
            wheat_seed: 0,
            cabbage_seed: 0,
            cucumber_seed: 0,
            potato_seed: 0,
            carrot_seed: 0,
            hemp_seed: 0,
            corn_seed: 0,
            mushroom_seed: 0,
            red_berry_seed: 0,
            black_berry_seed: 0,
            strawberry_seed: 0,
            tomato_seed: 0,
            // Harvested produce
            pumpkin: 0,
            wheat: 0,
            cabbage: 0,
            cucumber: 0,
            potato: 0,
            carrot: 0,
            hemp_fiber: 0,
            corn: 0,
            mushroom_crop: 0,
            red_berries: 0,
            black_berries: 0,
            strawberry: 0,
            tomato: 0,
            building_bench: 0,
            sewing_table: 0,
            recycler: 0,
            curtain_red: 0,
            curtain_blue: 0,
            curtain_green: 0,
            curtain_white: 0,
            curtain_beige: 0,
            code_lock: 0,
            iron_helmet: 0,
            iron_vest: 0,
            iron_gloves: 0,
            iron_pants: 0,
            iron_boots: 0,
            bronze_helmet: 0,
            bronze_vest: 0,
            bronze_gloves: 0,
            bronze_pants: 0,
            bronze_boots: 0,
            // Cooking station outputs
            meat_stew: 0,
            vegetable_stew: 0,
            berry_jam: 0,
            corn_bread: 0,
            hearty_meal: 0,
            cooking_station: 0,
            water_bottle: 0,
            water_catcher: 0,
            // Cooking station outputs
            flour: 0,
            bread: 0,
            blackcurrant_jam: 0,
            strawberry_jam: 0,
            toast_jam: 0,
            ham_sandwich: 0
        };
        
        // Pistol state
        const pistolState = {
            clipSize: 8,
            currentClip: 8,
            isReloading: false,
            reloadStartTime: 0,
            reloadDuration: 1500 // 1.5 seconds
        };
        
        // Code lock state
        let currentCodeLockDoor = null;
        let codeLockMode = null; // 'set' or 'enter'
        let currentCode = '';
        let wrongCodeDamageTimer = null;
        
        // Healing over time state
        const healingState = {
            active: false,
            totalHealing: 0,
            healPerTick: 0,
            tickInterval: 1000, // 1 second
            lastTickTime: 0,
            healingsRemaining: 0
        };
        
        // Spawn point
        let spawnPoint = { x: 0, y: 1.7, z: 5 };
        
        const equipment = {
            weapon: null,
            tool: null
        };
        
        // Armor equipment slots
        const armorSlots = {
            head: null,
            chest: null,
            hands: null,
            legs: null,
            feet: null
        };
        
        const hotbar = [
            { type: 'tool', item: 'sharp_stone' },  // Sharp stone in first slot!
            { type: 'tool', item: null },
            { type: 'food', item: 'berries' },
            { type: 'building', item: null },
            { type: 'misc', item: null },
            { type: 'misc', item: null }
        ];
        let selectedHotbarSlot = 0;
        
        // Consumable items
        const _foodItems = new Set([
            'berries','mushroom','roasted_mushroom','meat','cooked_meat',
            'pumpkin','wheat','cabbage','cucumber','potato','carrot',
            'hemp_fiber','corn','mushroom_crop','red_berries','black_berries',
            'strawberry','tomato',
            'meat_stew','vegetable_stew','berry_jam','corn_bread','hearty_meal',
            'water_bottle',
            'bread','toast_jam','ham_sandwich','blackcurrant_jam','strawberry_jam','flour'
        ]);
        function consumeItem(itemName) {
            if (_foodItems.has(itemName) && inventory[itemName] > 0) playEatSound();
            if (itemName === 'berries' && inventory.berries > 0) {
                inventory.berries--;
                hunger = Math.min(100, hunger + 15);
                thirst = Math.min(100, thirst + 5);
                showMessage('\ud83e\uded0 Ate berries! +15 Hunger, +5 Thirst');
                updateUI();
                updateHotbar();
            } else if (itemName === 'mushroom' && inventory.mushroom > 0) {
                inventory.mushroom--;
                hunger = Math.min(100, hunger + 10);
                showMessage('\ud83c\udf44 Ate mushroom! +10 Hunger');
                updateUI();
                updateHotbar();
            } else if (itemName === 'roasted_mushroom' && inventory.roasted_mushroom > 0) {
                inventory.roasted_mushroom--;
                hunger = Math.min(100, hunger + 25);
                health = Math.min(100, health + 5);
                showMessage('\ud83c\udf44 Ate roasted mushroom! +25 Hunger, +5 Health');
                updateUI();
                updateHotbar();
            } else if (itemName === 'meat' && inventory.meat > 0) {
                inventory.meat--;
                hunger = Math.min(100, hunger + 20);
                showMessage('\ud83e\udd69 Ate raw meat! +20 Hunger');
                updateUI();
                updateHotbar();
            } else if (itemName === 'cooked_meat' && inventory.cooked_meat > 0) {
                inventory.cooked_meat--;
                hunger = Math.min(100, hunger + 40);
                health = Math.min(100, health + 10);
                showMessage('\ud83c\udf56 Ate cooked meat! +40 Hunger, +10 Health');
                updateUI();
                updateHotbar();
            } else if (itemName === 'bandage' && inventory.bandage > 0) {
                inventory.bandage--;
                // Heal 15 HP over 5 seconds (3 HP per second)
                startHealing(15, 3, 5);
                showMessage('\ud83e\ude79 Applied bandage! Healing over time...');
                updateUI();
                updateHotbar();
            } else if (itemName === 'medkit' && inventory.medkit > 0) {
                inventory.medkit--;
                startHealing(40, 10, 4);
                showMessage('\ud83c\udfe5 Used medkit! Rapid healing!');
                updateUI();
                updateHotbar();
            //  Harvested produce 
            } else if (itemName === 'pumpkin' && inventory.pumpkin > 0) {
                inventory.pumpkin--;
                hunger = Math.min(100, hunger + 35); thirst = Math.min(100, thirst + 10);
                showMessage('\ud83c\udf83 Ate pumpkin! +35 Hunger, +10 Thirst');
                updateUI(); updateHotbar();
            } else if (itemName === 'wheat' && inventory.wheat > 0) {
                inventory.wheat--;
                hunger = Math.min(100, hunger + 20);
                showMessage('\ud83c\udf3e Ate wheat! +20 Hunger');
                updateUI(); updateHotbar();
            } else if (itemName === 'cabbage' && inventory.cabbage > 0) {
                inventory.cabbage--;
                hunger = Math.min(100, hunger + 18); thirst = Math.min(100, thirst + 8);
                showMessage('\ud83e\udd66 Ate cabbage! +18 Hunger, +8 Thirst');
                updateUI(); updateHotbar();
            } else if (itemName === 'cucumber' && inventory.cucumber > 0) {
                inventory.cucumber--;
                hunger = Math.min(100, hunger + 12); thirst = Math.min(100, thirst + 20);
                showMessage('\ud83e\udd52 Ate cucumber! +12 Hunger, +20 Thirst');
                updateUI(); updateHotbar();
            } else if (itemName === 'potato' && inventory.potato > 0) {
                inventory.potato--;
                hunger = Math.min(100, hunger + 30);
                showMessage('\ud83e\udd54 Ate potato! +30 Hunger');
                updateUI(); updateHotbar();
            } else if (itemName === 'carrot' && inventory.carrot > 0) {
                inventory.carrot--;
                hunger = Math.min(100, hunger + 22); health = Math.min(100, health + 3);
                showMessage('\ud83e\udd55 Ate carrot! +22 Hunger, +3 Health');
                updateUI(); updateHotbar();
            } else if (itemName === 'hemp_fiber' && inventory.hemp_fiber > 0) {
                inventory.hemp_fiber--;
                health = Math.min(100, health + 8);
                showMessage('\ud83c\udf3f Ate hemp! +8 Health');
                updateUI(); updateHotbar();
            } else if (itemName === 'corn' && inventory.corn > 0) {
                inventory.corn--;
                hunger = Math.min(100, hunger + 28); thirst = Math.min(100, thirst + 5);
                showMessage('\ud83c\udf3d Ate corn! +28 Hunger, +5 Thirst');
                updateUI(); updateHotbar();
            } else if (itemName === 'mushroom_crop' && inventory.mushroom_crop > 0) {
                inventory.mushroom_crop--;
                hunger = Math.min(100, hunger + 15); health = Math.min(100, health + 5);
                showMessage('\ud83c\udf44 Ate mushroom! +15 Hunger, +5 Health');
                updateUI(); updateHotbar();
            } else if (itemName === 'red_berries' && inventory.red_berries > 0) {
                inventory.red_berries--;
                hunger = Math.min(100, hunger + 10); thirst = Math.min(100, thirst + 12);
                showMessage('\ud83c\udf53 Ate red berries! +10 Hunger, +12 Thirst');
                updateUI(); updateHotbar();
            } else if (itemName === 'black_berries' && inventory.black_berries > 0) {
                inventory.black_berries--;
                hunger = Math.min(100, hunger + 10); thirst = Math.min(100, thirst + 12); health = Math.min(100, health + 4);
                showMessage('\ud83e\uded0 Ate black berries! +10 Hunger, +12 Thirst, +4 Health');
                updateUI(); updateHotbar();
            } else if (itemName === 'strawberry' && inventory.strawberry > 0) {
                inventory.strawberry--;
                hunger = Math.min(100, hunger + 12); thirst = Math.min(100, thirst + 15); health = Math.min(100, health + 5);
                showMessage('\ud83c\udf53 Ate strawberry! +12 Hunger, +15 Thirst, +5 Health');
                updateUI(); updateHotbar();
            } else if (itemName === 'tomato' && inventory.tomato > 0) {
                inventory.tomato--;
                hunger = Math.min(100, hunger + 16); thirst = Math.min(100, thirst + 18);
                showMessage('\ud83c\udf45 Ate tomato! +16 Hunger, +18 Thirst');
                updateUI(); updateHotbar();
            } else if (itemName === 'meat_stew' && inventory.meat_stew > 0) {
                inventory.meat_stew--;
                hunger = Math.min(100, hunger + 60); health = Math.min(130, health + 15);
                applyBuff('meat_stew');
                showMessage('\ud83c\udf72 Ate meat stew! +60 Hunger, +15 Health | Buff: Fortified (+30% max health, 10 mins)');
                updateUI(); updateHotbar();
            } else if (itemName === 'vegetable_stew' && inventory.vegetable_stew > 0) {
                inventory.vegetable_stew--;
                hunger = Math.min(100, hunger + 50); thirst = Math.min(100, thirst + 20); health = Math.min(100, health + 10);
                applyBuff('veggi_stew');
                showMessage('\ud83c\udf72 Ate vegetable stew! +50 Hunger, +20 Thirst, +10 Health | Buff: Stamina Saver (10 mins)');
                updateUI(); updateHotbar();
            } else if (itemName === 'berry_jam' && inventory.berry_jam > 0) {
                inventory.berry_jam--;
                hunger = Math.min(100, hunger + 35); thirst = Math.min(100, thirst + 25);
                showMessage('\ud83c\udf53 Ate berry jam! +35 Hunger, +25 Thirst');
                updateUI(); updateHotbar();
            } else if (itemName === 'corn_bread' && inventory.corn_bread > 0) {
                inventory.corn_bread--;
                hunger = Math.min(100, hunger + 45);
                showMessage('\ud83c\udf5e Ate corn bread! +45 Hunger');
                updateUI(); updateHotbar();
            } else if (itemName === 'hearty_meal' && inventory.hearty_meal > 0) {
                inventory.hearty_meal--;
                hunger = Math.min(100, hunger + 80); health = Math.min(100, health + 25); thirst = Math.min(100, thirst + 15);
                applyBuff('hearty');
                showMessage('\ud83c\udf7d\ufe0f Ate hearty meal! +80 Hunger, +25 Health, +15 Thirst | Buff: Double Gathering (10 mins)');
                updateUI(); updateHotbar();
            } else if (itemName === 'water_bottle' && inventory.water_bottle > 0) {
                inventory.water_bottle--;
                thirst = Math.min(100, thirst + 50);
                showMessage(' Drank water bottle! +50 Thirst');
                updateUI(); updateHotbar();
            } else if (itemName === 'flour' && inventory.flour > 0) {
                inventory.flour--;
                hunger = Math.min(100, hunger + 5);
                showMessage(' Ate flour... not great. +5 Hunger');
                updateUI(); updateHotbar();
            } else if (itemName === 'bread' && inventory.bread > 0) {
                inventory.bread--;
                hunger = Math.min(100, hunger + 35);
                showMessage(' Ate bread! +35 Hunger');
                updateUI(); updateHotbar();
            } else if (itemName === 'blackcurrant_jam' && inventory.blackcurrant_jam > 0) {
                inventory.blackcurrant_jam--;
                hunger = Math.min(100, hunger + 20); thirst = Math.min(100, thirst + 10);
                showMessage(' Ate blackcurrant jam! +20 Hunger, +10 Thirst');
                updateUI(); updateHotbar();
            } else if (itemName === 'strawberry_jam' && inventory.strawberry_jam > 0) {
                inventory.strawberry_jam--;
                hunger = Math.min(100, hunger + 20); thirst = Math.min(100, thirst + 10); health = Math.min(100, health + 5);
                showMessage(' Ate strawberry jam! +20 Hunger, +10 Thirst, +5 Health');
                updateUI(); updateHotbar();
            } else if (itemName === 'toast_jam' && inventory.toast_jam > 0) {
                inventory.toast_jam--;
                hunger = Math.min(100, hunger + 50); health = Math.min(100, health + 5);
                showMessage(' Ate toast with jam! +50 Hunger, +5 Health');
                updateUI(); updateHotbar();
            } else if (itemName === 'ham_sandwich' && inventory.ham_sandwich > 0) {
                inventory.ham_sandwich--;
                hunger = Math.min(100, hunger + 65); health = Math.min(100, health + 10); thirst = Math.min(100, thirst + 10);
                showMessage(' Ate ham sandwich! +65 Hunger, +10 Health, +10 Thirst');
                updateUI(); updateHotbar();
            }
        }
        
        // Start healing over time
        function startHealing(totalAmount, amountPerTick, ticks) {
            healingState.active = true;
            healingState.totalHealing = totalAmount;
            healingState.healPerTick = amountPerTick;
            healingState.healingsRemaining = ticks;
            healingState.lastTickTime = Date.now();
        }
        
        // Update healing over time
        function updateHealing() {
            if (!healingState.active) return;
            
            const now = Date.now();
            if (now - healingState.lastTickTime >= healingState.tickInterval) {
                health = Math.min(100, health + healingState.healPerTick);
                healingState.healingsRemaining--;
                healingState.lastTickTime = now;
                updateUI();
                
                if (healingState.healingsRemaining <= 0) {
                    healingState.active = false;
                    showMessage('\ud83d\udc9a Healing complete!');
                }
            }
        }
        
        // ===== ENHANCED TREES =====
        const trees = [];
        const treePositions = [];
        const stumpRespawnQueue = []; // Track stumps waiting to respawn
        const rockRespawnQueue = []; // Track rocks waiting to respawn
        const oreRespawnQueue = []; // Track ores waiting to respawn
        
        function createTree(x, z) {
            // Try GLB first; fall back to procedural if not loaded yet
            if (_assetGLBCache['Tree.glb']) {
                const targetH = 5.5 + Math.random() * 3.0;
                const inst = _instantiateGLB('Tree.glb', targetH);
                inst.position.set(x, inst.position.y, z);
                inst.rotation.y = Math.random() * Math.PI * 2;
                inst.userData.type = 'tree';
                inst.userData.health = 5;
                inst.userData.maxHealth = 5;
                inst.userData.trunkHeight = targetH * 0.65;
                inst.userData.swayPhase = Math.random() * Math.PI * 2;
                inst.userData.swaySpeed = 0.4 + Math.random() * 0.3;
                inst.userData.canopy = null;
                trees.push(inst);
                treePositions.push({ x, z, radius: 1.2 });
                scene.add(inst);
                return;
            }
            _loadAssetGLB('Tree.glb').then(() => { /* will be used on next spawn */ });
            const tree = new THREE.Group();
            
            // ?? Shape variation ??????????????????????????????????????????????
            // Pick a tree "archetype" so forests feel varied
            const archetype = Math.floor(Math.random() * 4);
            // 0 = tall/slender, 1 = short/wide, 2 = conical, 3 = lopsided
            
            const trunkHeight = archetype === 0 ? 7 + Math.random() * 3
                              : archetype === 1 ? 6 + Math.random() * 2
                              : archetype === 2 ? 6 + Math.random() * 2
                              :                   6 + Math.random() * 2.5;

            const trunkTopR    = archetype === 0 ? 0.28 + Math.random() * 0.08 : 0.35 + Math.random() * 0.12;
            const trunkBottomR = trunkTopR + 0.12 + Math.random() * 0.06;
            const trunkSegs    = 7 + Math.floor(Math.random() * 3); // 7?9 sides
            const trunkGeometry = new THREE.CylinderGeometry(trunkTopR, trunkBottomR, trunkHeight, trunkSegs);

            // Subtle random lean
            const leanX = (Math.random() - 0.5) * 0.12;
            const leanZ = (Math.random() - 0.5) * 0.12;

            // Better bark texture with more detail
            const barkData = new Uint8Array(16 * 16 * 4);
            for (let i = 0; i < 16 * 16; i++) {
                const bx = i % 16;
                const by = Math.floor(i / 16);
                const verticalPattern = Math.abs(Math.sin(bx * 0.8)) * 20;
                const horizontalRings = Math.abs(Math.sin(by * 0.5)) * 15;
                const noise = Math.random() * 10;
                const baseColor = 45 + verticalPattern + horizontalRings + noise;
                barkData[i * 4]     = baseColor;
                barkData[i * 4 + 1] = baseColor * 0.6;
                barkData[i * 4 + 2] = baseColor * 0.4;
                barkData[i * 4 + 3] = 255;
            }
            const trunkTexture = new THREE.DataTexture(barkData, 16, 16, THREE.RGBAFormat);
            trunkTexture.needsUpdate = true;
            trunkTexture.wrapS = THREE.RepeatWrapping;
            trunkTexture.wrapT = THREE.RepeatWrapping;
            trunkTexture.repeat.set(2, 4);
            trunkTexture.magFilter = THREE.NearestFilter;
            
            const trunkMaterial = new THREE.MeshStandardMaterial({
                map: trunkTexture,
                roughness: 0.95,
                metalness: 0
            });
            
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = trunkHeight / 2;
            trunk.rotation.x = leanX;
            trunk.rotation.z = leanZ;
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            tree.add(trunk);

            // ?? Optional side branch (50% chance) ???????????????????????????
            if (Math.random() < 0.5) {
                const branchAngle   = Math.random() * Math.PI * 2;          // random azimuth
                const branchHeightFrac = 0.55 + Math.random() * 0.3;        // 55?85% up trunk
                const branchY       = trunkHeight * branchHeightFrac;
                const branchLen     = 1.2 + Math.random() * 1.4;
                const branchR       = trunkTopR * (0.25 + Math.random() * 0.15);
                const branchGeo     = new THREE.CylinderGeometry(branchR * 0.4, branchR, branchLen, 6);
                const branch        = new THREE.Mesh(branchGeo, trunkMaterial);

                // Rotate so the cylinder points outward-and-upward from the trunk
                branch.rotation.z  =  Math.PI / 2;                          // lay it flat first
                branch.rotation.y  =  branchAngle;                          // azimuth
                // Tilt upward ~25?45?
                const tiltUp       = -(0.44 + Math.random() * 0.35);        // negative = tip goes up
                branch.rotation.x  = tiltUp;

                // Offset so the branch root sits at the trunk surface
                const offsetX = Math.cos(branchAngle) * trunkTopR;
                const offsetZ = Math.sin(branchAngle) * trunkTopR;
                branch.position.set(offsetX, branchY, offsetZ);
                branch.castShadow = true;
                tree.add(branch);

                // No separate tuft \ufffd branch blends into main crown
            }
            
            // ?? Foliage crown ????????????????????????????????????????????????
            // Archetype-specific crown shapes
            let foliageLayers, baseSize, sizeStep, spreadY, spreadXZ;
            if (archetype === 0) {          // tall / slender
                foliageLayers = 4; baseSize = 2.8; sizeStep = 0.5; spreadY = 1.8; spreadXZ = 0;
            } else if (archetype === 1) {   // short / wide
                foliageLayers = 2; baseSize = 4.2; sizeStep = 0.9; spreadY = 1.2; spreadXZ = 0.5;
            } else if (archetype === 2) {   // conical (pine-like stacked)
                foliageLayers = 5; baseSize = 3.2; sizeStep = 0.55; spreadY = 1.5; spreadXZ = -0.1;
            } else {                        // lopsided ? offset cluster
                foliageLayers = 3; baseSize = 3.0; sizeStep = 0.65; spreadY = 1.6; spreadXZ = 0.3;
            }

            for (let i = 0; i < foliageLayers; i++) {
                const size = baseSize - i * sizeStep;
                const foliageGeometry = new THREE.SphereGeometry(Math.max(size, 0.8), 8, 7);
                
                // Distort sphere vertices for a fluffy, non-uniform crown
                const fPos = foliageGeometry.attributes.position;
                for (let vi = 0; vi < fPos.count; vi++) {
                    const vx = fPos.getX(vi), vy = fPos.getY(vi), vz = fPos.getZ(vi);
                    const bumpScale = 0.12 + Math.random() * 0.1;
                    fPos.setXYZ(vi,
                        vx * (1 + (Math.random() - 0.5) * bumpScale),
                        vy * (1 + (Math.random() - 0.5) * bumpScale * 0.7),
                        vz * (1 + (Math.random() - 0.5) * bumpScale)
                    );
                }
                foliageGeometry.computeVertexNormals();

                const leafData = new Uint8Array(16 * 16 * 4);
                for (let j = 0; j < 16 * 16; j++) {
                    const lx = (j % 16) / 16;
                    const ly = Math.floor(j / 16) / 16;
                    const pattern = (Math.sin(lx * 8) * Math.cos(ly * 8) + 1) * 0.5;
                    const brightness = pattern + Math.random() * 0.2;
                    const greenBase = 50 + brightness * 80;
                    leafData[j * 4]     = greenBase * 0.4;
                    leafData[j * 4 + 1] = greenBase;
                    leafData[j * 4 + 2] = greenBase * 0.3;
                    leafData[j * 4 + 3] = 255;
                }
                const leafTexture = new THREE.DataTexture(leafData, 16, 16, THREE.RGBAFormat);
                leafTexture.needsUpdate = true;
                leafTexture.wrapS = THREE.RepeatWrapping;
                leafTexture.wrapT = THREE.RepeatWrapping;
                leafTexture.magFilter = THREE.NearestFilter;
                
                const foliageMaterial = new THREE.MeshStandardMaterial({
                    map: leafTexture,
                    color: new THREE.Color().setHSL(0.28 + Math.random() * 0.05 - i * 0.015, 0.78, 0.38 + i * 0.04),
                    roughness: 0.9,
                    metalness: 0,
                    flatShading: false
                });
                
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                // Lopsided archetype offsets the whole crown sideways
                const xOff = archetype === 3 ? (Math.random() - 0.5) * spreadXZ * 2 : 0;
                const zOff = archetype === 3 ? (Math.random() - 0.5) * spreadXZ * 2 : 0;
                // Push foliage down into the trunk top so no gap/flat-bottom is visible
                const overlapY = size * 0.18;  // small overlap to avoid gap, but trunk stays visible
                foliage.position.set(xOff, trunkHeight - overlapY + i * spreadY, zOff);
                // Squash bottom half slightly so the underside blends into the trunk
                foliage.scale.set(1, 0.82, 1);
                foliage.castShadow = true;
                foliage.receiveShadow = true;
                tree.add(foliage);
            }
            
            tree.position.set(x, 0, z);
            tree.userData.health = 3;
            tree.userData.type = 'tree';
            tree.userData.swayPhase = Math.random() * Math.PI * 2;
            tree.userData.swaySpeed = 0.5 + Math.random() * 0.3;
            
            // Dirt patch under trunk base
            const treeDirtRadius = trunkBottomR * 2.8 + Math.random() * 0.6;
            const treeDirtPatch = spawnDirtPatch(x, z, treeDirtRadius, 0.45);
            scene.add(treeDirtPatch);

            trees.push(tree);
            const _treePosEntry = { x, z, radius: 2 };
            tree.userData._posEntry = _treePosEntry;
            tree.userData._posArray = treePositions;
            treePositions.push(_treePosEntry);
            scene.add(tree);
        }
        
        // Create tree stump after tree is cut
        async function createTreeStump(x, z, trunkHeight) {
            const stump = new THREE.Group();
            
            // Stump trunk (short)
            const stumpHeight = 0.8;
            const stumpGeometry = new THREE.CylinderGeometry(0.45, 0.52, stumpHeight, 8);
            
            const trunkTexture = new THREE.DataTexture(
                new Uint8Array([
                    60, 40, 20, 255,  55, 38, 18, 255,
                    58, 39, 19, 255,  62, 41, 21, 255
                ]),
                2, 2, THREE.RGBAFormat
            );
            trunkTexture.needsUpdate = true;
            trunkTexture.wrapS = THREE.RepeatWrapping;
            trunkTexture.wrapT = THREE.RepeatWrapping;
            trunkTexture.repeat.set(1, 1);
            trunkTexture.magFilter = THREE.NearestFilter;
            
            const trunkMaterial = new THREE.MeshStandardMaterial({
                map: trunkTexture,
                roughness: 0.95,
                metalness: 0
            });
            
            const stumpMesh = new THREE.Mesh(stumpGeometry, trunkMaterial);
            stumpMesh.position.y = stumpHeight / 2;
            stumpMesh.castShadow = true;
            stumpMesh.receiveShadow = true;
            stump.add(stumpMesh);
            
            // Top of stump (flat cut surface)
            const topGeo = new THREE.CylinderGeometry(0.45, 0.45, 0.05, 16);
            const topMat = await createWoodMaterial(0xD2691E, 0.9);
            const top = new THREE.Mesh(topGeo, topMat);
            top.position.y = stumpHeight + 0.025;
            top.castShadow = true;
            top.receiveShadow = true;
            stump.add(top);
            
            // Tree rings on top
            for (let i = 0; i < 4; i++) {
                const ringGeo = new THREE.TorusGeometry(0.1 + (i * 0.08), 0.01, 8, 16);
                const ringMat = new THREE.MeshStandardMaterial({
                    color: 0x8B4513,
                    roughness: 0.95
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.position.y = stumpHeight + 0.03;
                ring.rotation.x = Math.PI / 2;
                stump.add(ring);
            }
            
            stump.position.set(x, 0, z);
            stump.userData.type = 'stump';
            stump.castShadow = true;
            stump.receiveShadow = true;
            
            scene.add(stump);
            return stump;
        }
        
        // Generate forest  spawn immediately (GLB used if loaded, else procedural fallback)
        for (let i = 0; i < 80; i++) {
            let x, z, valid;
            let attempts = 0;
            do {
                valid = true;
                x = (Math.random() - 0.5) * 180;
                z = (Math.random() - 0.5) * 180;
                
                if (Math.sqrt(x * x + z * z) < 15) {
                    valid = false;
                    continue;
                }
                
                for (let pos of treePositions) {
                    const dist = Math.sqrt((x - pos.x) ** 2 + (z - pos.z) ** 2);
                    if (dist < 8) {
                        valid = false;
                        break;
                    }
                }
                attempts++;
            } while (!valid && attempts < 50);
            
            if (valid) createTree(x, z);
        }

        // Once Tree.glb loads, swap all procedural FOREST trees for GLB versions
        _loadAssetGLB('Tree.glb').then(tmpl => {
            if (!tmpl) { console.warn(' Tree.glb failed  keeping procedural forest trees'); return; }
            console.log(` Tree.glb loaded  scanning ${trees.length} entries for procedural forest trees...`);
            let swapped = 0;
            for (let i = trees.length - 1; i >= 0; i--) {
                const old = trees[i];
                // Skip: wrong type, already a GLB (no swayPhase), or a palm tree
                if (old.userData.type !== 'tree') continue;
                if (!old.userData.swayPhase) continue;       // already a GLB instance  skip
                if (old.userData.isPalmTree) continue;        // palm trees get their own swap below
                const x = old.position.x, z = old.position.z;
                const targetH = 5.5 + Math.random() * 3.0;
                const inst = _instantiateGLB('Tree.glb', targetH);
                if (!inst) { console.warn(' _instantiateGLB returned null for Tree.glb'); continue; }
                inst.position.set(x, inst.position.y, z);
                inst.rotation.y = Math.random() * Math.PI * 2;
                inst.userData.type = 'tree';
                inst.userData.health = old.userData.health ?? 5;
                inst.userData.maxHealth = 5;
                inst.userData.trunkHeight = targetH * 0.65;
                inst.userData.swayPhase = Math.random() * Math.PI * 2;
                inst.userData.swaySpeed = 0.4 + Math.random() * 0.3;
                inst.userData._posEntry = old.userData._posEntry;
                inst.userData._posArray = old.userData._posArray;
                scene.remove(old);
                scene.add(inst);
                trees[i] = inst;
                swapped++;
                if (swapped === 1) {
                    inst.updateMatrixWorld(true);
                    const wp = new THREE.Vector3();
                    inst.getWorldPosition(wp);
                    const bb = new THREE.Box3().setFromObject(inst);
                    console.log(` FIRST TREE world pos: (${wp.x.toFixed(1)}, ${wp.y.toFixed(1)}, ${wp.z.toFixed(1)}) | bbox Y: ${bb.min.y.toFixed(2)}  ${bb.max.y.toFixed(2)} | inst.position.y=${inst.position.y.toFixed(3)} | scale=${inst.scale.x.toFixed(3)}`);
                }
            }
            console.log(` Forest tree swap done: ${swapped} procedural  GLB`);
        });

        // ===== ENHANCED ROCKS =====
        const rocks = [];
        const rockPositions = [];
        
        function createRock(x, z) {
            if (_assetGLBCache['Rock Medium.glb']) {
                const targetSize = 0.6 + Math.random() * 1.2;
                const inst = _instantiateGLB('Rock Medium.glb', targetSize);
                inst.position.set(x, inst.position.y, z);
                inst.rotation.y = Math.random() * Math.PI * 2;
                inst.userData.type = 'rock';
                inst.userData.health = 5;
                inst.userData.maxHealth = 5;
                inst.userData.resources = { stone: 3, flint: 1 };
                rocks.push(inst);
                rockPositions.push({ x, z, radius: targetSize * 0.7 });
                scene.add(inst);
                return;
            }
            _loadAssetGLB('Rock Medium.glb');
            const rock = new THREE.Group();
            
            const size = 0.8 + Math.random() * 0.6;
            
            // Main rock body - use sphere with higher subdivision for smoother look
            const rockGeometry = new THREE.SphereGeometry(size, 16, 12);
            
            // Apply noise-based distortion for natural irregular shape
            const positions = rockGeometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const vertex = new THREE.Vector3(
                    positions.getX(i),
                    positions.getY(i),
                    positions.getZ(i)
                );
                
                // Normalize to get direction
                const direction = vertex.clone().normalize();
                
                // Apply multiple octaves of noise for natural variation
                const noise1 = Math.sin(direction.x * 3.5 + direction.y * 2.1) * 
                              Math.cos(direction.z * 2.8);
                const noise2 = Math.sin(direction.x * 7.2) * 
                              Math.cos(direction.y * 6.4 + direction.z * 5.3);
                
                // Combine noises with different scales
                const distortion = 1.0 + noise1 * 0.15 + noise2 * 0.08;
                
                // Apply distortion
                vertex.multiplyScalar(distortion);
                
                // Slightly flatten the bottom
                if (vertex.y < 0) {
                    vertex.y *= 0.7;
                }
                
                positions.setXYZ(i, vertex.x, vertex.y, vertex.z);
            }
            rockGeometry.computeVertexNormals();
            
            // Rich procedural stone texture
            const stoneCanvas = document.createElement('canvas');
            stoneCanvas.width = 512;
            stoneCanvas.height = 512;
            const sCtx = stoneCanvas.getContext('2d');

            // Base stone colour \ufffd medium grey
            sCtx.fillStyle = '#8a8a8a';
            sCtx.fillRect(0, 0, 512, 512);

            // Large-scale colour variation patches
            for (let i = 0; i < 60; i++) {
                const px = Math.random() * 512, py = Math.random() * 512;
                const r  = 30 + Math.random() * 80;
                const grd = sCtx.createRadialGradient(px, py, 0, px, py, r);
                const light = Math.random() > 0.5;
                grd.addColorStop(0, light ? 'rgba(200,198,192,0.55)' : 'rgba(90,88,84,0.55)');
                grd.addColorStop(1, 'rgba(0,0,0,0)');
                sCtx.fillStyle = grd;
                sCtx.beginPath();
                sCtx.ellipse(px, py, r * 1.4, r * 0.8, Math.random() * Math.PI, 0, Math.PI * 2);
                sCtx.fill();
            }

            // Fine grain noise
            for (let i = 0; i < 8000; i++) {
                const px = Math.random() * 512, py = Math.random() * 512;
                const sz = 1 + Math.random() * 2.5;
                const br = Math.random();
                sCtx.fillStyle = br > 0.6
                    ? `rgba(180,175,165,${0.08 + Math.random() * 0.18})`
                    : `rgba(15,12,10,${0.08 + Math.random() * 0.18})`;
                sCtx.fillRect(px, py, sz, sz);
            }

            // Mineral/quartz streaks
            for (let i = 0; i < 12; i++) {
                sCtx.save();
                sCtx.strokeStyle = `rgba(200,195,185,${0.12 + Math.random() * 0.22})`;
                sCtx.lineWidth = 0.5 + Math.random() * 2;
                sCtx.beginPath();
                const sx = Math.random() * 512, sy = Math.random() * 512;
                sCtx.moveTo(sx, sy);
                sCtx.bezierCurveTo(
                    sx + (Math.random()-0.5)*120, sy + (Math.random()-0.5)*120,
                    sx + (Math.random()-0.5)*120, sy + (Math.random()-0.5)*120,
                    sx + (Math.random()-0.5)*200, sy + (Math.random()-0.5)*200
                );
                sCtx.stroke();
                sCtx.restore();
            }

            // Dark cracks
            for (let i = 0; i < 8; i++) {
                sCtx.save();
                sCtx.strokeStyle = `rgba(10,8,6,${0.4 + Math.random() * 0.35})`;
                sCtx.lineWidth = 0.8 + Math.random() * 1.5;
                sCtx.beginPath();
                let crx = Math.random() * 512, cry = Math.random() * 512;
                sCtx.moveTo(crx, cry);
                for (let j = 0; j < 4; j++) {
                    crx += (Math.random()-0.5)*80; cry += (Math.random()-0.5)*80;
                    sCtx.lineTo(crx, cry);
                }
                sCtx.stroke();
                sCtx.restore();
            }

            // Subtle moss/lichen patches near bottom
            for (let i = 0; i < 18; i++) {
                const px = Math.random() * 512, py = 300 + Math.random() * 212;
                const r  = 10 + Math.random() * 30;
                const grd2 = sCtx.createRadialGradient(px, py, 0, px, py, r);
                grd2.addColorStop(0, 'rgba(72,85,45,0.45)');
                grd2.addColorStop(1, 'rgba(0,0,0,0)');
                sCtx.fillStyle = grd2;
                sCtx.beginPath();
                sCtx.ellipse(px, py, r, r * 0.7, Math.random()*Math.PI, 0, Math.PI*2);
                sCtx.fill();
            }

            const stoneTexture = new THREE.CanvasTexture(stoneCanvas);
            stoneTexture.wrapS = THREE.RepeatWrapping;
            stoneTexture.wrapT = THREE.RepeatWrapping;
            stoneTexture.encoding = THREE.sRGBEncoding;

            const rockMaterial = new THREE.MeshStandardMaterial({
                map: stoneTexture,
                color: 0xbbbbbb,
                roughness: 0.97,
                metalness: 0.02,
                flatShading: false
            });
            
            const rockMesh = new THREE.Mesh(rockGeometry, rockMaterial);
            rockMesh.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            rockMesh.castShadow = true;
            rockMesh.receiveShadow = true;
            rock.add(rockMesh);
            
            // Add smaller rocks around base
            for (let i = 0; i < 2; i++) {
                const smallSize = size * (0.15 + Math.random() * 0.15);
                const smallGeo = new THREE.SphereGeometry(smallSize, 8, 6);
                
                // Distort small rocks too
                const smallPositions = smallGeo.attributes.position;
                for (let j = 0; j < smallPositions.count; j++) {
                    const v = new THREE.Vector3(
                        smallPositions.getX(j),
                        smallPositions.getY(j),
                        smallPositions.getZ(j)
                    );
                    const dir = v.clone().normalize();
                    const n = Math.sin(dir.x * 5) * Math.cos(dir.y * 4 + dir.z * 3);
                    v.multiplyScalar(1.0 + n * 0.2);
                    smallPositions.setXYZ(j, v.x, v.y, v.z);
                }
                smallGeo.computeVertexNormals();
                
                const smallRock = new THREE.Mesh(smallGeo, rockMaterial);
                const angle = Math.random() * Math.PI * 2;
                const dist = size * 0.7;
                smallRock.position.set(
                    Math.cos(angle) * dist,
                    smallSize * 0.3,
                    Math.sin(angle) * dist
                );
                smallRock.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                smallRock.castShadow = true;
                rock.add(smallRock);
            }
            
            // Compute actual lowest point of the distorted+rotated geometry
            rock.updateMatrixWorld(true);
            const rockBox = new THREE.Box3().setFromObject(rock);
            const rockHeight = rockBox.max.y - rockBox.min.y;
            rock.position.set(x, -rockBox.min.y - rockHeight * 0.3, z);
            rock.userData.health = 3;
            rock.userData.maxHealth = 3;
            rock.userData.type = 'rock';
            
            rocks.push(rock);
            const _rockPos = { x, z, radius: size * 1.5 };
            rock.userData._posEntry = _rockPos;
            rock.userData._posArray = rockPositions;
            rockPositions.push(_rockPos);
            scene.add(rock);

            // Dirt patch at original size
            const dirtPatch = spawnDirtPatch(x, z, size * 2.5 + Math.random() * 0.8);
            scene.add(dirtPatch);
        }
        
        // Generate rocks
        for (let i = 0; i < 20; i++) {
            let x, z, valid;
            let attempts = 0;
            do {
                valid = true;
                x = (Math.random() - 0.5) * 180;
                z = (Math.random() - 0.5) * 180;
                
                if (Math.sqrt(x * x + z * z) < 15) {
                    valid = false;
                    continue;
                }
                
                for (let pos of [...treePositions, ...rockPositions]) {
                    const dist = Math.sqrt((x - pos.x) ** 2 + (z - pos.z) ** 2);
                    if (dist < 5) {
                        valid = false;
                        break;
                    }
                }
                attempts++;
            } while (!valid && attempts < 50);
            
            if (valid) createRock(x, z);
        }

        // Once Rock Medium.glb loads, swap procedural rocks for GLB versions
        _loadAssetGLB('Rock Medium.glb').then(tmpl => {
            if (!tmpl) return;
            for (let i = rocks.length - 1; i >= 0; i--) {
                const old = rocks[i];
                if (old.userData.type !== 'rock') continue;
                const x = old.position.x, z = old.position.z;
                const targetSize = 0.6 + Math.random() * 1.2;
                const inst = _instantiateGLB('Rock Medium.glb', targetSize);
                inst.position.set(x, inst.position.y, z);
                inst.rotation.y = Math.random() * Math.PI * 2;
                inst.userData.type = 'rock';
                inst.userData.health = old.userData.health ?? 5;
                inst.userData.maxHealth = 5;
                inst.userData.resources = { stone: 3, flint: 1 };
                inst.userData._posEntry = old.userData._posEntry;
                inst.userData._posArray = old.userData._posArray;
                scene.remove(old);
                scene.add(inst);
                rocks[i] = inst;
            }
        });

        // ===== METAL ORE NODES =====
        const metalOres = [];
        const orePositions = [];
        
        function createMetalOre(x, z) {
            const ore = new THREE.Group();
            
            const size = 0.9 + Math.random() * 0.5;
            
            // Dark procedural ore texture \ufffd near-black with rusty/metallic tones
            const oreCanvas = document.createElement('canvas');
            oreCanvas.width = 512; oreCanvas.height = 512;
            const oCtx = oreCanvas.getContext('2d');

            // Very dark base \ufffd reddish brown
            oCtx.fillStyle = '#5c3020';
            oCtx.fillRect(0, 0, 512, 512);

            // Dark variation patches
            for (let i = 0; i < 50; i++) {
                const px = Math.random() * 512, py = Math.random() * 512;
                const r = 25 + Math.random() * 70;
                const grd = oCtx.createRadialGradient(px, py, 0, px, py, r);
                const light = Math.random() > 0.5;
                grd.addColorStop(0, light ? 'rgba(130,70,40,0.6)' : 'rgba(35,15,8,0.6)');
                grd.addColorStop(1, 'rgba(0,0,0,0)');
                oCtx.fillStyle = grd;
                oCtx.beginPath();
                oCtx.ellipse(px, py, r * 1.3, r * 0.8, Math.random() * Math.PI, 0, Math.PI * 2);
                oCtx.fill();
            }

            // Fine grain noise
            for (let i = 0; i < 8000; i++) {
                const px = Math.random() * 512, py = Math.random() * 512;
                const sz = 1 + Math.random() * 2;
                oCtx.fillStyle = Math.random() > 0.6
                    ? `rgba(160,80,40,${0.06 + Math.random() * 0.14})`
                    : `rgba(30,10,5,${0.1 + Math.random() * 0.2})`;
                oCtx.fillRect(px, py, sz, sz);
            }

            // Rusty orange-brown streaks \ufffd hints of iron ore
            for (let i = 0; i < 10; i++) {
                oCtx.save();
                oCtx.strokeStyle = `rgba(${180 + Math.random()*60},${80 + Math.random()*40},20,${0.3 + Math.random() * 0.35})`;
                oCtx.lineWidth = 1 + Math.random() * 3;
                oCtx.beginPath();
                const sx = Math.random() * 512, sy = Math.random() * 512;
                oCtx.moveTo(sx, sy);
                oCtx.bezierCurveTo(
                    sx + (Math.random()-0.5)*140, sy + (Math.random()-0.5)*140,
                    sx + (Math.random()-0.5)*140, sy + (Math.random()-0.5)*140,
                    sx + (Math.random()-0.5)*220, sy + (Math.random()-0.5)*220
                );
                oCtx.stroke();
                oCtx.restore();
            }

            // Sharp cracks
            for (let i = 0; i < 6; i++) {
                oCtx.save();
                oCtx.strokeStyle = `rgba(5,3,2,${0.6 + Math.random() * 0.3})`;
                oCtx.lineWidth = 0.8 + Math.random() * 1.5;
                oCtx.beginPath();
                let crx = Math.random() * 512, cry = Math.random() * 512;
                oCtx.moveTo(crx, cry);
                for (let j = 0; j < 4; j++) {
                    crx += (Math.random()-0.5)*90; cry += (Math.random()-0.5)*90;
                    oCtx.lineTo(crx, cry);
                }
                oCtx.stroke();
                oCtx.restore();
            }

            const oreBaseTexture = new THREE.CanvasTexture(oreCanvas);
            oreBaseTexture.wrapS = THREE.RepeatWrapping;
            oreBaseTexture.wrapT = THREE.RepeatWrapping;
            oreBaseTexture.encoding = THREE.sRGBEncoding;

            const baseMat = new THREE.MeshStandardMaterial({
                map: oreBaseTexture,
                color: 0xaaaaaa,
                roughness: 0.55,
                metalness: 0.35,
                flatShading: true
            });

            const baseGeo = new THREE.SphereGeometry(size * 1.1, 7, 6);

            // Slightly distort for a natural lumpy rock shape (no sharp angles)
            const bPos = baseGeo.attributes.position;
            for (let i = 0; i < bPos.count; i++) {
                const v = new THREE.Vector3(bPos.getX(i), bPos.getY(i), bPos.getZ(i));
                const dir = v.clone().normalize();
                const n = Math.sin(dir.x * 4 + dir.y * 2.5) * Math.cos(dir.z * 3.2);
                const n2 = Math.sin(dir.x * 8) * Math.cos(dir.y * 7 + dir.z * 5);
                v.multiplyScalar(1.0 + n * 0.12 + n2 * 0.06);
                if (v.y < 0) v.y *= 0.75;
                bPos.setXYZ(i, v.x, v.y, v.z);
            }
            baseGeo.computeVertexNormals();

            const baseMesh = new THREE.Mesh(baseGeo, baseMat);
            baseMesh.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            baseMesh.castShadow = true;
            baseMesh.receiveShadow = true;
            ore.add(baseMesh);

            // Compute actual lowest point so the ore sits flush on the ground
            ore.updateMatrixWorld(true);
            const oreBox = new THREE.Box3().setFromObject(ore);
            const oreHeight = oreBox.max.y - oreBox.min.y;
            ore.position.set(x, -oreBox.min.y - oreHeight * 0.3, z);
            ore.userData.health = 4;
            ore.userData.maxHealth = 4;
            ore.userData.type = 'metal_ore';
            
            metalOres.push(ore);
            const _orePos = { x, z, radius: 1.5 };
            ore.userData._posEntry = _orePos;
            ore.userData._posArray = orePositions;
            orePositions.push(_orePos);
            scene.add(ore);

            // Dirt patch at original size
            const dirtPatch = spawnDirtPatch(x, z, size * 2.5 + Math.random() * 0.8);
            scene.add(dirtPatch);
        }
        
        // Generate metal ore nodes
        for (let i = 0; i < 10; i++) {
            let x, z, valid;
            let attempts = 0;
            do {
                valid = true;
                x = (Math.random() - 0.5) * 180;
                z = (Math.random() - 0.5) * 180;
                
                if (Math.sqrt(x * x + z * z) < 15) {
                    valid = false;
                    continue;
                }
                
                for (let pos of [...treePositions, ...rockPositions, ...orePositions]) {
                    const dist = Math.sqrt((x - pos.x) ** 2 + (z - pos.z) ** 2);
                    if (dist < 6) {
                        valid = false;
                        break;
                    }
                }
                attempts++;
            } while (!valid && attempts < 50);
            
            if (valid) createMetalOre(x, z);
        }

        // ===== SULPHUR ORE NODES =====
        const sulfurOres = [];
        const sulfurPositions = [];

        function createSulfurOre(x, z) {
            const ore = new THREE.Group();
            const size = 0.9 + Math.random() * 0.5;

            // Stone-like base texture with green sulphur veins
            const sCanvas = document.createElement('canvas');
            sCanvas.width = 512; sCanvas.height = 512;
            const sCtx2 = sCanvas.getContext('2d');

            // Base \ufffd same medium grey as stone nodes
            sCtx2.fillStyle = '#8a8a8a';
            sCtx2.fillRect(0, 0, 512, 512);

            // Large-scale grey variation patches
            for (let i = 0; i < 60; i++) {
                const px = Math.random() * 512, py = Math.random() * 512;
                const r = 30 + Math.random() * 80;
                const grd = sCtx2.createRadialGradient(px, py, 0, px, py, r);
                const light = Math.random() > 0.5;
                grd.addColorStop(0, light ? 'rgba(200,198,192,0.55)' : 'rgba(90,88,84,0.55)');
                grd.addColorStop(1, 'rgba(0,0,0,0)');
                sCtx2.fillStyle = grd;
                sCtx2.beginPath();
                sCtx2.ellipse(px, py, r * 1.4, r * 0.8, Math.random() * Math.PI, 0, Math.PI * 2);
                sCtx2.fill();
            }

            // Fine grain noise
            for (let i = 0; i < 8000; i++) {
                const px = Math.random() * 512, py = Math.random() * 512;
                const sz = 1 + Math.random() * 2.5;
                sCtx2.fillStyle = Math.random() > 0.6
                    ? `rgba(180,175,165,${0.08 + Math.random() * 0.18})`
                    : `rgba(15,12,10,${0.08 + Math.random() * 0.18})`;
                sCtx2.fillRect(px, py, sz, sz);
            }

            // Bright green sulphur veins cutting through the rock
            for (let i = 0; i < 14; i++) {
                sCtx2.save();
                const greenAlpha = 0.5 + Math.random() * 0.4;
                sCtx2.strokeStyle = `rgba(${60 + Math.random()*40},${160 + Math.random()*60},${20 + Math.random()*30},${greenAlpha})`;
                sCtx2.lineWidth = 1.5 + Math.random() * 4;
                sCtx2.beginPath();
                const sx = Math.random() * 512, sy = Math.random() * 512;
                sCtx2.moveTo(sx, sy);
                sCtx2.bezierCurveTo(
                    sx + (Math.random()-0.5)*150, sy + (Math.random()-0.5)*150,
                    sx + (Math.random()-0.5)*150, sy + (Math.random()-0.5)*150,
                    sx + (Math.random()-0.5)*240, sy + (Math.random()-0.5)*240
                );
                sCtx2.stroke();
                // Thin bright highlight down centre of vein
                sCtx2.strokeStyle = `rgba(180,255,100,${greenAlpha * 0.5})`;
                sCtx2.lineWidth = 0.5;
                sCtx2.stroke();
                sCtx2.restore();
            }

            // Green sulphur deposit blobs
            for (let i = 0; i < 20; i++) {
                const px = Math.random() * 512, py = Math.random() * 512;
                const r = 5 + Math.random() * 18;
                const grd = sCtx2.createRadialGradient(px, py, 0, px, py, r);
                grd.addColorStop(0, `rgba(100,200,40,0.55)`);
                grd.addColorStop(1, 'rgba(0,0,0,0)');
                sCtx2.fillStyle = grd;
                sCtx2.beginPath();
                sCtx2.ellipse(px, py, r, r * 0.7, Math.random()*Math.PI, 0, Math.PI*2);
                sCtx2.fill();
            }

            // Dark cracks
            for (let i = 0; i < 8; i++) {
                sCtx2.save();
                sCtx2.strokeStyle = `rgba(10,8,6,${0.4 + Math.random() * 0.3})`;
                sCtx2.lineWidth = 0.8 + Math.random() * 1.5;
                sCtx2.beginPath();
                let crx = Math.random() * 512, cry = Math.random() * 512;
                sCtx2.moveTo(crx, cry);
                for (let j = 0; j < 4; j++) {
                    crx += (Math.random()-0.5)*80; cry += (Math.random()-0.5)*80;
                    sCtx2.lineTo(crx, cry);
                }
                sCtx2.stroke();
                sCtx2.restore();
            }

            const sulfurTexture = new THREE.CanvasTexture(sCanvas);
            sulfurTexture.wrapS = THREE.RepeatWrapping;
            sulfurTexture.wrapT = THREE.RepeatWrapping;
            sulfurTexture.encoding = THREE.sRGBEncoding;

            const baseMat = new THREE.MeshStandardMaterial({
                map: sulfurTexture,
                color: 0xcccccc,
                roughness: 0.58,
                metalness: 0.28,
                flatShading: false
            });

            // Rounded lumpy shape like the stone node
            const baseGeo = new THREE.SphereGeometry(size * 1.05, 16, 12);
            const bPos = baseGeo.attributes.position;
            for (let i = 0; i < bPos.count; i++) {
                const v = new THREE.Vector3(bPos.getX(i), bPos.getY(i), bPos.getZ(i));
                const dir = v.clone().normalize();
                const n1 = Math.sin(dir.x * 3.5 + dir.y * 2.1) * Math.cos(dir.z * 2.8);
                const n2 = Math.sin(dir.x * 7.2) * Math.cos(dir.y * 6.4 + dir.z * 5.3);
                v.multiplyScalar(1.0 + n1 * 0.15 + n2 * 0.08);
                if (v.y < 0) v.y *= 0.7;
                bPos.setXYZ(i, v.x, v.y, v.z);
            }
            baseGeo.computeVertexNormals();

            const baseMesh = new THREE.Mesh(baseGeo, baseMat);
            baseMesh.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            baseMesh.castShadow = true;
            baseMesh.receiveShadow = true;
            ore.add(baseMesh);

            // Green sulphur crystals protruding from surface
            const crystalMat = new THREE.MeshStandardMaterial({
                color: 0x4ac420,
                roughness: 0.3,
                metalness: 0.1,
                emissive: 0x2a7010,
                emissiveIntensity: 0.25,
                flatShading: true,
                transparent: true,
                opacity: 0.88
            });

            const numCrystals = 4 + Math.floor(Math.random() * 4);
            for (let i = 0; i < numCrystals; i++) {
                // Cluster 2-3 small crystals together per group
                const clusterAngle = (i / numCrystals) * Math.PI * 2 + (Math.random()-0.5) * 0.5;
                const clusterPhi = 0.3 + Math.random() * 1.0;
                const clusterBase = new THREE.Vector3(
                    Math.sin(clusterPhi) * Math.cos(clusterAngle),
                    Math.cos(clusterPhi),
                    Math.sin(clusterPhi) * Math.sin(clusterAngle)
                ).multiplyScalar(size * 0.85);

                const numInCluster = 2 + Math.floor(Math.random() * 2);
                for (let j = 0; j < numInCluster; j++) {
                    const cSize = size * (0.12 + Math.random() * 0.18);
                    // Use a tapered cone-like shape for crystals
                    const cGeo = new THREE.CylinderGeometry(0, cSize * 0.5, cSize * 2.5, 5, 1);
                    const crystal = new THREE.Mesh(cGeo, crystalMat);
                    crystal.position.copy(clusterBase).addScaledVector(
                        new THREE.Vector3((Math.random()-0.5)*0.3, (Math.random()-0.5)*0.3, (Math.random()-0.5)*0.3), size * 0.2
                    );
                    // Point outward from centre
                    crystal.lookAt(crystal.position.clone().multiplyScalar(2));
                    crystal.rotateX(-Math.PI / 2);
                    crystal.rotateZ(Math.random() * Math.PI);
                    crystal.castShadow = true;
                    ore.add(crystal);
                }
            }

            ore.updateMatrixWorld(true);
            const oreBox = new THREE.Box3().setFromObject(ore);
            const oreHeight = oreBox.max.y - oreBox.min.y;
            ore.position.set(x, -oreBox.min.y - oreHeight * 0.3, z);
            ore.userData.health = 4;
            ore.userData.maxHealth = 4;
            ore.userData.type = 'sulfur_ore';

            sulfurOres.push(ore);
            const _sulfurPos = { x, z, radius: size * 1.5 };
            ore.userData._posEntry = _sulfurPos;
            ore.userData._posArray = sulfurPositions;
            sulfurPositions.push(_sulfurPos);
            scene.add(ore);

            const dirtPatch = spawnDirtPatch(x, z, size * 2.5 + Math.random() * 0.8);
            scene.add(dirtPatch);
        }

        // Generate sulphur ore nodes
        for (let i = 0; i < 8; i++) {
            let x, z, valid;
            let attempts = 0;
            do {
                valid = true;
                x = (Math.random() - 0.5) * 180;
                z = (Math.random() - 0.5) * 180;
                if (Math.sqrt(x * x + z * z) < 15) { valid = false; continue; }
                for (let pos of [...treePositions, ...rockPositions, ...orePositions, ...sulfurPositions]) {
                    if (Math.sqrt((x - pos.x) ** 2 + (z - pos.z) ** 2) < 6) { valid = false; break; }
                }
                attempts++;
            } while (!valid && attempts < 50);
            if (valid) createSulfurOre(x, z);
        }

        // ===== DESERT ROCKS & ORE NODES =====
        // Spawned after all position arrays are initialised.
        {
            const drMargin   = 10;
            const drCenterZ  = -desertOffset + 0.5;
            const drHalf     = groundSize / 2 - drMargin;
            const drXMin     = -groundSize / 2 + drMargin;
            const drXMax     =  groundSize / 2 - drMargin;
            const drZMin     = drCenterZ - drHalf;
            const drZMax     = drCenterZ + drHalf - 18;

            function desertRandomPos() {
                return {
                    x: drXMin + Math.random() * (drXMax - drXMin),
                    z: drZMin + Math.random() * (drZMax - drZMin)
                };
            }

            function tryDesertSpawn(minDist, spawnFn, count) {
                for (let i = 0; i < count; i++) {
                    let attempts = 0, valid = false, x, z;
                    do {
                        const p = desertRandomPos();
                        x = p.x; z = p.z;
                        valid = true;
                        // Avoid rock formations
                        for (const ob of desertFormationColliders) {
                            if (Math.sqrt((x-ob.x)**2 + (z-ob.z)**2) < ob.r + 2) { valid = false; break; }
                        }
                        if (!valid) continue;
                        // Avoid other desert rocks/ores already placed
                        for (const pos of [...rockPositions, ...orePositions, ...sulfurPositions]) {
                            if (Math.sqrt((x-pos.x)**2 + (z-pos.z)**2) < minDist) { valid = false; break; }
                        }
                        attempts++;
                    } while (!valid && attempts < 80);
                    if (valid) spawnFn(x, z);
                }
            }

            tryDesertSpawn(5, createRock, 14);
            tryDesertSpawn(6, createMetalOre, 6);
            tryDesertSpawn(6, createSulfurOre, 4);
        }

        // ===== DESERT CACTI =====
        const cacti = [];
        const cactiPositions = [];

        function createCactus(x, z) {
            const cactusGlb = Math.random() > 0.35 ? 'Cactus.glb' : 'Prickly pear cactus.glb';
            if (_assetGLBCache[cactusGlb]) {
                const targetH = 1.2 + Math.random() * 1.5;
                const inst = _instantiateGLB(cactusGlb, targetH);
                inst.position.set(x, inst.position.y, z);
                inst.rotation.y = Math.random() * Math.PI * 2;
                inst.userData.type = 'cactus';
                inst.userData.hasCloth = true;
                cacti.push(inst);
                cactiPositions.push({ x, z, radius: 0.6 });
                scene.add(inst);
                return;
            }
            _loadAssetGLB(cactusGlb);
            const group = new THREE.Group();

            // Cactus green material - waxy, slightly shiny
            const cactusMat = new THREE.MeshStandardMaterial({
                color: new THREE.Color(0.18 + Math.random()*0.06, 0.42 + Math.random()*0.08, 0.18 + Math.random()*0.06),
                roughness: 0.72,
                metalness: 0.04,
            });
            const spineMat = new THREE.MeshStandardMaterial({ color: 0xf0e8c8, roughness: 0.8 });

            const cactusType = Math.floor(Math.random() * 3); // 0=saguaro, 1=barrel, 2=small branched

            function addSpines(mesh, radius, height, count) {
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2 + Math.random() * 0.3;
                    const y = (Math.random() - 0.1) * height * 0.5;
                    const spineLen = 0.06 + Math.random() * 0.07;
                    const spineGeo = new THREE.CylinderGeometry(0.004, 0.001, spineLen, 3);
                    const spine = new THREE.Mesh(spineGeo, spineMat);
                    spine.position.set(
                        Math.cos(angle) * (radius + spineLen * 0.4),
                        y,
                        Math.sin(angle) * (radius + spineLen * 0.4)
                    );
                    spine.rotation.z = Math.PI / 2;
                    spine.rotation.y = -angle;
                    spine.castShadow = false;
                    group.add(spine);
                }
            }

            if (cactusType === 0) {
                // Saguaro - tall central column with 1-2 arms
                const trunkH = 2.5 + Math.random() * 2.0;
                const trunkR = 0.18 + Math.random() * 0.08;
                const trunkGeo = new THREE.CylinderGeometry(trunkR * 0.85, trunkR, trunkH, 9);
                const trunk = new THREE.Mesh(trunkGeo, cactusMat);
                trunk.position.y = trunkH / 2;
                trunk.castShadow = trunk.receiveShadow = true;
                group.add(trunk);
                addSpines(trunk, trunkR, trunkH, 24);

                // Top rounded cap
                const capGeo = new THREE.SphereGeometry(trunkR * 0.88, 8, 6, 0, Math.PI*2, 0, Math.PI*0.55);
                const cap = new THREE.Mesh(capGeo, cactusMat);
                cap.position.y = trunkH;
                group.add(cap);

                // 1 or 2 arms
                const armCount = Math.random() > 0.4 ? (Math.random() > 0.5 ? 2 : 1) : 0;
                for (let a = 0; a < armCount; a++) {
                    const armAngle = (a === 0 ? 0.6 : -0.7) + (Math.random()-0.5)*0.4;
                    const armBaseY = trunkH * (0.45 + Math.random() * 0.25);
                    const armR = trunkR * 0.72;
                    // Horizontal segment
                    const hLen = 0.4 + Math.random() * 0.5;
                    const hGeo = new THREE.CylinderGeometry(armR, armR*1.05, hLen, 8);
                    const hArm = new THREE.Mesh(hGeo, cactusMat);
                    hArm.rotation.z = Math.PI / 2;
                    hArm.position.set(Math.cos(armAngle) * hLen * 0.5, armBaseY, Math.sin(armAngle) * hLen * 0.5);
                    group.add(hArm);
                    // Vertical segment going up
                    const vLen = 0.6 + Math.random() * 0.7;
                    const vGeo = new THREE.CylinderGeometry(armR * 0.82, armR, vLen, 8);
                    const vArm = new THREE.Mesh(vGeo, cactusMat);
                    vArm.position.set(Math.cos(armAngle) * hLen, armBaseY + vLen/2, Math.sin(armAngle) * hLen);
                    group.add(vArm);
                    addSpines(vArm, armR, vLen, 14);
                }

            } else if (cactusType === 1) {
                // Barrel cactus - short fat ribbed cylinder
                const h = 0.7 + Math.random() * 0.6;
                const r = 0.22 + Math.random() * 0.14;
                // Ribbed look via multiple overlapping slightly offset cylinders
                const ribCount = 10;
                for (let i = 0; i < ribCount; i++) {
                    const ribAngle = (i / ribCount) * Math.PI * 2;
                    const ribGeo = new THREE.CylinderGeometry(r * 0.28, r * 0.30, h, 5);
                    const rib = new THREE.Mesh(ribGeo, cactusMat);
                    rib.position.set(Math.cos(ribAngle) * r * 0.72, h/2, Math.sin(ribAngle) * r * 0.72);
                    rib.castShadow = true;
                    group.add(rib);
                    // Spines on each rib
                    for (let s = 0; s < 4; s++) {
                        const sy = (s / 3 - 0.5) * h * 0.7;
                        const spineLen = 0.07 + Math.random() * 0.05;
                        const sGeo = new THREE.CylinderGeometry(0.004, 0.001, spineLen, 3);
                        const spine = new THREE.Mesh(sGeo, spineMat);
                        spine.position.set(Math.cos(ribAngle) * (r + spineLen*0.5), h/2 + sy, Math.sin(ribAngle) * (r + spineLen*0.5));
                        spine.rotation.z = Math.PI/2;
                        spine.rotation.y = -ribAngle;
                        group.add(spine);
                    }
                }
                // Domed top with a small flower
                const topGeo = new THREE.SphereGeometry(r * 0.9, 8, 5, 0, Math.PI*2, 0, Math.PI*0.5);
                const top = new THREE.Mesh(topGeo, cactusMat);
                top.position.y = h;
                group.add(top);

            } else {
                // Small branched cluster - 3-5 short columns at ground level
                const count = 2 + Math.floor(Math.random() * 3);
                const offsets = [{x:0,z:0},{x:0.28,z:0.1},{x:-0.22,z:0.18},{x:0.05,z:-0.28},{x:-0.15,z:-0.2}];
                for (let i = 0; i < count; i++) {
                    const h = 0.5 + Math.random() * 0.8;
                    const r = 0.10 + Math.random() * 0.06;
                    const seg = new THREE.CylinderGeometry(r*0.88, r, h, 8);
                    const m = new THREE.Mesh(seg, cactusMat);
                    m.position.set(offsets[i].x, h/2, offsets[i].z);
                    m.rotation.y = Math.random() * Math.PI;
                    m.castShadow = m.receiveShadow = true;
                    group.add(m);
                    addSpines(m, r, h, 16);
                    const capG = new THREE.SphereGeometry(r*0.9, 7, 5, 0, Math.PI*2, 0, Math.PI*0.5);
                    const capM = new THREE.Mesh(capG, cactusMat);
                    capM.position.set(offsets[i].x, h, offsets[i].z);
                    group.add(capM);
                }
            }

            group.position.set(x, 0, z);
            group.rotation.y = Math.random() * Math.PI * 2;
            group.userData.type = 'cactus';
            group.userData.hasCloth = true; // freshly harvestable
            cacti.push(group);
            cactiPositions.push({ x, z, radius: 0.6 });
            scene.add(group);
        }

        // Spawn 20-26 cacti across the desert, avoiding formations and other obstacles
        {
            const dcMargin  = 8;
            const dcCenterZ = -desertOffset + 0.5;
            const dcHalf    = groundSize / 2 - dcMargin;
            const dcXMin    = -groundSize / 2 + dcMargin;
            const dcXMax    =  groundSize / 2 - dcMargin;
            const dcZMin    = dcCenterZ - dcHalf;
            const dcZMax    = dcCenterZ + dcHalf - 18;
            const numCacti  = 20 + Math.floor(Math.random() * 7);

            for (let i = 0; i < numCacti; i++) {
                let attempts = 0, valid = false, fx, fz;
                do {
                    fx = dcXMin + Math.random() * (dcXMax - dcXMin);
                    fz = dcZMin + Math.random() * (dcZMax - dcZMin);
                    valid = true;
                    for (const ob of desertFormationColliders) {
                        if (Math.sqrt((fx-ob.x)**2+(fz-ob.z)**2) < ob.r + 1.5) { valid=false; break; }
                    }
                    if (!valid) { attempts++; continue; }
                    for (const p of [...rockPositions, ...orePositions, ...sulfurPositions, ...cactiPositions]) {
                        if (Math.sqrt((fx-p.x)**2+(fz-p.z)**2) < 4) { valid=false; break; }
                    }
                    attempts++;
                } while (!valid && attempts < 80);
                if (valid) createCactus(fx, fz);
            }
        }

        // Once cactus GLBs load, swap procedural cacti for GLB versions
        Promise.all([_loadAssetGLB('Cactus.glb'), _loadAssetGLB('Prickly pear cactus.glb')]).then(() => {
            console.log(` Cactus GLBs loaded  scanning ${cacti.length} cacti for swap...`);
            let swapped = 0;
            for (let i = cacti.length - 1; i >= 0; i--) {
                const old = cacti[i];
                if (old.userData.type !== 'cactus') continue;
                const x = old.position.x, z = old.position.z;
                const glbName = Math.random() > 0.35 ? 'Cactus.glb' : 'Prickly pear cactus.glb';
                if (!_assetGLBCache[glbName]) continue;
                const targetH = 1.2 + Math.random() * 1.5;
                const inst = _instantiateGLB(glbName, targetH);
                if (!inst) { console.warn(` _instantiateGLB null for ${glbName}`); continue; }
                inst.position.set(x, inst.position.y, z);
                inst.rotation.y = Math.random() * Math.PI * 2;
                inst.userData.type = 'cactus';
                inst.userData.hasCloth = old.userData.hasCloth ?? true;
                scene.remove(old);
                scene.add(inst);
                cacti[i] = inst;
                swapped++;
            }
            console.log(` Cactus swap done: ${swapped} procedural  GLB`);
        });


        // ===== DESERT PALM TREES =====
        function createPalmTree(x, z) {
            if (_assetGLBCache['Palm Tree.glb']) {
                const targetH = 5.0 + Math.random() * 3.5;
                const inst = _instantiateGLB('Palm Tree.glb', targetH);
                inst.position.set(x, inst.position.y, z);
                inst.rotation.y = Math.random() * Math.PI * 2;
                inst.userData.type = 'tree';
                inst.userData.isPalmTree = true;
                inst.userData.health = 3;
                inst.userData.maxHealth = 3;
                inst.userData.trunkHeight = targetH * 0.75;
                inst.userData.swayPhase = Math.random() * Math.PI * 2;
                inst.userData.swaySpeed = 0.3 + Math.random() * 0.2;
                trees.push(inst);
                treePositions.push({ x, z, radius: 1.0 });
                scene.add(inst);
                return;
            }
            _loadAssetGLB('Palm Tree.glb');

            const tree = new THREE.Group();

            // Trunk: tall, slender, segmented with a gentle curve
            const trunkH   = 6 + Math.random() * 4;
            const trunkSegs = 10;
            // Slight random lean direction for character
            const leanAngle = 0.10 + Math.random() * 0.14;
            const leanDir   = Math.random() * Math.PI * 2;

            // Sandy-tan bark texture
            const barkData = new Uint8Array(16 * 16 * 4);
            for (let i = 0; i < 16 * 16; i++) {
                const bx = i % 16, by = Math.floor(i / 16);
                // Horizontal ring bands (palm trunk segments)
                const ring  = Math.abs(Math.sin(by * 1.2)) * 22;
                const noise = Math.random() * 8;
                const base  = 110 + ring + noise;
                barkData[i*4]   = Math.min(255, base);
                barkData[i*4+1] = Math.min(255, base * 0.78);
                barkData[i*4+2] = Math.min(255, base * 0.50);
                barkData[i*4+3] = 255;
            }
            const barkTex = new THREE.DataTexture(barkData, 16, 16, THREE.RGBAFormat);
            barkTex.needsUpdate = true;
            barkTex.wrapS = barkTex.wrapT = THREE.RepeatWrapping;
            barkTex.repeat.set(2, 6);
            barkTex.magFilter = THREE.NearestFilter;
            const barkMat = new THREE.MeshStandardMaterial({ map: barkTex, roughness: 0.97, metalness: 0 });

            // Build trunk as stacked tapered segments \u2013 merged into one mesh
            const segH = trunkH / trunkSegs;
            const trunkPieces = [];
            const _tDummy = new THREE.Object3D();
            for (let s = 0; s < trunkSegs; s++) {
                const t   = s / trunkSegs;
                const r0  = 0.22 - t * 0.07;
                const r1  = 0.22 - (t + 1 / trunkSegs) * 0.07;
                const sGeo = new THREE.CylinderGeometry(r1, r0, segH, 8);
                const curve = leanAngle * t * t;
                _tDummy.position.set(
                    Math.cos(leanDir) * curve * trunkH * 0.5,
                    s * segH + segH / 2,
                    Math.sin(leanDir) * curve * trunkH * 0.5
                );
                _tDummy.rotation.set(
                    Math.cos(leanDir + Math.PI / 2) * curve * 0.6,
                    0,
                    Math.sin(leanDir + Math.PI / 2) * curve * 0.6
                );
                _tDummy.scale.set(1, 1, 1);
                _tDummy.updateMatrix();
                trunkPieces.push({ geo: sGeo, matrix: _tDummy.matrix.clone() });
            }
            const mergedTrunkGeo = mergeGeometries(trunkPieces);
            mergedTrunkGeo.computeVertexNormals();
            const trunkMesh = new THREE.Mesh(mergedTrunkGeo, barkMat);
            trunkMesh.castShadow = trunkMesh.receiveShadow = true;
            tree.add(trunkMesh);

            // Crown position (top of curved trunk)
            const crownX = Math.cos(leanDir) * leanAngle * trunkH * 0.35;
            const crownY = trunkH;
            const crownZ = Math.sin(leanDir) * leanAngle * trunkH * 0.35;

            // \u2500\u2500 Palm fronds: merged into 2 meshes (spines + leaflets) \u2500\u2500
            const frondCount = 8 + Math.floor(Math.random() * 5);
            const leafHue    = 0.29 + Math.random() * 0.05;

            // Shared materials (only 2 for the whole crown)
            const spineMat2 = new THREE.MeshStandardMaterial({
                color: new THREE.Color().setHSL(leafHue - 0.01, 0.70, 0.18),
                roughness: 0.97, metalness: 0, side: THREE.DoubleSide
            });
            const leafletMat = new THREE.MeshStandardMaterial({
                color: new THREE.Color().setHSL(leafHue, 0.76, 0.30 + Math.random() * 0.07),
                roughness: 0.82, metalness: 0, side: THREE.DoubleSide,
            });

            // Accumulate transformed geometry pieces for merging
            const spinePieces   = [];
            const leafletPieces = [];
            const _dummy = new THREE.Object3D();

            // Helper: build a refined leaflet shape in local space
            // Returns a BufferGeometry of a curved, tapered leaflet blade
            function makeLeafletGeo(len, width) {
                // 3-segment blade with a natural curve and taper
                const segs = 3;
                const verts = [];
                const idxs  = [];
                for (let i = 0; i <= segs; i++) {
                    const t   = i / segs;
                    const w   = width * (1 - t * 0.82);      // taper to a sharp tip
                    const y   = len * t;
                    const arc = Math.sin(t * Math.PI) * width * 0.18; // slight belly curve
                    // left edge, right edge
                    verts.push(-w * 0.5 - arc, y, 0,
                                w * 0.5 + arc, y, 0);
                }
                for (let i = 0; i < segs; i++) {
                    const a = i * 2, b = a + 1, c = a + 2, d = a + 3;
                    idxs.push(a, b, c,  b, d, c);
                }
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
                geo.setIndex(idxs);
                geo.computeVertexNormals();
                return geo;
            }

            for (let f = 0; f < frondCount; f++) {
                const frondAngle = (f / frondCount) * Math.PI * 2 + (Math.random() - 0.5) * 0.28;
                const frondLen   = 2.8 + Math.random() * 1.8;
                const droop      = 0.30 + Math.random() * 0.30;
                const tiltUp     = 0.22 + Math.random() * 0.28;

                // \u2500\u2500 Spine arc points in frond-local space \u2500\u2500
                const spineSegs  = 9;
                const spinePoints = [];
                for (let s = 0; s <= spineSegs; s++) {
                    const t  = s / spineSegs;
                    const sx = t * frondLen;
                    const sy = Math.sin(tiltUp) * t * frondLen * 0.55 - droop * t * t * frondLen;
                    spinePoints.push(new THREE.Vector3(sx, sy, 0));
                }

                // Matrix that transforms from frond-local \u2192 crown-local
                // (rotate around Y by frondAngle, small Z tilt, then translate to crown)
                const frondMatrix = new THREE.Matrix4()
                    .makeTranslation(crownX, crownY + 0.2, crownZ)
                    .multiply(new THREE.Matrix4().makeRotationY(frondAngle))
                    .multiply(new THREE.Matrix4().makeRotationZ(tiltUp * 0.45));

                // \u2500\u2500 Spine cylinders \u2013 merged \u2500\u2500
                for (let s = 0; s < spineSegs; s++) {
                    const p0  = spinePoints[s], p1 = spinePoints[s + 1];
                    const mid = p0.clone().add(p1).multiplyScalar(0.5);
                    const segLen = p0.distanceTo(p1);
                    const t   = s / spineSegs;
                    const r   = 0.024 * (1 - t * 0.78);
                    const sGeo = new THREE.CylinderGeometry(r * 0.55, r, segLen, 4);
                    // orient along spine dir
                    const dir = p1.clone().sub(p0).normalize();
                    _dummy.position.copy(mid);
                    _dummy.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
                    _dummy.scale.set(1, 1, 1);
                    _dummy.updateMatrix();
                    const localMat = frondMatrix.clone().multiply(_dummy.matrix);
                    spinePieces.push({ geo: sGeo, matrix: localMat });
                }

                // \u2500\u2500 Leaflets \u2013 merged \u2500\u2500
                const leafletCount = 10 + Math.floor(Math.random() * 4);
                for (let l = 0; l < leafletCount; l++) {
                    const t      = (l + 0.5) / leafletCount;
                    const ptIdx  = Math.floor(t * spineSegs);
                    const pt     = spinePoints[ptIdx];
                    const ptN    = spinePoints[Math.min(ptIdx + 1, spineSegs)];
                    const spineDir = ptN.clone().sub(pt).normalize();

                    const lLen   = (0.52 + Math.random() * 0.28) * (1 - t * 0.50);
                    const lWid   = (0.13 + Math.random() * 0.05) * (1 - t * 0.38);
                    const lGeo   = makeLeafletGeo(lLen, lWid);
                    const spineAngle = Math.atan2(spineDir.y, spineDir.x);

                    // Left leaflet
                    _dummy.position.copy(pt);
                    _dummy.rotation.set(
                         0.10 + Math.random() * 0.14,   // fold up slightly
                         Math.PI / 2,
                         spineAngle + 0.18 + Math.random() * 0.10
                    );
                    _dummy.scale.set(1, 1, 1);
                    _dummy.updateMatrix();
                    leafletPieces.push({ geo: lGeo, matrix: frondMatrix.clone().multiply(_dummy.matrix) });

                    // Right leaflet (mirror)
                    _dummy.position.copy(pt);
                    _dummy.rotation.set(
                        -(0.10 + Math.random() * 0.14),
                        -Math.PI / 2,
                         spineAngle + 0.18 + Math.random() * 0.10
                    );
                    _dummy.scale.set(1, 1, 1);
                    _dummy.updateMatrix();
                    leafletPieces.push({ geo: lGeo.clone(), matrix: frondMatrix.clone().multiply(_dummy.matrix) });
                }
            }

            // \u2500\u2500 Build 2 merged meshes for the entire crown \u2500\u2500
            const mergedSpineGeo   = mergeGeometries(spinePieces);
            mergedSpineGeo.computeVertexNormals();
            const spineMesh = new THREE.Mesh(mergedSpineGeo, spineMat2);
            spineMesh.castShadow = true;
            tree.add(spineMesh);

            const mergedLeafGeo = mergeGeometries(leafletPieces);
            mergedLeafGeo.computeVertexNormals();
            const leafMesh = new THREE.Mesh(mergedLeafGeo, leafletMat);
            leafMesh.castShadow = true;
            tree.add(leafMesh);

            // Small coconut cluster at crown
            if (Math.random() > 0.4) {
                const cocoMat = new THREE.MeshStandardMaterial({ color: 0x5a4020, roughness: 0.9 });
                const cocoCount = 2 + Math.floor(Math.random() * 3);
                for (let c = 0; c < cocoCount; c++) {
                    const cocoGeo = new THREE.SphereGeometry(0.12 + Math.random()*0.05, 7, 6);
                    const coco    = new THREE.Mesh(cocoGeo, cocoMat);
                    const ca = Math.random() * Math.PI * 2;
                    coco.position.set(crownX + Math.cos(ca)*0.18, crownY - 0.22, crownZ + Math.sin(ca)*0.18);
                    coco.castShadow = true;
                    tree.add(coco);
                }
            }

            tree.position.set(x, 0, z);
            tree.userData.health     = 3;
            tree.userData.type       = 'tree';   // identical to regular tree - same chop logic
            tree.userData.isPalmTree = true;      // flag so GLB-swap loops can tell palms from forest trees
            tree.userData.swayPhase  = Math.random() * Math.PI * 2;
            tree.userData.swaySpeed  = 0.3 + Math.random() * 0.2; // slower sway than forest trees

            trees.push(tree);
            const _desertTreePosEntry = { x, z, radius: 1.5 };
            tree.userData._posEntry = _desertTreePosEntry;
            tree.userData._posArray = treePositions;
            treePositions.push(_desertTreePosEntry);
            scene.add(tree);
        }

        // Spawn 8-12 palm trees spread across the desert
        {
            const dpMargin  = 10;
            const dpCenterZ = -desertOffset + 0.5;
            const dpHalf    = groundSize / 2 - dpMargin;
            const dpXMin    = -groundSize / 2 + dpMargin;
            const dpXMax    =  groundSize / 2 - dpMargin;
            const dpZMin    = dpCenterZ - dpHalf;
            const dpZMax    = dpCenterZ + dpHalf - 18;
            const numPalms  = 8 + Math.floor(Math.random() * 5);

            for (let i = 0; i < numPalms; i++) {
                let attempts = 0, valid = false, fx, fz;
                do {
                    fx = dpXMin + Math.random() * (dpXMax - dpXMin);
                    fz = dpZMin + Math.random() * (dpZMax - dpZMin);
                    valid = true;
                    for (const ob of desertFormationColliders) {
                        if (Math.sqrt((fx-ob.x)**2+(fz-ob.z)**2) < ob.r + 2) { valid=false; break; }
                    }
                    if (!valid) { attempts++; continue; }
                    for (const p of [...treePositions, ...rockPositions, ...orePositions, ...sulfurPositions, ...cactiPositions]) {
                        if (Math.sqrt((fx-p.x)**2+(fz-p.z)**2) < 6) { valid=false; break; }
                    }
                    attempts++;
                } while (!valid && attempts < 80);
                if (valid) createPalmTree(fx, fz);
            }
        }

        // Once Palm Tree.glb loads, swap procedural palms for GLB versions
        _loadAssetGLB('Palm Tree.glb').then(tmpl => {
            if (!tmpl) { console.warn(' Palm Tree.glb failed  keeping procedural palms'); return; }
            console.log(` Palm Tree.glb loaded  scanning ${trees.length} entries for procedural palms...`);
            let swapped = 0;
            for (let i = trees.length - 1; i >= 0; i--) {
                const old = trees[i];
                // Only swap procedural palm trees: must have type 'tree', the isPalmTree flag, AND swayPhase
                // (isPalmTree + swayPhase = procedural; missing either means already a GLB instance)
                if (old.userData.type !== 'tree') continue;
                if (!old.userData.isPalmTree) continue;       // not a palm  skip
                if (!old.userData.swayPhase) continue;        // already swapped to GLB  skip
                const x = old.position.x, z = old.position.z;
                const targetH = 5.0 + Math.random() * 3.5;
                const inst = _instantiateGLB('Palm Tree.glb', targetH);
                if (!inst) { console.warn(' _instantiateGLB returned null for Palm Tree.glb'); continue; }
                inst.position.set(x, inst.position.y, z);
                inst.rotation.y = Math.random() * Math.PI * 2;
                inst.userData.type = 'tree';
                inst.userData.isPalmTree = true;
                inst.userData.health = old.userData.health ?? 3;
                inst.userData.maxHealth = 3;
                inst.userData.trunkHeight = targetH * 0.75;
                inst.userData.swayPhase = Math.random() * Math.PI * 2;
                inst.userData.swaySpeed = 0.3 + Math.random() * 0.2;
                scene.remove(old);
                scene.add(inst);
                trees[i] = inst;
                swapped++;
                if (swapped === 1) {
                    inst.updateMatrixWorld(true);
                    const wp = new THREE.Vector3();
                    inst.getWorldPosition(wp);
                    const bb = new THREE.Box3().setFromObject(inst);
                    console.log(` FIRST PALM world pos: (${wp.x.toFixed(1)}, ${wp.y.toFixed(1)}, ${wp.z.toFixed(1)}) | bbox Y: ${bb.min.y.toFixed(2)}  ${bb.max.y.toFixed(2)} | inst.position.y=${inst.position.y.toFixed(3)}`);
                }
            }
            console.log(` Palm swap done: ${swapped} procedural  GLB`);
        });

        // ===== DESERT OASES =====
        (function createOases() {

            // --- Lush grass blade tuft for oasis interior ---
            const oasisGrassMat = new THREE.MeshStandardMaterial({
                side: THREE.DoubleSide, roughness: 0.88, metalness: 0, vertexColors: true,
            });

            function makeOasisGrassTuft(x, z, lushness) {
                // lushness 0=edge (yellow-green) 1=centre (deep green)
                const numBlades = 10 + Math.floor(Math.random() * 8);
                const allPos = [], allNorm = [], allUV = [], allCol = [], allIdx = [];
                let vOff = 0;
                for (let b = 0; b < numBlades; b++) {
                    const h = 0.40 + Math.random() * 0.55 + lushness * 0.25;
                    const w = 0.04 + Math.random() * 0.04;
                    const bx = (Math.random() - 0.5) * 0.32;
                    const bz = (Math.random() - 0.5) * 0.32;
                    const ry = Math.random() * Math.PI * 2;
                    const cr = Math.cos(ry), sr = Math.sin(ry);
                    const segsY = 4, cols = 2, rows = segsY + 1;
                    // Colour: sandy-yellow at edge, vivid green at centre
                    const hue = 0.22 - lushness * 0.05;  // 0.22=yellow-green, 0.17=golden
                    const sat = 0.45 + lushness * 0.38;
                    const lit = 0.30 + lushness * 0.12;
                    const baseCol = new THREE.Color().setHSL(hue, sat, lit);
                    const tipCol  = new THREE.Color().setHSL(hue + 0.04, sat * 0.70, lit + 0.22);
                    for (let row = 0; row < rows; row++) {
                        for (let col2 = 0; col2 < cols; col2++) {
                            const u = col2 / (cols - 1);
                            const v = row  / (rows - 1);
                            const lx = (u - 0.5) * w;
                            const ly = v * h;
                            const bend = ((v + 0.5) ** 2) * (0.12 + Math.random() * 0.08);
                            allPos.push(cr * (lx + bend) + bx, ly, sr * (lx + bend) + bz);
                            allNorm.push(0, 1, 0);
                            allUV.push(u, v);
                            const c = baseCol.clone().lerp(tipCol, v * v);
                            allCol.push(c.r, c.g, c.b);
                        }
                    }
                    for (let row = 0; row < segsY; row++) {
                        const a = vOff + row * cols;
                        const b2 = a + 1, c2 = a + cols, d = c2 + 1;
                        allIdx.push(a, c2, b2,  b2, c2, d);
                    }
                    vOff += rows * cols;
                }
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.Float32BufferAttribute(allPos,  3));
                geo.setAttribute('normal',   new THREE.Float32BufferAttribute(allNorm, 3));
                geo.setAttribute('uv',       new THREE.Float32BufferAttribute(allUV,   2));
                geo.setAttribute('color',    new THREE.Float32BufferAttribute(allCol,  3));
                geo.setIndex(allIdx);
                geo.computeVertexNormals();
                const tuft = new THREE.Mesh(geo, oasisGrassMat);
                tuft.position.set(x, 0.01, z);
                tuft.userData.windSpeed = 0.45 + Math.random() * 0.30;
                tuft.userData.windPhase = Math.random() * Math.PI * 2;
                tuft.userData.type = 'desert_grass'; // uses same wind update loop
                desertGrassTufts.push(tuft);
                scene.add(tuft);
            }

            // --- Blended ground disc: sand \u2192 brown-green \u2192 green, with vertex colours ---
            function makeGroundBlend(cx, cy, cz, innerR, outerR) {
                // A flat disc made of rings: centre=lush green, edge=sand colour
                const ringCount  = 14;  // radial rings
                const segCount   = 36;  // angular segments
                const positions  = [];
                const colours    = [];
                const normals    = [];
                const uvs        = [];
                const indices    = [];

                // Colour stops from centre outward
                // 0.0 \u2192 deep green pool-edge, 0.5 \u2192 yellow-green, 0.85 \u2192 dried grass, 1.0 \u2192 sand
                function ringColour(t) {
                    if (t < 0.45) {
                        // green to yellow-green
                        const c0 = new THREE.Color(0x2d7a1f);
                        const c1 = new THREE.Color(0x8ab84a);
                        return c0.lerp(c1, t / 0.45);
                    } else if (t < 0.75) {
                        // yellow-green to dry tan
                        const c0 = new THREE.Color(0x8ab84a);
                        const c1 = new THREE.Color(0xb89a5a);
                        return c0.lerp(c1, (t - 0.45) / 0.30);
                    } else {
                        // dry tan to sand
                        const c0 = new THREE.Color(0xb89a5a);
                        const c1 = new THREE.Color(0xc8a86a);
                        return c0.lerp(c1, (t - 0.75) / 0.25);
                    }
                }

                for (let ri = 0; ri <= ringCount; ri++) {
                    const t  = ri / ringCount;
                    const r  = innerR + (outerR - innerR) * t;
                    const col = ringColour(t);
                    // Add tiny random variation per vertex for organic edge
                    for (let si = 0; si <= segCount; si++) {
                        const angle = (si / segCount) * Math.PI * 2;
                        const jitter = ri > 0 ? (Math.random() - 0.5) * (outerR - innerR) * 0.06 : 0;
                        const rx = cx + (r + jitter) * Math.cos(angle);
                        const rz = cz + (r + jitter) * Math.sin(angle);
                        positions.push(rx, cy, rz);
                        normals.push(0, 1, 0);
                        uvs.push(si / segCount, t);
                        const cv = col.clone();
                        cv.r = Math.min(1, cv.r + (Math.random() - 0.5) * 0.04);
                        cv.g = Math.min(1, cv.g + (Math.random() - 0.5) * 0.04);
                        cv.b = Math.min(1, cv.b + (Math.random() - 0.5) * 0.04);
                        colours.push(cv.r, cv.g, cv.b);
                    }
                }

                for (let ri = 0; ri < ringCount; ri++) {
                    for (let si = 0; si < segCount; si++) {
                        const a = ri * (segCount + 1) + si;
                        const b = a + 1;
                        const c = a + (segCount + 1);
                        const d = c + 1;
                        indices.push(a, c, b,  b, c, d);
                    }
                }

                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geo.setAttribute('normal',   new THREE.Float32BufferAttribute(normals,   3));
                geo.setAttribute('uv',       new THREE.Float32BufferAttribute(uvs,       2));
                geo.setAttribute('color',    new THREE.Float32BufferAttribute(colours,   3));
                geo.setIndex(indices);
                const mat = new THREE.MeshStandardMaterial({
                    vertexColors: true, roughness: 0.94, metalness: 0,
                    depthWrite: true,
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.receiveShadow = true;
                mesh.renderOrder = 1; // paint above the sand beneath
                scene.add(mesh);
            }

            // --- Water disc: vivid tropical pool ---
            function makeWaterDisc(cx, cy, cz, r) {
                const segs  = 48;
                const rings = 8;
                const positions = [], normals = [], uvs = [], colours = [], indices = [];

                // Centre \u2014 deep jewel blue
                positions.push(cx, cy, cz);
                normals.push(0, 1, 0);
                uvs.push(0.5, 0.5);
                colours.push(0.0, 0.35, 0.95); // saturated cobalt blue

                for (let ri = 1; ri <= rings; ri++) {
                    const t   = ri / rings;
                    const rad = r * t;
                    for (let si = 0; si < segs; si++) {
                        const angle  = (si / segs) * Math.PI * 2;
                        const ripple = 0.015 * Math.sin(si * 1.5 + ri * 2.3);
                        positions.push(
                            cx + rad * Math.cos(angle),
                            cy + ripple,
                            cz + rad * Math.sin(angle)
                        );
                        normals.push(0, 1, 0);
                        uvs.push(0.5 + Math.cos(angle) * t * 0.5, 0.5 + Math.sin(angle) * t * 0.5);
                        // deep blue centre \u2192 bright teal edge, always vivid
                        colours.push(0.0 + t * 0.10, 0.38 + t * 0.22, 0.92 - t * 0.12);
                    }
                }

                // Centre fan
                for (let si = 0; si < segs; si++) {
                    indices.push(0, 1 + si, 1 + (si + 1) % segs);
                }
                // Stitch rings
                for (let ri = 0; ri < rings - 1; ri++) {
                    const base = 1 + ri * segs;
                    for (let si = 0; si < segs; si++) {
                        const a = base + si, b = base + (si + 1) % segs;
                        const c = base + segs + si, d = base + segs + (si + 1) % segs;
                        indices.push(a, c, b,  b, c, d);
                    }
                }

                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geo.setAttribute('normal',   new THREE.Float32BufferAttribute(normals,   3));
                geo.setAttribute('uv',       new THREE.Float32BufferAttribute(uvs,       2));
                geo.setAttribute('color',    new THREE.Float32BufferAttribute(colours,   3));
                geo.setIndex(indices);
                geo.computeVertexNormals();

                // MeshBasicMaterial ignores ALL lighting \u2014 colour is always vivid
                const mat = new THREE.MeshBasicMaterial({
                    vertexColors: true,
                    depthWrite: true,
                    side: THREE.FrontSide,
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.renderOrder = 0;
                scene.add(mesh);
            }

            // Spawn-exclusion list (used only to keep other features from spawning inside oases)
            const oasisSpawnExclusion = [];

            // --- Build one complete oasis at (cx, cz) ---
            function buildOasis(cx, cz) {
                const waterR   = 5.0 + Math.random() * 2.0;   // bigger, more visible pond
                const grassR   = waterR + 4.0;                 // lush grass zone
                const blendR   = grassR  + 6.5;                // full blend-to-sand radius
                const waterY   = 0.12;  // clearly above everything
                const blendY   = 0.005;

                // 1. Blended ground ring (sand \u2192 green \u2192 sand colour, layered above desert)
                makeGroundBlend(cx, blendY, cz, waterR, blendR);

                // 2. Water disc
                makeWaterDisc(cx, waterY, cz, waterR);

                // 3. Lush grass tufts \u2013 dense near water, sparser at edge
                const grassTuftCount = 55 + Math.floor(Math.random() * 20);
                const placedTufts = [];
                let att = 0;
                while (placedTufts.length < grassTuftCount && att < 600) {
                    att++;
                    const angle = Math.random() * Math.PI * 2;
                    // Weight toward inner band
                    const dist  = waterR + 0.4 + Math.pow(Math.random(), 0.6) * (blendR - waterR - 0.4);
                    const tx2 = cx + Math.cos(angle) * dist;
                    const tz2 = cz + Math.sin(angle) * dist;
                    // Avoid water
                    if (Math.sqrt((tx2 - cx) ** 2 + (tz2 - cz) ** 2) < waterR + 0.2) continue;
                    let tooClose = false;
                    for (const p of placedTufts) {
                        if (Math.sqrt((tx2 - p.x) ** 2 + (tz2 - p.z) ** 2) < 1.1) { tooClose = true; break; }
                    }
                    if (tooClose) continue;
                    const lushness = Math.max(0, 1 - (dist - waterR) / (blendR - waterR));
                    makeOasisGrassTuft(tx2, tz2, lushness);
                    placedTufts.push({ x: tx2, z: tz2 });
                }

                // 4. Dense ring of palm trees around the pond, leaning outward a little
                const palmRing = 3.8 + Math.random() * 1.5; // ring radius from centre
                const palmCount = 5 + Math.floor(Math.random() * 4);
                for (let i = 0; i < palmCount; i++) {
                    const angle = (i / palmCount) * Math.PI * 2 + (Math.random() - 0.5) * 0.35;
                    const dist  = palmRing * (0.85 + Math.random() * 0.30);
                    const px = cx + Math.cos(angle) * dist;
                    const pz = cz + Math.sin(angle) * dist;
                    createPalmTree(px, pz);
                    // Remove the last treePositions entry so tight oasis ring isn't blocked
                    // (palm trees are very close here intentionally)
                }

                // NOTE: oases are walkable \u2014 do NOT add to desertFormationColliders
                // We track them separately just for spawn-exclusion of other features
                oasisSpawnExclusion.push({ x: cx, z: cz, r: blendR });
            }

            // --- Pick 2 well-spaced oasis positions deep in the desert ---
            const oasisPositions = [];
            const oz_margin = 20;
            const oz_cx0 = desertXMin + oz_margin;
            const oz_cx1 = desertXMax - oz_margin;
            const oz_cz0 = desertZMin + oz_margin;
            const oz_cz1 = desertZMax - oz_margin;

            let placed2 = 0;
            let tries = 0;
            while (placed2 < 2 && tries < 400) {
                tries++;
                const ox = oz_cx0 + Math.random() * (oz_cx1 - oz_cx0);
                const oz = oz_cz0 + Math.random() * (oz_cz1 - oz_cz0);

                let bad = false;
                for (const p of oasisPositions) {
                    if (Math.sqrt((ox - p.x) ** 2 + (oz - p.z) ** 2) < 50) { bad = true; break; }
                }
                if (bad) continue;
                for (const p of desertFormationPositions) {
                    if (Math.sqrt((ox - p.x) ** 2 + (oz - p.z) ** 2) < 16) { bad = true; break; }
                }
                if (bad) continue;

                buildOasis(ox, oz);
                oasisPositions.push({ x: ox, z: oz });
                placed2++;
            }

        })();

        const berryBushes = [];
        const bushPositions = []; // { x, z, radius } for collision
        
        // Procedural leaf texture \ufffd bright greens with colour variation
        // Foliage texture for berry bush
        function createBushFoliageTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#3a8a18';
            ctx.fillRect(0, 0, 256, 256);
            for (let i = 0; i < 60; i++) {
                const cx = Math.random() * 256, cy = Math.random() * 256;
                const rx = 8 + Math.random() * 20, ry = 5 + Math.random() * 13;
                const bright = Math.random() > 0.35;
                const delta = bright ? (25 + Math.random() * 45) : -(12 + Math.random() * 28);
                const g2 = Math.min(255, Math.max(0, 138 + delta));
                const r2 = Math.min(255, Math.max(0, 58 + delta * 0.3));
                ctx.fillStyle = `rgba(${r2|0},${g2|0},24,0.55)`;
                ctx.beginPath();
                ctx.ellipse(cx, cy, rx, ry, Math.random() * Math.PI, 0, Math.PI * 2);
                ctx.fill();
            }
            for (let i = 0; i < 35; i++) {
                ctx.strokeStyle = `rgba(0,40,0,${0.06 + Math.random() * 0.1})`;
                ctx.lineWidth = 0.6;
                ctx.beginPath();
                const sx = Math.random()*256, sy = Math.random()*256;
                ctx.moveTo(sx, sy);
                ctx.lineTo(sx + (Math.random()-0.5)*30, sy + (Math.random()-0.5)*30);
                ctx.stroke();
            }
            for (let i = 0; i < 30; i++) {
                ctx.fillStyle = `rgba(160,255,80,${0.07 + Math.random() * 0.11})`;
                ctx.beginPath();
                ctx.arc(Math.random()*256, Math.random()*256, 1.5 + Math.random()*3, 0, Math.PI*2);
                ctx.fill();
            }
            return canvas;
        }

        // Helper: merge an array of {geo, matrix} into one BufferGeometry
        function mergeGeometries(pieces) {
            let totalVerts = 0, totalIdx = 0;
            pieces.forEach(p => {
                totalVerts += p.geo.attributes.position.count;
                totalIdx   += p.geo.index ? p.geo.index.count : p.geo.attributes.position.count;
            });

            const positions = new Float32Array(totalVerts * 3);
            const normals   = new Float32Array(totalVerts * 3);
            const uvs       = new Float32Array(totalVerts * 2);
            const indices   = [];

            let vOffset = 0, iOffset = 0;
            const _v  = new THREE.Vector3();
            const _n  = new THREE.Vector3();
            const _m3 = new THREE.Matrix3();

            pieces.forEach(({ geo, matrix }) => {
                const posArr = geo.attributes.position.array;
                const nrmArr = geo.attributes.normal ? geo.attributes.normal.array : null;
                const uvArr  = geo.attributes.uv     ? geo.attributes.uv.array     : null;
                const count  = geo.attributes.position.count;
                _m3.getNormalMatrix(matrix);

                for (let i = 0; i < count; i++) {
                    _v.set(posArr[i*3], posArr[i*3+1], posArr[i*3+2]).applyMatrix4(matrix);
                    positions[(vOffset+i)*3]   = _v.x;
                    positions[(vOffset+i)*3+1] = _v.y;
                    positions[(vOffset+i)*3+2] = _v.z;

                    if (nrmArr) {
                        _n.set(nrmArr[i*3], nrmArr[i*3+1], nrmArr[i*3+2]).applyMatrix3(_m3).normalize();
                        normals[(vOffset+i)*3]   = _n.x;
                        normals[(vOffset+i)*3+1] = _n.y;
                        normals[(vOffset+i)*3+2] = _n.z;
                    }
                    if (uvArr) {
                        uvs[(vOffset+i)*2]   = uvArr[i*2];
                        uvs[(vOffset+i)*2+1] = uvArr[i*2+1];
                    }
                }

                const idxArr = geo.index ? geo.index.array : null;
                const idxCount = idxArr ? idxArr.length : count;
                for (let i = 0; i < idxCount; i++) {
                    indices.push(vOffset + (idxArr ? idxArr[i] : i));
                }

                vOffset += count;
            });

            const merged = new THREE.BufferGeometry();
            merged.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            merged.setAttribute('normal',   new THREE.BufferAttribute(normals,   3));
            merged.setAttribute('uv',       new THREE.BufferAttribute(uvs,       2));
            merged.setIndex(indices);
            return merged;
        }

        async function createBerryBush(x, z) {
            const bush = new THREE.Group();

            // ?? Single shared foliage material ??
            const foliageTex = new THREE.CanvasTexture(createBushFoliageTexture());
            foliageTex.wrapS = foliageTex.wrapT = THREE.RepeatWrapping;
            foliageTex.repeat.set(2, 2);
            const foliageMat = new THREE.MeshStandardMaterial({
                map: foliageTex, roughness: 0.88, metalness: 0, color: 0xffffff
            });

            // ?? Define 4 foliage lumps: positions, radii, scale ??
            // Intentionally asymmetric for a natural look
            const lumpDefs = [
                { x:  0.00, y: 0.40, z:  0.00, r: 0.58, sx: 1.30, sy: 0.80, sz: 1.30 }, // wide flat centre
                { x:  0.48, y: 0.62, z:  0.10, r: 0.40, sx: 1.00, sy: 1.10, sz: 0.95 }, // right side up
                { x: -0.38, y: 0.55, z: -0.25, r: 0.38, sx: 0.95, sy: 1.05, sz: 1.00 }, // left back
                { x:  0.10, y: 0.72, z:  0.38, r: 0.36, sx: 1.05, sy: 0.90, sz: 0.95 }, // front top
            ];

            // Build pieces list for merging
            const pieces = [];
            const dummy = new THREE.Object3D();
            lumpDefs.forEach(d => {
                const geo = new THREE.SphereGeometry(d.r, 9, 7);
                dummy.position.set(d.x, d.y, d.z);
                dummy.scale.set(d.sx, d.sy, d.sz);
                dummy.updateMatrix();
                pieces.push({ geo, matrix: dummy.matrix.clone() });
            });

            const mergedGeo  = mergeGeometries(pieces);
            mergedGeo.computeVertexNormals();
            const foliageMesh = new THREE.Mesh(mergedGeo, foliageMat);
            foliageMesh.castShadow = true;
            foliageMesh.receiveShadow = true;
            bush.add(foliageMesh);

            // ?? Two woody branches visible at the base ??
            const branchMat = await createWoodMaterial(0x4a2e12, 0.9);
            [
                { angle: 0.4,  lean: 0.28, len: 0.70 },
                { angle: 3.5,  lean: 0.22, len: 0.60 },
            ].forEach(b => {
                const geo  = new THREE.CylinderGeometry(0.018, 0.048, b.len, 6);
                const mesh = new THREE.Mesh(geo, branchMat);
                mesh.position.set(Math.cos(b.angle)*b.len*0.38, b.len*0.42, Math.sin(b.angle)*b.len*0.38);
                mesh.rotation.set(b.lean * -Math.sin(b.angle), 0, b.lean * Math.cos(b.angle));
                mesh.castShadow = true;
                bush.add(mesh);
            });

            // ?? BERRIES: 10-14 total, spread across top & upper sides ??
            const berries = [];
            const berryColors = [0xcc1111, 0xaa0808, 0xdd2020, 0xbb1515];
            const berryMat  = new THREE.MeshStandardMaterial({
                color: 0xcc1111, roughness: 0.28, metalness: 0.06,
                emissive: 0x330000, emissiveIntensity: 0.8
            });
            const bCalyxMat = new THREE.MeshStandardMaterial({ color: 0x1e4d08, roughness: 0.9 });

            const totalBerries = 10 + Math.floor(Math.random() * 5); // 10-14
            for (let i = 0; i < totalBerries; i++) {
                const bg = new THREE.Group();
                const br = 0.068 + Math.random() * 0.022;

                // Choose which lump this berry sits on
                const lump = lumpDefs[i % lumpDefs.length];

                // Evenly space phi around 360\ufffd, theta covers top + upper sides (0 to ~75\ufffd)
                const phi   = (i / totalBerries) * Math.PI * 2 + (Math.random()-0.5) * 0.7;
                const theta = Math.random() * Math.PI * 0.70;
                const nx = Math.sin(theta) * Math.cos(phi);
                const ny = Math.cos(theta);
                const nz = Math.sin(theta) * Math.sin(phi);

                // Sit on lump surface (account for lump's non-uniform scale)
                const sx = lump.sx, sy = lump.sy, sz = lump.sz;
                const scaledR = lump.r * Math.sqrt((nx*nx)/(sx*sx) + (ny*ny)/(sy*sy) + (nz*nz)/(sz*sz));
                const outDist = lump.r + br * 0.6;
                const bx = lump.x + nx * outDist;
                const by = lump.y + ny * outDist;
                const bz = lump.z + nz * outDist;

                // Berry sphere
                const col = berryColors[Math.floor(Math.random() * berryColors.length)];
                const bMat = berryMat.clone();
                bMat.color.setHex(col);
                bg.add(new THREE.Mesh(new THREE.SphereGeometry(br, 7, 7), bMat));

                // Calyx nub
                const calyx = new THREE.Mesh(new THREE.ConeGeometry(br*0.28, br*0.5, 5), bCalyxMat);
                calyx.position.y = -br * 0.82;
                calyx.rotation.z = Math.PI;
                bg.add(calyx);


                bg.position.set(bx, by, bz);
                bg.userData.isVisible   = true;
                bg.userData.respawnTime = 0;
                berries.push(bg);
                bush.add(bg);
            }

            bush.updateMatrixWorld(true);
            const bushBox = new THREE.Box3().setFromObject(bush);
            bush.position.set(x, -bushBox.min.y - 0.3, z);
            bush.userData.type   = 'berryBush';
            bush.userData.berries = berries;

            berryBushes.push(bush);
            bushPositions.push({ x, z, radius: 1.2 });
            scene.add(bush);
        }
        
        // ===== GROUND COLLECTIBLES =====
        const groundCollectibles = [];
        const wildPlants = []; // { mesh, seedType, harvestable, respawnAt }
        
        function createStickPickup(x, z) {
            const stick = new THREE.Group();
            
            // Create 2-3 sticks bundled together
            const numSticks = 2 + Math.floor(Math.random() * 2);
            for (let i = 0; i < numSticks; i++) {
                const length = 0.35 + Math.random() * 0.15;
                const thickness = 0.015 + Math.random() * 0.01;
                const stickGeo = new THREE.CylinderGeometry(
                    thickness, 
                    thickness * 0.8, 
                    length, 
                    6
                );
                const stickMat = new THREE.MeshStandardMaterial({ 
                    color: 0x6B4423,
                    roughness: 0.9,
                    metalness: 0
                });
                const stickMesh = new THREE.Mesh(stickGeo, stickMat);
                stickMesh.rotation.z = Math.random() * Math.PI;
                stickMesh.rotation.x = Math.random() * 0.5;
                stickMesh.rotation.y = (i / numSticks) * Math.PI * 0.5;
                stickMesh.position.x += (Math.random() - 0.5) * 0.05;
                stickMesh.position.z += (Math.random() - 0.5) * 0.05;
                stickMesh.castShadow = true;
                stick.add(stickMesh);
                
                // Add small branches
                if (Math.random() > 0.5) {
                    const branchGeo = new THREE.CylinderGeometry(thickness * 0.4, thickness * 0.3, length * 0.3, 4);
                    const branch = new THREE.Mesh(branchGeo, stickMat);
                    branch.position.y = length * (0.2 + Math.random() * 0.3);
                    branch.rotation.z = Math.PI / 3;
                    stickMesh.add(branch);
                }
            }
            
            stick.updateMatrixWorld(true);
            const stickBox = new THREE.Box3().setFromObject(stick);
            stick.position.set(x, -stickBox.min.y - 0.05, z);
            stick.userData.type = 'stick_pickup';
            stick.userData.collectible = 'sticks';
            stick.userData.amount = 3;
            
            groundCollectibles.push(stick);
            scene.add(stick);
        }
        
        function createMushroomPickup(x, z) {
            const mushroom = new THREE.Group();
            
            // Stem with texture
            const stemGeo = new THREE.CylinderGeometry(0.08, 0.06, 0.15, 12);
            const stemMat = new THREE.MeshStandardMaterial({ 
                color: 0xF5DEB3,
                roughness: 0.8,
                metalness: 0
            });
            const stem = new THREE.Mesh(stemGeo, stemMat);
            stem.position.y = 0.075;
            stem.castShadow = true;
            mushroom.add(stem);
            
            // Stem rings for detail
            for (let i = 0; i < 2; i++) {
                const ringGeo = new THREE.TorusGeometry(0.07, 0.01, 8, 12);
                const ring = new THREE.Mesh(ringGeo, stemMat);
                ring.rotation.x = Math.PI / 2;
                ring.position.y = 0.05 + i * 0.05;
                mushroom.add(ring);
            }
            
            // Cap with better shape
            const capGeo = new THREE.SphereGeometry(0.12, 16, 16, 0, Math.PI * 2, 0, Math.PI * 0.7);
            const capMat = new THREE.MeshStandardMaterial({ 
                color: 0xDC143C,
                roughness: 0.7,
                metalness: 0
            });
            const cap = new THREE.Mesh(capGeo, capMat);
            cap.scale.y = 0.6;
            cap.position.y = 0.18;
            cap.castShadow = true;
            mushroom.add(cap);
            
            // Gills under cap
            const gillsGeo = new THREE.CylinderGeometry(0.11, 0.11, 0.02, 16);
            const gillsMat = new THREE.MeshStandardMaterial({ 
                color: 0xFFE4C4,
                roughness: 0.9
            });
            const gills = new THREE.Mesh(gillsGeo, gillsMat);
            gills.position.y = 0.17;
            mushroom.add(gills);
            
            // White spots with better distribution
            for (let i = 0; i < 5; i++) {
                const spotSize = 0.02 + Math.random() * 0.015;
                const spotGeo = new THREE.SphereGeometry(spotSize, 8, 8);
                const spotMat = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF,
                    roughness: 0.6
                });
                const spot = new THREE.Mesh(spotGeo, spotMat);
                const angle = Math.random() * Math.PI * 2;
                const radius = 0.06 + Math.random() * 0.04;
                spot.position.set(
                    Math.cos(angle) * radius,
                    0.2 + Math.random() * 0.02,
                    Math.sin(angle) * radius
                );
                mushroom.add(spot);
            }
            
            mushroom.position.set(x, -0.03, z);
            mushroom.userData.type = 'mushroom_pickup';
            mushroom.userData.collectible = 'mushroom';
            mushroom.userData.amount = 2;
            
            groundCollectibles.push(mushroom);
            scene.add(mushroom);
        }
        
        async function createSmallRockPickup(x, z) {
            const rock = new THREE.Group();
            
            // Main rock with better detail
            const rockGeo = new THREE.IcosahedronGeometry(0.12, 0);
            const rockMat = await createStoneMaterial(0x8A8A8A, 0.95);
            rockMat.flatShading = true;
            
            const rockMesh = new THREE.Mesh(rockGeo, rockMat);
            rockMesh.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            rockMesh.castShadow = true;
            rock.add(rockMesh);
            
            // Add 1-2 smaller pebbles nearby
            const numPebbles = 1 + Math.floor(Math.random() * 2);
            for (let i = 0; i < numPebbles; i++) {
                const pebbleSize = 0.04 + Math.random() * 0.04;
                const pebbleGeo = new THREE.DodecahedronGeometry(pebbleSize, 0);
                const pebble = new THREE.Mesh(pebbleGeo, rockMat);
                const angle = Math.random() * Math.PI * 2;
                const dist = 0.15 + Math.random() * 0.1;
                pebble.position.set(
                    Math.cos(angle) * dist,
                    pebbleSize * 0.3,
                    Math.sin(angle) * dist
                );
                pebble.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                pebble.castShadow = true;
                rock.add(pebble);
            }
            
            rock.updateMatrixWorld(true);
            const pickupBox = new THREE.Box3().setFromObject(rock);
            rock.position.set(x, -pickupBox.min.y - 0.05, z);
            rock.userData.type = 'rock_pickup';
            rock.userData.collectible = 'stone';
            rock.userData.amount = 2;
            
            groundCollectibles.push(rock);
            scene.add(rock);
        }
        
        // Generate ground collectibles
        for (let i = 0; i < 30; i++) {
            const x = (Math.random() - 0.5) * 180;
            const z = (Math.random() - 0.5) * 180;
            if (Math.sqrt(x * x + z * z) > 10) {
                createStickPickup(x, z);
            }
        }
        
        for (let i = 0; i < 20; i++) {
            const x = (Math.random() - 0.5) * 180;
            const z = (Math.random() - 0.5) * 180;
            if (Math.sqrt(x * x + z * z) > 10) {
                createMushroomPickup(x, z);
            }
        }
        
        const _sharedMatCache = new Map();

        async function createWoodMaterial(baseColor = 0x8B4513, roughness = 0.85) {
            const matKey = `wood_mat_${baseColor}_${roughness}`;
            if (_sharedMatCache.has(matKey)) return _sharedMatCache.get(matKey);
            const cacheId = `wood_${baseColor}_${roughness}`;
            let canvas = await textureCache.loadTexture(cacheId);
            if (!canvas) {
                textureCache.cacheStats.generated++;
                canvas = document.createElement('canvas');
                canvas.width = 256; canvas.height = 256;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = `#${baseColor.toString(16).padStart(6,'0')}`;
                ctx.fillRect(0,0,256,256);
                for (let i=0;i<30;i++) {
                    const y = Math.random()*256;
                    ctx.strokeStyle=`rgba(0,0,0,${0.1+Math.random()*0.15})`;
                    ctx.lineWidth=1+Math.random()*2; ctx.beginPath(); ctx.moveTo(0,y);
                    ctx.bezierCurveTo(64,y+(Math.random()-0.5)*10,192,y+(Math.random()-0.5)*10,256,y); ctx.stroke();
                }
                for (let i=0;i<3;i++) {
                    ctx.fillStyle=`rgba(0,0,0,0.2)`; ctx.beginPath();
                    ctx.ellipse(Math.random()*256,Math.random()*256,5+Math.random()*10,3+Math.random()*6,Math.random()*Math.PI,0,Math.PI*2); ctx.fill();
                }
                await textureCache.saveTexture(cacheId, canvas);
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.encoding = THREE.sRGBEncoding;
            const mat = new THREE.MeshStandardMaterial({ map:texture, roughness, metalness:0.01, envMapIntensity:0.15 });
            _sharedMatCache.set(matKey, mat); return mat;
        }

        async function createStoneMaterial(baseColor = 0x808080, roughness = 0.95) {
            const matKey = `stone_mat_${baseColor}_${roughness}`;
            if (_sharedMatCache.has(matKey)) return _sharedMatCache.get(matKey);
            const cacheId = `stone_${baseColor}_${roughness}`;
            let canvas = await textureCache.loadTexture(cacheId);
            if (!canvas) {
                textureCache.cacheStats.generated++;
                canvas = document.createElement('canvas');
                canvas.width = 256; canvas.height = 256;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle=`#${baseColor.toString(16).padStart(6,'0')}`; ctx.fillRect(0,0,256,256);
                for (let i=0;i<1000;i++) {
                    const a=0.1+Math.random()*0.2;
                    ctx.fillStyle=Math.random()>0.5?`rgba(0,0,0,${a})`:`rgba(255,255,255,${a*0.5})`;
                    ctx.fillRect(Math.random()*256,Math.random()*256,Math.random()*3,Math.random()*3);
                }
                for (let i=0;i<5;i++) {
                    ctx.strokeStyle=`rgba(0,0,0,0.3)`; ctx.lineWidth=1; ctx.beginPath();
                    ctx.moveTo(Math.random()*256,Math.random()*256);
                    for (let j=0;j<3;j++) ctx.lineTo(Math.random()*256,Math.random()*256);
                    ctx.stroke();
                }
                await textureCache.saveTexture(cacheId, canvas);
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.encoding = THREE.sRGBEncoding;
            const mat = new THREE.MeshStandardMaterial({ map:texture, roughness, metalness:0.08, envMapIntensity:0.2 });
            _sharedMatCache.set(matKey, mat); return mat;
        }

        async function createMetalMaterial(baseColor = 0x888888, roughness = 0.4) {
            const matKey = `metal_mat_${baseColor}_${roughness}`;
            if (_sharedMatCache.has(matKey)) return _sharedMatCache.get(matKey);
            const cacheId = `metal_${baseColor}_${roughness}`;
            let canvas = await textureCache.loadTexture(cacheId);
            if (!canvas) {
                textureCache.cacheStats.generated++;
                canvas = document.createElement('canvas');
                canvas.width = 256; canvas.height = 256;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle=`#${baseColor.toString(16).padStart(6,'0')}`; ctx.fillRect(0,0,256,256);
                for (let i=0;i<100;i++) {
                    const y=Math.random()*256; const a=0.1+Math.random()*0.1;
                    ctx.strokeStyle=Math.random()>0.5?`rgba(255,255,255,${a})`:`rgba(0,0,0,${a})`;
                    ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(0,y);
                    ctx.lineTo(256,y+(Math.random()-0.5)*2); ctx.stroke();
                }
                await textureCache.saveTexture(cacheId, canvas);
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.encoding = THREE.sRGBEncoding;
            const mat = new THREE.MeshStandardMaterial({ map:texture, roughness, metalness:0.15, envMapIntensity:0.3 });
            _sharedMatCache.set(matKey, mat); return mat;
        }

        async function createFabricMaterial(baseColor = 0xFFFFFF, roughness = 0.9) {
            const matKey = `fabric_mat_${baseColor}_${roughness}`;
            if (_sharedMatCache.has(matKey)) return _sharedMatCache.get(matKey);
            const cacheId = `fabric_${baseColor}_${roughness}`;
            let canvas = await textureCache.loadTexture(cacheId);
            if (!canvas) {
                textureCache.cacheStats.generated++;
                canvas = document.createElement('canvas');
                canvas.width = 128; canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle=`#${baseColor.toString(16).padStart(6,'0')}`; ctx.fillRect(0,0,128,128);
                const gs=4;
                for (let x=0;x<128;x+=gs) for (let y=0;y<128;y+=gs) {
                    ctx.fillStyle=((x/gs+y/gs)%2===0)?`rgba(0,0,0,0.1)`:`rgba(255,255,255,0.05)`;
                    ctx.fillRect(x,y,gs,gs);
                }
                await textureCache.saveTexture(cacheId, canvas);
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4,4);
            const mat = new THREE.MeshStandardMaterial({ map:texture, roughness, metalness:0 });
            _sharedMatCache.set(matKey, mat); return mat;
        }

                // ===== ENEMIES (Original style with animated eyes and hook arm) =====
        const enemies = [];

        // Generate a realistic cracked red skin texture once and reuse
        function makeEnemySkinTexture() {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');

            // Base  dark blood red
            ctx.fillStyle = '#6b0000';
            ctx.fillRect(0, 0, size, size);

            // Mid-layer blotchy flesh tones
            for (let i = 0; i < 180; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                const r = 6 + Math.random() * 22;
                const g = ctx.createRadialGradient(x, y, 0, x, y, r);
                const lightness = Math.random();
                if (lightness > 0.65) {
                    g.addColorStop(0, 'rgba(180,20,20,0.55)');
                    g.addColorStop(1, 'rgba(100,0,0,0)');
                } else {
                    g.addColorStop(0, 'rgba(60,0,0,0.6)');
                    g.addColorStop(1, 'rgba(60,0,0,0)');
                }
                ctx.fillStyle = g;
                ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
            }

            // Veins / cracks
            ctx.lineWidth = 1;
            for (let v = 0; v < 28; v++) {
                let vx = Math.random() * size;
                let vy = Math.random() * size;
                const segs = 6 + Math.floor(Math.random() * 8);
                const alpha = 0.3 + Math.random() * 0.4;
                ctx.strokeStyle = `rgba(20,0,0,${alpha})`;
                ctx.beginPath(); ctx.moveTo(vx, vy);
                for (let s = 0; s < segs; s++) {
                    vx += (Math.random() - 0.5) * 28;
                    vy += (Math.random() - 0.5) * 28;
                    ctx.lineTo(vx, vy);
                }
                ctx.stroke();
            }

            // Bright red veins (blood vessels)
            for (let v = 0; v < 14; v++) {
                let vx = Math.random() * size;
                let vy = Math.random() * size;
                const segs = 4 + Math.floor(Math.random() * 6);
                ctx.strokeStyle = `rgba(220,0,0,${0.25 + Math.random() * 0.3})`;
                ctx.lineWidth = 0.5 + Math.random();
                ctx.beginPath(); ctx.moveTo(vx, vy);
                for (let s = 0; s < segs; s++) {
                    vx += (Math.random() - 0.5) * 20;
                    vy += (Math.random() - 0.5) * 20;
                    ctx.lineTo(vx, vy);
                }
                ctx.stroke();
            }

            // Pustule / bump highlights
            for (let b = 0; b < 40; b++) {
                const bx = Math.random() * size;
                const by = Math.random() * size;
                const br = 2 + Math.random() * 5;
                const bg = ctx.createRadialGradient(bx - br*0.3, by - br*0.3, 0, bx, by, br);
                bg.addColorStop(0, 'rgba(220,60,60,0.7)');
                bg.addColorStop(0.5, 'rgba(140,10,10,0.4)');
                bg.addColorStop(1, 'rgba(60,0,0,0)');
                ctx.fillStyle = bg;
                ctx.beginPath(); ctx.arc(bx, by, br, 0, Math.PI * 2); ctx.fill();
            }

            // Dark crevice overlay
            for (let i = 0; i < 60; i++) {
                const cx2 = Math.random() * size;
                const cy2 = Math.random() * size;
                const cr = 3 + Math.random() * 9;
                const cg2 = ctx.createRadialGradient(cx2, cy2, 0, cx2, cy2, cr);
                cg2.addColorStop(0, 'rgba(0,0,0,0.45)');
                cg2.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = cg2;
                ctx.beginPath(); ctx.arc(cx2, cy2, cr, 0, Math.PI * 2); ctx.fill();
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(1.5, 2.5);
            return tex;
        }

        const _enemySkinTex = makeEnemySkinTexture();

        function createEnemy(x, z) {
            const enemyGroup = new THREE.Group();
            
            // Body  box shape with realistic red skin texture
            const enemyGeo = new THREE.BoxGeometry(0.8, 1.6, 0.8);
            const enemyMat = new THREE.MeshPhongMaterial({
                map: _enemySkinTex,
                color: 0xcc1111,
                specular: 0x330000,
                shininess: 18,
            });
            const enemyBody = new THREE.Mesh(enemyGeo, enemyMat);
            enemyBody.castShadow = true;
            enemyGroup.add(enemyBody);
            
            // Eyes (glowing red lines angled toward center)
            const eyeMat = new THREE.MeshPhongMaterial({ 
                color: 0xff0000, 
                emissive: 0xff0000,
                emissiveIntensity: 2.5
            });
            
            // Left eye (angled inward toward center)
            const leftEyeGeo = new THREE.BoxGeometry(0.15, 0.03, 0.02);
            const leftEye = new THREE.Mesh(leftEyeGeo, eyeMat);
            leftEye.position.set(-0.2, 0.4, 0.41);
            leftEye.rotation.z = 0.4;
            enemyGroup.add(leftEye);
            
            // Right eye (angled inward toward center)
            const rightEyeGeo = new THREE.BoxGeometry(0.15, 0.03, 0.02);
            const rightEye = new THREE.Mesh(rightEyeGeo, eyeMat);
            rightEye.position.set(0.2, 0.4, 0.41);
            rightEye.rotation.z = -0.4;
            enemyGroup.add(rightEye);
            
            // Angry eyes (brighter and angled outward)
            const angryEyeMat = new THREE.MeshPhongMaterial({ 
                color: 0xff0000, 
                emissive: 0xff0000,
                emissiveIntensity: 4.0
            });
            
            const angryLeftGeo = new THREE.BoxGeometry(0.18, 0.04, 0.02);
            const angryLeft = new THREE.Mesh(angryLeftGeo, angryEyeMat);
            angryLeft.position.set(-0.2, 0.42, 0.41);
            angryLeft.rotation.z = -0.7;
            angryLeft.visible = false;
            enemyGroup.add(angryLeft);
            
            const angryRightGeo = new THREE.BoxGeometry(0.18, 0.04, 0.02);
            const angryRight = new THREE.Mesh(angryRightGeo, angryEyeMat);
            angryRight.position.set(0.2, 0.42, 0.41);
            angryRight.rotation.z = 0.7;
            angryRight.visible = false;
            enemyGroup.add(angryRight);
            
            // Hook arm (right arm)
            const hookGroup = new THREE.Group();
            
            // Hook shaft  dark rusted steel with blood tinge
            const hookShaftGeo = new THREE.CylinderGeometry(0.045, 0.038, 0.35, 8);
            const hookShaftMat = new THREE.MeshPhongMaterial({
                color: 0x3a1a1a,
                specular: 0x884444,
                shininess: 60,
                emissive: 0x110000,
                emissiveIntensity: 0.3
            });
            const hookShaft = new THREE.Mesh(hookShaftGeo, hookShaftMat);
            hookShaft.rotation.z = Math.PI / 2;
            hookShaft.position.set(0.175, 0, 0);
            hookShaft.castShadow = true;
            hookGroup.add(hookShaft);

            // Hook curve  sharp, dark, blood-stained
            const hookCurveGeo = new THREE.TorusGeometry(0.17, 0.045, 8, 14, Math.PI * 1.1);
            const hookCurveMat = new THREE.MeshPhongMaterial({
                color: 0x2a0a0a,
                specular: 0xaa3333,
                shininess: 90,
                emissive: 0x1a0000,
                emissiveIntensity: 0.4
            });
            const hookCurve = new THREE.Mesh(hookCurveGeo, hookCurveMat);
            hookCurve.rotation.y = Math.PI / 2;
            hookCurve.rotation.z = -Math.PI / 4;
            hookCurve.position.set(0.34, -0.05, 0);
            hookCurve.castShadow = true;
            hookGroup.add(hookCurve);

            // Hook tip  glinting sharp point
            const tipGeo = new THREE.ConeGeometry(0.04, 0.12, 6);
            const tipMat = new THREE.MeshPhongMaterial({
                color: 0x1a0505,
                specular: 0xff4444,
                shininess: 140,
                emissive: 0x220000,
                emissiveIntensity: 0.5
            });
            const tip = new THREE.Mesh(tipGeo, tipMat);
            tip.rotation.z = Math.PI * 0.75;
            tip.position.set(0.46, -0.23, 0);
            tip.castShadow = true;
            hookGroup.add(tip);
            
            hookGroup.position.set(0.5, 0, 0);
            enemyGroup.add(hookGroup);


            
            enemyGroup.position.set(x, 0.8, z);
            enemyGroup.userData.health = 100;
            enemyGroup.userData.type = 'enemy';
            enemyGroup.userData.damage = 5;
            enemyGroup.userData.attackCooldown = 0;
            enemyGroup.userData.normalEyes = [leftEye, rightEye];
            enemyGroup.userData.angryEyes = [angryLeft, angryRight];
            enemyGroup.userData.isAngry = false;
            enemyGroup.userData.lastAttackTime = 0;
            enemyGroup.userData.soundTimer = 0;
            
            enemies.push(enemyGroup);
            scene.add(enemyGroup);
        }
        
        // 
        // SCORPION ENEMY SYSTEM  Desert biome only
        // 
        const scorpions = [];

        // Shared shiny black material for all scorpion parts
        const _scorpionMat = new THREE.MeshPhongMaterial({
            color: 0x0a0a0a,
            specular: 0x9999cc,
            shininess: 180,
            reflectivity: 1.0,
        });
        const _scorpionAccentMat = new THREE.MeshPhongMaterial({
            color: 0x111118,
            specular: 0xaaaaff,
            shininess: 220,
        });
        const _stingerMat = new THREE.MeshPhongMaterial({
            color: 0x1a0a00,
            specular: 0x66ff44,
            shininess: 200,
            emissive: 0x002200,
            emissiveIntensity: 0.4,
        });
        const _eyeMatS = new THREE.MeshPhongMaterial({
            color: 0xff4400,
            emissive: 0xff2200,
            emissiveIntensity: 2.0,
        });

        function createScorpion(x, z) {
            const g = new THREE.Group();

            //  Main body (mesosoma) 
            const bodyGeo = new THREE.BoxGeometry(0.28, 0.12, 0.38);
            const body = new THREE.Mesh(bodyGeo, _scorpionMat);
            body.position.set(0, 0, 0);
            body.castShadow = true;
            g.add(body);

            // Body ridge (dorsal crest)
            const ridgeGeo = new THREE.BoxGeometry(0.14, 0.06, 0.32);
            const ridge = new THREE.Mesh(ridgeGeo, _scorpionAccentMat);
            ridge.position.set(0, 0.09, 0);
            g.add(ridge);

            //  Head (cephalothorax / prosoma) 
            const headGeo = new THREE.BoxGeometry(0.22, 0.10, 0.18);
            const head = new THREE.Mesh(headGeo, _scorpionMat);
            head.position.set(0, 0.01, 0.26);
            head.castShadow = true;
            g.add(head);

            // Eyes  two tiny glowing red dots
            const eyeGeo = new THREE.SphereGeometry(0.022, 6, 6);
            const eyeL = new THREE.Mesh(eyeGeo, _eyeMatS);
            eyeL.position.set(-0.065, 0.07, 0.34);
            g.add(eyeL);
            const eyeR = new THREE.Mesh(eyeGeo, _eyeMatS);
            eyeR.position.set(0.065, 0.07, 0.34);
            g.add(eyeR);

            //  Abdomen segments (metasoma base  3 segments) 
            const segW = [0.22, 0.18, 0.14];
            const segD = [0.10, 0.09, 0.08];
            for (let i = 0; i < 3; i++) {
                const segGeo = new THREE.BoxGeometry(segW[i], 0.11, segD[i]);
                const seg = new THREE.Mesh(segGeo, _scorpionMat);
                seg.position.set(0, 0, -(0.22 + i * 0.10));
                seg.castShadow = true;
                g.add(seg);
            }

            //  Curved tail (5 segments bending upward then forward) 
            // Each tail segment: smaller cylinder, rotated to form curve
            const tailData = [
                // [radius, length, posX, posY, posZ, rotX]
                [0.055, 0.12,  0,  0.05, -0.54,  -0.30],
                [0.048, 0.12,  0,  0.17, -0.60,  -0.70],
                [0.040, 0.11,  0,  0.30, -0.60,  -1.15],
                [0.033, 0.10,  0,  0.40, -0.54,  -1.55],
                [0.026, 0.09,  0,  0.47, -0.44,  -1.90],
            ];
            tailData.forEach(([r, l, px, py, pz, rx]) => {
                const tGeo = new THREE.CylinderGeometry(r * 0.85, r, l, 8);
                const tSeg = new THREE.Mesh(tGeo, _scorpionMat);
                tSeg.position.set(px, py, pz);
                tSeg.rotation.x = rx;
                tSeg.castShadow = true;
                g.add(tSeg);
            });

            // Stinger (last tail piece  curved cone with toxic glow)
            const stingerGeo = new THREE.ConeGeometry(0.022, 0.11, 7);
            const stinger = new THREE.Mesh(stingerGeo, _stingerMat);
            stinger.position.set(0, 0.50, -0.26);
            stinger.rotation.x = -2.4;  // pointing forward-down
            stinger.castShadow = true;
            g.add(stinger);

            // Stinger bulb (venom sac)
            const sacGeo = new THREE.SphereGeometry(0.035, 8, 8);
            const sac = new THREE.Mesh(sacGeo, _stingerMat);
            sac.position.set(0, 0.48, -0.30);
            g.add(sac);

            //  Pincers (chelae)  left and right 
            [-1, 1].forEach(side => {
                const px = side * 0.17;

                // Arm segment (merus)
                const armGeo = new THREE.BoxGeometry(0.06, 0.07, 0.16);
                const arm = new THREE.Mesh(armGeo, _scorpionMat);
                arm.position.set(px, 0.01, 0.36);
                g.add(arm);

                // Fixed finger (immovable claw)
                const fixedGeo = new THREE.BoxGeometry(0.045, 0.055, 0.13);
                const fixed = new THREE.Mesh(fixedGeo, _scorpionAccentMat);
                fixed.position.set(px + side * 0.01, 0.025, 0.47);
                g.add(fixed);

                // Moveable finger tip (dactyl)
                const dactylGeo = new THREE.BoxGeometry(0.035, 0.04, 0.10);
                const dactyl = new THREE.Mesh(dactylGeo, _scorpionMat);
                dactyl.position.set(px + side * 0.04, -0.01, 0.47);
                dactyl.rotation.z = side * 0.25;
                g.add(dactyl);

                // Claw tip spikes
                const spikeGeo = new THREE.ConeGeometry(0.012, 0.055, 5);
                const spike = new THREE.Mesh(spikeGeo, _stingerMat);
                spike.position.set(px + side * 0.02, 0.02, 0.54);
                spike.rotation.x = -Math.PI / 2;
                g.add(spike);
            });

            //  8 Legs (4 per side) 
            const legPositionsZ = [-0.04, 0.04, 0.12, 0.20]; // along body
            [-1, 1].forEach(side => {
                legPositionsZ.forEach((lz, i) => {
                    // Upper leg
                    const upperGeo = new THREE.CylinderGeometry(0.018, 0.015, 0.14, 5);
                    const upper = new THREE.Mesh(upperGeo, _scorpionMat);
                    upper.rotation.z = side * (Math.PI / 2 + 0.3);
                    upper.rotation.x = 0.15;
                    upper.position.set(side * 0.22, -0.02, lz);
                    g.add(upper);

                    // Lower leg (tibia  angles down to ground)
                    const lowerGeo = new THREE.CylinderGeometry(0.014, 0.010, 0.13, 5);
                    const lower = new THREE.Mesh(lowerGeo, _scorpionAccentMat);
                    lower.rotation.z = side * (Math.PI / 2 - 0.5);
                    lower.rotation.x = 0.3;
                    lower.position.set(side * 0.32, -0.08, lz + 0.02);
                    g.add(lower);
                });
            });

            // Position scorpion close to ground
            g.position.set(x, 0.06, z);
            g.scale.set(1.4, 1.4, 1.4); // Scale up slightly for visibility

            g.userData.type       = 'scorpion';
            g.userData.health     = 25;
            g.userData.maxHealth  = 25;
            g.userData.damage     = 3;
            g.userData.lastAttackTime = 0;
            g.userData.animTime   = Math.random() * Math.PI * 2;
            g.userData.scuttleDir = new THREE.Vector3(
                (Math.random() - 0.5), 0, (Math.random() - 0.5)
            ).normalize();
            g.userData.scuttleTimer = 0;

            scene.add(g);
            scorpions.push(g);
            return g;
        }

        //  Poison debuff state 
        // Integrated into activeBuffs system: activeBuffs.poison
        // We need to add 'poison' to the debuff system separately since
        // it's a damage-over-time debuff not a positive buff
        let poisonDebuff = null; // { endTime, tickTimer }
        const POISON_DURATION = 30000;  // 30 seconds of poison
        const POISON_TICK_MS  = 1000;   // 1 damage per second

        function applyPoison() {
            if (poisonDebuff) {
                // Refresh duration
                poisonDebuff.endTime = Date.now() + POISON_DURATION;
            } else {
                poisonDebuff = { endTime: Date.now() + POISON_DURATION, tickTimer: Date.now() };
                showMessage(' Poisoned! Losing 1 HP/sec for 30 seconds. Find an antidote or wait it out!');
            }
            updatePoisonHUD();
        }

        function tickPoison() {
            if (!poisonDebuff) return;
            const now = Date.now();
            if (now >= poisonDebuff.endTime) {
                poisonDebuff = null;
                showMessage(' Poison has worn off.');
                updatePoisonHUD();
                return;
            }
            if (now - poisonDebuff.tickTimer >= POISON_TICK_MS) {
                poisonDebuff.tickTimer = now;
                health = Math.max(0, health - 1);
                updateUI();
                if (health <= 0) die();
            }
            // Update HUD timer every tick
            updatePoisonHUD();
        }

        function updatePoisonHUD() {
            // Reuse buff-hud  add/remove poison indicator
            let poisonEl = document.getElementById('poison-hud-indicator');
            if (!poisonDebuff) {
                if (poisonEl) poisonEl.remove();
                return;
            }
            const hud = document.getElementById('buff-hud');
            if (!hud) return;
            if (!poisonEl) {
                poisonEl = document.createElement('div');
                poisonEl.id = 'poison-hud-indicator';
                poisonEl.className = 'buff-indicator';
                poisonEl.style.borderColor = 'rgba(80,220,40,0.7)';
                poisonEl.style.background = 'linear-gradient(135deg,rgba(10,40,5,0.95),rgba(15,50,5,0.95))';
                poisonEl.style.color = '#aaff44';
                hud.appendChild(poisonEl);
            }
            const secsLeft = Math.max(0, Math.ceil((poisonDebuff.endTime - Date.now()) / 1000));
            poisonEl.innerHTML = ` Poisoned! -1 HP/sec <span class="buff-indicator-timer">${secsLeft}s</span>`;
        }

        //  Scorpion spawning in desert biome 
        function spawnScorpions() {
            if (!isInDesert()) return;
            if (scorpions.length >= 8) return;
            if (Math.random() > 0.003) return; // ~1 spawn attempt every ~5 seconds at 60fps

            const angle = Math.random() * Math.PI * 2;
            const dist  = 15 + Math.random() * 25;
            const sx = camera.position.x + Math.cos(angle) * dist;
            const sz = camera.position.z + Math.sin(angle) * dist;

            // Only spawn if position is actually in desert (z < -80)
            if (sz > -80) return;
            createScorpion(sx, sz);
        }

        //  Scorpion AI update 
        function updateScorpions() {
            const now = Date.now();
            for (let i = scorpions.length - 1; i >= 0; i--) {
                const sc = scorpions[i];
                // Full 3D dist for despawn; flat XZ dist for AI/attack (scorpion is ground-level, camera is at eye height ~1.7)
                const dist     = camera.position.distanceTo(sc.position);
                const flatDist = Math.sqrt(
                    Math.pow(camera.position.x - sc.position.x, 2) +
                    Math.pow(camera.position.z - sc.position.z, 2)
                );

                // Leg scuttle animation  body bobs slightly
                sc.userData.animTime += 0.12;
                sc.position.y = 0.06 * sc.scale.y + Math.abs(Math.sin(sc.userData.animTime * 3)) * 0.012;

                // Tail sway
                const tailBob = Math.sin(sc.userData.animTime * 2) * 0.08;
                sc.rotation.z = tailBob * 0.15;

                //  Shared stuck-check (same pattern as other animals) 
                if (!sc.userData.stuckCheckTimer) sc.userData.stuckCheckTimer = 0;
                if (!sc.userData.stuckFrames)     sc.userData.stuckFrames     = 0;
                if (!sc.userData.stuckLastPos)    sc.userData.stuckLastPos    = sc.position.clone();
                sc.userData.stuckCheckTimer++;
                if (sc.userData.stuckCheckTimer >= 60) {
                    sc.userData.stuckCheckTimer = 0;
                    const moved = sc.position.distanceTo(sc.userData.stuckLastPos);
                    if (moved < 0.05) {
                        sc.userData.stuckFrames++;
                    } else {
                        sc.userData.stuckFrames = 0;
                    }
                    sc.userData.stuckLastPos = sc.position.clone();
                    // After 3 consecutive stuck checks (~3 seconds), brute-force an escape
                    if (sc.userData.stuckFrames >= 3) {
                        let freed = false;
                        for (let attempt = 0; attempt < 16 && !freed; attempt++) {
                            const escAngle  = Math.random() * Math.PI * 2;
                            const radius    = 0.5 + attempt * 0.3;
                            const escapePos = new THREE.Vector3(
                                sc.position.x + Math.cos(escAngle) * radius,
                                sc.position.y,
                                sc.position.z + Math.sin(escAngle) * radius
                            );
                            const eBox = new THREE.Box3(
                                new THREE.Vector3(escapePos.x - 0.2, escapePos.y - 0.15, escapePos.z - 0.2),
                                new THREE.Vector3(escapePos.x + 0.2, escapePos.y + 0.15, escapePos.z + 0.2)
                            );
                            let blocked = false;
                            for (const b of buildings) {
                                if (b.userData.isDoor && b.userData.isOpen) continue;
                                if (new THREE.Box3().setFromObject(b).intersectsBox(eBox)) { blocked = true; break; }
                            }
                            if (!blocked) {
                                sc.position.copy(escapePos);
                                sc.userData.scuttleDir.set(Math.cos(escAngle), 0, Math.sin(escAngle));
                                freed = true;
                            }
                        }
                        sc.userData.stuckFrames = 0;
                    }
                }

                //  AI: chase when within 20 units 
                if (flatDist < 20) {
                    const dir = new THREE.Vector3()
                        .subVectors(camera.position, sc.position);
                    dir.y = 0;
                    dir.normalize();

                    const speed = 0.022;
                    const newPos = sc.position.clone().add(dir.clone().multiplyScalar(speed));
                    newPos.y = sc.position.y;

                    // Building collision check
                    let canMove = true;
                    const scBox = new THREE.Box3(
                        new THREE.Vector3(newPos.x - 0.2, newPos.y - 0.15, newPos.z - 0.2),
                        new THREE.Vector3(newPos.x + 0.2, newPos.y + 0.15, newPos.z + 0.2)
                    );
                    for (const b of buildings) {
                        if (b.userData.isDoor && b.userData.isOpen) continue;
                        if (new THREE.Box3().setFromObject(b).intersectsBox(scBox)) {
                            canMove = false;
                            // Nudge scuttle dir to help unstick while chasing
                            sc.userData.scuttleDir.set(
                                (Math.random() - 0.5), 0, (Math.random() - 0.5)
                            ).normalize();
                            break;
                        }
                    }

                    if (canMove) {
                        sc.position.copy(newPos);
                        sc.rotation.y = Math.atan2(dir.x, dir.z);
                    }

                } else {
                    // Wander randomly in desert
                    sc.userData.scuttleTimer++;
                    if (sc.userData.scuttleTimer > 120) {
                        sc.userData.scuttleDir.set(
                            (Math.random() - 0.5), 0, (Math.random() - 0.5)
                        ).normalize();
                        sc.userData.scuttleTimer = 0;
                    }
                    const wanderPos = sc.position.clone().add(
                        sc.userData.scuttleDir.clone().multiplyScalar(0.01)
                    );
                    wanderPos.y = sc.position.y;

                    // Wander collision check  bounce off buildings immediately
                    const wBox = new THREE.Box3(
                        new THREE.Vector3(wanderPos.x - 0.2, wanderPos.y - 0.15, wanderPos.z - 0.2),
                        new THREE.Vector3(wanderPos.x + 0.2, wanderPos.y + 0.15, wanderPos.z + 0.2)
                    );
                    let wanderBlocked = false;
                    for (const b of buildings) {
                        if (b.userData.isDoor && b.userData.isOpen) continue;
                        if (new THREE.Box3().setFromObject(b).intersectsBox(wBox)) {
                            wanderBlocked = true; break;
                        }
                    }
                    if (wanderBlocked) {
                        sc.userData.scuttleDir.set(
                            (Math.random() - 0.5), 0, (Math.random() - 0.5)
                        ).normalize();
                        sc.userData.scuttleTimer = 0;
                    } else {
                        sc.position.copy(wanderPos);
                        sc.rotation.y = Math.atan2(sc.userData.scuttleDir.x, sc.userData.scuttleDir.z);
                    }
                }

                //  Attack 
                if (flatDist < 1.3) {
                    if (now - sc.userData.lastAttackTime > 1200) {
                        sc.userData.lastAttackTime = now;
                        playScorpionAttackSound();
                        health = Math.max(0, health - sc.userData.damage);
                        updateUI();

                        // 10% chance to poison
                        if (Math.random() < 0.10) {
                            applyPoison();
                        } else {
                            showMessage(' Scorpion stings you! -3 HP');
                        }

                        if (health <= 0) die();
                    }
                }

                //  Despawn if too far or player left desert 
                if (dist > 80 || !isInDesert()) {
                    scene.remove(sc);
                    scorpions.splice(i, 1);
                }
            }

            // Tick poison every frame
            tickPoison();
        }

        //  Initial scorpion spawn (a few waiting in the desert) 
        for (let i = 0; i < 4; i++) {
            const angle = (i / 4) * Math.PI * 2;
            const dist  = 180 + Math.random() * 20; // deep in desert
            createScorpion(Math.cos(angle) * 20, -dist / 2);
        }

        // 
        // COYOTE ENEMY SYSTEM  Desert biome only
        // 
        const coyotes = [];

        //  Coyote sound assets 
        const _coyoteHowlAudio  = new Audio('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/wolfhowl.mp3');
        _coyoteHowlAudio.preload = 'auto';
        const _coyoteGrowlAudio = new Audio('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/wolfgrowl.mp3');
        _coyoteGrowlAudio.preload = 'auto';

        // Track all live growl clips so we can silence them on player death
        const _activeCoyoteGrowlClips = [];

        function stopAllCoyoteSounds() {
            for (const clip of _activeCoyoteGrowlClips) {
                try { clip.pause(); clip.currentTime = 0; } catch(e){}
            }
            _activeCoyoteGrowlClips.length = 0;
        }

        function playCoyoteHowl(flatDist) {
            // Proximity volume: full at 5 units, silent at 40
            const proximity = Math.max(0, 1 - (flatDist - 5) / 35);
            const vol = Math.min(1, volumeSettings.enemies * 0.9 * proximity);
            if (vol < 0.01) return;
            const clip = _coyoteHowlAudio.cloneNode();
            clip.volume = vol;
            clip.play().catch(() => {});
        }

        // Growl: proximity volume + random pitch + 3s play / 3s gap cycle
        // Each coyote tracks its own growl timer in userData
        function tickCoyoteGrowl(cy, flatDist) {
            const now = Date.now();
            if (!cy.userData.growlPhase)     cy.userData.growlPhase     = 'gap';
            if (!cy.userData.growlPhaseStart) cy.userData.growlPhaseStart = now;
            if (!cy.userData.growlClip)       cy.userData.growlClip       = null;

            const elapsed = now - cy.userData.growlPhaseStart;

            if (cy.userData.growlPhase === 'gap') {
                if (elapsed >= 3000) {
                    // Start playing
                    const proximity = Math.max(0, 1 - Math.max(0, flatDist - 2) / 25);
                    const vol = Math.min(1, volumeSettings.enemies * 0.85 * proximity);
                    if (vol > 0.01) {
                        const clip = _coyoteGrowlAudio.cloneNode();
                        clip.volume = vol;
                        // Random pitch via playbackRate: 0.85  1.15
                        clip.playbackRate = 0.85 + Math.random() * 0.30;
                        clip.play().catch(() => {});
                        _activeCoyoteGrowlClips.push(clip);
                        cy.userData.growlClip = clip;
                    }
                    cy.userData.growlPhase     = 'playing';
                    cy.userData.growlPhaseStart = now;
                }
            } else {
                // playing phase  stop after 3s
                if (elapsed >= 3000) {
                    if (cy.userData.growlClip) {
                        try { cy.userData.growlClip.pause(); cy.userData.growlClip.currentTime = 0; } catch(e){}
                        const idx = _activeCoyoteGrowlClips.indexOf(cy.userData.growlClip);
                        if (idx !== -1) _activeCoyoteGrowlClips.splice(idx, 1);
                        cy.userData.growlClip = null;
                    }
                    cy.userData.growlPhase     = 'gap';
                    cy.userData.growlPhaseStart = now;
                }
            }
        }

        //  Realistic coyote materials 
        // Sandy-grey tawny fur (true coyote colouration)

        

        (async () => {
            for (let i = 0; i < 25; i++) {
                const x = (Math.random() - 0.5) * 180;
                const z = (Math.random() - 0.5) * 180;
                if (Math.sqrt(x * x + z * z) > 10) {
                    await createSmallRockPickup(x, z);
                }
            }
        })();
        
        (async () => {
            for (let i = 0; i < 30; i++) {
                let x, z, valid;
                let attempts = 0;
                do {
                    valid = true;
                    x = (Math.random() - 0.5) * 180;
                    z = (Math.random() - 0.5) * 180;
                
                    if (Math.sqrt(x * x + z * z) < 15) {
                        valid = false;
                        continue;
                    }
                    
                    for (let pos of [...treePositions, ...rockPositions]) {
                        const dist = Math.sqrt((x - pos.x) ** 2 + (z - pos.z) ** 2);
                        if (dist < 5) {
                            valid = false;
                            break;
                        }
                    }
                    attempts++;
                } while (!valid && attempts < 50);
                
                if (valid) await createBerryBush(x, z);
            }
        })();

        // ===== WILD PLANTS (Forest Biome) =====
        // Small number of fully-grown plants  player's first source of seeds.
        // 15-minute real-time respawn after harvest.
        //  PLANT GLB LOADER 
        // Maps each seedType to its GLB filename (same host as Wolf.glb)
        const _PLANT_GLB_BASE = 'https://jam110uk.github.io/Crust-Sounds/';
        const _plantGLBFiles = {
            cabbage_seed:     'Cabbage.glb',
            wheat_seed:       'Wheat.glb',
            cucumber_seed:    'Cucumber.glb',
            pumpkin_seed:     'Pumpkin.glb',
            red_berry_seed:   'Bush with Berries.glb',
            black_berry_seed: 'Bush with Berries.glb',
            hemp_seed:        'Suspicious Plant.glb',
            tomato_seed:      'Tomato.glb',
            strawberry_seed:  'Strawberries.glb',
            mushroom_seed:    'Mushrooms.glb',
            carrot_seed:      'Carrot.glb',
            potato_seed:      'Potato.glb',
            corn_seed:        'Corn.glb',
        };

        // Cache: seedType  THREE.Object3D template (or null if load failed)
        const _plantGLBCache = {};
        // Promises so we don't double-fetch
        const _plantGLBPromises = {};

        function _loadPlantGLB(seedType) {
            if (seedType in _plantGLBCache) return Promise.resolve(_plantGLBCache[seedType]);
            if (_plantGLBPromises[seedType]) return _plantGLBPromises[seedType];
            const file = _plantGLBFiles[seedType];
            if (!file) { _plantGLBCache[seedType] = null; return Promise.resolve(null); }

            // Per-crop target height (metres, largest axis)
            const _plantTargetSize = {
                wheat_seed:       1.20,   // 0.55  ~2.2
                corn_seed:        1.10,   // 0.52  ~2.1
                hemp_seed:        1.05,   // 0.48  ~2.2
                red_berry_seed:   0.14,   // 0.42 / 3
                black_berry_seed: 0.14,   // 0.42 / 3
                tomato_seed:      0.095,  // 0.38 / 4
                pumpkin_seed:     0.64,   // 0.32  2
                cucumber_seed:    0.30,
                potato_seed:      0.28,
                carrot_seed:      0.28,
                cabbage_seed:     0.30,
                mushroom_seed:    0.24,
                strawberry_seed:  0.22,
            };

            // _glbLoad handles fetch, parse, Draco, texture fix, mesh validation  all for free.
            // We then normalise the template size and ground it so _buildPlantGLBInstance
            // can simply clone without any further scaling.
            _plantGLBPromises[seedType] = _glbLoad(file, _PLANT_GLB_BASE).then(tmpl => {
                if (!tmpl) { _plantGLBCache[seedType] = null; return null; }
                const targetSize = _plantTargetSize[seedType] || 0.28;
                const box = new THREE.Box3().setFromObject(tmpl);
                const sz  = new THREE.Vector3(); box.getSize(sz);
                const maxDim = Math.max(sz.x, sz.y, sz.z);
                if (maxDim > 0) tmpl.scale.setScalar(targetSize / maxDim);
                tmpl.updateMatrixWorld(true);
                const b2 = new THREE.Box3().setFromObject(tmpl);
                if (isFinite(b2.min.y)) tmpl.position.y -= b2.min.y;
                const b3 = new THREE.Box3().setFromObject(tmpl);
                const h = (b3.max.y - b3.min.y).toFixed(3);
                console.log(` Plant GLB ready: ${file} @ ${targetSize}m  grounded height=${h}m (sink override: ${(_plantSoilSink||{})[seedType]??0}m)`);
                _plantGLBCache[seedType] = tmpl;
                return tmpl;
            });
            return _plantGLBPromises[seedType];
        }

        // Kick off all plant GLB loads immediately in the background
        Object.keys(_plantGLBFiles).forEach(seed => _loadPlantGLB(seed));

        // Build a stage-4 GLB instance from the cached template (deep clone).
        // The template is already normalised to the correct world size by _loadPlantGLB 
        // the `scale` param is a procedural-geometry multiplier and must NOT be reapplied.
        function _buildPlantGLBInstance(seedType, _scale) {
            const tmpl = _plantGLBCache[seedType];
            if (!tmpl) return null;
            const inst = tmpl.clone(true);
            inst.scale.copy(tmpl.scale);   // use pre-normalised scale, ignore _scale
            inst.position.copy(tmpl.position);
            inst.updateMatrixWorld(true);
            // Deep-clone materials per-instance (Three.js r128 shared-material bug)
            inst.traverse(c => {
                if (!c.isMesh) return;
                if (Array.isArray(c.material)) {
                    c.material = c.material.map(m => { const mc = m ? m.clone() : m; if (mc) mc.needsUpdate = true; return mc; });
                } else if (c.material) {
                    c.material = c.material.clone();
                    c.material.needsUpdate = true;
                }
                c.visible = true; c.frustumCulled = false;
                if (c.isMesh) { c.castShadow = true; c.receiveShadow = true; if (c.geometry) { c.geometry.computeBoundingBox(); c.geometry.computeBoundingSphere(); } }
            });
            _fixGLBTextures(inst);
            return inst;
        }

        (function spawnWildPlants() {
            const WILD_SEED_TYPES = [
                'pumpkin_seed','wheat_seed','cabbage_seed','cucumber_seed',
                'potato_seed','carrot_seed','hemp_seed','corn_seed','mushroom_seed',
                'red_berry_seed','black_berry_seed','strawberry_seed','tomato_seed'
            ];
            // 12 plants per type scattered in the forest (z > 0 = forest side)
            const perType = 2;
            WILD_SEED_TYPES.forEach(seedType => {
                for (let i = 0; i < perType; i++) {
                    let x, z, attempts = 0, valid = false;
                    do {
                        x = (Math.random() - 0.5) * 160;
                        z = 10 + Math.random() * 70; // forest side only
                        // Not too close to spawn
                        if (Math.sqrt(x*x + z*z) < 18) continue;
                        valid = true;
                        for (const pos of [...treePositions, ...rockPositions, ...bushPositions]) {
                            if (Math.sqrt((x-pos.x)**2+(z-pos.z)**2) < 4) { valid = false; break; }
                        }
                        attempts++;
                    } while (!valid && attempts < 80);
                    if (!valid) continue;

                    const _wsc={wheat_seed:7.5,corn_seed:6.8,hemp_seed:6.5,red_berry_seed:1.2,black_berry_seed:1.2,tomato_seed:0.625,pumpkin_seed:5.0,cucumber_seed:2.5,potato_seed:2.5,carrot_seed:2.5,cabbage_seed:2.5,mushroom_seed:2.5,strawberry_seed:2.5};
                    const plant = buildPlantModel(seedType, 4, _wsc[seedType] || 2.5);
                    plant.position.set(x, 0, z);
                    plant.rotation.y = Math.random() * Math.PI * 2;
                    plant.userData.isWildPlant = true;
                    plant.userData.seedType = seedType;
                    plant.userData.harvestable = true;
                    plant.userData.respawnAt = 0;
                    scene.add(plant);
                    wildPlants.push(plant);
                }
            });
        })();
        // Bleached driftwood sticks and sandstone pebbles scattered across the desert
        (async () => {
            const dMargin  = 8;
            const dCenterZ = -desertOffset + 0.5;
            const dHalf    = groundSize / 2 - dMargin;
            const dXMin    = -groundSize / 2 + dMargin;
            const dXMax    =  groundSize / 2 - dMargin;
            const dZMin    = dCenterZ - dHalf;
            const dZMax    = dCenterZ + dHalf - 15;

            function randDesertPos() {
                return {
                    x: dXMin + Math.random() * (dXMax - dXMin),
                    z: dZMin + Math.random() * (dZMax - dZMin),
                };
            }

            function tooCloseToFormation(x, z, minDist) {
                for (const p of desertFormationPositions) {
                    if (Math.sqrt((x - p.x) ** 2 + (z - p.z) ** 2) < minDist) return true;
                }
                for (const c of desertFormationColliders) {
                    if (Math.sqrt((x - c.x) ** 2 + (z - c.z) ** 2) < c.r + 1) return true;
                }
                return false;
            }

            // \u2500\u2500 Desert sticks: bleached pale wood \u2500\u2500
            function createDesertStickPickup(x, z) {
                const stick = new THREE.Group();
                const numSticks = 2 + Math.floor(Math.random() * 2);
                for (let i = 0; i < numSticks; i++) {
                    const length = 0.32 + Math.random() * 0.18;
                    const thickness = 0.013 + Math.random() * 0.009;
                    const geo = new THREE.CylinderGeometry(thickness, thickness * 0.7, length, 5);
                    // Bleached pale tan \u2014 dried out desert wood
                    const mat = new THREE.MeshStandardMaterial({
                        color: 0xc4a97a,
                        roughness: 0.95, metalness: 0
                    });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.rotation.z = Math.random() * Math.PI;
                    mesh.rotation.x = Math.random() * 0.4;
                    mesh.rotation.y = (i / numSticks) * Math.PI * 0.6;
                    mesh.position.x += (Math.random() - 0.5) * 0.06;
                    mesh.position.z += (Math.random() - 0.5) * 0.06;
                    mesh.castShadow = true;
                    stick.add(mesh);
                }
                stick.updateMatrixWorld(true);
                const box = new THREE.Box3().setFromObject(stick);
                stick.position.set(x, -box.min.y - 0.04, z);
                stick.userData.type      = 'stick_pickup';
                stick.userData.collectible = 'sticks';
                stick.userData.amount    = 3;
                groundCollectibles.push(stick);
                scene.add(stick);
            }

            // \u2500\u2500 Desert pebbles: warm sandstone tone \u2500\u2500
            async function createDesertRockPickup(x, z) {
                const rock = new THREE.Group();
                const geo  = new THREE.IcosahedronGeometry(0.11, 0);
                const mat  = await createStoneMaterial(0xb09060, 0.96);
                mat.flatShading = true;
                const mesh = new THREE.Mesh(geo, mat);
                mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                mesh.castShadow = true;
                rock.add(mesh);
                const numPebbles = 1 + Math.floor(Math.random() * 2);
                for (let i = 0; i < numPebbles; i++) {
                    const ps = 0.04 + Math.random() * 0.035;
                    const pg = new THREE.DodecahedronGeometry(ps, 0);
                    const pm = new THREE.Mesh(pg, mat);
                    const a  = Math.random() * Math.PI * 2;
                    pm.position.set(Math.cos(a) * 0.14, ps * 0.3, Math.sin(a) * 0.14);
                    pm.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    pm.castShadow = true;
                    rock.add(pm);
                }
                rock.updateMatrixWorld(true);
                const box = new THREE.Box3().setFromObject(rock);
                rock.position.set(x, -box.min.y - 0.04, z);
                rock.userData.type       = 'rock_pickup';
                rock.userData.collectible = 'stone';
                rock.userData.amount     = 2;
                groundCollectibles.push(rock);
                scene.add(rock);
            }

            // Spawn 40 stick pickups across the desert
            let placed = [];
            for (let i = 0; i < 40; i++) {
                let pos, tries = 0, ok = false;
                do {
                    pos = randDesertPos();
                    ok = !tooCloseToFormation(pos.x, pos.z, 4);
                    if (ok) for (const p of placed) {
                        if (Math.sqrt((pos.x-p.x)**2+(pos.z-p.z)**2) < 2.5) { ok=false; break; }
                    }
                    tries++;
                } while (!ok && tries < 60);
                if (ok) { createDesertStickPickup(pos.x, pos.z); placed.push(pos); }
            }

            // Spawn 35 stone pickups across the desert
            placed = [];
            for (let i = 0; i < 35; i++) {
                let pos, tries = 0, ok = false;
                do {
                    pos = randDesertPos();
                    ok = !tooCloseToFormation(pos.x, pos.z, 4);
                    if (ok) for (const p of placed) {
                        if (Math.sqrt((pos.x-p.x)**2+(pos.z-p.z)**2) < 2.5) { ok=false; break; }
                    }
                    tries++;
                } while (!ok && tries < 60);
                if (ok) { await createDesertRockPickup(pos.x, pos.z); placed.push(pos); }
            }
        })();
        const grassBlades = [];

        // One shared material for all grass ? avoids per-blade material switching
        const sharedGrassMat = new THREE.MeshStandardMaterial({
            color: new THREE.Color().setHSL(0.27, 0.42, 0.22),
            side: THREE.DoubleSide,
            roughness: 0.98,
            metalness: 0,
            vertexColors: true,
        });

        for (let i = 0; i < 200; i++) { // 200 clusters (was 400) ? merged geo looks just as dense
            const x = (Math.random() - 0.5) * 180;
            const z = (Math.random() - 0.5) * 180;
            if (Math.sqrt(x * x + z * z) < 10) continue;

            const numBlades = 4 + Math.floor(Math.random() * 3); // 4?6 blades

            // Accumulate geometry data for all blades in this cluster
            const allPos = [], allNorm = [], allUV = [], allCol = [], allIdx = [];
            let vertOffset = 0;

            for (let b = 0; b < numBlades; b++) {
                const bladeHeight = 0.8 + Math.random() * 0.4;
                const bladeWidth  = 0.08 + Math.random() * 0.04;
                const bx = (Math.random() - 0.5) * 0.15;
                const bz = (Math.random() - 0.5) * 0.15;
                const ry = Math.random() * Math.PI * 2;
                const cosR = Math.cos(ry), sinR = Math.sin(ry);

                // PlaneGeometry 1?4 segments: 2 cols ? 5 rows = 10 verts
                const segsY = 4;
                const cols  = 2, rows = segsY + 1; // 2 ? 5

                // Colour variation per blade \ufffd muted naturalistic palette
                // Mix of dark green, mid green, yellow-green and occasional straw
                const palettes = [
                    { h: 0.28, sMin: 0.35, sMax: 0.55, lMin: 0.14, lMax: 0.24 }, // dark rich green
                    { h: 0.27, sMin: 0.30, sMax: 0.50, lMin: 0.20, lMax: 0.32 }, // mid green
                    { h: 0.24, sMin: 0.25, sMax: 0.45, lMin: 0.25, lMax: 0.38 }, // yellow-green
                    { h: 0.20, sMin: 0.20, sMax: 0.35, lMin: 0.30, lMax: 0.42 }, // dry straw-green
                ];
                const pal = palettes[Math.floor(Math.random() * palettes.length)];
                const hue  = pal.h + (Math.random() - 0.5) * 0.04;
                const sat  = pal.sMin + Math.random() * (pal.sMax - pal.sMin);
                const lit  = pal.lMin + Math.random() * (pal.lMax - pal.lMin);
                const col  = new THREE.Color().setHSL(hue, sat, lit);

                for (let row = 0; row < rows; row++) {
                    for (let col2 = 0; col2 < cols; col2++) {
                        const u = col2 / (cols - 1);         // 0 or 1
                        const v = row  / (rows - 1);         // 0..1 bottom to top
                        const lx = (u - 0.5) * bladeWidth;
                        const ly = v * bladeHeight - bladeHeight * 0.5;

                        // Bend: tip bends forward
                        const bendFactor = ((v + 0.5) ** 2);
                        const bendX = bendFactor * (0.1 + Math.random() * 0.05);

                        // Rotate blade around Y by ry, then offset to bx/bz
                        const wx = cosR * (lx + bendX) - sinR * 0 + bx;
                        const wz = sinR * (lx + bendX) + cosR * 0 + bz;

                        allPos.push(wx, ly + bladeHeight * 0.5, wz);
                        allNorm.push(0, 1, 0); // normals recomputed below
                        allUV.push(u, v);
                        allCol.push(col.r, col.g, col.b);
                    }
                }

                // Two quads per row segment
                for (let row = 0; row < segsY; row++) {
                    const a = vertOffset + row * cols;
                    const b = a + 1, c = a + cols, d = c + 1;
                    allIdx.push(a, c, b,  b, c, d);
                }
                vertOffset += rows * cols;
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position',  new THREE.Float32BufferAttribute(allPos,  3));
            geo.setAttribute('normal',    new THREE.Float32BufferAttribute(allNorm, 3));
            geo.setAttribute('uv',        new THREE.Float32BufferAttribute(allUV,   2));
            geo.setAttribute('color',     new THREE.Float32BufferAttribute(allCol,  3));
            geo.setIndex(allIdx);
            geo.computeVertexNormals();

            const grassCluster = new THREE.Mesh(geo, sharedGrassMat);
            grassCluster.position.set(x, 0, z);
            grassCluster.castShadow   = false;
            grassCluster.receiveShadow = false;
            grassCluster.userData.windSpeed = 0.8 + Math.random() * 0.4;
            grassCluster.userData.windPhase = Math.random() * Math.PI * 2;
            grassCluster.userData.type = 'grass';

            grassBlades.push(grassCluster);
            scene.add(grassCluster);
        }
        
        // ===== ANIMALS (Exactly like original with bunny ears and toe beans) =====
        window.animals = [];
        
        function createAnimal(x, z) {
            const animalGroup = new THREE.Group();

            //  Procedural fur texture 
            const furCanvas = document.createElement('canvas');
            furCanvas.width = 128; furCanvas.height = 128;
            const fCtx = furCanvas.getContext('2d');
            fCtx.fillStyle = '#8B5E3C';
            fCtx.fillRect(0, 0, 128, 128);
            for (let i = 0; i < 600; i++) {
                const fx = Math.random() * 128, fy = Math.random() * 128;
                const len = 4 + Math.random() * 10;
                const ang = Math.PI * 0.5 + (Math.random() - 0.5) * 0.7;
                fCtx.strokeStyle = Math.random() > 0.5
                    ? `rgba(${55+Math.random()*30|0},${32+Math.random()*18|0},${8+Math.random()*10|0},${0.20+Math.random()*0.25})`
                    : `rgba(${175+Math.random()*45|0},${125+Math.random()*35|0},${65+Math.random()*30|0},${0.14+Math.random()*0.20})`;
                fCtx.lineWidth = 0.4 + Math.random() * 1.2;
                fCtx.beginPath();
                fCtx.moveTo(fx, fy);
                fCtx.lineTo(fx + Math.cos(ang)*len, fy + Math.sin(ang)*len);
                fCtx.stroke();
            }
            const furTex = new THREE.CanvasTexture(furCanvas);
            furTex.wrapS = furTex.wrapT = THREE.RepeatWrapping;
            furTex.repeat.set(3, 2);

            //  Materials 
            const furMat   = new THREE.MeshStandardMaterial({ map: furTex, roughness: 0.97, metalness: 0.0 });
            const earOutMat= new THREE.MeshStandardMaterial({ map: furTex, roughness: 0.97, metalness: 0.0 });
            const earInMat = new THREE.MeshStandardMaterial({ color: 0xf5ede0, roughness: 0.95, metalness: 0.0 });
            const eyeMat   = new THREE.MeshStandardMaterial({ color: 0x1a0d00, roughness: 0.3, metalness: 0.1 });
            const eyeShine = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1 });
            const beanMat  = new THREE.MeshStandardMaterial({ color: 0xffb6c1, roughness: 0.9 });

            //  Body  original boxy shape 
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 1.2), furMat);
            body.castShadow = true;
            animalGroup.add(body);

            //  Head  boxy too, matches body style 
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.38, 0.42), furMat);
            head.position.set(0, 0.12, 0.72);
            head.castShadow = true;
            animalGroup.add(head);
            animalGroup.userData.head = head;

            // Eyes
            [-0.14, 0.14].forEach(sx => {
                const eye = new THREE.Mesh(new THREE.SphereGeometry(0.040, 8, 7), eyeMat);
                eye.position.set(sx, 0.055, 0.19);
                head.add(eye);
                const glint = new THREE.Mesh(new THREE.SphereGeometry(0.013, 5, 5), eyeShine);
                glint.position.set(sx * 0.18, 0.014, 0.036);
                eye.add(glint);
            });

            //  4 Realistic deer-style ears 
            // Large triangular cones (4-sided) with white inner face, splayed naturally
            const earDefs = [
                { pos: [-0.18, 0.24,  0.06], rotZ:  0.38, rotX: -0.10 },
                { pos: [ 0.18, 0.24,  0.06], rotZ: -0.38, rotX: -0.10 },
                { pos: [-0.14, 0.22, -0.10], rotZ:  0.25, rotX:  0.20 },
                { pos: [ 0.14, 0.22, -0.10], rotZ: -0.25, rotX:  0.20 },
            ];
            earDefs.forEach(({ pos, rotZ, rotX }) => {
                const earGroup = new THREE.Group();
                earGroup.position.set(...pos);
                earGroup.rotation.z = rotZ;
                earGroup.rotation.x = rotX;
                // Outer ear  fur texture, triangular cone
                const outer = new THREE.Mesh(new THREE.ConeGeometry(0.10, 0.32, 4, 1), earOutMat);
                outer.castShadow = true;
                earGroup.add(outer);
                // White inner face  slightly smaller, inset forward
                const inner = new THREE.Mesh(new THREE.ConeGeometry(0.065, 0.24, 4, 1), earInMat);
                inner.position.set(0, 0.006, 0.016);
                earGroup.add(inner);
                head.add(earGroup);
            });

            //  Paw beans  kept from original 
            const beanGeo = new THREE.SphereGeometry(0.06, 8, 8);
            [[-0.25, 0.5], [0.25, 0.5], [-0.25, -0.4], [0.25, -0.4]].forEach(([bx, bz]) => {
                const bean = new THREE.Mesh(beanGeo, beanMat);
                bean.position.set(bx, -0.25, bz);
                bean.scale.y = 0.6;
                animalGroup.add(bean);
            });

            //  Placement & metadata 
            animalGroup.position.set(x, 0.3, z);
            animalGroup.userData.health    = 50;
            animalGroup.userData.type      = 'animal';
            animalGroup.userData.velocity  = new THREE.Vector3(
                (Math.random() - 0.5) * 0.02, 0, (Math.random() - 0.5) * 0.02
            );
            animalGroup.userData.soundTimer = Math.random() * 30;
            animalGroup.userData.animTime   = Math.random() * Math.PI * 2;

            window.animals.push(animalGroup);
            scene.add(animalGroup);
        }
        
        for (let i = 0; i < 40; i++) {
            const x = (Math.random() - 0.5) * 160;
            const z = (Math.random() - 0.5) * 160;
            if (Math.sqrt(x * x + z * z) > 20) {
                createAnimal(x, z);
            }
        }
        
        // ===== SQUIRRELS =====
        window.squirrels = [];

        function createSquirrel(x, z) {
            const squirrelGroup = new THREE.Group();

            //  Materials 
            const furMat    = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9, metalness: 0.0 });
            const bellyMat  = new THREE.MeshStandardMaterial({ color: 0xD2996A, roughness: 0.9, metalness: 0.0 });
            const tailMat   = new THREE.MeshStandardMaterial({ color: 0xA0522D, roughness: 1.0, metalness: 0.0 });
            const tailTipMat= new THREE.MeshStandardMaterial({ color: 0xF5DEB3, roughness: 1.0, metalness: 0.0 });
            const eyeMat    = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.3, metalness: 0.1 });
            const eyeShine  = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1, metalness: 0.0 });
            const noseMat   = new THREE.MeshStandardMaterial({ color: 0x3d1a00, roughness: 0.5 });
            const earInner  = new THREE.MeshStandardMaterial({ color: 0xffb6b6, roughness: 0.9 });

            //  Body 
            const bodyGeo = new THREE.SphereGeometry(0.1, 10, 8);
            // Stretch into an elongated oval
            const bodyPos = bodyGeo.attributes.position;
            for (let i = 0; i < bodyPos.count; i++) {
                bodyPos.setZ(i, bodyPos.getZ(i) * 1.55);
                bodyPos.setY(i, bodyPos.getY(i) * 0.88);
            }
            bodyGeo.computeVertexNormals();
            const body = new THREE.Mesh(bodyGeo, furMat);
            body.castShadow = true;
            squirrelGroup.add(body);

            // Belly patch
            const bellyGeo = new THREE.SphereGeometry(0.065, 8, 6);
            const belly = new THREE.Mesh(bellyGeo, bellyMat);
            belly.scale.set(0.7, 0.6, 0.5);
            belly.position.set(0, -0.018, 0.03);
            squirrelGroup.add(belly);

            //  Head 
            const headGeo = new THREE.SphereGeometry(0.072, 10, 8);
            const head = new THREE.Mesh(headGeo, furMat);
            head.position.set(0, 0.055, 0.135);
            head.castShadow = true;
            squirrelGroup.add(head);

            // Snout
            const snoutGeo = new THREE.SphereGeometry(0.032, 8, 6);
            const snout = new THREE.Mesh(snoutGeo, bellyMat);
            snout.scale.set(1.1, 0.7, 1.2);
            snout.position.set(0, -0.005, 0.068);
            head.add(snout);

            // Nose
            const noseGeo = new THREE.SphereGeometry(0.010, 6, 5);
            const nose = new THREE.Mesh(noseGeo, noseMat);
            nose.position.set(0, 0.004, 0.030);
            snout.add(nose);

            // Eyes
            [-0.028, 0.028].forEach(side => {
                const eyeGeo = new THREE.SphereGeometry(0.013, 7, 6);
                const eye = new THREE.Mesh(eyeGeo, eyeMat);
                eye.position.set(side, 0.018, 0.058);
                head.add(eye);
                // Highlight glint
                const glintGeo = new THREE.SphereGeometry(0.005, 4, 4);
                const glint = new THREE.Mesh(glintGeo, eyeShine);
                glint.position.set(side * 0.25, 0.006, 0.010);
                eye.add(glint);
            });

            //  Ears 
            [-0.032, 0.032].forEach(side => {
                const earOuter = new THREE.ConeGeometry(0.020, 0.045, 5);
                const earMesh = new THREE.Mesh(earOuter, furMat);
                earMesh.position.set(side, 0.062, -0.005);
                earMesh.rotation.z = side > 0 ? -0.18 : 0.18;
                head.add(earMesh);
                // Pink inner ear
                const earIn = new THREE.ConeGeometry(0.011, 0.030, 5);
                const earInMesh = new THREE.Mesh(earIn, earInner);
                earInMesh.position.set(0, 0.003, 0.004);
                earMesh.add(earInMesh);
            });

            //  Legs 
            const legGeo = new THREE.CylinderGeometry(0.016, 0.013, 0.055, 5);
            const legPositions = [
                [ 0.055,  0.05],   // front-right
                [-0.055,  0.05],   // front-left
                [ 0.048, -0.06],   // back-right
                [-0.048, -0.06],   // back-left
            ];
            legPositions.forEach(([lx, lz]) => {
                const leg = new THREE.Mesh(legGeo, furMat);
                leg.position.set(lx, -0.072, lz);
                leg.castShadow = true;
                squirrelGroup.add(leg);
            });

            //  Fluffy Tail 
            // Built from a curved arc of overlapping spheres that get smaller toward the tip,
            // giving a natural feathered / bushy silhouette.
            const tailGroup = new THREE.Group();
            tailGroup.position.set(0, 0.04, -0.135);  // base at the squirrel's rump

            // Arc parameters  tail curves up and over the back
            const tailSegments = 9;
            for (let i = 0; i < tailSegments; i++) {
                const t       = i / (tailSegments - 1);          // 0  1
                const angle   = -0.25 + t * 1.85;                // arc from slightly behind to above
                const radius  = 0.17;                             // arc radius
                const px      = 0;
                const py      = Math.sin(angle) * radius;
                const pz      = -Math.cos(angle) * radius + radius; // offset so base starts at 0
                // Blob size: fattest in the middle, tapers at base and tip
                const blob = 0.038 + Math.sin(t * Math.PI) * 0.038;
                const mat  = t > 0.78 ? tailTipMat : tailMat;
                const seg  = new THREE.SphereGeometry(blob, 8, 7);
                const mesh = new THREE.Mesh(seg, mat);
                mesh.position.set(px, py, pz);
                mesh.castShadow = true;
                tailGroup.add(mesh);

                // Add two side puffs per segment to widen the tail into a fan shape
                if (i > 0 && i < tailSegments - 1) {
                    [-0.045, 0.045].forEach(sx => {
                        const puffR = blob * 0.78;
                        const puff  = new THREE.Mesh(new THREE.SphereGeometry(puffR, 7, 6), mat);
                        puff.position.set(sx, py + (Math.random()-0.5)*0.01, pz);
                        puff.castShadow = true;
                        tailGroup.add(puff);
                    });
                }
            }

            squirrelGroup.add(tailGroup);
            squirrelGroup.userData.tailGroup = tailGroup;

            //  Placement & metadata 
            squirrelGroup.position.set(x, 0.15, z);
            squirrelGroup.userData.health       = 20;
            squirrelGroup.userData.type         = 'squirrel';
            squirrelGroup.userData.velocity     = new THREE.Vector3(
                (Math.random() - 0.5) * 0.03, 0, (Math.random() - 0.5) * 0.03
            );
            squirrelGroup.userData.soundTimer   = Math.random() * 2;
            squirrelGroup.userData.animTime     = Math.random() * Math.PI * 2;

            window.squirrels.push(squirrelGroup);
            scene.add(squirrelGroup);
        }
        
        for (let i = 0; i < 10; i++) {
            const x = (Math.random() - 0.5) * 160;
            const z = (Math.random() - 0.5) * 160;
            if (Math.sqrt(x * x + z * z) > 20) {
                createSquirrel(x, z);
            }
        }
        
        // ===== MATERIAL HELPER FUNCTIONS =====
        // Create wood material with grain detail (CACHED VERSION)
        // In-memory material object cache  same params = same object = shader compiled once

        // ===== WOLF GLB MODEL + ANIMATION SYSTEM =====
        // Wolf.glb  use relative path since it's in the same repo as index.html
        // If this fails, check Wolf.glb is committed & pushed to the same GitHub repo
        const _WOLF_BASE = 'https://jam110uk.github.io/Crust-Sounds/Wolf.glb';
        const _WOLF_PROXY = null;
        let _WOLF_URL = _WOLF_BASE;
        console.log(' Game origin:', window.location.href);
        let _wolfTemplate   = null;
        let _wolfAnimClips  = {};
        let _wolfLoadPromise = null;
        const _wolfClock    = new THREE.Clock(); // for mixer delta

        function _loadWolfModel() {
            if (_wolfLoadPromise) return _wolfLoadPromise;
            _wolfLoadPromise = new Promise(resolve => {
                _glbLoadersReady().then(ok => {
                    if (!ok || typeof THREE.GLTFLoader === 'undefined') {
                        console.error(' GLTFLoader not available');
                        resolve([]);
                        return;
                    }
                    const _wolfFullURL = new URL(_WOLF_URL, window.location.href).href;
                    console.log(' Fetching Wolf.glb from:', _wolfFullURL);
                    fetch(_wolfFullURL)
                        .then(r => {
                            console.log(' Fetch status:', r.status, r.statusText);
                            if (!r.ok) throw new Error('HTTP ' + r.status);
                            return r.arrayBuffer();
                        })
                        .then(buffer => {
                            console.log(' Got buffer:', buffer.byteLength, 'bytes  parsing...');
                            _getGLTFLoader().parse(buffer, '',
                                function onLoad(gltf) {
                                    console.log(' Wolf.glb loaded successfully!');
                                    _wolfTemplate = gltf.scene;
                                    // template not added to scene, so no need to hide it

                                    // Measure raw size and store for use in _buildWolfInstance
                                    const box = new THREE.Box3().setFromObject(_wolfTemplate);
                                    const size = new THREE.Vector3();
                                    box.getSize(size);
                                    _wolfTemplate.userData._rawSize = size.clone();
                                    console.log(' Raw size:', size.x.toFixed(2), size.y.toFixed(2), size.z.toFixed(2));

                                    // Store animations
                                    gltf.animations.forEach(clip => {
                                        _wolfAnimClips[clip.name.toLowerCase()] = clip;
                                    });
                                    console.log(' Animations:', gltf.animations.length, Object.keys(_wolfAnimClips).join(', '));
                                    resolve(gltf.animations);
                                },
                                function onError(err) {
                                    console.error(' GLTFLoader.parse failed:', err);
                                    resolve([]);
                                }
                            );
                        })
                        .catch(err => {
                            console.error(' Fetch failed:', err.message);
                            resolve([]);
                        });
                });
            });
            return _wolfLoadPromise;
        }

        function _pickClip(keywords) {
            for (const kw of keywords) {
                for (const [k, v] of Object.entries(_wolfAnimClips)) {
                    if (k.includes(kw)) return v;
                }
            }
            const keys = Object.keys(_wolfAnimClips);
            return keys.length ? _wolfAnimClips[keys[0]] : null;
        }

        // Kick off load immediately
        _loadWolfModel();

        function _buildWolfInstance() {
            if (!_wolfTemplate) return null;

            // Three.js r128 clone() breaks SkinnedMesh bone refs.
            // Instead: clone the scene graph, then rebuild skeleton from scratch.
            const model = _wolfTemplate.clone(true);

            // Collect cloned bones by name
            const boneMap = {};
            model.traverse(c => { if (c.isBone) boneMap[c.name] = c; });

            model.traverse(c => {
                if (c.isSkinnedMesh) {
                    const origSkeleton = c.skeleton;
                    // Remap bones to cloned counterparts
                    const newBones = origSkeleton.bones.map(b => boneMap[b.name] || b);
                    const newSkeleton = new THREE.Skeleton(newBones, origSkeleton.boneInverses);
                    c.skeleton = newSkeleton;
                    // Bind using identity so bones drive the mesh from their own transforms
                    c.bindMatrix = new THREE.Matrix4();
                    c.bindMatrixInverse = new THREE.Matrix4();
                    newSkeleton.calculateInverses();
                    newSkeleton.pose();
                }
            });

            // Apply scale: raw size is 1.15 x 3.62 x 5.28  Y is height, scale to 0.85 units tall
            const rawSize = _wolfTemplate.userData._rawSize;
            if (rawSize) {
                const scale = rawSize.y > 0 ? 0.85 / rawSize.y : 0.161;
                model.scale.setScalar(scale);
            } else {
                model.scale.setScalar(0.161);
            }

            // Sink feet to ground after scaling
            model.updateMatrixWorld(true);
            const b = new THREE.Box3().setFromObject(model);
            model.position.y -= b.min.y;

            // Face forward
            model.rotation.y = 0;

            // Preserve the GLB's own materials  do NOT override with a flat colour.
            // Just make sure every mesh is visible, casts shadows, and has skinning enabled.
            model.traverse(c => {
                c.visible = true;
                if (c.isMesh || c.isSkinnedMesh) {
                    c.frustumCulled = false;
                    c.castShadow    = true;
                    // Keep original material; just ensure skinning flag is on if needed.
                    if (c.material) {
                        const mats = Array.isArray(c.material) ? c.material : [c.material];
                        mats.forEach(m => { if (typeof m.skinning !== 'undefined') m.skinning = true; });
                    }
                    if (c.isSkinnedMesh) {
                        c.pose();
                        console.log(" SkinnedMesh found:", c.name, "bones:", c.skeleton ? c.skeleton.bones.length : 0);
                    }
                }
            });

            const mixer = new THREE.AnimationMixer(model);
            const clips = {
                idle:   _pickClip(['idle']),
                walk:   _pickClip(['walk', 'sneak']),
                trot:   _pickClip(['trot', 'walk', 'sneak']),  // trot  walk if no trot clip
                run:    _pickClip(['run']),
                attack: _pickClip(['bite', 'attack']),
                howl:   _pickClip(['howl', 'bark']),
            };

            let _active = null;
            function playAnim(name, loop = true, timeScale = 1) {
                // Resolve the clip; fall back to walk, then idle
                let clip = clips[name];
                if (!clip) clip = clips['walk'];
                if (!clip) clip = clips['idle'];
                if (!clip) return;
                const next = mixer.clipAction(clip);
                next.setLoop(loop ? THREE.LoopRepeat : THREE.LoopOnce, Infinity);
                next.clampWhenFinished = !loop;
                next.timeScale = timeScale;
                if (_active !== next) {
                    // Switching animation  crossfade from old to new
                    if (_active) {
                        next.reset();
                        _active.crossFadeTo(next, 0.15, true);
                    }
                    next.play();
                    _active = next;
                } else {
                    // Same animation  make sure it hasn't stalled (e.g. after a LoopOnce finished)
                    if (!next.isRunning()) {
                        next.reset();
                        next.play();
                    }
                    next.timeScale = timeScale;
                }
            }

            return { model, mixer, playAnim };
        }


        const _coyFurMat    = new THREE.MeshPhongMaterial({ color: 0x9e7b4a, specular: 0x1a0d00, shininess: 14 });
        // Pale cream underbelly / muzzle
        const _coyBellyMat  = new THREE.MeshPhongMaterial({ color: 0xe8d4a8, specular: 0x110800, shininess: 8  });
        // Dark charcoal back saddle, leg tips, ear backs
        const _coyDarkMat   = new THREE.MeshPhongMaterial({ color: 0x3d2a10, specular: 0x110800, shininess: 10 });
        // Black nose / claws
        const _coyNoseMat   = new THREE.MeshPhongMaterial({ color: 0x100c08, shininess: 70 });
        // Glowing amber-yellow predator eyes
        const _coyEyeMat    = new THREE.MeshPhongMaterial({ color: 0xf0b000, emissive: 0xb06000, emissiveIntensity: 1.2, shininess: 180 });
        // Rusty-orange leg fur (coyote legs are often more orange)
        const _coyLegMat    = new THREE.MeshPhongMaterial({ color: 0xb5642a, specular: 0x1a0d00, shininess: 12 });
        // Pink inner ear
        const _coyEarInMat  = new THREE.MeshPhongMaterial({ color: 0xe88080, shininess: 6 });
        // Tail tip white
        const _coyTailTipMat= new THREE.MeshPhongMaterial({ color: 0xf0ead8, shininess: 6 });

        function createCoyote(x, z) {
            const g = new THREE.Group();

            function _attachWolf() {
                console.log(' _attachWolf called, _wolfTemplate:', !!_wolfTemplate);
                const inst = _buildWolfInstance();
                if (!inst) { console.warn(' _buildWolfInstance returned null'); return; }
                if (g.userData._fallbackMesh) {
                    g.remove(g.userData._fallbackMesh);
                    g.userData._fallbackMesh = null;
                }
                g.add(inst.model);
                g.userData.wolfModel    = inst.model;
                g.userData.wolfMixer    = inst.mixer;
                g.userData.wolfPlayAnim = inst.playAnim;
                inst.playAnim('idle');
                let meshCount = 0, skinnedCount = 0;
                inst.model.traverse(c => {
                    if (c.isSkinnedMesh) skinnedCount++;
                    else if (c.isMesh) meshCount++;
                });
                console.log(' Wolf attached | Mesh:', meshCount, 'SkinnedMesh:', skinnedCount, '| pos:', g.position.x.toFixed(1), g.position.z.toFixed(1));
            }

            if (_wolfTemplate) {
                _attachWolf();
            } else {
                _loadWolfModel().then(() => {
                    console.log(' .then fired, _wolfTemplate:', !!_wolfTemplate, 'g.parent:', !!g.parent);
                    if (g.parent) _attachWolf();
                });
            }

            g.userData.legs = [];
            g.position.set(x, 0, z);
            g.userData.type            = 'coyote';
            g.userData.health          = 60;
            g.userData.maxHealth       = 60;
            g.userData.damage          = 8;
            g.userData.state           = 'wander';
            g.userData.animTime        = Math.random() * Math.PI * 2;
            g.userData.wanderDir       = new THREE.Vector3((Math.random()-0.5), 0, (Math.random()-0.5)).normalize();
            g.userData.wanderTimer     = 0;
            g.userData.lastAttackTime  = 0;
            g.userData.howlTimer       = 0;
            g.userData.howlPlayed      = false;
            g.userData.backoffTimer    = 0;
            g.userData.circleAngle     = Math.random() * Math.PI * 2;
            g.userData.circleDir       = Math.random() < 0.5 ? 1 : -1;
            g.userData.circleTimer     = 0;
            g.userData.biteTimer       = 0;
            g.userData.growlPhase      = 'gap';
            g.userData.growlPhaseStart = Date.now() + Math.random() * 3000;
            g.userData.growlClip       = null;
            g.userData.stuckCheckTimer = 0;
            g.userData.stuckFrames     = 0;
            g.userData.stuckLastPos    = g.position.clone();
            g.userData.coyoteId        = Date.now() + Math.random();

            scene.add(g);
            coyotes.push(g);
            return g;
        }

        // Helper: try to move a coyote to newPos, checking buildings + other coyotes
        function _coyoteTryMove(cy, newPos) {
            const box = new THREE.Box3(
                new THREE.Vector3(newPos.x - 0.28, newPos.y - 0.35, newPos.z - 0.28),
                new THREE.Vector3(newPos.x + 0.28, newPos.y + 0.35, newPos.z + 0.28)
            );
            // Building collision
            for (const b of buildings) {
                if (b.userData.isDoor && b.userData.isOpen) continue;
                if (new THREE.Box3().setFromObject(b).intersectsBox(box)) return false;
            }
            // Inter-coyote separation  push apart if overlapping
            for (const other of coyotes) {
                if (other === cy) continue;
                const sep = newPos.distanceTo(other.position);
                if (sep < 0.80) return false; // personal space radius
            }
            return true;
        }

        //  Coyote spawning 
        function spawnCoyotes() {
            if (!isInDesert()) return;
            if (coyotes.length >= 4) return;
            if (Math.random() > 0.002) return;

            const angle = Math.random() * Math.PI * 2;
            const spawnDist = 20 + Math.random() * 30;
            const sx = camera.position.x + Math.cos(angle) * spawnDist;
            const sz = camera.position.z + Math.sin(angle) * spawnDist;
            if (sz > -80) return;
            createCoyote(sx, sz);
        }

        //  Coyote AI update 
        function _tickWolfMixer(cy) {
            if (!cy.userData.wolfMixer) return;
            const now = performance.now();
            if (!cy.userData._mixerLast) cy.userData._mixerLast = now;
            const dt = Math.min((now - cy.userData._mixerLast) / 1000, 0.1);
            cy.userData._mixerLast = now;
            cy.userData.wolfMixer.update(dt);
        }

        function updateCoyotes() {
            const now = Date.now();

            for (let i = coyotes.length - 1; i >= 0; i--) {
                const cy = coyotes[i];

                const flatDist = Math.sqrt(
                    (camera.position.x - cy.position.x) ** 2 +
                    (camera.position.z - cy.position.z) ** 2
                );
                const dist3d = camera.position.distanceTo(cy.position);

                //  Stuck check 
                cy.userData.stuckCheckTimer++;
                if (cy.userData.stuckCheckTimer >= 60) {
                    cy.userData.stuckCheckTimer = 0;
                    const moved = cy.position.distanceTo(cy.userData.stuckLastPos);
                    cy.userData.stuckFrames = moved < 0.05 ? cy.userData.stuckFrames + 1 : 0;
                    cy.userData.stuckLastPos = cy.position.clone();
                    if (cy.userData.stuckFrames >= 3) {
                        let freed = false;
                        for (let a = 0; a < 16 && !freed; a++) {
                            const ea  = Math.random() * Math.PI * 2;
                            const er  = 0.5 + a * 0.3;
                            const ep  = new THREE.Vector3(cy.position.x + Math.cos(ea)*er, cy.position.y, cy.position.z + Math.sin(ea)*er);
                            if (_coyoteTryMove(cy, ep)) {
                                cy.position.copy(ep);
                                cy.userData.wanderDir.set(Math.cos(ea), 0, Math.sin(ea));
                                freed = true;
                            }
                        }
                        cy.userData.stuckFrames = 0;
                    }
                }

                cy.userData.animTime += 0.10;
                const at = cy.userData.animTime;

                //  Tick animation mixer every frame regardless of state 
                _tickWolfMixer(cy);

                //  Direction to player (XZ only) 
                const toPlayerXZ = new THREE.Vector3(
                    camera.position.x - cy.position.x, 0,
                    camera.position.z - cy.position.z
                ).normalize();

                //  STATE MACHINE 

                if (cy.userData.state === 'wander') {
                    cy.userData.wanderTimer++;
                    if (cy.userData.wanderTimer > 180) {
                        cy.userData.wanderDir.set((Math.random()-0.5), 0, (Math.random()-0.5)).normalize();
                        cy.userData.wanderTimer = 0;
                    }
                    const wp = cy.position.clone().addScaledVector(cy.userData.wanderDir, 0.008);
                    wp.y = cy.position.y;
                    if (_coyoteTryMove(cy, wp)) {
                        cy.position.copy(wp);
                        const targetYaw = Math.atan2(cy.userData.wanderDir.x, cy.userData.wanderDir.z);
                        let diff = targetYaw - cy.rotation.y;
                        while (diff >  Math.PI) diff -= Math.PI * 2;
                        while (diff < -Math.PI) diff += Math.PI * 2;
                        cy.rotation.y += diff * 0.10;
                    } else {
                        cy.userData.wanderDir.set((Math.random()-0.5), 0, (Math.random()-0.5)).normalize();
                        cy.userData.wanderTimer = 0;
                    }

                    // Walk animation
                    if (cy.userData.wolfPlayAnim) cy.userData.wolfPlayAnim('walk', true, 0.8);
                    cy.position.y = 0;

                    // Spot player  howl
                    if (flatDist < 28) {
                        cy.userData.state     = 'howl';
                        cy.userData.howlTimer = 0;
                        cy.userData.howlPlayed = false;
                    }

                } else if (cy.userData.state === 'howl') {
                    cy.userData.howlTimer++;
                    // Face player and freeze
                    cy.rotation.y = Math.atan2(toPlayerXZ.x, toPlayerXZ.z);

                    if (!cy.userData.howlPlayed) {
                        playCoyoteHowl(flatDist);
                        cy.userData.howlPlayed = true;
                    }

                    // Head tilts up for howl
                    // Howl animation
                    if (cy.userData.wolfPlayAnim) cy.userData.wolfPlayAnim('howl', false, 1.0);

                    // ~2 seconds  charge
                    if (cy.userData.howlTimer > 120) {
                        cy.userData.state = 'chase';
                        // Start growl cycle immediately
                        cy.userData.growlPhase      = 'gap';
                        cy.userData.growlPhaseStart = now;
                    }

                } else if (cy.userData.state === 'chase') {
                    // Sprint hard at player
                    const speed = 0.060;
                    const np = cy.position.clone().addScaledVector(toPlayerXZ, speed);
                    np.y = cy.position.y;

                    if (_coyoteTryMove(cy, np)) {
                        cy.position.copy(np);
                        cy.rotation.y = Math.atan2(toPlayerXZ.x, toPlayerXZ.z);
                    } else {
                        // Slide around obstacle  try lateral offset
                        const right = new THREE.Vector3(-toPlayerXZ.z, 0, toPlayerXZ.x);
                        const slide = cy.position.clone().addScaledVector(right, speed);
                        slide.y = cy.position.y;
                        if (_coyoteTryMove(cy, slide)) {
                            cy.position.copy(slide);
                            // Face the slide direction so no sideways gliding
                            cy.rotation.y = Math.atan2(right.x, right.z);
                        }
                    }

                    // Gallop / attack animation
                    if (cy.userData.wolfPlayAnim) {
                        if (cy.userData.biteTimer > 0) {
                            cy.userData.biteTimer--;
                            cy.userData.wolfPlayAnim('attack', false, 1.4);
                        } else {
                            cy.userData.wolfPlayAnim('run', true, 1.2);
                        }
                    }
                    cy.position.y = 0;

                    // Growl sound cycle while chasing
                    tickCoyoteGrowl(cy, flatDist);

                    //  Bite attack 
                    if (flatDist < 1.5) {
                        if (now - cy.userData.lastAttackTime > 1200) {
                            cy.userData.lastAttackTime = now;
                            cy.userData.biteTimer = 28; // trigger jaw snap animation
                            health = Math.max(0, health - cy.userData.damage);
                            updateUI();
                            showMessage(' Coyote bites you! -8 HP');
                            if (health <= 0) die();

                            // Back off after biting
                            cy.userData.state       = 'backoff';
                            cy.userData.backoffTimer = 0;
                            // Back-off direction = away from player
                            cy.userData.backoffDir  = toPlayerXZ.clone().negate();
                        }
                    }

                } else if (cy.userData.state === 'backoff') {
                    cy.userData.backoffTimer++;

                    // Run backwards / away from player for ~0.7s
                    const bSpeed = 0.045;
                    const bp = cy.position.clone().addScaledVector(cy.userData.backoffDir, bSpeed);
                    bp.y = cy.position.y;
                    if (_coyoteTryMove(cy, bp)) cy.position.copy(bp);

                    // Face the direction of travel (away from player) so animation matches movement
                    cy.rotation.y = Math.atan2(cy.userData.backoffDir.x, cy.userData.backoffDir.z);

                    // Trot animation
                    if (cy.userData.wolfPlayAnim) cy.userData.wolfPlayAnim('trot', true, 1.0);

                    // Growl continues while backing off
                    tickCoyoteGrowl(cy, flatDist);

                    // Transition to circle
                    if (cy.userData.backoffTimer > 42) {
                        cy.userData.state       = 'circle';
                        cy.userData.circleTimer = 0;
                        // Lock circle radius at current distance
                        cy.userData.circleRadius = Math.max(2.5, flatDist);
                        cy.userData.circleAngle  = Math.atan2(
                            cy.position.z - camera.position.z,
                            cy.position.x - camera.position.x
                        );
                    }

                } else if (cy.userData.state === 'circle') {
                    cy.userData.circleTimer++;

                    // Orbit around player at circleRadius
                    cy.userData.circleAngle += cy.userData.circleDir * 0.018;
                    const r   = cy.userData.circleRadius;
                    const tx  = camera.position.x + Math.cos(cy.userData.circleAngle) * r;
                    const tz  = camera.position.z + Math.sin(cy.userData.circleAngle) * r;
                    const cp  = new THREE.Vector3(tx, cy.position.y, tz);

                    // Move toward that orbit point
                    const toOrbit = new THREE.Vector3().subVectors(cp, cy.position);
                    const toOrbitLen = toOrbit.length();
                    if (toOrbitLen > 0.01) {
                        toOrbit.normalize();
                        const circlePos = cy.position.clone().addScaledVector(toOrbit, Math.min(toOrbitLen, 0.035));
                        circlePos.y = cy.position.y;
                        if (_coyoteTryMove(cy, circlePos)) {
                            cy.position.copy(circlePos);
                            // Face the direction of travel so the walk animation matches movement
                            const targetYaw = Math.atan2(toOrbit.x, toOrbit.z);
                            // Smoothly interpolate rotation to avoid snapping
                            let diff = targetYaw - cy.rotation.y;
                            while (diff >  Math.PI) diff -= Math.PI * 2;
                            while (diff < -Math.PI) diff += Math.PI * 2;
                            cy.rotation.y += diff * 0.15;
                        }
                    }

                    // Circle trot animation
                    if (cy.userData.wolfPlayAnim) cy.userData.wolfPlayAnim('walk', true, 1.0);
                    cy.position.y = 0;

                    // Growl continues while circling
                    tickCoyoteGrowl(cy, flatDist);

                    // After circling 12 seconds, lunge again
                    if (cy.userData.circleTimer > 80 + Math.random() * 60) {
                        cy.userData.state = 'chase';
                        cy.userData.circleTimer = 0;
                    }
                }

                //  Despawn if too far or left desert 
                if (dist3d > 100 || !isInDesert()) {
                    // Stop this coyote's growl
                    if (cy.userData.growlClip) {
                        try { cy.userData.growlClip.pause(); cy.userData.growlClip.currentTime = 0; } catch(e){}
                        const idx = _activeCoyoteGrowlClips.indexOf(cy.userData.growlClip);
                        if (idx !== -1) _activeCoyoteGrowlClips.splice(idx, 1);
                    }
                    if (cy.userData.wolfMixer) cy.userData.wolfMixer.stopAllAction();
                    scene.remove(cy);
                    coyotes.splice(i, 1);
                }
            }
            // Each coyote tracks its own mixer delta in cy.userData._mixerLast
        }

        //  Initial coyote spawn 
        // Spawn one close to player for testing, rest in desert
        createCoyote(5, 5); // debug: close spawn
        for (let i = 0; i < 2; i++) {
            const angle = (i / 2) * Math.PI * 2;
            const dist  = 155 + Math.random() * 30;
            createCoyote(Math.cos(angle) * 25, -dist / 2);
        }

        function spawnEnemies() {
            const isNight = time >= 18 || time < 6;
            if (isNight && enemies.length < 10) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 30 + Math.random() * 20;
                const x = camera.position.x + Math.cos(angle) * distance;
                const z = camera.position.z + Math.sin(angle) * distance;
                createEnemy(x, z);
            }
        }
        
        // Initial enemy spawn
        for (let i = 0; i < 3; i++) {
            const angle = (i / 3) * Math.PI * 2;
            const distance = 40;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;
            createEnemy(x, z);
        }
        
        // ===== PARTICLE SYSTEM FOR FIRE AND SMOKE =====
        // Uses THREE.Points pools ? all fire in 1 draw call, all smoke in 1 draw call.
        const MAX_FIRE  = 80;
        const MAX_SMOKE = 60;

        // Internal particle state arrays (CPU side)
        const _firePx  = new Float32Array(MAX_FIRE);
        const _firePy  = new Float32Array(MAX_FIRE);
        const _firePz  = new Float32Array(MAX_FIRE);
        const _fireVx  = new Float32Array(MAX_FIRE);
        const _fireVy  = new Float32Array(MAX_FIRE);
        const _fireVz  = new Float32Array(MAX_FIRE);
        const _fireLife= new Float32Array(MAX_FIRE);  // 0 = dead
        const _fireMax = new Float32Array(MAX_FIRE);

        const _smokePx  = new Float32Array(MAX_SMOKE);
        const _smokePy  = new Float32Array(MAX_SMOKE);
        const _smokePz  = new Float32Array(MAX_SMOKE);
        const _smokeVx  = new Float32Array(MAX_SMOKE);
        const _smokeVy  = new Float32Array(MAX_SMOKE);
        const _smokeVz  = new Float32Array(MAX_SMOKE);
        const _smokeLife= new Float32Array(MAX_SMOKE);
        const _smokeMax = new Float32Array(MAX_SMOKE);

        // GPU geometry ? positions updated each frame
        const _firePosAttr  = new THREE.BufferAttribute(new Float32Array(MAX_FIRE  * 3), 3);
        const _smokePosAttr = new THREE.BufferAttribute(new Float32Array(MAX_SMOKE * 3), 3);
        _firePosAttr.setUsage(THREE.DynamicDrawUsage);
        _smokePosAttr.setUsage(THREE.DynamicDrawUsage);

        const _fireGeo = new THREE.BufferGeometry();
        _fireGeo.setAttribute('position', _firePosAttr);
        const _fireMat = new THREE.PointsMaterial({
            color: 0xff6600, size: 0.35, sizeAttenuation: true,
            transparent: true, opacity: 0.85,
            blending: THREE.AdditiveBlending, depthWrite: false,
        });
        const _firePoints = new THREE.Points(_fireGeo, _fireMat);
        _firePoints.frustumCulled = false;
        scene.add(_firePoints);

        const _smokeGeo = new THREE.BufferGeometry();
        _smokeGeo.setAttribute('position', _smokePosAttr);
        const _smokeMat = new THREE.PointsMaterial({
            color: 0x888888, size: 0.55, sizeAttenuation: true,
            transparent: true, opacity: 0.45, depthWrite: false,
        });
        const _smokePoints = new THREE.Points(_smokeGeo, _smokeMat);
        _smokePoints.frustumCulled = false;
        scene.add(_smokePoints);

        function createFireParticle(position) {
            // Find a dead slot
            for (let i = 0; i < MAX_FIRE; i++) {
                if (_fireLife[i] <= 0) {
                    _firePx[i] = position.x; _firePy[i] = position.y; _firePz[i] = position.z;
                    _fireVx[i] = (Math.random() - 0.5) * 0.01;
                    _fireVy[i] = 0.02 + Math.random() * 0.02;
                    _fireVz[i] = (Math.random() - 0.5) * 0.01;
                    _fireMax[i] = 0.5 + Math.random() * 0.5;
                    _fireLife[i] = _fireMax[i];
                    break;
                }
            }
        }

        function createSmokeParticle(position) {
            for (let i = 0; i < MAX_SMOKE; i++) {
                if (_smokeLife[i] <= 0) {
                    _smokePx[i] = position.x; _smokePy[i] = position.y; _smokePz[i] = position.z;
                    _smokeVx[i] = (Math.random() - 0.5) * 0.008;
                    _smokeVy[i] = 0.015 + Math.random() * 0.01;
                    _smokeVz[i] = (Math.random() - 0.5) * 0.008;
                    _smokeMax[i] = 2.0 + Math.random() * 1.5;
                    _smokeLife[i] = _smokeMax[i];
                    break;
                }
            }
        }

        // Scratch arrays kept outside updateParticles to avoid per-frame allocation
        const _fireParticles  = []; // legacy alias ? kept for any code that checks .length
        const fireParticles   = _fireParticles;
        const smokeParticles  = [];

        function updateParticles() {
            // ?? Fire ????????????????????????????????????????????????????????
            let fireVisible = 0;
            for (let i = 0; i < MAX_FIRE; i++) {
                if (_fireLife[i] <= 0) {
                    // Park dead particle off-screen so Points doesn't render a dot at origin
                    _firePosAttr.setXYZ(i, 0, -9999, 0);
                    continue;
                }
                _fireLife[i] -= 0.016;
                _firePx[i] += _fireVx[i];
                _firePy[i] += _fireVy[i];
                _firePz[i] += _fireVz[i];
                _firePosAttr.setXYZ(i, _firePx[i], _firePy[i], _firePz[i]);
                fireVisible++;
            }
            _firePosAttr.needsUpdate = true;
            // Colour shift: yellow?orange?red by average life (cheap, single material)
            const fireAvgLife = fireVisible > 0 ? _fireLife.reduce((a,b)=>a+b,0) / MAX_FIRE : 0;
            if      (fireAvgLife > 0.35) _fireMat.color.setHex(0xffdd00);
            else if (fireAvgLife > 0.15) _fireMat.color.setHex(0xff8800);
            else                         _fireMat.color.setHex(0xff3300);

            // ?? Smoke ???????????????????????????????????????????????????????
            for (let i = 0; i < MAX_SMOKE; i++) {
                if (_smokeLife[i] <= 0) {
                    _smokePosAttr.setXYZ(i, 0, -9999, 0);
                    continue;
                }
                _smokeLife[i] -= 0.008;
                _smokeVx[i] *= 0.99; _smokeVy[i] *= 0.99; _smokeVz[i] *= 0.99;
                _smokePx[i] += _smokeVx[i];
                _smokePy[i] += _smokeVy[i];
                _smokePz[i] += _smokeVz[i];
                _smokePosAttr.setXYZ(i, _smokePx[i], _smokePy[i], _smokePz[i]);
            }
            _smokePosAttr.needsUpdate = true;
            
            // Update muzzle flash particles (from gun shooting)
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                if (!particle.userData || particle.userData.life === undefined) {
                    // Remove invalid particles
                    scene.remove(particle);
                    particles.splice(i, 1);
                    continue;
                }
                
                particle.userData.life++;
                
                if (particle.userData.life >= particle.userData.maxLife) {
                    scene.remove(particle);
                    particles.splice(i, 1);
                } else {
                    // Update position with velocity
                    if (particle.userData.velocity) {
                        particle.position.add(particle.userData.velocity);
                        // Apply slight gravity/slowdown
                        particle.userData.velocity.multiplyScalar(0.96);
                        particle.userData.velocity.y -= 0.005;
                    }
                    
                    // Fade out and scale
                    const lifeRatio = particle.userData.life / particle.userData.maxLife;
                    particle.material.opacity = (1 - lifeRatio) * 0.9;
                    
                    if (particle.userData.startSize) {
                        const scale = particle.userData.startSize * (1 + lifeRatio * 0.5);
                        particle.scale.set(scale, scale, scale);
                    }
                }
            }
        }
        
        // ===== AUDIO (Keep original sounds) =====
        // audioContext already declared earlier
        
        function playHitSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.1);
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.1);
        }
        
        function playCollectSound() { /* replaced by specific MP3 sounds */ }
        
        function playAnimalSound(volume = 0.15) {
            // Play 2-3 chirps with random delays
            const numChirps = 2 + Math.floor(Math.random() * 2); // 2 or 3 chirps
            
            for (let i = 0; i < numChirps; i++) {
                const delay = i * (0.15 + Math.random() * 0.15); // 0.15-0.3 seconds between chirps
                
                setTimeout(() => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    const filter = audioContext.createBiquadFilter();
                    
                    oscillator.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    // Vary the pitch for each chirp
                    const basePitch = 160 + Math.random() * 40; // Random base pitch 160-200 Hz
                    const endPitch = basePitch - 20 - Math.random() * 20; // End 20-40 Hz lower
                    
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(basePitch, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(endPitch, audioContext.currentTime + 0.3);
                    
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(550 + Math.random() * 100, audioContext.currentTime); // Vary filter 550-650 Hz
                    
                    gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.3);
                }, delay * 1000);
            }
        }
        
        function playSquirrelSound(volume = 0.2) {
            // Play 2-3 chirps with random delays
            const numChirps = 2 + Math.floor(Math.random() * 2); // 2 or 3 chirps
            
            for (let i = 0; i < numChirps; i++) {
                const delay = i * (0.12 + Math.random() * 0.1); // 0.12-0.22 seconds between chirps (faster than animals)
                
                setTimeout(() => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    // Vary the pitch for each chirp
                    const basePitch = 1100 + Math.random() * 200; // Random base pitch 1100-1300 Hz
                    const midPitch = basePitch + 100 + Math.random() * 100; // Go up 100-200 Hz
                    
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(basePitch, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(midPitch, audioContext.currentTime + 0.05);
                    oscillator.frequency.exponentialRampToValueAtTime(basePitch, audioContext.currentTime + 0.1);
                    
                    gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.1);
                }, delay * 1000);
            }
        }
        
        function playEnemySound(volume = 0.3) {
            const now = audioContext.currentTime;
            const masterGain = audioContext.createGain();
            masterGain.connect(audioContext.destination);
            masterGain.gain.setValueAtTime(volume * 0.55, now);
            masterGain.gain.exponentialRampToValueAtTime(0.001, now + 1.8);

            // Layer 1: deep guttural sub-growl
            const sub = audioContext.createOscillator();
            const subGain = audioContext.createGain();
            const subFilter = audioContext.createBiquadFilter();
            sub.type = 'sawtooth';
            sub.frequency.setValueAtTime(38, now);
            sub.frequency.setValueAtTime(32, now + 0.3);
            sub.frequency.exponentialRampToValueAtTime(22, now + 1.8);
            subFilter.type = 'lowpass';
            subFilter.frequency.setValueAtTime(180, now);
            subFilter.Q.setValueAtTime(8, now);
            subGain.gain.setValueAtTime(1.0, now);
            sub.connect(subFilter); subFilter.connect(subGain); subGain.connect(masterGain);
            sub.start(now); sub.stop(now + 1.8);

            // Layer 2: raspy mid growl with tremolo
            const mid = audioContext.createOscillator();
            const midGain = audioContext.createGain();
            const midFilter = audioContext.createBiquadFilter();
            const tremolo = audioContext.createOscillator();
            const tremoloGain = audioContext.createGain();
            tremolo.type = 'sine';
            tremolo.frequency.setValueAtTime(7 + Math.random() * 4, now);
            tremoloGain.gain.setValueAtTime(0.4, now);
            tremolo.connect(tremoloGain);
            tremoloGain.connect(midGain.gain);
            mid.type = 'sawtooth';
            mid.frequency.setValueAtTime(65 + Math.random() * 15, now);
            mid.frequency.exponentialRampToValueAtTime(45, now + 1.4);
            midFilter.type = 'bandpass';
            midFilter.frequency.setValueAtTime(220, now);
            midFilter.Q.setValueAtTime(4, now);
            midGain.gain.setValueAtTime(0.7, now);
            mid.connect(midFilter); midFilter.connect(midGain); midGain.connect(masterGain);
            tremolo.start(now); tremolo.stop(now + 1.8);
            mid.start(now); mid.stop(now + 1.8);

            // Layer 3: high scratchy inhale-exhale breath
            const breath = audioContext.createOscillator();
            const breathGain = audioContext.createGain();
            const breathFilter = audioContext.createBiquadFilter();
            breath.type = 'square';
            breath.frequency.setValueAtTime(120, now);
            breath.frequency.setValueAtTime(180, now + 0.6);
            breath.frequency.exponentialRampToValueAtTime(90, now + 1.2);
            breathFilter.type = 'highpass';
            breathFilter.frequency.setValueAtTime(400, now);
            breathFilter.Q.setValueAtTime(2, now);
            breathGain.gain.setValueAtTime(0, now);
            breathGain.gain.linearRampToValueAtTime(0.3, now + 0.4);
            breathGain.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
            breath.connect(breathFilter); breathFilter.connect(breathGain); breathGain.connect(masterGain);
            breath.start(now); breath.stop(now + 1.8);
        }
        
        // Preload enemy attack sound
        let _enemyAttackAudio = null;

        function playEnemyAttackSound(volume) {
            const attackVolume = (volume !== undefined) ? volume : (volumeSettings.enemies * 0.9);
            const clip = _enemyAttackAudio.cloneNode();
            clip.volume = Math.min(1, Math.max(0, attackVolume));
            clip.play().catch(e => { console.error('playEnemyAttackSound error:', e); });
        }

        // Preload scorpion attack sound
        let _scorpionAttackAudio = new Audio('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/scorp.mp3');
        _scorpionAttackAudio.preload = 'auto';

        function playScorpionAttackSound() {
            if (!_scorpionAttackAudio) return;
            const clip = _scorpionAttackAudio.cloneNode();
            clip.volume = Math.min(1, Math.max(0, volumeSettings.enemies * 0.85));
            clip.play().catch(e => { console.error('playScorpionAttackSound error:', e); });
        }
        
        // Mechanical recycler sound
        let recyclerSound = null;
        let recyclerGainNode = null;

        let _recyclerBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/recycler.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _recyclerBuffer = buf; console.log('Recycler sound loaded OK'); })
            .catch(e => { console.error('Recycler sound fetch error:', e); });

        // Proximity audio constants for recycler
        const RECYCLER_AUDIO_MAX_DIST = 20;
        const RECYCLER_AUDIO_MIN_DIST = 3;
        const RECYCLER_AUDIO_MAX_VOL = 0.7;

        function startRecyclerSound() {
            if (recyclerSound) return;
            if (!_recyclerBuffer) return;
            recyclerGainNode = audioContext.createGain();
            recyclerGainNode.gain.setValueAtTime(0.0, audioContext.currentTime);
            recyclerGainNode.connect(audioContext.destination);
            recyclerSound = audioContext.createBufferSource();
            recyclerSound.buffer = _recyclerBuffer;
            recyclerSound.loop = true;
            recyclerSound.connect(recyclerGainNode);
            recyclerSound.start();
        }

        function updateRecyclerProximityAudio() {
            if (!recyclerSound || !recyclerGainNode) return;
            if (!currentRecycler) {
                recyclerGainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                return;
            }
            const rPos = currentRecycler.position;
            const cPos = camera.position;
            const dx = rPos.x - cPos.x;
            const dz = rPos.z - cPos.z;
            const dist = Math.sqrt(dx * dx + dz * dz);
            let vol;
            if (dist <= RECYCLER_AUDIO_MIN_DIST) {
                vol = RECYCLER_AUDIO_MAX_VOL;
            } else if (dist >= RECYCLER_AUDIO_MAX_DIST) {
                vol = 0.0;
            } else {
                const t = (dist - RECYCLER_AUDIO_MIN_DIST) / (RECYCLER_AUDIO_MAX_DIST - RECYCLER_AUDIO_MIN_DIST);
                vol = RECYCLER_AUDIO_MAX_VOL * (1 - t);
            }
            recyclerGainNode.gain.setValueAtTime(vol, audioContext.currentTime);
        }

        function stopRecyclerSound() {
            if (recyclerSound) {
                recyclerGainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                setTimeout(() => {
                    if (recyclerSound) { try { recyclerSound.stop(); } catch(e){} recyclerSound = null; }
                    recyclerGainNode = null;
                }, 400);
            }
        }
        
        // Fire/burning sounds for campfire and furnace
        let fireSound = null;
        let fireGainNode = null;
        let furnaceSound = null;
        let furnaceGainNode = null;

        // Preload campfire sound
        let _campfireBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/campfire.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _campfireBuffer = buf; console.log('Campfire sound loaded OK'); })
            .catch(e => { console.error('Campfire sound fetch error:', e); });

        // Preload furnace sound
        let _furnaceBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/furnace.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _furnaceBuffer = buf; console.log('Furnace sound loaded OK'); })
            .catch(e => { console.error('Furnace sound fetch error:', e); });

        function startFireSound() {
            if (fireSound) return;
            if (!_campfireBuffer) return;
            fireGainNode = audioContext.createGain();
            fireGainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
            fireGainNode.connect(audioContext.destination);
            fireSound = audioContext.createBufferSource();
            fireSound.buffer = _campfireBuffer;
            fireSound.loop = true;
            fireSound.connect(fireGainNode);
            fireSound.start();
        }

        function stopFireSound() {
            if (fireSound) {
                fireGainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                setTimeout(() => {
                    if (fireSound) { try { fireSound.stop(); } catch(e){} fireSound = null; }
                    fireGainNode = null;
                }, 600);
            }
        }

        function startFurnaceSound() {
            if (furnaceSound) return;
            if (!_furnaceBuffer) return;
            furnaceGainNode = audioContext.createGain();
            furnaceGainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
            furnaceGainNode.connect(audioContext.destination);
            furnaceSound = audioContext.createBufferSource();
            furnaceSound.buffer = _furnaceBuffer;
            furnaceSound.loop = true;
            furnaceSound.connect(furnaceGainNode);
            furnaceSound.start();
        }

        function stopFurnaceSound() {
            if (furnaceSound) {
                furnaceGainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                setTimeout(() => {
                    if (furnaceSound) { try { furnaceSound.stop(); } catch(e){} furnaceSound = null; }
                    furnaceGainNode = null;
                }, 600);
            }
        }
        
        // ===== CRAFTING SYSTEM =====
        // ? IMPORTANT FOR DEVELOPERS: When adding new items to any recipe system (craftingRecipes, 
        // workbenchRecipes, buildingBenchRecipes, furnaceRecipes, or buildingTypes), make sure to:
        // 1. Add an icon to the itemIcons object above (search for "const itemIcons")
        // 2. OR use registerItem('item_name', '\u2753', 'Category') to register it programmatically
        // 3. The admin menu will automatically include all items from all recipe systems
        // 4. Run validateAllItemsHaveIcons() in console to check for missing icons
        const craftingRecipes = {
            axe: {
                name: '\ud83e\ude93 Wooden Axe',
                cost: { wood: 3, stone: 2 },
                type: 'tool'
            },
            pickaxe: {
                name: '\u26cf\ufe0f Stone Pickaxe',
                cost: { wood: 2, stone: 4 },
                type: 'tool'
            },
            sword: {
                name: '\u2694\ufe0f Stone Sword',
                cost: { wood: 2, stone: 3 },
                type: 'weapon'
            },
            spear: {
                name: '\ud83d\udde1\ufe0f Wooden Spear',
                cost: { wood: 4, fiber: 2 },
                type: 'weapon'
            },
            building_hammer: {
                name: '\ud83d\udd28 Building Hammer',
                cost: { wood: 3, stone: 2 },
                type: 'tool'
            },
            sleeping_bag: {
                name: '\ud83d\udecf\ufe0f Sleeping Bag',
                cost: { fiber: 10, wood: 2 },
                type: 'building'
            },
            workbench: {
                name: '\ud83d\udd27 Workbench',
                cost: { wood: 10, stone: 5 },
                type: 'crafting_station'
            },
            furnace: {
                name: '\ud83d\udd25 Furnace',
                cost: { wood: 5, stone: 15 },
                type: 'crafting_station'
            },
            storage_box: {
                name: '\ud83d\udce6 Large Storage',
                cost: { wood: 8, stone: 2 },
                type: 'building'
            },
        };
        
        // Workbench recipes (accessed via workbench)
        const workbenchRecipes = {
            bow: {
                name: '\ud83c\udff9 Wooden Bow',
                cost: { wood: 5, fiber: 3 },
                type: 'weapon'
            },
            arrows: {
                name: '\ud83c\udff9 Arrows (x5)',
                cost: { wood: 2, stone: 1 },
                count: 5,
                type: 'ammo'
            },
            pistol: {
                name: '\ud83d\udd2b Pistol',
                cost: { iron_ingot: 20 },
                type: 'weapon'
            },
            pistol_ammo: {
                name: '\ud83d\udd2b Pistol Ammo (x8)',
                cost: { iron_ingot: 2, gunpowder: 1 },
                count: 8,
                type: 'ammo'
            },
            bandage: {
                name: '\ud83e\ude79 Bandage',
                cost: { fiber: 3 },
                type: 'consumable'
            },
            medkit: {
                name: '\ud83c\udfe5 Medkit',
                cost: { bandage: 2, fiber: 6 },
                type: 'consumable'
            },
            code_lock: {
                name: '\ud83d\udd12 Code Lock',
                cost: { iron_ingot: 8 },
                type: 'tool'
            },
            gunpowder: {
                name: '\ud83d\udca5 Gunpowder (x10)',
                cost: { coal: 1, smelted_sulfur: 1 },
                count: 10,
                type: 'material'
            },
            building_bench: {
                name: '\ud83e\ude9a Building Bench',
                cost: { wood: 8, stone: 6 },
                type: 'tool'
            },
            sewing_table: {
                name: '\ud83e\uddf5 Sewing Table',
                cost: { wood: 8, iron_ingot: 3 },
                type: 'tool'
            },
            recycler: {
                name: '\u267b\ufe0f Recycler',
                cost: { iron_ingot: 15, wood: 5 },
                type: 'tool'
            }
        };
        
        // Sewing Table recipes (accessed via sewing table)
        const sewingTableRecipes = {
            cloth: {
                name: '\ud83e\uddf5 Cloth',
                cost: { fiber: 5 },
                type: 'material'
            },
            curtain_red: {
                name: '\ud83d\udd34 Red Curtain',
                cost: { cloth: 2 },
                type: 'decoration'
            },
            curtain_blue: {
                name: '\ud83d\udd35 Blue Curtain',
                cost: { cloth: 2 },
                type: 'decoration'
            },
            curtain_green: {
                name: '\ud83d\udfe2 Green Curtain',
                cost: { cloth: 2 },
                type: 'decoration'
            },
            curtain_white: {
                name: '\u2b1c White Curtain',
                cost: { cloth: 2 },
                type: 'decoration'
            },
            curtain_beige: {
                name: '\ud83d\udfe4 Beige Curtain',
                cost: { cloth: 2 },
                type: 'decoration'
            },
            floor_rug_red: {
                name: '\ud83d\udfe5 Red Floor Rug',
                cost: { fiber: 8 },
                type: 'decoration'
            },
            floor_rug_blue: {
                name: '\ud83d\udfe6 Blue Floor Rug',
                cost: { fiber: 8 },
                type: 'decoration'
            },
            floor_rug_green: {
                name: '\ud83d\udfe9 Green Floor Rug',
                cost: { fiber: 8 },
                type: 'decoration'
            },
            // Bronze Armor (Early Game - 2% reduction per piece)
            bronze_helmet: {
                name: '\u26d1\ufe0f Bronze Helmet',
                cost: { stone: 8, iron_ore: 3 },
                type: 'armor'
            },
            bronze_vest: {
                name: '\ud83e\uddba Bronze Vest',
                cost: { stone: 12, iron_ore: 5 },
                type: 'armor'
            },
            bronze_gloves: {
                name: '\ud83e\udde4 Bronze Gloves',
                cost: { stone: 6, iron_ore: 2 },
                type: 'armor'
            },
            bronze_pants: {
                name: '\ud83d\udc56 Bronze Pants',
                cost: { stone: 10, iron_ore: 4 },
                type: 'armor'
            },
            bronze_boots: {
                name: '\ud83d\udc62 Bronze Boots',
                cost: { stone: 8, iron_ore: 3 },
                type: 'armor'
            },
            // Iron Armor (Mid Game - 5% reduction per piece)
            iron_helmet: {
                name: '\u26d1\ufe0f Iron Helmet',
                cost: { iron_ingot: 10 },
                type: 'armor'
            },
            iron_vest: {
                name: '\ud83e\uddba Iron Vest',
                cost: { iron_ingot: 15 },
                type: 'armor'
            },
            iron_gloves: {
                name: '\ud83e\udde4 Iron Gloves',
                cost: { iron_ingot: 8 },
                type: 'armor'
            },
            iron_pants: {
                name: '\ud83d\udc56 Iron Pants',
                cost: { iron_ingot: 12 },
                type: 'armor'
            },
            iron_boots: {
                name: '\ud83d\udc62 Iron Boots',
                cost: { iron_ingot: 10 },
                type: 'armor'
            }
        };
        
        // Recycle recipes - items return 50% of their materials
        const recycleRecipes = {
            // Tools
            'axe': { wood: 2, stone: 1 },
            'pickaxe': { wood: 1, stone: 2 },
            'sword': { wood: 1, stone: 2 },
            'spear': { wood: 2, fiber: 1 },
            'bow': { wood: 3, fiber: 2 },
            'building_hammer': { wood: 2, stone: 1 },
            
            // Buildings
            'wall': { wood: 3 },
            'floor': { wood: 2 },
            'ceiling': { wood: 2 },
            'door': { wood: 3, fiber: 1 },
            'campfire': { wood: 3, stone: 2 },
            'cooking_station': { stone: 6, iron_ingot: 2, wood: 3 },
            'workbench': { wood: 5, stone: 3 },
            'building_bench': { wood: 4, stone: 3 },
            'furnace': { wood: 3, stone: 8 },
            'storage_box': { wood: 4, stone: 1 },
            'small_storage_box': { wood: 2, stone: 1 },
            'storage_shelf': { iron_ingot: 2 },
            'wall_shelf': { wood: 6, iron_ingot: 2 },
            'sewing_table': { wood: 4, iron_ingot: 2 },
            
            // Consumables/Materials
            'arrows': { wood: 1 },
            'pistol': { iron_ingot: 10 },
            'pistol_ammo': { iron_ingot: 1 },
            'cloth': { fiber: 3 },
            'bandage': { fiber: 2 },
            'medkit': { fiber: 3 },
            'code_lock': { iron_ingot: 4 },
            
            // Armor (50% return)
            'iron_helmet': { iron_ingot: 5 },
            'iron_vest': { iron_ingot: 8 },
            'iron_gloves': { iron_ingot: 4 },
            'iron_pants': { iron_ingot: 6 },
            'iron_boots': { iron_ingot: 5 },
            'bronze_helmet': { stone: 4, iron_ore: 2 },
            'bronze_vest': { stone: 6, iron_ore: 3 },
            'bronze_gloves': { stone: 3, iron_ore: 1 },
            'bronze_pants': { stone: 5, iron_ore: 2 },
            'bronze_boots': { stone: 4, iron_ore: 2 },
            
            // Decorations
            'curtain_red': { cloth: 1 },
            'curtain_blue': { cloth: 1 },
            'curtain_green': { cloth: 1 },
            'curtain_white': { cloth: 1 },
            'curtain_beige': { cloth: 1 },
            'floor_rug_red': { fiber: 4 },
            'floor_rug_blue': { fiber: 4 },
            'floor_rug_green': { fiber: 4 }
        };
        
        // Recycler state
        const recyclerState = {
            inputSlots: [null, null, null, null, null],
            outputSlots: [null, null, null, null, null],
            isProcessing: false,
            currentSlot: 0,
            progress: 0,
            processTime: 3000,
            isPaused: false,        // Track if we're in pause between items
            pauseTime: 500,         // 0.5 second pause between items in same slot
            pauseProgress: 0        // Track pause progress
        };
        
        // Well State  persists progress across rain sessions
        const waterCatcherState = {
            outputSlots: [null, null, null, null, null], // up to 5 water bottles waiting to be collected
            progress: 0,         // 0-100 fill progress for current bottle (real-time ms)
            fillTime: 120000,    // 2 real minutes per bottle (120,000 ms)
            isOpen: false        // whether UI is open
        };
        
        // Building Bench recipes
        const buildingBenchRecipes = {
            wall: {
                name: '\ud83e\uddf1 Wooden Wall',
                cost: { wood: 5 },
                type: 'building_piece'
            },
            window_wall: {
                name: '\ud83e\ude9f Window Wall',
                cost: { wood: 5, stone: 2 },
                type: 'building_piece'
            },
            floor: {
                name: '\ud83d\udfeb Wooden Floor',
                cost: { wood: 4 },
                type: 'building_piece'
            },
            ceiling: {
                name: '\ud83d\udfeb Wooden Ceiling',
                cost: { wood: 4 },
                type: 'building_piece'
            },
            ladder_ceiling: {
                name: '\ud83e\ude9c Ladder Ceiling',
                cost: { wood: 3 },
                type: 'building_piece'
            },
            stairs: {
                name: '\ud83e\ude9c Wooden Stairs',
                cost: { wood: 8, stone: 2 },
                type: 'building_piece'
            },
            corner_stairs_left: {
                name: '\ud83e\ude9c Corner Stairs (Left)',
                cost: { wood: 10, stone: 3 },
                type: 'building_piece'
            },
            corner_stairs_right: {
                name: '\ud83e\ude9c Corner Stairs (Right)',
                cost: { wood: 10, stone: 3 },
                type: 'building_piece'
            },
            ladder: {
                name: '\ud83e\ude9c Ladder',
                cost: { wood: 4 },
                type: 'building_piece'
            },
            door_frame: {
                name: '\ud83d\udeaa Door Frame',
                cost: { wood: 4 },
                type: 'building_piece'
            },
            single_door_wall: {
                name: '\ud83d\udeaa Wall with Single Door',
                cost: { wood: 8, fiber: 2 },
                type: 'building_piece'
            },
            double_door_wall: {
                name: '\ud83d\udeaa Wall with Double Doors',
                cost: { wood: 10, fiber: 3 },
                type: 'building_piece'
            },
            double_door_frame: {
                name: '\ud83d\udeaa Double Door Frame',
                cost: { wood: 5 },
                type: 'building_piece'
            },
            door: {
                name: '\ud83d\udeaa Wooden Door',
                cost: { wood: 6, fiber: 2 },
                type: 'building_piece'
            },
            campfire: {
                name: '\ud83d\udd25 Campfire',
                cost: { wood: 5, stone: 3 },
                type: 'building_piece'
            },
            cooking_station: {
                name: '\ud83c\udf73 Cooking Station',
                cost: { stone: 12, iron_ingot: 4, wood: 6 },
                type: 'building_piece'
            },
            small_storage_box: {
                name: '\ud83d\udce6 Small Storage',
                cost: { wood: 4, stone: 1 },
                type: 'building_piece'
            },
            storage_shelf: {
                name: '\ud83d\udce6 Storage Shelf',
                cost: { iron_ingot: 4 },
                type: 'building_piece'
            },
            planter_box: {
                name: '\ud83c\udf31 Planter Box (4 Slot)',
                cost: { wood: 12, stone: 4 },
                type: 'building_piece'
            },
            large_planter: {
                name: '\ud83c\udf31 Large Planter (12 Slot)',
                cost: { wood: 28, stone: 10 },
                type: 'building_piece'
            },
            water_catcher: {
                name: ' Well',
                cost: { wood: 8, stone: 4, fiber: 6 },
                type: 'building_piece'
            }
        };
        
        // Furnace recipes
        const furnaceRecipes = {
            iron_ingot: {
                name: '\ud83d\udd29 Iron Ingot',
                cost: { iron_ore: 2 },
                type: 'material'
            }
        };
        
        function updateCraftingMenu() {
            const list = document.getElementById('crafting-list');
            list.innerHTML = '';
            
            // Group recipes by category
            const categories = {
                'Tools': [],
                'Weapons': [],
                'Materials': [],
                'Consumables': []
            };
            
            for (let id in craftingRecipes) {
                const recipe = craftingRecipes[id];
                if (!recipe.type) recipe.type = 'materials';
                
                const categoryName = recipe.type === 'tool' ? 'Tools' :
                                    recipe.type === 'weapon' ? 'Weapons' :
                                    recipe.type === 'consumable' ? 'Consumables' : 'Materials';
                
                categories[categoryName].push({ id, recipe });
            }
            
            // Create grid for each category
            for (let categoryName in categories) {
                if (categories[categoryName].length === 0) continue;
                
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'menu-category';
                
                const titleDiv = document.createElement('div');
                titleDiv.className = 'category-title';
                titleDiv.textContent = categoryName;
                categoryDiv.appendChild(titleDiv);
                
                const gridDiv = document.createElement('div');
                gridDiv.className = 'category-grid';
                
                categories[categoryName].forEach(({ id, recipe }) => {
                    const canCraft = Object.entries(recipe.cost).every(
                        ([resource, amount]) => inventory[resource] >= amount
                    );
                    
                    const item = document.createElement('div');
                    item.className = 'grid-item' + (canCraft ? '' : ' disabled');
                    
                    const icon = itemIcons[id] || '\u2753';
                    const costText = Object.entries(recipe.cost)
                        .map(([r, a]) => `${a} ${r}`)
                        .join(', ');
                    
                    item.innerHTML = `
                        <div class="grid-item-icon">${icon}</div>
                        <div class="grid-item-name">${recipe.name.replace(/^[^\s]+\s/, '')}</div>
                        <div class="grid-item-cost">${costText}</div>
                    `;
                    
                    if (canCraft) {
                        item.onclick = () => craftItem(id, recipe);
                    }
                    
                    gridDiv.appendChild(item);
                });
                
                categoryDiv.appendChild(gridDiv);
                list.appendChild(categoryDiv);
            }
        }
        
        function craftItem(id, recipe) {
            for (let resource in recipe.cost) {
                inventory[resource] -= recipe.cost[resource];
            }
            
            // Add crafted item to inventory
            if (!inventory[id]) inventory[id] = 0;
            inventory[id]++;
            
            showMessage(`\u2705 Crafted ${recipe.name}!`);
            playCollectSound();
            updateUI();
            updateCraftingMenu();
        }
        
        // Workbench Menu
        let currentWorkbench = null;
        
        function openWorkbenchMenu(workbench) {
            currentWorkbench = workbench;
            playBenchSound();
            document.getElementById('workbench-menu').style.display = 'block';
            document.getElementById('workbench-menu').querySelector('.menu-title').textContent = '\ud83d\udd27 Workbench';
            uiOpen();
            updateWorkbenchMenu();
        }
        
        function closeWorkbenchMenu() {
            closeAllUI();
        }
        
        function updateWorkbenchMenu() {
            const list = document.getElementById('workbench-list');
            list.innerHTML = '';
            
            // Group recipes by category
            const categories = {
                'Weapons': [],
                'Tools': []
            };
            
            for (let id in workbenchRecipes) {
                const recipe = workbenchRecipes[id];
                const categoryName = recipe.type === 'tool' ? 'Tools' : 'Weapons';
                categories[categoryName].push({ id, recipe });
            }
            
            // Create grid for each category
            for (let categoryName in categories) {
                if (categories[categoryName].length === 0) continue;
                
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'menu-category';
                
                const titleDiv = document.createElement('div');
                titleDiv.className = 'category-title';
                titleDiv.textContent = categoryName;
                categoryDiv.appendChild(titleDiv);
                
                const gridDiv = document.createElement('div');
                gridDiv.className = 'category-grid';
                
                categories[categoryName].forEach(({ id, recipe }) => {
                    const canCraft = Object.entries(recipe.cost).every(
                        ([resource, amount]) => inventory[resource] >= amount
                    );
                    
                    const item = document.createElement('div');
                    item.className = 'grid-item' + (canCraft ? '' : ' disabled');
                    
                    const icon = itemIcons[id] || '\u2753';
                    const costText = Object.entries(recipe.cost)
                        .map(([r, a]) => `${a} ${r}`)
                        .join(', ');
                    
                    item.innerHTML = `
                        <div class="grid-item-icon">${icon}</div>
                        <div class="grid-item-name">${recipe.name.replace(/^[^\s]+\s/, '')}</div>
                        <div class="grid-item-cost">${costText}</div>
                    `;
                    
                    if (canCraft) {
                        item.onclick = () => craftWorkbenchItem(id, recipe);
                    }
                    
                    gridDiv.appendChild(item);
                });
                
                categoryDiv.appendChild(gridDiv);
                list.appendChild(categoryDiv);
            }
        }
        
        function craftWorkbenchItem(id, recipe) {
            for (let resource in recipe.cost) {
                inventory[resource] -= recipe.cost[resource];
            }
            
            if (!inventory[id]) inventory[id] = 0;
            inventory[id] += recipe.count || 1;
            
            showMessage(`\u2705 Crafted ${recipe.name}!`);
            playCollectSound();
            updateUI();
            updateWorkbenchMenu();
        }
        
        // Building Bench Menu
        let currentBuildingBench = null;
        
        function openBuildingBenchMenu(bench) {
            currentBuildingBench = bench;
            playBenchSound();
            document.getElementById('workbench-menu').style.display = 'block';
            document.getElementById('workbench-menu').querySelector('.menu-title').textContent = '\ud83e\ude9a Building Bench';
            uiOpen();
            updateBuildingBenchMenu();
        }
        
        function closeBuildingBenchMenu() {
            closeAllUI();
        }
        
        function updateBuildingBenchMenu() {
            const list = document.getElementById('workbench-list');
            list.innerHTML = '';
            
            // Group recipes by category
            const categories = {
                'Structure': [],
                'Doors & Windows': [],
                'Crafting Stations': [],
                'Storage': [],
                'Decorations': []
            };
            
            for (let id in buildingBenchRecipes) {
                const recipe = buildingBenchRecipes[id];
                
                let categoryName = 'Structure';
                if (recipe.type === 'crafting_station') categoryName = 'Crafting Stations';
                else if (recipe.type === 'storage') categoryName = 'Storage';
                else if (recipe.type === 'decoration') categoryName = 'Decorations';
                else if (id.includes('door') || id.includes('window')) categoryName = 'Doors & Windows';
                
                categories[categoryName].push({ id, recipe });
            }
            
            // Create grid for each category
            for (let categoryName in categories) {
                if (categories[categoryName].length === 0) continue;
                
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'menu-category';
                
                const titleDiv = document.createElement('div');
                titleDiv.className = 'category-title';
                titleDiv.textContent = categoryName;
                categoryDiv.appendChild(titleDiv);
                
                const gridDiv = document.createElement('div');
                gridDiv.className = 'category-grid';
                
                categories[categoryName].forEach(({ id, recipe }) => {
                    const canCraft = Object.entries(recipe.cost).every(
                        ([resource, amount]) => inventory[resource] >= amount
                    );
                    
                    const item = document.createElement('div');
                    item.className = 'grid-item' + (canCraft ? '' : ' disabled');
                    
                    const icon = itemIcons[id] || '\u2753';
                    const costText = Object.entries(recipe.cost)
                        .map(([r, a]) => `${a} ${r}`)
                        .join(', ');
                    
                    item.innerHTML = `
                        <div class="grid-item-icon">${icon}</div>
                        <div class="grid-item-name">${recipe.name.replace(/^[^\s]+\s/, '')}</div>
                        <div class="grid-item-cost">${costText}</div>
                    `;
                    
                    if (canCraft) {
                        item.onclick = () => craftBuildingItem(id, recipe);
                    }
                    
                    gridDiv.appendChild(item);
                });
                
                categoryDiv.appendChild(gridDiv);
                list.appendChild(categoryDiv);
            }
        }
        
        function craftBuildingItem(id, recipe) {
            for (let resource in recipe.cost) {
                inventory[resource] -= recipe.cost[resource];
            }
            
            if (!inventory[id]) inventory[id] = 0;
            inventory[id]++;
            
            showMessage(`\u2705 Crafted ${recipe.name}!`);
            playCollectSound();
            updateUI();
            updateBuildingBenchMenu();
        }
        
        // Sewing Table Menu
        let currentSewingTable = null;
        
        function openSewingTableMenu(table) {
            currentSewingTable = table;
            playBenchSound();
            document.getElementById('workbench-menu').style.display = 'block';
            document.getElementById('workbench-menu').querySelector('.menu-title').textContent = '\ud83e\uddf5 Sewing Table';
            uiOpen();
            updateSewingTableMenu();
        }
        
        function closeSewingTableMenu() {
            closeAllUI();
        }

        // Smart dispatcher  close whichever bench/table menu is currently open
        function closeAnyWorkbenchMenu() {
            closeAllUI();
        }
        
        function updateSewingTableMenu() {
            const list = document.getElementById('workbench-list');
            list.innerHTML = '';
            
            // Group recipes by category
            const categories = {
                'Materials': [],
                'Curtains': [],
                'Rugs': []
            };
            
            for (let id in sewingTableRecipes) {
                const recipe = sewingTableRecipes[id];
                
                let categoryName = 'Materials';
                if (id.includes('curtain')) categoryName = 'Curtains';
                else if (id.includes('rug')) categoryName = 'Rugs';
                
                categories[categoryName].push({ id, recipe });
            }
            
            // Create grid for each category
            for (let categoryName in categories) {
                if (categories[categoryName].length === 0) continue;
                
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'menu-category';
                
                const titleDiv = document.createElement('div');
                titleDiv.className = 'category-title';
                titleDiv.textContent = categoryName;
                categoryDiv.appendChild(titleDiv);
                
                const gridDiv = document.createElement('div');
                gridDiv.className = 'category-grid';
                
                categories[categoryName].forEach(({ id, recipe }) => {
                    const canCraft = Object.entries(recipe.cost).every(
                        ([resource, amount]) => inventory[resource] >= amount
                    );
                    
                    const item = document.createElement('div');
                    item.className = 'grid-item' + (canCraft ? '' : ' disabled');
                    
                    const icon = itemIcons[id] || '\u2753';
                    const costText = Object.entries(recipe.cost)
                        .map(([r, a]) => `${a} ${r}`)
                        .join(', ');
                    
                    item.innerHTML = `
                        <div class="grid-item-icon">${icon}</div>
                        <div class="grid-item-name">${recipe.name.replace(/^[^\s]+\s/, '')}</div>
                        <div class="grid-item-cost">${costText}</div>
                    `;
                    
                    if (canCraft) {
                        item.onclick = () => craftSewingItem(id, recipe);
                    }
                    
                    gridDiv.appendChild(item);
                });
                
                categoryDiv.appendChild(gridDiv);
                list.appendChild(categoryDiv);
            }
        }
        
        function craftSewingItem(id, recipe) {
            for (let resource in recipe.cost) {
                inventory[resource] -= recipe.cost[resource];
            }
            
            if (!inventory[id]) inventory[id] = 0;
            inventory[id] += recipe.count || 1;
            
            showMessage(`\u2705 Crafted ${recipe.name}!`);
            playCollectSound();
            updateUI();
            updateSewingTableMenu();
        }
        
        // ===== RECYCLER SYSTEM =====
        let currentRecycler = null;
        
        function openRecyclerMenu(recycler) {
            currentRecycler = recycler;
            playBenchSound();
            const recyclerMenu = document.getElementById('recycler-menu');
            const inventoryPanel = document.getElementById('inventory-panel');
            
            // Position recycler on the left
            recyclerMenu.style.display = 'block';
            recyclerMenu.style.left = '28%';
            recyclerMenu.style.transform = 'translate(-50%, -50%)';
            
            positionInventoryRight(inventoryPanel);
            inventoryPanel.style.display = 'block';
            uiOpen();
            updateInventoryDisplay();
            updateRecyclerDisplay();
        }
        
        function closeRecyclerMenu() {
            closeAllUI();
        }
        
        // ===== WATER CATCHER UI =====
        let currentWaterCatcher = null;
        
        function openWaterCatcherMenu(wc) {
            currentWaterCatcher = wc;
            waterCatcherState.isOpen = true;
            playBenchSound();
            const wcMenu = document.getElementById('water-catcher-menu');
            const inventoryPanel = document.getElementById('inventory-panel');
            wcMenu.style.display = 'block';
            positionInventoryRight(inventoryPanel);
            inventoryPanel.style.display = 'block';
            uiOpen();
            updateInventoryDisplay();
            updateWaterCatcherDisplay();
        }
        
        function closeWaterCatcherMenu() {
            closeAllUI();
        }
        
        function updateWaterCatcherDisplay() {
            const pct = Math.min(100, (waterCatcherState.progress / waterCatcherState.fillTime) * 100);
            const fillEl = document.getElementById('wc-progress-fill');
            const textEl = document.getElementById('wc-progress-text');
            const statusEl = document.getElementById('wc-rain-status');
            if (!fillEl) return;
            fillEl.style.width = pct.toFixed(1) + '%';
            if (isRaining) {
                const secsLeft = Math.ceil((waterCatcherState.fillTime - waterCatcherState.progress) / 1000);
                textEl.textContent = pct >= 100 ? 'Bottle ready!' : `Filling... ${secsLeft}s remaining`;
                statusEl.className = 'wc-rain-status wc-rain-active';
                statusEl.textContent = ' Raining  collecting water!';
            } else {
                const secsLeft = Math.ceil((waterCatcherState.fillTime - waterCatcherState.progress) / 1000);
                const remaining = Math.max(0, secsLeft);
                textEl.textContent = waterCatcherState.progress > 0
                    ? `Paused at ${pct.toFixed(0)}%  resumes when rain returns (${remaining}s left)`
                    : 'Waiting for rain...';
                statusEl.className = 'wc-rain-status wc-rain-inactive';
                statusEl.textContent = ' Not raining  waiting...';
            }
            // Update output slots
            for (let i = 0; i < 5; i++) {
                const slot = document.querySelector(`.wc-slot[data-wc-slot="${i}"]`);
                if (!slot) continue;
                const slotData = waterCatcherState.outputSlots[i];
                if (slotData) {
                    slot.classList.add('filled');
                    slot.innerHTML = `<span class="wc-slot-icon"></span><span class="wc-slot-count">${slotData.count}</span>`;
                } else {
                    slot.classList.remove('filled');
                    slot.innerHTML = '';
                }
            }
        }
        
        // Called every frame from animate()  progresses filling only when raining
        function updateWaterCatcher(deltaMs) {
            // Only run if a well has actually been placed in the world
            const wellExists = buildings.some(b => b.userData.isWaterCatcher);
            if (!wellExists) return;

            if (!isRaining) {
                if (waterCatcherState.isOpen) updateWaterCatcherDisplay();
                return;
            }
            // Check if there's space in output
            const totalOut = waterCatcherState.outputSlots.reduce((s, sl) => s + (sl ? sl.count : 0), 0);
            if (totalOut >= 25) return; // max 5 slots * 5 bottles  don't overfill
            
            waterCatcherState.progress += deltaMs;
            
            if (waterCatcherState.progress >= waterCatcherState.fillTime) {
                // Produce one water bottle
                waterCatcherState.progress = 0;
                let added = false;
                for (let i = 0; i < 5; i++) {
                    if (!waterCatcherState.outputSlots[i]) {
                        waterCatcherState.outputSlots[i] = { item: 'water_bottle', count: 1 };
                        added = true;
                        break;
                    } else if (waterCatcherState.outputSlots[i].item === 'water_bottle' && waterCatcherState.outputSlots[i].count < 5) {
                        waterCatcherState.outputSlots[i].count++;
                        added = true;
                        break;
                    }
                }
                if (added) showMessage(' Water bottle ready in the Well!');
            }
            if (waterCatcherState.isOpen) updateWaterCatcherDisplay();
        }
        
        function updateRecyclerDisplay() {
            // Update input slots
            for (let i = 0; i < 5; i++) {
                const slotDiv = document.querySelector(`.recycler-slot[data-slot="input"][data-index="${i}"]`);
                const slotData = recyclerState.inputSlots[i];
                
                if (slotData) {
                    slotDiv.classList.add('filled');
                    slotDiv.innerHTML = `
                        <span class="recycler-slot-icon">${itemIcons[slotData.item] || '\u2753'}</span>
                        <span class="recycler-slot-count">${slotData.count}</span>
                    `;
                } else {
                    slotDiv.classList.remove('filled');
                    slotDiv.innerHTML = '';
                }
            }
            
            // Update output slots
            for (let i = 0; i < 5; i++) {
                const slotDiv = document.querySelector(`.recycler-slot[data-slot="output"][data-index="${i}"]`);
                const slotData = recyclerState.outputSlots[i];
                
                if (slotData) {
                    slotDiv.classList.add('filled');
                    slotDiv.innerHTML = `
                        <span class="recycler-slot-icon">${itemIcons[slotData.item] || '\u2753'}</span>
                        <span class="recycler-slot-count">${slotData.count}</span>
                    `;
                } else {
                    slotDiv.classList.remove('filled');
                    slotDiv.innerHTML = '';
                }
            }
            
            // Update progress bar
            const progressBar = document.getElementById('recycler-progress');
            const progressText = document.getElementById('recycler-progress-text');
            progressBar.style.width = recyclerState.progress + '%';
            progressText.textContent = Math.floor(recyclerState.progress) + '%';
            
            // Update start button
            const startBtn = document.getElementById('recycler-start-btn');
            if (recyclerState.isProcessing) {
                startBtn.textContent = '\u2699\ufe0f PROCESSING...';
                startBtn.disabled = true;
            } else {
                const hasInput = recyclerState.inputSlots.some(slot => slot !== null);
                startBtn.textContent = '\u267b\ufe0f START RECYCLING';
                startBtn.disabled = !hasInput;
            }
        }
        
        function addToRecyclerSlot(slotType, slotIndex, itemName = null) {
            if (slotType === 'input') {
                // If no item specified, do nothing (will be called from inventory double-click)
                if (!itemName) return;
                
                // Check if item exists in inventory
                if (!inventory[itemName] || inventory[itemName] === 0) {
                    showMessage('\u274c Item not found in inventory!');
                    return;
                }
                
                // Check if item can be recycled
                if (!recycleRecipes[itemName]) {
                    showMessage('\u274c This item cannot be recycled!');
                    return;
                }
                
                // Add 1 item by default (can be modified to prompt for amount later)
                const count = 1;
                
                // Remove from inventory
                inventory[itemName] -= count;
                
                // Add to recycler input slot
                if (recyclerState.inputSlots[slotIndex]) {
                    // Slot occupied, try to stack
                    if (recyclerState.inputSlots[slotIndex].item === itemName) {
                        recyclerState.inputSlots[slotIndex].count += count;
                    } else {
                        showMessage('\u26a0\ufe0f Slot already occupied!');
                        inventory[itemName] += count; // Return to inventory
                        return;
                    }
                } else {
                    recyclerState.inputSlots[slotIndex] = { item: itemName, count };
                }
                
                showMessage(`\u267b\ufe0f Added ${itemName} to recycler`);
                updateUI();
                updateRecyclerDisplay();
                updateInventoryDisplay();
                
            } else if (slotType === 'output') {
                // Take from recycler output to inventory
                const slotData = recyclerState.outputSlots[slotIndex];
                if (!slotData) return;
                
                // Add to inventory
                if (!inventory[slotData.item]) inventory[slotData.item] = 0;
                inventory[slotData.item] += slotData.count;
                
                // Clear output slot
                recyclerState.outputSlots[slotIndex] = null;
                
                updateUI();
                updateRecyclerDisplay();
                updateInventoryDisplay();
                playCollectSound();
            }
        }
        
        // Function to add item from inventory to next available recycler slot
        function addItemToRecycler(itemName) {
            if (!currentRecycler) return;
            
            // Check if item can be recycled
            if (!recycleRecipes[itemName]) {
                showMessage('\u274c This item cannot be recycled!');
                return;
            }
            
            // Find first empty slot
            let emptySlotIndex = -1;
            for (let i = 0; i < 5; i++) {
                if (!recyclerState.inputSlots[i]) {
                    emptySlotIndex = i;
                    break;
                }
                // Or if same item, can stack
                if (recyclerState.inputSlots[i].item === itemName) {
                    emptySlotIndex = i;
                    break;
                }
            }
            
            if (emptySlotIndex === -1) {
                showMessage('\u26a0\ufe0f All recycler slots are full!');
                return;
            }
            
            // Add to that slot
            addToRecyclerSlot('input', emptySlotIndex, itemName);
        }
        
        function startRecycling() {
            if (recyclerState.isProcessing) return;
            
            const hasInput = recyclerState.inputSlots.some(slot => slot !== null);
            if (!hasInput) {
                showMessage('\u26a0\ufe0f No items to recycle!');
                return;
            }
            
            recyclerState.isProcessing = true;
            recyclerState.currentSlot = 0;
            recyclerState.progress = 0;
            recyclerState.isPaused = false;
            recyclerState.pauseProgress = 0;
            
            // Find first non-empty slot
            while (recyclerState.currentSlot < 5 && !recyclerState.inputSlots[recyclerState.currentSlot]) {
                recyclerState.currentSlot++;
            }
            
            updateRecyclerDisplay();
            
            // Turn on green light on recycler
            if (currentRecycler && currentRecycler.userData.statusLight) {
                currentRecycler.userData.statusLight.visible = true;
            }
            
            // Start mechanical sound
            startRecyclerSound();
            
            showMessage('\u267b\ufe0f Recycling started!');
        }
        
        function updateRecycling(deltaTime) {
            if (!recyclerState.isProcessing) return;
            
            // Update recycler sound volume based on player proximity
            updateRecyclerProximityAudio();
            
            // Animate recycler if it exists in the scene
            if (currentRecycler) {
                // Rotate drum
                if (currentRecycler.userData.drum) {
                    currentRecycler.userData.drum.rotation.x += deltaTime * 0.002;
                }
                // Vibrate hopper
                if (currentRecycler.userData.hopper) {
                    currentRecycler.userData.hopper.position.y = 0.95 + Math.sin(Date.now() * 0.01) * 0.02;
                }
            }
            
            // Handle pause between items in same slot
            if (recyclerState.isPaused) {
                recyclerState.pauseProgress += deltaTime;
                if (recyclerState.pauseProgress >= recyclerState.pauseTime) {
                    // Pause complete, continue processing same slot
                    recyclerState.isPaused = false;
                    recyclerState.pauseProgress = 0;
                    recyclerState.progress = 0;
                }
                return;
            }
            
            // Increment progress
            const progressIncrement = (deltaTime / recyclerState.processTime) * 100;
            recyclerState.progress += progressIncrement;
            
            if (recyclerState.progress >= 100) {
                // Process current item
                const inputSlot = recyclerState.inputSlots[recyclerState.currentSlot];
                if (inputSlot) {
                    const recipe = recycleRecipes[inputSlot.item];
                    if (recipe) {
                        // Calculate 50% return
                        const materials = {};
                        for (let mat in recipe) {
                            materials[mat] = recipe[mat];
                        }
                        
                        // Try to add materials to output slots
                        let allAdded = true;
                        for (let mat in materials) {
                            let amountToAdd = materials[mat];
                            let added = false;
                            
                            // Try to find existing slot with this material
                            for (let i = 0; i < 5; i++) {
                                if (recyclerState.outputSlots[i] && recyclerState.outputSlots[i].item === mat) {
                                    recyclerState.outputSlots[i].count += amountToAdd;
                                    added = true;
                                    break;
                                }
                            }
                            
                            // If not found, try to find empty slot
                            if (!added) {
                                for (let i = 0; i < 5; i++) {
                                    if (!recyclerState.outputSlots[i]) {
                                        recyclerState.outputSlots[i] = { item: mat, count: amountToAdd };
                                        added = true;
                                        break;
                                    }
                                }
                            }
                            
                            if (!added) {
                                allAdded = false;
                                showMessage('\u26a0\ufe0f Output slots full! Recycling stopped.');
                                break;
                            }
                        }
                        
                        if (allAdded) {
                            // Remove one item from input
                            inputSlot.count--;
                            if (inputSlot.count <= 0) {
                                // Slot is empty, move to next slot
                                recyclerState.inputSlots[recyclerState.currentSlot] = null;
                                recyclerState.progress = 0;
                                
                                // Move to next slot
                                recyclerState.currentSlot++;
                                while (recyclerState.currentSlot < 5 && !recyclerState.inputSlots[recyclerState.currentSlot]) {
                                    recyclerState.currentSlot++;
                                }
                                
                                // If no more items, stop
                                if (recyclerState.currentSlot >= 5) {
                                    recyclerState.isProcessing = false;
                                    recyclerState.progress = 0;
                                    
                                    // Turn off green light
                                    if (currentRecycler && currentRecycler.userData.statusLight) {
                                        currentRecycler.userData.statusLight.visible = false;
                                    }
                                    
                                    // Stop mechanical sound
                                    stopRecyclerSound();
                                    
                                    showMessage('\u267b\ufe0f Recycling complete!');
                                }
                            } else {
                                // More items in same slot, enter pause state
                                recyclerState.isPaused = true;
                                recyclerState.pauseProgress = 0;
                                recyclerState.progress = 0;
                            }
                        } else {
                            // Couldn't add all materials, stop processing
                            recyclerState.isProcessing = false;
                            recyclerState.progress = 0;
                            
                            // Turn off green light
                            if (currentRecycler && currentRecycler.userData.statusLight) {
                                currentRecycler.userData.statusLight.visible = false;
                            }
                            
                            // Stop mechanical sound
                            stopRecyclerSound();
                        }
                    }
                }
                
                updateRecyclerDisplay();
            }
        }
        
        // ===== FURNACE AND CAMPFIRE SMELTING SYSTEM =====
        let currentFurnace = null;
        let currentCampfire = null;
        
        // Helper function to create individual smelting state for each station
        function createSmeltingState(processTime) {
            return {
                // Multi-slot input for furnace (3 slots); campfire only uses slot 0
                inputSlots: [null, null, null], // each: {item, count} or null
                // Legacy single-slot properties kept for campfire compatibility
                inputItem: null,
                inputCount: 0,
                fuelItem: null,
                fuelCount: 0,
                // Furnace uses outputSlots[0] (iron ingot) and outputSlots[1] (smelted sulfur)
                // Campfire uses outputItem/outputCount
                outputSlots: [{ item: 'iron_ingot', count: 0 }, { item: 'smelted_sulfur', count: 0 }],
                outputItem: null,
                outputCount: 0,
                wasteCount: 0,
                progress: 0,
                isProcessing: false,
                processTime: processTime,
                currentInputSlot: 0  // which slot is currently being smelted (furnace only)
            };
        }
        
        function openFurnaceMenu(furnace) {
            currentFurnace = furnace;
            playFurnaceInteractSound();
            const furnaceMenu = document.getElementById('furnace-menu');
            const inventoryPanel = document.getElementById('inventory-panel');
            
            // Position furnace on the left, inventory on the right (like recycler)
            furnaceMenu.style.display = 'block';
            furnaceMenu.style.left = '30%';
            furnaceMenu.style.transform = 'translate(-50%, -50%)';
            
            positionInventoryRight(inventoryPanel);
            inventoryPanel.style.display = 'block';
            uiOpen();
            updateInventoryDisplay();
            updateSmeltingDisplay('furnace');
        }
        
        function closeFurnaceMenu() {
            closeAllUI();
        }
        
        function openCampfireMenu(campfire) {
            currentCampfire = campfire;
            playFurnaceInteractSound();
            const campfireMenu = document.getElementById('campfire-menu');
            const inventoryPanel = document.getElementById('inventory-panel');
            
            // Position campfire on the left, inventory on the right
            campfireMenu.style.display = 'block';
            campfireMenu.style.left = '30%';
            campfireMenu.style.transform = 'translate(-50%, -50%)';
            
            positionInventoryRight(inventoryPanel);
            inventoryPanel.style.display = 'block';
            uiOpen();
            updateInventoryDisplay();
            updateSmeltingDisplay('campfire');
        }
        
        function closeCampfireMenu() {
            closeAllUI();
        }
        
        function updateSmeltingDisplay(type) {
            const building = type === 'furnace' ? currentFurnace : currentCampfire;
            if (!building || !building.userData.smeltingState) return;
            
            const state = building.userData.smeltingState;
            const prefix = type;
            
            if (type === 'furnace') {
                // Multi-slot input display
                for (let i = 0; i < 3; i++) {
                    const slotEl = document.getElementById(`furnace-input-slot-${i}`);
                    if (!slotEl) continue;
                    const slotData = state.inputSlots[i];
                    slotEl.classList.toggle('active-smelt', state.isProcessing && i === state.currentInputSlot && slotData);
                    if (slotData && slotData.count > 0) {
                        const icon = itemIcons[slotData.item] || '\u2753';
                        slotEl.innerHTML = `${icon}<div class="smelting-slot-count">${slotData.count}</div>`;
                    } else {
                        slotEl.innerHTML = '+';
                    }
                }
                // Active slot label
                const lbl = document.getElementById('furnace-active-label');
                if (lbl) {
                    if (state.isProcessing) {
                        const activeSlot = state.inputSlots[state.currentInputSlot];
                        lbl.textContent = activeSlot ? `Smelting: ${activeSlot.item.replace(/_/g,' ')}` : '';
                    } else {
                        lbl.textContent = '';
                    }
                }
            } else {
                // Campfire single input slot
                const inputSlot = document.getElementById(`${prefix}-input-slot`);
                if (state.inputItem && state.inputCount > 0) {
                    const icon = itemIcons[state.inputItem] || '\u2753';
                    inputSlot.innerHTML = `${icon}<div class="smelting-slot-count">${state.inputCount}</div>`;
                } else {
                    inputSlot.innerHTML = '+';
                }
            }
            
            // Fuel slot
            const fuelSlot = document.getElementById(`${prefix}-fuel-slot`);
            if (state.fuelItem && state.fuelCount > 0) {
                const icon = itemIcons[state.fuelItem] || '\u2753';
                fuelSlot.innerHTML = `${icon}<div class="smelting-slot-count">${state.fuelCount}</div>`;
                fuelSlot.draggable = true;
                fuelSlot.dataset.itemName = state.fuelItem;
                fuelSlot.dataset.slotType = prefix + '-fuel';
                fuelSlot.dataset.slotIndex = '0';
            } else {
                fuelSlot.innerHTML = '+';
                fuelSlot.draggable = false;
                delete fuelSlot.dataset.itemName;
                fuelSlot.dataset.slotType = prefix + '-fuel';
                fuelSlot.dataset.slotIndex = '0';
            }
            
            // Output slot(s)
            if (type === 'furnace') {
                // Two output slots for furnace
                for (let oi = 0; oi < 2; oi++) {
                    const outEl = document.getElementById(`furnace-output-slot-${oi}`);
                    if (!outEl) continue;
                    const outData = state.outputSlots && state.outputSlots[oi];
                    if (outData && outData.count > 0) {
                        const icon = itemIcons[outData.item] || '\u2753';
                        outEl.innerHTML = `${icon}<div class="smelting-slot-count">${outData.count}</div>`;
                    } else {
                        outEl.innerHTML = '';
                    }
                }
            } else {
                const outputSlot = document.getElementById(`${prefix}-output-slot`);
                if (state.outputCount > 0) {
                    const icon = itemIcons[state.outputItem] || '\u2753';
                    outputSlot.innerHTML = `${icon}<div class="smelting-slot-count">${state.outputCount}</div>`;
                } else {
                    outputSlot.innerHTML = '';
                }
            }
            
            // Waste slot
            const wasteSlot = document.getElementById(`${prefix}-waste-slot`);
            const wasteItem = type === 'furnace' ? 'coal' : 'ash';
            if (state.wasteCount > 0) {
                const icon = itemIcons[wasteItem] || '\u2753';
                wasteSlot.innerHTML = `${icon}<div class="smelting-slot-count">${state.wasteCount}</div>`;
            } else {
                wasteSlot.innerHTML = '';
            }
            
            // Progress bar
            const progressFill = document.getElementById(`${prefix}-progress`);
            const progressText = document.getElementById(`${prefix}-progress-text`);
            const percentage = Math.floor(state.progress);
            progressFill.style.width = percentage + '%';
            progressText.textContent = percentage + '%';
        }
        
        // Valid items per station type
        const FURNACE_VALID_ORES = ['iron_ore', 'sulfur_ore'];
        const CAMPFIRE_VALID_FOODS = ['meat', 'mushroom'];

        function addToSmeltingSlot(type, slotType, slotIndex = null, dragItemName = null) {
            const building = type === 'furnace' ? currentFurnace : currentCampfire;
            if (!building || !building.userData.smeltingState) return;
            
            const state = building.userData.smeltingState;
            
            if (slotType === 'input') {
                if (type === 'furnace') {
                    // Multi-slot furnace input
                    if (dragItemName !== null) {
                        // Drag path: specific item, specific slot index
                        const targetSlotIdx = (slotIndex !== null) ? slotIndex : null;
                        if (targetSlotIdx === null) return;
                        if (!FURNACE_VALID_ORES.includes(dragItemName)) {
                            showMessage('\u26a0\ufe0f Only ores can be placed in the furnace!');
                            return;
                        }
                        if (inventory[dragItemName] <= 0) return;
                        const slotData = state.inputSlots[targetSlotIdx];
                        if (slotData && slotData.item !== dragItemName) {
                            showMessage('\u26a0\ufe0f That slot already contains a different ore!');
                            return;
                        }
                        // Move all of dragged item into this slot
                        const amount = inventory[dragItemName];
                        if (!slotData) {
                            state.inputSlots[targetSlotIdx] = { item: dragItemName, count: amount };
                        } else {
                            slotData.count += amount;
                        }
                        inventory[dragItemName] = 0;
                        updateUI();
                        updateSmeltingDisplay('furnace');
                    } else {
                        // Click path: pick first valid ore from inventory and put in first empty/matching slot
                        for (let ore of FURNACE_VALID_ORES) {
                            if (inventory[ore] > 0) {
                                // Find a slot that has this ore, or first empty slot
                                let placed = false;
                                for (let i = 0; i < 3; i++) {
                                    const sd = state.inputSlots[i];
                                    if (sd && sd.item === ore) {
                                        sd.count++;
                                        inventory[ore]--;
                                        placed = true;
                                        break;
                                    }
                                }
                                if (!placed) {
                                    for (let i = 0; i < 3; i++) {
                                        if (!state.inputSlots[i]) {
                                            state.inputSlots[i] = { item: ore, count: 1 };
                                            inventory[ore]--;
                                            placed = true;
                                            break;
                                        }
                                    }
                                }
                                if (placed) {
                                    updateUI();
                                    updateSmeltingDisplay('furnace');
                                    return;
                                }
                            }
                        }
                        showMessage('\u26a0\ufe0f No ores in inventory!');
                    }
                } else {
                    // Campfire single input
                    if (dragItemName !== null) {
                        if (!CAMPFIRE_VALID_FOODS.includes(dragItemName)) {
                            showMessage('\u26a0\ufe0f Only food items can be placed in the campfire!');
                            return;
                        }
                        if (inventory[dragItemName] <= 0) return;
                        if (state.inputItem && state.inputItem !== dragItemName) {
                            showMessage('\u26a0\ufe0f Remove existing food first!');
                            return;
                        }
                        const amount = inventory[dragItemName];
                        if (!state.inputItem) state.inputItem = dragItemName;
                        state.inputCount += amount;
                        inventory[dragItemName] = 0;
                        updateUI();
                        updateSmeltingDisplay('campfire');
                    } else {
                        // Click path
                        for (let food of CAMPFIRE_VALID_FOODS) {
                            if (inventory[food] > 0) {
                                if (!state.inputItem) state.inputItem = food;
                                if (state.inputItem === food) {
                                    inventory[food]--;
                                    state.inputCount++;
                                    updateUI();
                                    updateSmeltingDisplay('campfire');
                                    return;
                                }
                            }
                        }
                        showMessage('\u26a0\ufe0f No valid food in inventory!');
                    }
                }
            } else if (slotType === 'fuel') {
                // Add fuel
                if (inventory.wood > 0) {
                    if (!state.fuelItem) state.fuelItem = 'wood';
                    inventory.wood--;
                    state.fuelCount++;
                } else if (inventory.sticks > 0) {
                    if (!state.fuelItem) state.fuelItem = 'sticks';
                    inventory.sticks--;
                    state.fuelCount++;
                } else {
                    showMessage('\u26a0\ufe0f No fuel available!');
                    return;
                }
                updateUI();
                updateSmeltingDisplay(type);
            } else if (slotType === 'output') {
                // Take output - furnace uses outputSlots[slotIndex], campfire uses outputCount
                if (type === 'furnace') {
                    const idx = slotIndex !== null ? slotIndex : 0;
                    if (state.outputSlots && state.outputSlots[idx] && state.outputSlots[idx].count > 0) {
                        const outItem = state.outputSlots[idx].item;
                        if (!inventory[outItem]) inventory[outItem] = 0;
                        inventory[outItem] += state.outputSlots[idx].count;
                        state.outputSlots[idx].count = 0;
                        updateUI();
                        updateSmeltingDisplay(type);
                        playCollectSound();
                    }
                } else {
                    if (state.outputCount > 0) {
                        if (!inventory[state.outputItem]) inventory[state.outputItem] = 0;
                        inventory[state.outputItem] += state.outputCount;
                        state.outputCount = 0;
                        updateUI();
                        updateSmeltingDisplay(type);
                        playCollectSound();
                    }
                }
            } else if (slotType === 'waste') {
                // Take waste
                if (state.wasteCount > 0) {
                    const wasteItem = type === 'furnace' ? 'coal' : 'ash';
                    if (!inventory[wasteItem]) inventory[wasteItem] = 0;
                    inventory[wasteItem] += state.wasteCount;
                    state.wasteCount = 0;
                    updateUI();
                    updateSmeltingDisplay(type);
                    playCollectSound();
                }
            }
        }
        
        function updateSmelting() {
            // Update particles and sounds for all active campfires and furnaces
            let anyCampfireActive = false;
            let anyFurnaceActive = false;
            
            buildings.forEach(building => {
                if (building.userData.isCampfire && building.userData.smeltingState) {
                    // Update this campfire's smelting process
                    updateSmeltingProcess(building, 'campfire');
                    
                    if (building.userData.smeltingState.isProcessing) {
                        anyCampfireActive = true;
                        
                        // Turn on fire light
                        if (building.userData.fireLight) {
                            building.userData.fireLight.intensity = 3;
                        }
                        
                        // Show fire glow
                        if (building.userData.fireGlow) {
                            building.userData.fireGlow.visible = true;
                            // Flicker effect
                            building.userData.fireGlow.material.opacity = 0.6 + Math.random() * 0.2;
                            building.userData.fireGlow.scale.y = 0.9 + Math.random() * 0.2;
                        }
                        
                        // Spawn fire particles
                        building.userData.particleTimer = (building.userData.particleTimer || 0) + 1;
                        if (building.userData.particleTimer >= 3) {
                            building.userData.particleTimer = 0;
                            const pos = building.position.clone();
                            pos.y += 0.3;
                            createFireParticle(pos);
                        }
                        
                        // Spawn smoke particles
                        building.userData.smokeTimer = (building.userData.smokeTimer || 0) + 1;
                        if (building.userData.smokeTimer >= 8) {
                            building.userData.smokeTimer = 0;
                            const pos = building.position.clone();
                            pos.y += 0.6;
                            createSmokeParticle(pos);
                        }
                    } else {
                        // Turn off fire light when not active
                        if (building.userData.fireLight) {
                            building.userData.fireLight.intensity = 0;
                        }
                        
                        // Hide fire glow when not active
                        if (building.userData.fireGlow) {
                            building.userData.fireGlow.visible = false;
                        }
                    }
                }
                
                if (building.userData.isFurnace && building.userData.smeltingState) {
                    // Update this furnace's smelting process
                    updateSmeltingProcess(building, 'furnace');
                    
                    if (building.userData.smeltingState.isProcessing) {
                        anyFurnaceActive = true;
                        
                        // Turn on fire light
                        if (building.userData.fireLight) {
                            building.userData.fireLight.intensity = 2;
                        }
                        
                        // Show fire glow in door
                        if (building.userData.fireGlow) {
                            building.userData.fireGlow.visible = true;
                            // Flicker effect
                            building.userData.fireGlow.material.opacity = 0.8 + Math.random() * 0.15;
                        }
                        
                        // Spawn smoke from chimney
                        building.userData.smokeTimer = (building.userData.smokeTimer || 0) + 1;
                        if (building.userData.smokeTimer >= 6) {
                            building.userData.smokeTimer = 0;
                            const pos = building.position.clone();
                            pos.y += 2.8; // Top of chimney
                            createSmokeParticle(pos);
                        }
                    } else {
                        // Turn off fire light when not active
                        if (building.userData.fireLight) {
                            building.userData.fireLight.intensity = 0;
                        }
                        
                        // Hide fire glow when not active
                        if (building.userData.fireGlow) {
                            building.userData.fireGlow.visible = false;
                        }
                    }
                }
            });
            
            // Control fire sound
            if (anyCampfireActive) {
                if (!fireSound) startFireSound();
            } else {
                if (fireSound) stopFireSound();
            }

            if (anyFurnaceActive) {
                if (!furnaceSound) startFurnaceSound();
            } else {
                if (furnaceSound) stopFurnaceSound();
            }
            
            // Update UI if a menu is currently open
            if (currentCampfire) {
                updateSmeltingDisplay('campfire');
            }
            if (currentFurnace) {
                updateSmeltingDisplay('furnace');
            }

            // Cooking station visuals (glow + smoke when processing)
            buildings.forEach(building => {
                if (!building.userData.isCookingStation || !building.userData.cookingState) return;
                const isActive = building.userData.cookingState.isProcessing;
                if (building.userData.ovenGlow) {
                    building.userData.ovenGlow.visible = isActive;
                    if (isActive) building.userData.ovenGlow.material.opacity = 0.5 + Math.random() * 0.3;
                }
                if (building.userData.fireLight) {
                    building.userData.fireLight.intensity = isActive ? (1.5 + Math.random() * 0.5) : 0;
                }
                if (isActive) {
                    building.userData.smokeTimer = (building.userData.smokeTimer || 0) + 1;
                    if (building.userData.smokeTimer >= 10) {
                        building.userData.smokeTimer = 0;
                        const pos = building.position.clone();
                        pos.y += 1.8; pos.x += 0.35;
                        createSmokeParticle(pos);
                    }
                }
            });
        }
        
        function updateSmeltingProcess(building, type) {
            if (!building || !building.userData.smeltingState) return;
            
            const state = building.userData.smeltingState;
            
            if (type === 'furnace') {
                // Reset currentInputSlot to 0 if it ran past the end but new ores may exist
                if (state.currentInputSlot >= 3) {
                    state.currentInputSlot = 0;
                }
                // Advance currentInputSlot to first non-empty slot
                while (state.currentInputSlot < 3 && (!state.inputSlots[state.currentInputSlot] || state.inputSlots[state.currentInputSlot].count <= 0)) {
                    state.currentInputSlot++;
                }
                const hasInput = state.currentInputSlot < 3;
                
                // Start as soon as fuel is available  even if some input slots are empty
                if (!state.isProcessing && hasInput && state.fuelCount > 0) {
                    state.isProcessing = true;
                    state.progress = 0;
                }
                
                if (state.isProcessing) {
                    const progressIncrement = (1000 / 60 / state.processTime) * 100;
                    state.progress += progressIncrement;
                    
                    if (state.progress >= 100) {
                        const slotData = state.inputSlots[state.currentInputSlot];
                        if (slotData && slotData.count > 0) {
                            slotData.count--;
                            state.fuelCount--;
                            
                            // Route output to the correct slot based on ore type
                            if (!state.outputSlots) {
                                state.outputSlots = [{ item: 'iron_ingot', count: 0 }, { item: 'smelted_sulfur', count: 0 }];
                            }
                            if (slotData.item === 'sulfur_ore') {
                                state.outputSlots[1].count++;
                            } else {
                                state.outputSlots[0].count++;
                            }
                            state.wasteCount++;
                            
                            state.progress = 0;
                            
                            // If slot is now empty, advance to next
                            if (slotData.count <= 0) {
                                state.inputSlots[state.currentInputSlot] = null;
                                state.currentInputSlot++;
                            }
                            
                            // Check if we can continue
                            while (state.currentInputSlot < 3 && (!state.inputSlots[state.currentInputSlot] || state.inputSlots[state.currentInputSlot].count <= 0)) {
                                state.currentInputSlot++;
                            }
                            const stillHasInput = state.currentInputSlot < 3;
                            if (!stillHasInput || state.fuelCount <= 0) {
                                state.isProcessing = false;
                            }
                        } else {
                            state.isProcessing = false;
                        }
                    }
                }
            } else {
                // Campfire - single slot logic (unchanged)
                if (!state.isProcessing && state.inputCount > 0 && state.fuelCount > 0) {
                    state.isProcessing = true;
                    state.progress = 0;
                }
                
                if (state.isProcessing) {
                    const progressIncrement = (1000 / 60 / state.processTime) * 100;
                    state.progress += progressIncrement;
                    
                    if (state.progress >= 100) {
                        state.inputCount--;
                        state.fuelCount--;
                        
                        if (state.inputItem === 'mushroom') {
                            state.outputItem = 'roasted_mushroom';
                        } else {
                            state.outputItem = 'cooked_meat';
                        }
                        state.outputCount++;
                        state.wasteCount++;
                        
                        state.progress = 0;
                        
                        if (state.inputCount <= 0 || state.fuelCount <= 0) {
                            state.isProcessing = false;
                        }
                    }
                }
            }
        }
        
        // ===== COOKING STATION SYSTEM =====
        let currentCookingStation = null;

        // All valid ingredients for the cooking station
        const CS_VALID_FOODS = new Set([
            'meat','cooked_meat','mushroom','roasted_mushroom',
            'potato','carrot','corn','cabbage','tomato','pumpkin','wheat',
            'cucumber','strawberry','red_berries','black_berries','berries',
            'mushroom_crop','hemp_fiber','water_bottle','flour','bread',
            'blackcurrant_jam','strawberry_jam'
        ]);

        // All cooking station recipes with display info
        const CS_RECIPES = [
            {
                id: 'corn_bread',
                label: 'Corn Bread',
                desc: '+45 Hunger',
                ingredients: ['corn','wheat'],
                result: 'corn_bread'
            },
            {
                id: 'hearty_meal',
                label: 'Hearty Meal',
                desc: '+80 Hunger, +25 Health, +15 Thirst',
                ingredients: ['cooked_meat','carrot','corn','potato','tomato'],
                result: 'hearty_meal',
                buff: { id: 'hearty', icon: '', label: 'Double Gathering', desc: 'Doubles resources from all gathering activities', duration: 600000 }
            },
            {
                id: 'flour',
                label: 'Flour',
                desc: 'Crafting ingredient',
                ingredients: ['wheat','water_bottle'],
                result: 'flour'
            },
            {
                id: 'bread',
                label: 'Bread',
                desc: '+35 Hunger',
                ingredients: ['flour','water_bottle'],
                result: 'bread'
            },
            {
                id: 'blackcurrant_jam',
                label: 'Blackcurrant Jam',
                desc: '+20 Hunger, +10 Thirst',
                ingredients: ['black_berries','black_berries','black_berries'],
                result: 'blackcurrant_jam'
            },
            {
                id: 'strawberry_jam',
                label: 'Strawberry Jam',
                desc: '+20 Hunger, +10 Thirst, +5 Health',
                ingredients: ['strawberry','strawberry','strawberry'],
                result: 'strawberry_jam'
            },
            {
                id: 'vegetable_stew',
                label: 'Vegetable Stew',
                desc: '+50 Hunger, +20 Thirst, +10 Health',
                ingredients: ['mushroom_crop','carrot','potato','water_bottle'],
                result: 'vegetable_stew',
                buff: { id: 'veggi_stew', icon: '', label: 'Stamina Saver', desc: 'Reduces stamina drain by 50% while sprinting', duration: 600000 }
            },
            {
                id: 'meat_stew',
                label: 'Meat Stew',
                desc: '+60 Hunger, +15 Health',
                ingredients: ['cooked_meat','potato','water_bottle'],
                result: 'meat_stew',
                buff: { id: 'meat_stew', icon: '', label: 'Fortified', desc: 'Gain 30% additional max health', duration: 600000 }
            },
            {
                id: 'toast_jam_blackcurrant',
                label: 'Toast with Blackcurrant Jam',
                desc: '+50 Hunger, +5 Health',
                ingredients: ['bread','blackcurrant_jam'],
                result: 'toast_jam'
            },
            {
                id: 'toast_jam_strawberry',
                label: 'Toast with Strawberry Jam',
                desc: '+50 Hunger, +5 Health',
                ingredients: ['bread','strawberry_jam'],
                result: 'toast_jam'
            },
            {
                id: 'ham_sandwich',
                label: 'Ham Sandwich',
                desc: '+65 Hunger, +10 Health, +10 Thirst',
                ingredients: ['cucumber','tomato','cooked_meat','bread'],
                result: 'ham_sandwich'
            },
        ];

        function _csGetFilledIngredients(state) {
            const items = [];
            for (let slot of state.csInputSlots) {
                if (slot && slot.item) items.push(slot.item);
            }
            return items.sort();
        }

        function _csMatchRecipe(state) {
            const filled = _csGetFilledIngredients(state);
            if (filled.length === 0) return null;
            for (const recipe of CS_RECIPES) {
                const sorted = [...recipe.ingredients].sort();
                if (sorted.length !== filled.length) continue;
                if (sorted.join(',') === filled.join(',')) return recipe;
            }
            return null;
        }

        function createCookingStationState() {
            return {
                csInputSlots: [null, null, null, null, null],
                outputItem: null,
                outputCount: 0,
                wasteCount: 0,
                progress: 0,
                isProcessing: false,
                processTime: 20000, // 20 seconds
                currentRecipe: null
            };
        }

        // Populate recipe book
        function _csPopulateRecipeBook() {
            const list = document.getElementById('cs-recipe-list');
            if (!list) return;
            list.innerHTML = '';
            CS_RECIPES.forEach(recipe => {
                const div = document.createElement('div');
                div.className = 'cs-recipe-entry';
                div.style.position = 'relative';
                const ingNames = recipe.ingredients.map(i => (itemIcons[i]||'') + ' ' + (itemDisplayNames[i]||i)).join(', ');
                const chevron = recipe.buff ? `<em class="cs-buff-chevron" title="Has buff"></em>` : '';
                div.innerHTML = `<span class="cs-recipe-ings">${ingNames}</span><span class="cs-recipe-arrow"></span><span class="cs-recipe-result">${itemIcons[recipe.result]||''}${chevron} ${recipe.label}</span><span style="font-size:10px; color:rgba(255,255,255,0.45); margin-left:auto;">${recipe.desc}</span>`;
                if (recipe.buff) {
                    const tip = document.createElement('div');
                    tip.className = 'cs-recipe-tip';
                    tip.innerHTML = `<div class="cs-recipe-tip-title">${recipe.buff.icon} ${recipe.buff.label}</div><div class="cs-recipe-tip-buff">${recipe.buff.desc}</div><div class="cs-recipe-tip-duration"> Lasts 10 minutes</div>`;
                    div.appendChild(tip);
                }
                div.title = 'Click to auto-fill from inventory';
                div.addEventListener('click', () => _csAutoFillRecipe(recipe));
                list.appendChild(div);
            });
        }

        function _csAutoFillRecipe(recipe) {
            const station = currentCookingStation;
            if (!station || !station.userData.cookingState) return;
            const state = station.userData.cookingState;
            // Check if player has all ingredients
            const needed = {};
            recipe.ingredients.forEach(ing => { needed[ing] = (needed[ing]||0) + 1; });
            for (const [item, count] of Object.entries(needed)) {
                if ((inventory[item]||0) < count) {
                    showMessage(` Not enough ${itemDisplayNames[item]||item}!`);
                    return;
                }
            }
            // Clear current slots
            state.csInputSlots.forEach((slot, i) => {
                if (slot) { inventory[slot.item] = (inventory[slot.item]||0) + slot.count; }
                state.csInputSlots[i] = null;
            });
            // Fill with recipe ingredients
            recipe.ingredients.forEach((ing, i) => {
                state.csInputSlots[i] = { item: ing, count: 1 };
                inventory[ing] = Math.max(0, (inventory[ing]||0) - 1);
            });
            updateUI();
            updateInventoryDisplay();
            updateCookingStationDisplay();
        }

        // Cooking sound
        let _cookingBuffer = null;
        let cookingSound = null;
        let cookingGainNode = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/cooking.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _cookingBuffer = buf; console.log('Cooking sound loaded OK'); })
            .catch(e => { console.error('Cooking sound fetch error:', e); });

        function startCookingSound() {
            if (cookingSound) return;
            if (!_cookingBuffer) return;
            cookingGainNode = audioContext.createGain();
            cookingGainNode.gain.setValueAtTime(0.55, audioContext.currentTime);
            cookingGainNode.connect(audioContext.destination);
            cookingSound = audioContext.createBufferSource();
            cookingSound.buffer = _cookingBuffer;
            cookingSound.loop = true;
            cookingSound.connect(cookingGainNode);
            cookingSound.start();
        }

        function stopCookingSound() {
            if (cookingSound) {
                try { cookingGainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4); } catch(e){}
                setTimeout(() => {
                    try { cookingSound.stop(); } catch(e){}
                    cookingSound = null; cookingGainNode = null;
                }, 500);
            }
        }

        function openCookingStationMenu(station) {
            currentCookingStation = station;
            playBenchSound();
            const menu = document.getElementById('cooking-station-menu');
            const inventoryPanel = document.getElementById('inventory-panel');
            menu.style.display = 'block';
            positionInventoryRight(inventoryPanel);
            inventoryPanel.style.display = 'block';
            uiOpen();
            _csPopulateRecipeBook();
            updateInventoryDisplay();
            updateCookingStationDisplay();
        }

        function closeCookingStationMenu() {
            closeAllUI();
        }

        function updateCookingStationDisplay() {
            const station = currentCookingStation;
            if (!station || !station.userData.cookingState) return;
            const state = station.userData.cookingState;

            // Input slots
            for (let i = 0; i < 5; i++) {
                const el = document.getElementById(`cs-input-${i}`);
                if (!el) continue;
                const slot = state.csInputSlots[i];
                if (slot && slot.item) {
                    el.innerHTML = `${itemIcons[slot.item] || '?'}<div class="cs-slot-count">${slot.count}</div>`;
                } else {
                    el.innerHTML = '+';
                }
            }

            // Recipe hint & cook button
            const hint = document.getElementById('cs-recipe-hint');
            const cookBtn = document.getElementById('cs-cook-btn');
            const recipe = _csMatchRecipe(state);
            state.currentRecipe = recipe;
            if (state.isProcessing) {
                hint.textContent = ` Cooking: ${itemDisplayNames[state.currentRecipe?.result] || '...'}`;
                hint.style.color = 'rgba(100,255,130,0.95)';
                if (cookBtn) { cookBtn.disabled = true; cookBtn.textContent = ' Cooking...'; }
            } else if (recipe) {
                const resultName = itemDisplayNames[recipe.result] || recipe.result;
                hint.textContent = ` Recipe matched: ${itemIcons[recipe.result] || ''} ${resultName}  press Cook!`;
                hint.style.color = 'rgba(100,255,130,0.95)';
                if (cookBtn) { cookBtn.disabled = false; cookBtn.textContent = ' COOK (20s)'; }
            } else if (_csGetFilledIngredients(state).length > 0) {
                hint.textContent = 'No recipe found for these ingredients...';
                hint.style.color = 'rgba(255,180,80,0.9)';
                if (cookBtn) { cookBtn.disabled = true; cookBtn.textContent = ' COOK (20s)'; }
            } else {
                hint.textContent = 'Place ingredients to see recipe...';
                hint.style.color = 'rgba(255,200,100,0.9)';
                if (cookBtn) { cookBtn.disabled = true; cookBtn.textContent = ' COOK (20s)'; }
            }

            // Output slot
            const outEl = document.getElementById('cs-output-slot');
            if (outEl) {
                if (state.outputCount > 0) {
                    outEl.innerHTML = `${itemIcons[state.outputItem] || '?'}<div class="cs-slot-count">${state.outputCount}</div>`;
                } else {
                    outEl.innerHTML = '';
                }
            }

            // Waste slot
            const wasteEl = document.getElementById('cs-waste-slot');
            if (wasteEl) {
                if (state.wasteCount > 0) {
                    wasteEl.innerHTML = `${itemIcons['ash'] || ''}<div class="cs-slot-count">${state.wasteCount}</div>`;
                } else {
                    wasteEl.innerHTML = '';
                }
            }

            // Progress bar
            const pct = Math.floor(state.progress);
            const progEl = document.getElementById('cs-progress');
            const textEl = document.getElementById('cs-progress-text');
            if (progEl) progEl.style.width = pct + '%';
            if (textEl) textEl.textContent = state.isProcessing ? pct + '%' : (pct > 0 ? pct + '%' : '0%');
        }

        function addToCookingSlot(slotType, slotIndex) {
            const station = currentCookingStation;
            if (!station || !station.userData.cookingState) return;
            const state = station.userData.cookingState;
            if (state.isProcessing) { showMessage(' Cooking in progress!'); return; }

            if (slotType === 'input') {
                const slot = state.csInputSlots[slotIndex];
                // If slot has item, return it to inventory
                if (slot && slot.item) {
                    inventory[slot.item] = (inventory[slot.item]||0) + slot.count;
                    state.csInputSlots[slotIndex] = null;
                    updateUI(); updateInventoryDisplay(); updateCookingStationDisplay();
                    return;
                }
                // Otherwise try to add from inventory
                let placed = false;
                for (const itemName of CS_VALID_FOODS) {
                    if ((inventory[itemName]||0) > 0) {
                        state.csInputSlots[slotIndex] = { item: itemName, count: 1 };
                        inventory[itemName]--;
                        placed = true;
                        break;
                    }
                }
                if (!placed) { showMessage(' No valid ingredients in inventory!'); return; }
                updateUI(); updateCookingStationDisplay();
            } else if (slotType === 'output') {
                if (state.outputCount > 0) {
                    inventory[state.outputItem] = (inventory[state.outputItem]||0) + state.outputCount;
                    state.outputCount = 0; state.outputItem = null;
                    playInventoryMoveSound(); updateUI(); updateCookingStationDisplay();
                }
            } else if (slotType === 'waste') {
                if (state.wasteCount > 0) {
                    inventory.ash = (inventory.ash||0) + state.wasteCount;
                    state.wasteCount = 0;
                    playInventoryMoveSound(); updateUI(); updateCookingStationDisplay();
                }
            }
        }

        function _csDragDropToInputSlot(slotIndex, dragItemName, dragCount) {
            const station = currentCookingStation;
            if (!station || !station.userData.cookingState) return;
            const state = station.userData.cookingState;
            if (state.isProcessing) { showMessage(' Cooking in progress!'); return; }
            if (!CS_VALID_FOODS.has(dragItemName)) {
                showMessage(' That item cannot be cooked!');
                return;
            }
            const slot = state.csInputSlots[slotIndex];
            if (slot && slot.item !== dragItemName) {
                showMessage(' That slot already has a different ingredient!');
                return;
            }
            const actual = Math.min(dragCount, inventory[dragItemName] || 0);
            if (actual <= 0) return;
            if (!slot) {
                state.csInputSlots[slotIndex] = { item: dragItemName, count: actual };
            } else {
                slot.count += actual;
            }
            if (draggedFromType === 'inventory') {
                inventory[dragItemName] = Math.max(0, (inventory[dragItemName] || 0) - actual);
                if (inventorySlotCounts[draggedFromSlot] !== null) {
                    inventorySlotCounts[draggedFromSlot] = Math.max(0, inventorySlotCounts[draggedFromSlot] - actual);
                    if (inventorySlotCounts[draggedFromSlot] <= 0) { inventorySlotCounts[draggedFromSlot] = null; inventorySlots[draggedFromSlot] = null; }
                } else if (inventory[dragItemName] <= 0) { inventorySlots[draggedFromSlot] = null; }
            } else if (draggedFromType === 'hotbar') {
                inventory[dragItemName] = Math.max(0, (inventory[dragItemName] || 0) - actual);
                if (inventory[dragItemName] <= 0) hotbar[draggedFromSlot].item = null;
            }
            updateInventoryDisplay();
            updateHotbar();
            updateCookingStationDisplay();
        }

        function updateCookingProcess() {
            buildings.forEach(building => {
                if (!building.userData.isCookingStation || !building.userData.cookingState) return;
                const state = building.userData.cookingState;
                if (!state.isProcessing) return;

                const recipe = state.currentRecipe || _csMatchRecipe(state);
                if (!recipe) { state.isProcessing = false; stopCookingSound(); return; }

                const inc = (1000 / 60 / state.processTime) * 100;
                state.progress += inc;

                if (state.progress >= 100) {
                    state.progress = 0;
                    state.isProcessing = false;
                    stopCookingSound();
                    // Consume ingredients
                    const toConsume = [...recipe.ingredients];
                    for (let i = 0; i < 5; i++) {
                        const slot = state.csInputSlots[i];
                        if (!slot) continue;
                        const idx = toConsume.indexOf(slot.item);
                        if (idx !== -1) {
                            toConsume.splice(idx, 1);
                            slot.count--;
                            if (slot.count <= 0) state.csInputSlots[i] = null;
                        }
                    }
                    // Add output
                    if (!state.outputItem) state.outputItem = recipe.result;
                    if (state.outputItem === recipe.result) {
                        state.outputCount++;
                    } else {
                        inventory[recipe.result] = (inventory[recipe.result]||0) + 1;
                    }
                    state.wasteCount++;
                    state.currentRecipe = null;
                    showMessage(` ${itemDisplayNames[recipe.result]||recipe.result} is ready!`);
                }
            });

            if (currentCookingStation) updateCookingStationDisplay();
        }

        // ===== BUILDING SYSTEM =====
        const buildings = [];
        let buildMode = null;
        let buildPreview = null;
        let snapToGrid = true; // Toggle for snapping
        let buildRotation = 0; // Current rotation angle
        
        // Upgrade system: defines upgrade paths and costs for each building piece
        const buildingUpgrades = {
            wall: {
                tiers: ['wall', 'stone_wall', 'metal_wall'],
                costs: {
                    stone_wall: { stone: 10 },
                    metal_wall: { iron_ingot: 5 }
                }
            },
            window_wall: {
                tiers: ['window_wall', 'stone_window_wall', 'metal_window_wall'],
                costs: {
                    stone_window_wall: { stone: 10 },
                    metal_window_wall: { iron_ingot: 5 }
                }
            },
            floor: {
                tiers: ['floor', 'stone_floor', 'metal_floor'],
                costs: {
                    stone_floor: { stone: 10 },
                    metal_floor: { iron_ingot: 5 }
                }
            },
            ceiling: {
                tiers: ['ceiling', 'stone_ceiling', 'metal_ceiling'],
                costs: {
                    stone_ceiling: { stone: 10 },
                    metal_ceiling: { iron_ingot: 5 }
                }
            },
            single_door_wall: {
                tiers: ['single_door_wall', 'stone_single_door_wall', 'metal_single_door_wall'],
                costs: {
                    stone_single_door_wall: { stone: 10, wood: 3 },
                    metal_single_door_wall: { iron_ingot: 5, wood: 3 }
                }
            },
            double_door_wall: {
                tiers: ['double_door_wall', 'stone_double_door_wall', 'metal_double_door_wall'],
                costs: {
                    stone_double_door_wall: { stone: 12, wood: 4 },
                    metal_double_door_wall: { iron_ingot: 6, wood: 4 }
                }
            },
            stairs: {
                tiers: ['stairs', 'stone_stairs', 'metal_stairs'],
                costs: {
                    stone_stairs: { stone: 8 },
                    metal_stairs: { iron_ingot: 4 }
                }
            },
            corner_stairs_left: {
                tiers: ['corner_stairs_left', 'stone_corner_stairs_left', 'metal_corner_stairs_left'],
                costs: {
                    stone_corner_stairs_left: { stone: 8 },
                    metal_corner_stairs_left: { iron_ingot: 4 }
                }
            },
            corner_stairs_right: {
                tiers: ['corner_stairs_right', 'stone_corner_stairs_right', 'metal_corner_stairs_right'],
                costs: {
                    stone_corner_stairs_right: { stone: 8 },
                    metal_corner_stairs_right: { iron_ingot: 4 }
                }
            }
        };
        
        // Helper function to get upgrade info for a building
        function getUpgradeInfo(buildingType) {
            for (const baseType in buildingUpgrades) {
                const upgrade = buildingUpgrades[baseType];
                const currentIndex = upgrade.tiers.indexOf(buildingType);
                if (currentIndex !== -1 && currentIndex < upgrade.tiers.length - 1) {
                    const nextTier = upgrade.tiers[currentIndex + 1];
                    return {
                        canUpgrade: true,
                        nextTier: nextTier,
                        cost: upgrade.costs[nextTier],
                        currentTier: currentIndex + 1,
                        maxTier: upgrade.tiers.length
                    };
                } else if (currentIndex === upgrade.tiers.length - 1) {
                    return { canUpgrade: false, maxed: true };
                }
            }
            return { canUpgrade: false };
        }
        
        // Helper function to check if a building type is a floor or ceiling
        function isFloorOrCeiling(buildingType) {
            return buildingType === 'floor' || buildingType === 'stone_floor' || buildingType === 'metal_floor' ||
                   buildingType === 'ceiling' || buildingType === 'stone_ceiling' || buildingType === 'metal_ceiling';
        }
        
        // Check if player is standing under a ceiling/roof
        function isPlayerUnderRoof() {
            const playerX = camera.position.x;
            const playerY = camera.position.y;
            const playerZ = camera.position.z;
            
            for (let building of buildings) {
                const bt = building.userData.buildingType;
                // Check if it's a ceiling
                if (bt === 'ceiling' || bt === 'stone_ceiling' || bt === 'metal_ceiling') {
                    const box = new THREE.Box3().setFromObject(building);
                    
                    // Check if player is under this ceiling (XZ within bounds, Y below ceiling)
                    if (playerX >= box.min.x && playerX <= box.max.x &&
                        playerZ >= box.min.z && playerZ <= box.max.z &&
                        playerY < box.max.y && playerY > box.min.y - 4) { // Within 4 units below ceiling
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Helper function to check if player has enough resources
        function hasResources(cost) {
            for (const resource in cost) {
                if (!inventory[resource] || inventory[resource] < cost[resource]) {
                    return false;
                }
            }
            return true;
        }
        
        // Helper function to deduct resources
        function deductResources(cost) {
            for (const resource in cost) {
                inventory[resource] -= cost[resource];
            }
        }
        
        //  Shared planter mesh builder (used by both planter_box and large_planter) 
        // slotXArr and slotZArr are parallel arrays of local X,Z positions for each slot
        function _buildPlanterMesh(W, D, slotCount, slotXArr, slotZArr) {
            const group = new THREE.Group();
            const H = 0.52, plankT = 0.07;
            const woodMat  = new THREE.MeshStandardMaterial({ color: 0x8B6418, roughness: 0.9 });
            const frameMat = new THREE.MeshStandardMaterial({ color: 0x6B4C10, roughness: 0.85 });
            const linerMat = new THREE.MeshStandardMaterial({ color: 0x2255AA, roughness: 0.95, side: THREE.FrontSide });
            const dirtMat  = new THREE.MeshStandardMaterial({ color: 0x5C3D1E, roughness: 1.0 });
            const stoneMat = new THREE.MeshStandardMaterial({ color: 0x888877, roughness: 0.95 });
            const divotMat = new THREE.MeshStandardMaterial({ color: 0x3A2510, roughness: 1.0 });

            const pc = 5; // planks per side
            // Long sides (x-axis)
            for (let side=0; side<2; side++) {
                const zSign = side===0?-1:1;
                for (let p=0; p<pc; p++) {
                    const py = -H/2 + plankT/2 + p*(H-plankT)/(pc-1);
                    const m = new THREE.Mesh(new THREE.BoxGeometry(W, plankT*1.1, plankT), woodMat);
                    m.position.set(0, py, zSign*(D/2-plankT/2));
                    m.castShadow = m.receiveShadow = true;
                    group.add(m);
                }
            }
            // Short sides (z-axis)
            for (let side=0; side<2; side++) {
                const xSign = side===0?-1:1;
                for (let p=0; p<4; p++) {
                    const py = -H/2 + plankT/2 + p*(H-plankT)/3;
                    const m = new THREE.Mesh(new THREE.BoxGeometry(plankT, plankT*1.1, D-plankT*2), woodMat);
                    m.position.set(xSign*(W/2-plankT/2), py, 0);
                    m.castShadow = true;
                    group.add(m);
                }
            }
            // Corner posts
            const postS = 0.1, postH = H+0.14;
            [[-1,-1],[1,-1],[-1,1],[1,1]].forEach(([xs,zs]) => {
                const p = new THREE.Mesh(new THREE.BoxGeometry(postS, postH, postS), frameMat);
                p.position.set(xs*(W/2-postS/2), 0, zs*(D/2-postS/2));
                p.castShadow = p.receiveShadow = true;
                group.add(p);
            });
            // Bottom board
            const btm = new THREE.Mesh(new THREE.BoxGeometry(W-plankT*2, plankT, D-plankT*2), woodMat);
            btm.position.set(0, -H/2+plankT/2, 0);
            group.add(btm);
            // Blue liner
            const lD = H-plankT;
            [-1,1].forEach(zs => {
                const l = new THREE.Mesh(new THREE.BoxGeometry(W-plankT*2, lD, 0.01), linerMat);
                l.position.set(0, -plankT/2, zs*(D/2-plankT-0.005));
                group.add(l);
            });
            [-1,1].forEach(xs => {
                const l = new THREE.Mesh(new THREE.BoxGeometry(0.01, lD, D-plankT*2), linerMat);
                l.position.set(xs*(W/2-plankT-0.005), -plankT/2, 0);
                group.add(l);
            });
            // Dirt
            const dirtY = H/2 - 0.1;
            const dirt = new THREE.Mesh(new THREE.BoxGeometry(W-plankT*2-0.02, 0.18, D-plankT*2-0.02), dirtMat);
            dirt.position.set(0, dirtY-0.09, 0);
            dirt.receiveShadow = true;
            group.add(dirt);
            // Pebbles
            for (let i=0; i<10; i++) {
                const sr = 0.03+Math.random()*0.04;
                const s = new THREE.Mesh(new THREE.DodecahedronGeometry(sr,0), stoneMat);
                s.position.set((Math.random()-0.5)*(W-plankT*2-0.2), dirtY+sr*0.3, (Math.random()-0.5)*(D-plankT*2-0.15));
                s.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
                group.add(s);
            }
            // Slot divots
            for (let i=0; i<slotCount; i++) {
                const divot = new THREE.Mesh(new THREE.CylinderGeometry(0.07,0.05,0.04,8), divotMat);
                divot.position.set(slotXArr[i], dirtY+0.01, slotZArr[i]||0);
                group.add(divot);
            }
            // Plant container
            const plantContainer = new THREE.Group();
            plantContainer.name = 'plantContainer';
            group.add(plantContainer);

            // Build slot position objects for the userData
            const slotDefs = [];
            for (let i=0; i<slotCount; i++) slotDefs.push({x: slotXArr[i], z: slotZArr[i]||0});

            group.userData.isPlanterBox = true;
            group.userData.dirtY = dirtY;
            group.userData.slotDefs = slotDefs;          // [{x,z}]  new format
            group.userData.slotPositions = slotXArr;     // legacy compat (x only)
            group.userData.slotZPositions = slotZArr || slotXArr.map(()=>0);
            group.userData.seeds = new Array(slotCount).fill(null);
            group.userData.plantContainer = plantContainer;
            group.userData.wateredThisRain = false;
            return group;
        }

        const buildingTypes = {
            wall: {
                name: '\ud83e\uddf1 Wooden Wall',
                cost: { wood: 5 },
                create: async () => {
                    const wallGroup = new THREE.Group();

                    const plankMat = await createWoodMaterial(0x8B6914, 0.85);
                    const beamMat  = await createWoodMaterial(0x654321, 0.8);

                    // Vertical planks spanning full height
                    const plankWidth = 0.35;
                    const numPlanks  = 11;
                    for (let i = 0; i < numPlanks; i++) {
                        const plank = new THREE.Mesh(
                            new THREE.BoxGeometry(plankWidth, 3.0, 0.12),
                            plankMat.clone()
                        );
                        plank.position.x = -2 + (i * (4 / (numPlanks - 1)));
                        plank.position.y = 0;
                        plank.castShadow = true;
                        plank.receiveShadow = true;
                        wallGroup.add(plank);
                    }

                    // Top horizontal beam  sits on top of plank ends, z flush with back face
                    const topBeam = new THREE.Mesh(
                        new THREE.BoxGeometry(4.1, 0.18, 0.12),
                        beamMat.clone()
                    );
                    topBeam.position.y = 1.59;
                    topBeam.position.z = 0.0;
                    topBeam.castShadow = true;
                    wallGroup.add(topBeam);

                    // Bottom horizontal beam  sits below plank ends
                    const bottomBeam = new THREE.Mesh(
                        new THREE.BoxGeometry(4.1, 0.18, 0.12),
                        beamMat.clone()
                    );
                    bottomBeam.position.y = -1.59;
                    bottomBeam.position.z = 0.0;
                    bottomBeam.castShadow = true;
                    wallGroup.add(bottomBeam);

                    // Middle horizontal beam  proud of plank face, no clip
                    const midBeam = new THREE.Mesh(
                        new THREE.BoxGeometry(4.1, 0.14, 0.06),
                        beamMat.clone()
                    );
                    midBeam.position.y = 0;
                    midBeam.position.z = 0.09;
                    midBeam.castShadow = true;
                    wallGroup.add(midBeam);

                    // Diagonal cross-brace (top-left to bottom-right)  fully in front of planks
                    const braceLen = Math.sqrt(4*4 + 3*3);
                    const brace1 = new THREE.Mesh(
                        new THREE.BoxGeometry(braceLen, 0.10, 0.06),
                        beamMat.clone()
                    );
                    brace1.rotation.z = Math.atan2(3, 4);
                    brace1.position.z = 0.15;
                    wallGroup.add(brace1);

                    // Diagonal cross-brace (top-right to bottom-left)
                    const brace2 = new THREE.Mesh(
                        new THREE.BoxGeometry(braceLen, 0.10, 0.06),
                        beamMat.clone()
                    );
                    brace2.rotation.z = -Math.atan2(3, 4);
                    brace2.position.z = 0.15;
                    wallGroup.add(brace2);

                    wallGroup.userData.collisionBox = new THREE.Box3().setFromObject(wallGroup);
                    return wallGroup;
                }
            },
            stone_wall: {
                name: '\ud83e\uddf1 Stone Wall',
                cost: { stone: 10 },
                create: async () => {
                    const wallGroup = new THREE.Group();
                    
                    // Stone block material
                    const stoneMat = await createStoneMaterial(0x808080, 0.9);
                    
                    // Create stone blocks in a pattern
                    const blockRows = 3;
                    const blocksPerRow = [5, 6, 5]; // Alternating pattern
                    
                    for (let row = 0; row < blockRows; row++) {
                        const numBlocks = blocksPerRow[row];
                        const blockWidth = 4 / numBlocks;
                        const offset = row % 2 === 0 ? 0 : blockWidth / 2;
                        
                        for (let i = 0; i < numBlocks; i++) {
                            const block = new THREE.Mesh(
                                new THREE.BoxGeometry(blockWidth - 0.05, 1 - 0.05, 0.3),
                                stoneMat.clone()
                            );
                            block.position.x = -2 + offset + (i * blockWidth) + blockWidth / 2;
                            block.position.y = -1 + row * 1;
                            block.position.z = 0;
                            block.castShadow = true;
                            block.receiveShadow = true;
                            wallGroup.add(block);
                            
                            // Add mortar lines  slightly proud of blocks, no z-fight
                            if (i < numBlocks - 1) {
                                const mortar = new THREE.Mesh(
                                    new THREE.BoxGeometry(0.03, 1, 0.32),
                                    new THREE.MeshStandardMaterial({ color: 0x5a5a5a, roughness: 0.95 })
                                );
                                mortar.position.x = -2 + offset + ((i + 1) * blockWidth);
                                mortar.position.y = -1 + row * 1;
                                wallGroup.add(mortar);
                            }
                        }
                    }
                    
                    // Horizontal mortar lines  slightly wider than blocks, no z-fight
                    for (let row = 0; row < blockRows + 1; row++) {
                        const line = new THREE.Mesh(
                            new THREE.BoxGeometry(4, 0.03, 0.32),
                            new THREE.MeshStandardMaterial({ color: 0x5a5a5a, roughness: 0.95 })
                        );
                        line.position.y = -1.5 + row * 1;
                        wallGroup.add(line);
                    }
                    
                    wallGroup.userData.collisionBox = new THREE.Box3().setFromObject(wallGroup);
                    return wallGroup;
                }
            },
            metal_wall: {
                name: '\ud83e\uddf1 Metal Wall',
                cost: { iron_ingot: 5 },
                create: async () => {
                    const wallGroup = new THREE.Group();
                    
                    // Metal panel material
                    const metalMat = await createMetalMaterial(0xb8b8b8, 0.3);
                    
                    // Main panels
                    const panelWidth = 1.9;
                    for (let i = 0; i < 2; i++) {
                        const panel = new THREE.Mesh(
                            new THREE.BoxGeometry(panelWidth, 3, 0.1),
                            metalMat.clone()
                        );
                        panel.position.x = -1 + i * 2;
                        panel.castShadow = true;
                        panel.receiveShadow = true;
                        wallGroup.add(panel);
                        
                        // Corrugation effect (vertical ridges)
                        for (let j = 0; j < 8; j++) {
                            const ridge = new THREE.Mesh(
                                new THREE.BoxGeometry(0.03, 3, 0.05),
                                createMetalMaterial(0xa8a8a8, 0.35)
                            );
                            ridge.position.set(
                                -1 + i * 2 - panelWidth/2 + (j * panelWidth/7),
                                0,
                                0.075
                            );
                            wallGroup.add(ridge);
                        }
                    }
                    
                    // Vertical frame posts  proud of panel front, back flush with panel back
                    const frameMat = await createMetalMaterial(0x999999, 0.45);
                    for (let x of [-2, 0, 2]) {
                        const post = new THREE.Mesh(
                            new THREE.BoxGeometry(0.15, 3.2, 0.12),
                            frameMat.clone()
                        );
                        post.position.x = x;
                        post.position.z = 0.01;
                        post.castShadow = true;
                        wallGroup.add(post);
                    }
                    
                    // Horizontal support beams  front proud of panels, no back clip
                    for (let y of [-1.4, 0, 1.4]) {
                        const beam = new THREE.Mesh(
                            new THREE.BoxGeometry(4.2, 0.12, 0.12),
                            frameMat.clone()
                        );
                        beam.position.y = y;
                        beam.position.z = 0.01;
                        beam.castShadow = true;
                        wallGroup.add(beam);
                    }
                    
                    // Rivets at intersections
                    const rivetMat = await createMetalMaterial(0x606060, 0.6);
                    for (let x of [-2, 0, 2]) {
                        for (let y of [-1.4, 0, 1.4]) {
                            const rivet = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.04, 0.04, 0.08, 8),
                                rivetMat.clone()
                            );
                            rivet.rotation.x = Math.PI / 2;
                            rivet.position.set(x, y, 0.12);
                            wallGroup.add(rivet);
                        }
                    }
                    
                    wallGroup.userData.collisionBox = new THREE.Box3().setFromObject(wallGroup);
                    return wallGroup;
                }
            },
            window_wall: {
                name: '\ud83e\ude9f Window Wall',
                cost: { wood: 5, stone: 2 },
                create: async () => {
                    const wallGroup = new THREE.Group();
                    
                    // Materials matching wooden wall style
                    const plankMat = await createWoodMaterial(0x8B6914, 0.85);
                    const beamMat = await createWoodMaterial(0x654321, 0.8);
                    
                    // Bottom section - vertical planks
                    const bottomPlankWidth = 0.35;
                    const numBottomPlanks = 11;
                    for (let i = 0; i < numBottomPlanks; i++) {
                        const plank = new THREE.Mesh(
                            new THREE.BoxGeometry(bottomPlankWidth, 1.2, 0.12),
                            plankMat.clone()
                        );
                        plank.position.x = -2 + (i * (4 / (numBottomPlanks - 1)));
                        plank.position.y = -0.9;
                        plank.castShadow = true;
                        plank.receiveShadow = true;
                        wallGroup.add(plank);
                    }
                    
                    // Top section - vertical planks
                    const topPlankWidth = 0.35;
                    const numTopPlanks = 11;
                    for (let i = 0; i < numTopPlanks; i++) {
                        const plank = new THREE.Mesh(
                            new THREE.BoxGeometry(topPlankWidth, 1.0, 0.12),
                            plankMat.clone()
                        );
                        plank.position.x = -2 + (i * (4 / (numTopPlanks - 1)));
                        plank.position.y = 1.0;
                        plank.castShadow = true;
                        plank.receiveShadow = true;
                        wallGroup.add(plank);
                    }
                    
                    // Horizontal support beams
                    const topBeam = new THREE.Mesh(
                        new THREE.BoxGeometry(4.1, 0.15, 0.18),
                        beamMat
                    );
                    topBeam.position.y = 1.5;
                    topBeam.position.z = 0.03;
                    topBeam.castShadow = true;
                    wallGroup.add(topBeam);
                    
                    const bottomBeam = new THREE.Mesh(
                        new THREE.BoxGeometry(4.1, 0.15, 0.18),
                        beamMat.clone()
                    );
                    bottomBeam.position.y = -1.5;
                    bottomBeam.position.z = 0.03;
                    bottomBeam.castShadow = true;
                    wallGroup.add(bottomBeam);
                    
                    // Window frame beams (above and below window)
                    const windowTopBeam = new THREE.Mesh(
                        new THREE.BoxGeometry(4.1, 0.15, 0.18),
                        beamMat.clone()
                    );
                    windowTopBeam.position.y = 0.75;
                    windowTopBeam.position.z = 0.03;
                    windowTopBeam.castShadow = true;
                    wallGroup.add(windowTopBeam);
                    
                    const windowBottomBeam = new THREE.Mesh(
                        new THREE.BoxGeometry(4.1, 0.15, 0.18),
                        beamMat.clone()
                    );
                    windowBottomBeam.position.y = -0.3;
                    windowBottomBeam.position.z = 0.03;
                    windowBottomBeam.castShadow = true;
                    wallGroup.add(windowBottomBeam);
                    
                    // Window glass
                    const windowGlass = new THREE.Mesh(
                        new THREE.BoxGeometry(3.8, 1.5, 0.05),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x87ceeb,
                            transparent: true,
                            opacity: 0.3,
                            roughness: 0.1,
                            metalness: 0.2
                        })
                    );
                    windowGlass.position.y = 0.25;
                    windowGlass.position.z = 0.08;
                    windowGlass.receiveShadow = true;
                    wallGroup.add(windowGlass);
                    
                    // Window side frames (vertical)
                    const leftFrame = new THREE.Mesh(
                        new THREE.BoxGeometry(0.15, 1.7, 0.18),
                        beamMat.clone()
                    );
                    leftFrame.position.set(-1.975, 0.25, 0.05);
                    wallGroup.add(leftFrame);
                    
                    const rightFrame = new THREE.Mesh(
                        new THREE.BoxGeometry(0.15, 1.7, 0.18),
                        beamMat.clone()
                    );
                    rightFrame.position.set(1.975, 0.25, 0.05);
                    wallGroup.add(rightFrame);
                    
                    // Metal corner brackets
                    const bracketMat = await createMetalMaterial(0xa0a0a0, 0.45);
                    for (let corner of [[-2, 1.5], [2, 1.5], [-2, -1.5], [2, -1.5]]) {
                        const bracket = new THREE.Mesh(
                            new THREE.BoxGeometry(0.1, 0.3, 0.05),
                            bracketMat
                        );
                        bracket.position.set(corner[0], corner[1], 0.1);
                        wallGroup.add(bracket);
                    }
                    
                    wallGroup.userData.collisionBox = new THREE.Box3().setFromObject(wallGroup);
                    return wallGroup;
                }
            },
            stone_window_wall: {
                name: '\ud83e\ude9f Stone Window Wall',
                cost: { stone: 10 },
                create: async () => {
                    const wallGroup = new THREE.Group();
                    const stoneMat = await createStoneMaterial(0x808080, 0.9);
                    
                    // Bottom stone section
                    const bottom = new THREE.Mesh(
                        new THREE.BoxGeometry(4, 1.2, 0.3),
                        stoneMat
                    );
                    bottom.position.y = -0.9;
                    bottom.castShadow = true;
                    bottom.receiveShadow = true;
                    wallGroup.add(bottom);
                    
                    // Top stone section
                    const top = new THREE.Mesh(
                        new THREE.BoxGeometry(4, 1.0, 0.3),
                        stoneMat.clone()
                    );
                    top.position.y = 1.0;
                    top.castShadow = true;
                    top.receiveShadow = true;
                    wallGroup.add(top);
                    
                    // Window glass
                    const windowGlass = new THREE.Mesh(
                        new THREE.BoxGeometry(3.6, 1.5, 0.1),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x87ceeb,
                            transparent: true,
                            opacity: 0.3,
                            roughness: 0.1
                        })
                    );
                    windowGlass.position.y = 0;
                    windowGlass.receiveShadow = true;
                    wallGroup.add(windowGlass);
                    
                    // Stone frame around window
                    const frameMat = await createStoneMaterial(0x606060, 0.85);
                    const leftFrame = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 1.7, 0.2),
                        frameMat
                    );
                    leftFrame.position.set(-1.8, 0, 0.05);
                    wallGroup.add(leftFrame);
                    
                    const rightFrame = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 1.7, 0.2),
                        frameMat.clone()
                    );
                    rightFrame.position.set(1.8, 0, 0.05);
                    wallGroup.add(rightFrame);
                    
                    wallGroup.userData.collisionBox = new THREE.Box3().setFromObject(wallGroup);
                    return wallGroup;
                }
            },
            metal_window_wall: {
                name: '\ud83e\ude9f Metal Window Wall',
                cost: { iron_ingot: 5 },
                create: async () => {
                    const wallGroup = new THREE.Group();
                    const metalMat = await createMetalMaterial(0xb8b8b8, 0.3);
                    
                    // Bottom metal section
                    const bottom = new THREE.Mesh(
                        new THREE.BoxGeometry(4, 1.2, 0.15),
                        metalMat
                    );
                    bottom.position.y = -0.9;
                    bottom.castShadow = true;
                    bottom.receiveShadow = true;
                    wallGroup.add(bottom);
                    
                    // Top metal section
                    const top = new THREE.Mesh(
                        new THREE.BoxGeometry(4, 1.0, 0.15),
                        metalMat.clone()
                    );
                    top.position.y = 1.0;
                    top.castShadow = true;
                    top.receiveShadow = true;
                    wallGroup.add(top);
                    
                    // Reinforced window glass
                    const windowGlass = new THREE.Mesh(
                        new THREE.BoxGeometry(3.6, 1.5, 0.08),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x87ceeb,
                            transparent: true,
                            opacity: 0.4,
                            roughness: 0.05,
                            metalness: 0.5
                        })
                    );
                    windowGlass.position.y = 0;
                    windowGlass.receiveShadow = true;
                    wallGroup.add(windowGlass);
                    
                    // Metal frame around window
                    const frameMat = await createMetalMaterial(0x999999, 0.4);
                    const leftFrame = new THREE.Mesh(
                        new THREE.BoxGeometry(0.15, 1.7, 0.18),
                        frameMat
                    );
                    leftFrame.position.set(-1.85, 0, 0.05);
                    wallGroup.add(leftFrame);
                    
                    const rightFrame = new THREE.Mesh(
                        new THREE.BoxGeometry(0.15, 1.7, 0.18),
                        frameMat.clone()
                    );
                    rightFrame.position.set(1.85, 0, 0.05);
                    wallGroup.add(rightFrame);
                    
                    // Horizontal bars across window
                    for (let i = 0; i < 3; i++) {
                        const bar = new THREE.Mesh(
                            new THREE.BoxGeometry(3.7, 0.04, 0.04),
                            frameMat.clone()
                        );
                        bar.position.set(0, -0.6 + i * 0.6, 0.05);
                        wallGroup.add(bar);
                    }
                    
                    wallGroup.userData.collisionBox = new THREE.Box3().setFromObject(wallGroup);
                    return wallGroup;
                }
            },
            door_frame: {
                name: '\ud83d\udeaa Door Frame',
                cost: { wood: 4 },
                create: async () => {
                    const frame = new THREE.Group();
                    
                    // Left side panel (wall section)
                    const leftPanel = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 3, 0.3),
                        new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 })
                    );
                    leftPanel.position.x = -1.5;
                    leftPanel.castShadow = true;
                    leftPanel.receiveShadow = true;
                    frame.add(leftPanel);
                    
                    // Right side panel (wall section)
                    const rightPanel = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 3, 0.3),
                        new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 })
                    );
                    rightPanel.position.x = 1.5;
                    rightPanel.castShadow = true;
                    rightPanel.receiveShadow = true;
                    frame.add(rightPanel);
                    
                    // Left door post
                    const leftPost = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 3, 0.3),
                        new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.8 })
                    );
                    leftPost.position.x = -1.0;
                    leftPost.castShadow = true;
                    leftPost.receiveShadow = true;
                    frame.add(leftPost);
                    
                    // Right door post
                    const rightPost = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 3, 0.3),
                        new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.8 })
                    );
                    rightPost.position.x = 1.0;
                    rightPost.castShadow = true;
                    rightPost.receiveShadow = true;
                    frame.add(rightPost);
                    
                    // Top beam across door opening
                    const topBeam = new THREE.Mesh(
                        new THREE.BoxGeometry(2.0, 0.3, 0.3),
                        new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.8 })
                    );
                    topBeam.position.y = 1.35;
                    topBeam.castShadow = true;
                    topBeam.receiveShadow = true;
                    frame.add(topBeam);
                    
                    frame.userData.isDoorFrame = true;
                    frame.userData.isWalkable = true;
                    return frame;
                }
            },
            single_door_wall: {
                name: '\ud83d\udeaa Wall with Single Door',
                cost: { wood: 8, fiber: 2 },
                create: async () => {
                    const wallGroup = new THREE.Group();
                    
                    // Left wall section - matching wooden wall style with vertical planks
                    const plankMat = await createWoodMaterial(0x8B6914, 0.85);
                    const beamMat = await createWoodMaterial(0x654321, 0.8);
                    
                    // Left section vertical planks
                    for (let i = 0; i < 3; i++) {
                        const plank = new THREE.Mesh(
                            new THREE.BoxGeometry(0.3, 3, 0.12),
                            plankMat.clone()
                        );
                        plank.position.x = -1.8 + (i * 0.35);
                        plank.castShadow = true;
                        plank.receiveShadow = true;
                        wallGroup.add(plank);
                    }
                    
                    // Right section vertical planks
                    for (let i = 0; i < 3; i++) {
                        const plank = new THREE.Mesh(
                            new THREE.BoxGeometry(0.3, 3, 0.12),
                            plankMat.clone()
                        );
                        plank.position.x = 1.1 + (i * 0.35);
                        plank.castShadow = true;
                        plank.receiveShadow = true;
                        wallGroup.add(plank);
                    }
                    
                    // Door frame posts (thicker beams)
                    const leftPost = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 3, 0.18),
                        beamMat
                    );
                    leftPost.position.x = -1.0;
                    leftPost.position.z = 0.03;
                    leftPost.castShadow = true;
                    wallGroup.add(leftPost);
                    
                    const rightPost = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 3, 0.18),
                        beamMat.clone()
                    );
                    rightPost.position.x = 1.0;
                    rightPost.position.z = 0.03;
                    rightPost.castShadow = true;
                    wallGroup.add(rightPost);
                    
                    // Top beam
                    const topBeam = new THREE.Mesh(
                        new THREE.BoxGeometry(2.2, 0.15, 0.18),
                        beamMat.clone()
                    );
                    topBeam.position.y = 1.5;
                    topBeam.position.z = 0.03;
                    topBeam.castShadow = true;
                    wallGroup.add(topBeam);
                    
                    // Bottom beam
                    const bottomBeam = new THREE.Mesh(
                        new THREE.BoxGeometry(2.2, 0.15, 0.18),
                        beamMat.clone()
                    );
                    bottomBeam.position.y = -1.5;
                    bottomBeam.position.z = 0.03;
                    bottomBeam.castShadow = true;
                    wallGroup.add(bottomBeam);
                    
                    // Metal corner brackets on door frame
                    const bracketMat = await createMetalMaterial(0xa0a0a0, 0.45);
                    for (let corner of [[-1, 1.5], [1, 1.5], [-1, -1.5], [1, -1.5]]) {
                        const bracket = new THREE.Mesh(
                            new THREE.BoxGeometry(0.1, 0.3, 0.05),
                            bracketMat
                        );
                        bracket.position.set(corner[0], corner[1], 0.1);
                        wallGroup.add(bracket);
                    }
                    
                    // Door with hinge on left side - stick design
                    const doorGroup = new THREE.Group();
                    doorGroup.position.set(-0.9, 0, 0.15);
                    
                    // Wooden door panel - stick design (tied together sticks)
                    const stickMat = await createWoodMaterial(0x5d4e37, 0.9);
                    
                    // Create vertical sticks
                    for (let i = 0; i < 6; i++) {
                        const stick = new THREE.Mesh(
                            new THREE.BoxGeometry(0.08, 2.7, 0.08),
                            stickMat.clone()
                        );
                        stick.position.x = 0.3 + i * 0.3;
                        stick.castShadow = true;
                        doorGroup.add(stick);
                    }
                    
                    // Horizontal binding sticks
                    for (let y of [-1.2, 0, 1.2]) {
                        const bind = new THREE.Mesh(
                            new THREE.BoxGeometry(1.8, 0.08, 0.12),
                            stickMat.clone()
                        );
                        bind.position.set(0.9, y, 0);
                        bind.castShadow = true;
                        doorGroup.add(bind);
                    }
                    
                    // Rope binding (darker color)
                    const ropeMat = new THREE.MeshStandardMaterial({ color: 0x3d2817, roughness: 0.95 });
                    for (let y of [-1.2, 0, 1.2]) {
                        for (let x of [0.3, 0.9, 1.5]) {
                            const rope = new THREE.Mesh(
                                new THREE.TorusGeometry(0.06, 0.02, 6, 8),
                                ropeMat
                            );
                            rope.rotation.y = Math.PI / 2;
                            rope.position.set(x, y, 0);
                            doorGroup.add(rope);
                        }
                    }
                    
                    // Door handle (on right side)
                    const handle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.08, 8, 8),
                        new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8 })
                    );
                    handle.position.set(1.6, 0, 0.1);
                    doorGroup.add(handle);
                    
                    wallGroup.add(doorGroup);
                    
                    wallGroup.userData.isDoor = true;
                    wallGroup.userData.isOpen = false;
                    wallGroup.userData.doorGroup = doorGroup;
                    wallGroup.userData.doorType = 'single';
                    return wallGroup;
                }
            },
            stone_single_door_wall: {
                name: '\ud83d\udeaa Stone Wall with Single Door',
                cost: { stone: 10, wood: 3 },
                create: async () => {
                    const wallGroup = new THREE.Group();
                    const stoneMat = await createStoneMaterial(0x808080, 0.9);
                    
                    // Left stone wall section
                    const leftWall = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 3, 0.3),
                        stoneMat
                    );
                    leftWall.position.x = -1.5;
                    leftWall.castShadow = true;
                    leftWall.receiveShadow = true;
                    wallGroup.add(leftWall);
                    
                    // Right stone wall section
                    const rightWall = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 3, 0.3),
                        stoneMat.clone()
                    );
                    rightWall.position.x = 1.5;
                    rightWall.castShadow = true;
                    rightWall.receiveShadow = true;
                    wallGroup.add(rightWall);
                    
                    // Stone door posts
                    const postMat = await createStoneMaterial(0x606060, 0.85);
                    const leftPost = new THREE.Mesh(
                        new THREE.BoxGeometry(0.25, 3, 0.3),
                        postMat
                    );
                    leftPost.position.x = -1.0;
                    leftPost.castShadow = true;
                    wallGroup.add(leftPost);
                    
                    const rightPost = new THREE.Mesh(
                        new THREE.BoxGeometry(0.25, 3, 0.3),
                        postMat.clone()
                    );
                    rightPost.position.x = 1.0;
                    rightPost.castShadow = true;
                    wallGroup.add(rightPost);
                    
                    // Stone top beam
                    const topBeam = new THREE.Mesh(
                        new THREE.BoxGeometry(2.0, 0.3, 0.3),
                        postMat.clone()
                    );
                    topBeam.position.y = 1.35;
                    topBeam.castShadow = true;
                    wallGroup.add(topBeam);
                    
                    // Door with hinge on left
                    const doorGroup = new THREE.Group();
                    doorGroup.position.set(-0.9, 0, 0.15);
                    
                    // Wooden plank door
                    const plankMat = await createWoodMaterial(0x8B6914, 0.85);
                    
                    // Create vertical planks
                    for (let i = 0; i < 7; i++) {
                        const plank = new THREE.Mesh(
                            new THREE.BoxGeometry(0.25, 2.7, 0.12),
                            plankMat.clone()
                        );
                        plank.position.x = 0.15 + i * 0.27;
                        plank.castShadow = true;
                        doorGroup.add(plank);
                    }
                    
                    // Horizontal support beams
                    const beamMat = await createWoodMaterial(0x654321, 0.8);
                    for (let y of [-1.1, 1.1]) {
                        const beam = new THREE.Mesh(
                            new THREE.BoxGeometry(1.8, 0.15, 0.15),
                            beamMat
                        );
                        beam.position.set(0.9, y, 0.08);
                        beam.castShadow = true;
                        doorGroup.add(beam);
                    }
                    
                    // Metal handle
                    const handle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.08, 8, 8),
                        new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8 })
                    );
                    handle.position.set(1.6, 0, 0.1);
                    doorGroup.add(handle);
                    
                    wallGroup.add(doorGroup);
                    
                    wallGroup.userData.isDoor = true;
                    wallGroup.userData.isOpen = false;
                    wallGroup.userData.doorGroup = doorGroup;
                    wallGroup.userData.doorType = 'single';
                    return wallGroup;
                }
            },
            metal_single_door_wall: {
                name: '\ud83d\udeaa Metal Wall with Single Door',
                cost: { iron_ingot: 5, wood: 3 },
                create: async () => {
                    const wallGroup = new THREE.Group();
                    const metalMat = await createMetalMaterial(0xb8b8b8, 0.3);
                    
                    // Left metal wall section
                    const leftWall = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 3, 0.15),
                        metalMat
                    );
                    leftWall.position.x = -1.5;
                    leftWall.castShadow = true;
                    leftWall.receiveShadow = true;
                    wallGroup.add(leftWall);
                    
                    // Right metal wall section
                    const rightWall = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 3, 0.15),
                        metalMat.clone()
                    );
                    rightWall.position.x = 1.5;
                    rightWall.castShadow = true;
                    rightWall.receiveShadow = true;
                    wallGroup.add(rightWall);
                    
                    // Metal door frame
                    const frameMat = await createMetalMaterial(0x999999, 0.45);
                    const leftPost = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 3, 0.2),
                        frameMat
                    );
                    leftPost.position.x = -1.0;
                    leftPost.castShadow = true;
                    wallGroup.add(leftPost);
                    
                    const rightPost = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 3, 0.2),
                        frameMat.clone()
                    );
                    rightPost.position.x = 1.0;
                    rightPost.castShadow = true;
                    wallGroup.add(rightPost);
                    
                    const topBeam = new THREE.Mesh(
                        new THREE.BoxGeometry(2.0, 0.2, 0.2),
                        frameMat.clone()
                    );
                    topBeam.position.y = 1.4;
                    topBeam.castShadow = true;
                    wallGroup.add(topBeam);
                    
                    // Door with hinge on left
                    const doorGroup = new THREE.Group();
                    doorGroup.position.set(-0.9, 0, 0.15);
                    
                    // Metal door panel
                    const doorMat = await createMetalMaterial(0xa8a8a8, 0.35);
                    const doorPanel = new THREE.Mesh(
                        new THREE.BoxGeometry(1.8, 2.7, 0.1),
                        doorMat
                    );
                    doorPanel.position.x = 0.9;
                    doorPanel.castShadow = true;
                    doorGroup.add(doorPanel);
                    
                    // Rivets on door
                    const rivetMat = await createMetalMaterial(0x606060, 0.6);
                    for (let x of [0.2, 0.9, 1.6]) {
                        for (let y of [-1.2, -0.6, 0, 0.6, 1.2]) {
                            const rivet = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.04, 0.04, 0.06, 8),
                                rivetMat.clone()
                            );
                            rivet.rotation.x = Math.PI / 2;
                            rivet.position.set(x, y, 0.08);
                            doorGroup.add(rivet);
                        }
                    }
                    
                    // Reinforcement bars
                    const barMat = await createMetalMaterial(0x999999, 0.45);
                    for (let y of [-1.1, 0, 1.1]) {
                        const bar = new THREE.Mesh(
                            new THREE.BoxGeometry(1.7, 0.08, 0.08),
                            barMat.clone()
                        );
                        bar.position.set(0.9, y, 0.08);
                        doorGroup.add(bar);
                    }
                    
                    // Metal handle
                    const handle = new THREE.Mesh(
                        new THREE.BoxGeometry(0.15, 0.3, 0.1),
                        new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.9 })
                    );
                    handle.position.set(1.6, 0, 0.12);
                    doorGroup.add(handle);
                    
                    wallGroup.add(doorGroup);
                    
                    wallGroup.userData.isDoor = true;
                    wallGroup.userData.isOpen = false;
                    wallGroup.userData.doorGroup = doorGroup;
                    wallGroup.userData.doorType = 'single';
                    return wallGroup;
                }
            },
            double_door_wall: {
                name: '\ud83d\udeaa Wall with Double Doors',
                cost: { wood: 10, fiber: 3 },
                create: async () => {
                    const wallGroup = new THREE.Group();
                    
                    // Materials matching wooden wall style
                    const plankMat = await createWoodMaterial(0x8B6914, 0.85);
                    const beamMat = await createWoodMaterial(0x654321, 0.8);
                    
                    // Left wall section - vertical planks
                    for (let i = 0; i < 3; i++) {
                        const plank = new THREE.Mesh(
                            new THREE.BoxGeometry(0.3, 3, 0.12),
                            plankMat.clone()
                        );
                        plank.position.x = -1.8 + (i * 0.35);
                        plank.castShadow = true;
                        plank.receiveShadow = true;
                        wallGroup.add(plank);
                    }
                    
                    // Right wall section - vertical planks
                    for (let i = 0; i < 3; i++) {
                        const plank = new THREE.Mesh(
                            new THREE.BoxGeometry(0.3, 3, 0.12),
                            plankMat.clone()
                        );
                        plank.position.x = 1.1 + (i * 0.35);
                        plank.castShadow = true;
                        plank.receiveShadow = true;
                        wallGroup.add(plank);
                    }
                    
                    // Door frame posts
                    const leftPost = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 3, 0.18),
                        beamMat
                    );
                    leftPost.position.x = -1.0;
                    leftPost.position.z = 0.03;
                    leftPost.castShadow = true;
                    wallGroup.add(leftPost);
                    
                    const rightPost = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 3, 0.18),
                        beamMat.clone()
                    );
                    rightPost.position.x = 1.0;
                    rightPost.position.z = 0.03;
                    rightPost.castShadow = true;
                    wallGroup.add(rightPost);
                    
                    // Top beam
                    const topBeam = new THREE.Mesh(
                        new THREE.BoxGeometry(2.2, 0.15, 0.18),
                        beamMat.clone()
                    );
                    topBeam.position.y = 1.5;
                    topBeam.position.z = 0.03;
                    topBeam.castShadow = true;
                    wallGroup.add(topBeam);
                    
                    // Bottom beam
                    const bottomBeam = new THREE.Mesh(
                        new THREE.BoxGeometry(2.2, 0.15, 0.18),
                        beamMat.clone()
                    );
                    bottomBeam.position.y = -1.5;
                    bottomBeam.position.z = 0.03;
                    bottomBeam.castShadow = true;
                    wallGroup.add(bottomBeam);
                    
                    // Metal corner brackets
                    const bracketMat = await createMetalMaterial(0xa0a0a0, 0.45);
                    for (let corner of [[-1, 1.5], [1, 1.5], [-1, -1.5], [1, -1.5]]) {
                        const bracket = new THREE.Mesh(
                            new THREE.BoxGeometry(0.1, 0.3, 0.05),
                            bracketMat
                        );
                        bracket.position.set(corner[0], corner[1], 0.1);
                        wallGroup.add(bracket);
                    }
                    
                    // Stick material for doors
                    const stickMat = await createWoodMaterial(0x5d4e37, 0.9);
                    const ropeMat = new THREE.MeshStandardMaterial({ color: 0x3d2817, roughness: 0.95 });
                    
                    // Left door with stick design
                    const leftDoorGroup = new THREE.Group();
                    leftDoorGroup.position.set(-1.0, 0, 0.15);
                    
                    // Vertical sticks
                    for (let i = 0; i < 4; i++) {
                        const stick = new THREE.Mesh(
                            new THREE.BoxGeometry(0.08, 2.7, 0.08),
                            stickMat.clone()
                        );
                        stick.position.x = 0.15 + i * 0.25;
                        stick.castShadow = true;
                        leftDoorGroup.add(stick);
                    }
                    
                    // Horizontal bindings
                    for (let y of [-1.2, 0, 1.2]) {
                        const bind = new THREE.Mesh(
                            new THREE.BoxGeometry(1.0, 0.08, 0.12),
                            stickMat.clone()
                        );
                        bind.position.set(0.5, y, 0);
                        bind.castShadow = true;
                        leftDoorGroup.add(bind);
                        
                        // Rope bindings
                        for (let x of [0.15, 0.4, 0.65, 0.9]) {
                            const rope = new THREE.Mesh(
                                new THREE.TorusGeometry(0.05, 0.015, 6, 8),
                                ropeMat
                            );
                            rope.rotation.y = Math.PI / 2;
                            rope.position.set(x, y, 0);
                            leftDoorGroup.add(rope);
                        }
                    }
                    
                    const leftHandle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.08, 8, 8),
                        new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8 })
                    );
                    leftHandle.position.set(0.9, 0, 0.1);
                    leftDoorGroup.add(leftHandle);
                    
                    wallGroup.add(leftDoorGroup);
                    
                    // Right door with stick design
                    const rightDoorGroup = new THREE.Group();
                    rightDoorGroup.position.set(1.0, 0, 0.15);
                    
                    // Vertical sticks
                    for (let i = 0; i < 4; i++) {
                        const stick = new THREE.Mesh(
                            new THREE.BoxGeometry(0.08, 2.7, 0.08),
                            stickMat.clone()
                        );
                        stick.position.x = -0.9 + i * 0.25;
                        stick.castShadow = true;
                        rightDoorGroup.add(stick);
                    }
                    
                    // Horizontal bindings
                    for (let y of [-1.2, 0, 1.2]) {
                        const bind = new THREE.Mesh(
                            new THREE.BoxGeometry(1.0, 0.08, 0.12),
                            stickMat.clone()
                        );
                        bind.position.set(-0.5, y, 0);
                        bind.castShadow = true;
                        rightDoorGroup.add(bind);
                        
                        // Rope bindings
                        for (let x of [-0.9, -0.65, -0.4, -0.15]) {
                            const rope = new THREE.Mesh(
                                new THREE.TorusGeometry(0.05, 0.015, 6, 8),
                                ropeMat
                            );
                            rope.rotation.y = Math.PI / 2;
                            rope.position.set(x, y, 0);
                            rightDoorGroup.add(rope);
                        }
                    }
                    
                    const rightHandle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.08, 8, 8),
                        new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8 })
                    );
                    rightHandle.position.set(-0.9, 0, 0.1);
                    rightDoorGroup.add(rightHandle);
                    
                    wallGroup.add(rightDoorGroup);
                    
                    wallGroup.userData.isDoor = true;
                    wallGroup.userData.isOpen = false;
                    wallGroup.userData.leftDoorGroup = leftDoorGroup;
                    wallGroup.userData.rightDoorGroup = rightDoorGroup;
                    wallGroup.userData.doorType = 'double';
                    return wallGroup;
                }
            },
            stone_double_door_wall: {
                name: '\ud83d\udeaa Stone Wall with Double Doors',
                cost: { stone: 12, wood: 4 },
                create: async () => {
                    const wallGroup = new THREE.Group();
                    const stoneMat = await createStoneMaterial(0x808080, 0.9);
                    
                    // Wall sections
                    const leftWall = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 3, 0.3),
                        stoneMat
                    );
                    leftWall.position.x = -1.5;
                    leftWall.castShadow = true;
                    wallGroup.add(leftWall);
                    
                    const rightWall = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 3, 0.3),
                        stoneMat.clone()
                    );
                    rightWall.position.x = 1.5;
                    rightWall.castShadow = true;
                    wallGroup.add(rightWall);
                    
                    // Stone posts
                    const postMat = await createStoneMaterial(0x606060, 0.85);
                    const leftPost = new THREE.Mesh(
                        new THREE.BoxGeometry(0.25, 3, 0.3),
                        postMat
                    );
                    leftPost.position.x = -1.0;
                    leftPost.castShadow = true;
                    wallGroup.add(leftPost);
                    
                    const rightPost = new THREE.Mesh(
                        new THREE.BoxGeometry(0.25, 3, 0.3),
                        postMat.clone()
                    );
                    rightPost.position.x = 1.0;
                    rightPost.castShadow = true;
                    wallGroup.add(rightPost);
                    
                    const topBeam = new THREE.Mesh(
                        new THREE.BoxGeometry(2.0, 0.3, 0.3),
                        postMat.clone()
                    );
                    topBeam.position.y = 1.35;
                    topBeam.castShadow = true;
                    wallGroup.add(topBeam);
                    
                    // Left door
                    const leftDoorGroup = new THREE.Group();
                    leftDoorGroup.position.set(-1.0, 0, 0.15);
                    
                    const plankMat = await createWoodMaterial(0x8B6914, 0.85);
                    const leftDoor = new THREE.Mesh(
                        new THREE.BoxGeometry(1.0, 2.7, 0.12),
                        plankMat
                    );
                    leftDoor.position.x = 0.5;
                    leftDoor.castShadow = true;
                    leftDoorGroup.add(leftDoor);
                    
                    const leftHandle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.08, 8, 8),
                        new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8 })
                    );
                    leftHandle.position.set(0.9, 0, 0.1);
                    leftDoorGroup.add(leftHandle);
                    wallGroup.add(leftDoorGroup);
                    
                    // Right door
                    const rightDoorGroup = new THREE.Group();
                    rightDoorGroup.position.set(1.0, 0, 0.15);
                    
                    const rightDoor = new THREE.Mesh(
                        new THREE.BoxGeometry(1.0, 2.7, 0.12),
                        plankMat.clone()
                    );
                    rightDoor.position.x = -0.5;
                    rightDoor.castShadow = true;
                    rightDoorGroup.add(rightDoor);
                    
                    const rightHandle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.08, 8, 8),
                        new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8 })
                    );
                    rightHandle.position.set(-0.9, 0, 0.1);
                    rightDoorGroup.add(rightHandle);
                    wallGroup.add(rightDoorGroup);
                    
                    wallGroup.userData.isDoor = true;
                    wallGroup.userData.isOpen = false;
                    wallGroup.userData.leftDoorGroup = leftDoorGroup;
                    wallGroup.userData.rightDoorGroup = rightDoorGroup;
                    wallGroup.userData.doorType = 'double';
                    return wallGroup;
                }
            },
            metal_double_door_wall: {
                name: '\ud83d\udeaa Metal Wall with Double Doors',
                cost: { iron_ingot: 6, wood: 4 },
                create: async () => {
                    const wallGroup = new THREE.Group();
                    const metalMat = await createMetalMaterial(0xb8b8b8, 0.3);
                    
                    // Wall sections
                    const leftWall = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 3, 0.15),
                        metalMat
                    );
                    leftWall.position.x = -1.5;
                    leftWall.castShadow = true;
                    wallGroup.add(leftWall);
                    
                    const rightWall = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 3, 0.15),
                        metalMat.clone()
                    );
                    rightWall.position.x = 1.5;
                    rightWall.castShadow = true;
                    wallGroup.add(rightWall);
                    
                    // Metal frame
                    const frameMat = await createMetalMaterial(0x999999, 0.45);
                    const leftPost = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 3, 0.2),
                        frameMat
                    );
                    leftPost.position.x = -1.0;
                    leftPost.castShadow = true;
                    wallGroup.add(leftPost);
                    
                    const rightPost = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 3, 0.2),
                        frameMat.clone()
                    );
                    rightPost.position.x = 1.0;
                    rightPost.castShadow = true;
                    wallGroup.add(rightPost);
                    
                    const topBeam = new THREE.Mesh(
                        new THREE.BoxGeometry(2.0, 0.2, 0.2),
                        frameMat.clone()
                    );
                    topBeam.position.y = 1.4;
                    topBeam.castShadow = true;
                    wallGroup.add(topBeam);
                    
                    // Left door
                    const leftDoorGroup = new THREE.Group();
                    leftDoorGroup.position.set(-1.0, 0, 0.15);
                    
                    const doorMat = await createMetalMaterial(0xa8a8a8, 0.35);
                    const leftDoor = new THREE.Mesh(
                        new THREE.BoxGeometry(1.0, 2.7, 0.1),
                        doorMat
                    );
                    leftDoor.position.x = 0.5;
                    leftDoor.castShadow = true;
                    leftDoorGroup.add(leftDoor);
                    
                    // Rivets
                    const rivetMat = await createMetalMaterial(0x606060, 0.6);
                    for (let y of [-1.2, 0, 1.2]) {
                        const rivet = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.04, 0.04, 0.06, 8),
                            rivetMat.clone()
                        );
                        rivet.rotation.x = Math.PI / 2;
                        rivet.position.set(0.5, y, 0.08);
                        leftDoorGroup.add(rivet);
                    }
                    
                    const leftHandle = new THREE.Mesh(
                        new THREE.BoxGeometry(0.15, 0.3, 0.1),
                        new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.9 })
                    );
                    leftHandle.position.set(0.9, 0, 0.12);
                    leftDoorGroup.add(leftHandle);
                    wallGroup.add(leftDoorGroup);
                    
                    // Right door
                    const rightDoorGroup = new THREE.Group();
                    rightDoorGroup.position.set(1.0, 0, 0.15);
                    
                    const rightDoor = new THREE.Mesh(
                        new THREE.BoxGeometry(1.0, 2.7, 0.1),
                        doorMat.clone()
                    );
                    rightDoor.position.x = -0.5;
                    rightDoor.castShadow = true;
                    rightDoorGroup.add(rightDoor);
                    
                    for (let y of [-1.2, 0, 1.2]) {
                        const rivet = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.04, 0.04, 0.06, 8),
                            rivetMat.clone()
                        );
                        rivet.rotation.x = Math.PI / 2;
                        rivet.position.set(-0.5, y, 0.08);
                        rightDoorGroup.add(rivet);
                    }
                    
                    const rightHandle = new THREE.Mesh(
                        new THREE.BoxGeometry(0.15, 0.3, 0.1),
                        new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.9 })
                    );
                    rightHandle.position.set(-0.9, 0, 0.12);
                    rightDoorGroup.add(rightHandle);
                    wallGroup.add(rightDoorGroup);
                    
                    wallGroup.userData.isDoor = true;
                    wallGroup.userData.isOpen = false;
                    wallGroup.userData.leftDoorGroup = leftDoorGroup;
                    wallGroup.userData.rightDoorGroup = rightDoorGroup;
                    wallGroup.userData.doorType = 'double';
                    return wallGroup;
                }
            },
            double_door_frame: {
                name: '\ud83d\udeaa Double Door Frame',
                cost: { wood: 5 },
                create: async () => {
                    const frame = new THREE.Group();
                    
                    // Left wall section
                    const leftWall = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 3, 0.3),
                        new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 })
                    );
                    leftWall.position.x = -1.5;
                    leftWall.castShadow = true;
                    leftWall.receiveShadow = true;
                    frame.add(leftWall);
                    
                    // Right wall section
                    const rightWall = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 3, 0.3),
                        new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 })
                    );
                    rightWall.position.x = 1.5;
                    rightWall.castShadow = true;
                    rightWall.receiveShadow = true;
                    frame.add(rightWall);
                    
                    // Door posts
                    const leftPost = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 3, 0.3),
                        new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.8 })
                    );
                    leftPost.position.x = -1.0;
                    leftPost.castShadow = true;
                    frame.add(leftPost);
                    
                    const rightPost = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 3, 0.3),
                        new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.8 })
                    );
                    rightPost.position.x = 1.0;
                    rightPost.castShadow = true;
                    frame.add(rightPost);
                    
                    // Top beam
                    const topBeam = new THREE.Mesh(
                        new THREE.BoxGeometry(2.0, 0.3, 0.3),
                        new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.8 })
                    );
                    topBeam.position.y = 1.35;
                    topBeam.castShadow = true;
                    frame.add(topBeam);
                    
                    frame.userData.isWalkable = true;
                    return frame;
                }
            },
            door: {
                name: '\ud83d\udeaa Wooden Door',
                cost: { wood: 6, fiber: 2 },
                create: async () => {
                    const doorGroup = new THREE.Group();
                    
                    const door = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 2.8, 0.15),
                        new THREE.MeshStandardMaterial({
                            color: 0x654321,
                            roughness: 0.8
                        })
                    );
                    door.position.x = 1; // Offset from hinge point
                    door.castShadow = true;
                    door.receiveShadow = true;
                    doorGroup.add(door);
                    
                    // Door handle
                    const handle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.08, 8, 8),
                        new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8 })
                    );
                    handle.position.set(1.7, 0, 0.1);
                    doorGroup.add(handle);
                    
                    doorGroup.userData.isDoor = true;
                    doorGroup.userData.isOpen = false;
                    doorGroup.userData.hingeOffset = -1; // Left hinge
                    return doorGroup;
                }
            },
            floor: {
                name: '\ud83d\udfeb Wooden Floor',
                cost: { wood: 4 },
                create: async () => {
                    const floorGroup = new THREE.Group();
                    
                    // Wood plank material
                    const plankMat = await createWoodMaterial(0x8B7355, 0.9);
                    
                    // Create horizontal planks
                    const plankWidth = 0.3;
                    const numPlanks = 13;
                    for (let i = 0; i < numPlanks; i++) {
                        const plank = new THREE.Mesh(
                            new THREE.BoxGeometry(4, 0.15, plankWidth),
                            plankMat.clone()
                        );
                        plank.position.z = -2 + (i * (4 / (numPlanks - 1)));
                        plank.position.y = -0.025;
                        plank.receiveShadow = true;
                        plank.castShadow = true;
                        floorGroup.add(plank);
                        
                        // Dark seam between planks  sits on top surface, no clip
                        if (i < numPlanks - 1) {
                            const gap = new THREE.Mesh(
                                new THREE.BoxGeometry(4, 0.002, 0.012),
                                new THREE.MeshStandardMaterial({ 
                                    color: 0x2d2214,
                                    roughness: 0.95
                                })
                            );
                            gap.position.z = -2 + (i * (4 / (numPlanks - 1))) + plankWidth / 2;
                            gap.position.y = 0.051;
                            floorGroup.add(gap);
                        }
                    }
                    
                    // Support beams underneath  hang below planks, no clip
                    const beamMat = await createWoodMaterial(0x654321, 0.85);
                    for (let i = 0; i < 3; i++) {
                        const beam = new THREE.Mesh(
                            new THREE.BoxGeometry(0.15, 0.15, 4),
                            beamMat.clone()
                        );
                        beam.position.x = -1.5 + i * 1.5;
                        beam.position.y = -0.175;
                        beam.castShadow = true;
                        floorGroup.add(beam);
                    }
                    
                    floorGroup.userData.collisionBox = new THREE.Box3().setFromObject(floorGroup);
                    return floorGroup;
                }
            },
            stone_floor: {
                name: '\u2b1c Stone Floor',
                cost: { stone: 10 },
                create: async () => {
                    const floorGroup = new THREE.Group();
                    const stoneMat = await createStoneMaterial(0x808080, 0.9);
                    
                    // Create stone tiles in a pattern
                    const tileSize = 1.0;
                    const tilesPerRow = 4;
                    
                    for (let x = 0; x < tilesPerRow; x++) {
                        for (let z = 0; z < tilesPerRow; z++) {
                            const tile = new THREE.Mesh(
                                new THREE.BoxGeometry(tileSize - 0.05, 0.2, tileSize - 0.05),
                                stoneMat.clone()
                            );
                            tile.position.x = -2 + (x * tileSize) + tileSize / 2;
                            tile.position.z = -2 + (z * tileSize) + tileSize / 2;
                            tile.position.y = -0.05;
                            tile.receiveShadow = true;
                            tile.castShadow = true;
                            floorGroup.add(tile);
                        }
                    }
                    
                    // Grout lines between tiles
                    const groutMat = new THREE.MeshStandardMaterial({ 
                        color: 0x5a5a5a, 
                        roughness: 0.95 
                    });
                    
                    // Vertical grout lines  sit in gap between tiles, flush with tile top
                    for (let x = 1; x < tilesPerRow; x++) {
                        const grout = new THREE.Mesh(
                            new THREE.BoxGeometry(0.05, 0.21, 4),
                            groutMat
                        );
                        grout.position.x = -2 + (x * tileSize);
                        grout.position.y = -0.055;
                        floorGroup.add(grout);
                    }
                    
                    // Horizontal grout lines  flush with tile top
                    for (let z = 1; z < tilesPerRow; z++) {
                        const grout = new THREE.Mesh(
                            new THREE.BoxGeometry(4, 0.21, 0.05),
                            groutMat.clone()
                        );
                        grout.position.z = -2 + (z * tileSize);
                        grout.position.y = -0.055;
                        floorGroup.add(grout);
                    }
                    
                    floorGroup.userData.collisionBox = new THREE.Box3().setFromObject(floorGroup);
                    return floorGroup;
                }
            },
            metal_floor: {
                name: '\u2b1c Metal Floor',
                cost: { iron_ingot: 5 },
                create: async () => {
                    const floorGroup = new THREE.Group();
                    const metalMat = await createMetalMaterial(0xb8b8b8, 0.3);
                    
                    // Main metal platform
                    const platform = new THREE.Mesh(
                        new THREE.BoxGeometry(4, 0.15, 4),
                        metalMat
                    );
                    platform.position.y = -0.025;
                    platform.receiveShadow = true;
                    platform.castShadow = true;
                    floorGroup.add(platform);
                    
                    // Diamond plate pattern (raised bumps)
                    const bumpMat = await createMetalMaterial(0xc0c0c0, 0.35);
                    const bumpSize = 0.15;
                    const spacing = 0.3;
                    
                    for (let x = -2; x <= 2; x += spacing) {
                        for (let z = -2; z <= 2; z += spacing) {
                            // Offset every other row for diamond pattern
                            const offsetX = (Math.floor((z + 2) / spacing) % 2) * (spacing / 2);
                            const bump = new THREE.Mesh(
                                new THREE.BoxGeometry(bumpSize, 0.03, bumpSize),
                                bumpMat.clone()
                            );
                            bump.position.set(x + offsetX, 0.065, z);
                            bump.rotation.y = Math.PI / 4; // Rotate 45 degrees for diamond shape
                            floorGroup.add(bump);
                        }
                    }
                    
                    // Support beams underneath (cross pattern)
                    const beamMat = await createMetalMaterial(0x999999, 0.45);
                    
                    // Lengthwise beams  hang below platform, no clip
                    for (let i = 0; i < 3; i++) {
                        const beam = new THREE.Mesh(
                            new THREE.BoxGeometry(0.12, 0.12, 4),
                            beamMat.clone()
                        );
                        beam.position.x = -1.5 + i * 1.5;
                        beam.position.y = -0.16;
                        beam.castShadow = true;
                        floorGroup.add(beam);
                    }
                    
                    // Crosswise beams  hang below platform, no clip
                    for (let i = 0; i < 3; i++) {
                        const beam = new THREE.Mesh(
                            new THREE.BoxGeometry(4, 0.12, 0.12),
                            beamMat.clone()
                        );
                        beam.position.z = -1.5 + i * 1.5;
                        beam.position.y = -0.16;
                        beam.castShadow = true;
                        floorGroup.add(beam);
                    }
                    
                    floorGroup.userData.collisionBox = new THREE.Box3().setFromObject(floorGroup);
                    return floorGroup;
                }
            },
            ceiling: {
                name: '\ud83d\udfeb Wooden Ceiling',
                cost: { wood: 4 },
                create: async () => {
                    const ceiling = new THREE.Mesh(
                        new THREE.BoxGeometry(4, 0.2, 4),
                        new THREE.MeshStandardMaterial({
                            color: 0x8B7355,
                            roughness: 0.9
                        })
                    );
                    ceiling.receiveShadow = true;
                    ceiling.castShadow = true;
                    ceiling.userData.collisionBox = new THREE.Box3().setFromObject(ceiling);
                    return ceiling;
                }
            },
            stone_ceiling: {
                name: '\u2b1c Stone Ceiling',
                cost: { stone: 10 },
                create: async () => {
                    const ceiling = new THREE.Mesh(
                        new THREE.BoxGeometry(4, 0.25, 4),
                        createStoneMaterial(0x808080, 0.9)
                    );
                    ceiling.receiveShadow = true;
                    ceiling.castShadow = true;
                    ceiling.userData.collisionBox = new THREE.Box3().setFromObject(ceiling);
                    return ceiling;
                }
            },
            metal_ceiling: {
                name: '\u2b1c Metal Ceiling',
                cost: { iron_ingot: 5 },
                create: async () => {
                    const group = new THREE.Group();
                    const metalMat = await createMetalMaterial(0xb8b8b8, 0.3);
                    
                    // Main panel
                    const ceiling = new THREE.Mesh(
                        new THREE.BoxGeometry(4, 0.15, 4),
                        metalMat
                    );
                    ceiling.receiveShadow = true;
                    ceiling.castShadow = true;
                    group.add(ceiling);
                    
                    // Support beams
                    const beamMat = await createMetalMaterial(0x999999, 0.45);
                    for (let x of [-1.5, 0, 1.5]) {
                        const beam = new THREE.Mesh(
                            new THREE.BoxGeometry(0.12, 0.2, 4),
                            beamMat.clone()
                        );
                        beam.position.x = x;
                        beam.position.y = -0.025;
                        beam.castShadow = true;
                        group.add(beam);
                    }
                    
                    group.userData.collisionBox = new THREE.Box3().setFromObject(group);
                    return group;
                }
            },
            ladder_ceiling: {
                name: '\ud83e\ude9c Ladder Ceiling',
                cost: { wood: 3 },
                create: async () => {
                    const group = new THREE.Group();
                    
                    // Create ceiling with cutout at one edge (where ladder attaches to wall)
                    // Cutout is on one side (front edge), rest is solid
                    const ceilingMat = new THREE.MeshStandardMaterial({
                        color: 0x8B7355,
                        roughness: 0.9
                    });
                    
                    // Main ceiling piece (covers most of the area, leaves front edge open)
                    const mainPiece = new THREE.Mesh(
                        new THREE.BoxGeometry(4, 0.2, 2.75),
                        ceilingMat
                    );
                    mainPiece.position.set(0, 0, 0.625); // Shifted back to leave front edge open
                    mainPiece.receiveShadow = true;
                    mainPiece.castShadow = true;
                    group.add(mainPiece);
                    
                    // Left side piece (beside the cutout)
                    const leftPiece = new THREE.Mesh(
                        new THREE.BoxGeometry(1.25, 0.2, 1.25),
                        ceilingMat
                    );
                    leftPiece.position.set(-1.375, 0, -1.375);
                    leftPiece.receiveShadow = true;
                    leftPiece.castShadow = true;
                    group.add(leftPiece);
                    
                    // Right side piece (beside the cutout)
                    const rightPiece = new THREE.Mesh(
                        new THREE.BoxGeometry(1.25, 0.2, 1.25),
                        ceilingMat
                    );
                    rightPiece.position.set(1.375, 0, -1.375);
                    rightPiece.receiveShadow = true;
                    rightPiece.castShadow = true;
                    group.add(rightPiece);
                    
                    // This leaves a 1.5 unit wide cutout at the front edge (z=-2 to z=-0.75)
                    // Perfect for ladder access from the wall
                    
                    group.userData.isLadderCeiling = true;
                    group.userData.collisionBox = new THREE.Box3().setFromObject(group);
                    return group;
                }
            },
            stairs: {
                name: '\ud83e\ude9c Wooden Stairs',
                cost: { wood: 6 },
                create: async () => {
                    const stairs = new THREE.Group();
                    // Create 10 steps - each 0.3 units high, total 3 units (one floor height)
                    // Steps go from z=-2 to z=+2 (4 units total to reach next floor)
                    // Width: 2 units (narrower to not block walls)
                    const numSteps = 10;
                    const stepHeight = 0.3;
                    const stepDepth = 4 / numSteps; // 0.4 units per step
                    const stairWidth = 2; // Narrower stairs
                    
                    for (let i = 0; i < numSteps; i++) {
                        const step = new THREE.Mesh(
                            new THREE.BoxGeometry(stairWidth, stepHeight, stepDepth),
                            new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 })
                        );
                        // Position: start at z=-2, increment by stepDepth
                        // Height: start at 0, increment by stepHeight
                        step.position.set(
                            0, 
                            (i * stepHeight) + (stepHeight / 2), 
                            -2 + (i * stepDepth) + (stepDepth / 2)
                        );
                        step.castShadow = true;
                        step.receiveShadow = true;
                        stairs.add(step);
                    }
                    stairs.userData.isStairs = true;
                    stairs.userData.collisionBox = new THREE.Box3().setFromObject(stairs);
                    return stairs;
                }
            },
            stone_stairs: {
                name: '\ud83e\ude9c Stone Stairs',
                cost: { stone: 8 },
                create: async () => {
                    const stairs = new THREE.Group();
                    const stoneMat = await createStoneMaterial(0x808080, 0.9);
                    const numSteps = 10;
                    const stepHeight = 0.3;
                    const stepDepth = 4 / numSteps;
                    const stairWidth = 2;
                    
                    for (let i = 0; i < numSteps; i++) {
                        const step = new THREE.Mesh(
                            new THREE.BoxGeometry(stairWidth, stepHeight, stepDepth),
                            stoneMat.clone()
                        );
                        step.position.set(
                            0, 
                            (i * stepHeight) + (stepHeight / 2), 
                            -2 + (i * stepDepth) + (stepDepth / 2)
                        );
                        step.castShadow = true;
                        step.receiveShadow = true;
                        stairs.add(step);
                    }
                    stairs.userData.isStairs = true;
                    stairs.userData.collisionBox = new THREE.Box3().setFromObject(stairs);
                    return stairs;
                }
            },
            metal_stairs: {
                name: '\ud83e\ude9c Metal Stairs',
                cost: { iron_ingot: 4 },
                create: async () => {
                    const stairs = new THREE.Group();
                    const metalMat = await createMetalMaterial(0xb8b8b8, 0.3);
                    const numSteps = 10;
                    const stepHeight = 0.3;
                    const stepDepth = 4 / numSteps;
                    const stairWidth = 2;
                    
                    for (let i = 0; i < numSteps; i++) {
                        // Step platform
                        const step = new THREE.Mesh(
                            new THREE.BoxGeometry(stairWidth, 0.1, stepDepth),
                            metalMat.clone()
                        );
                        step.position.set(
                            0, 
                            (i * stepHeight) + stepHeight, 
                            -2 + (i * stepDepth) + (stepDepth / 2)
                        );
                        step.castShadow = true;
                        step.receiveShadow = true;
                        stairs.add(step);
                        
                        // Support beam
                        const supportMat = await createMetalMaterial(0x999999, 0.45);
                        const support = new THREE.Mesh(
                            new THREE.BoxGeometry(0.1, stepHeight, 0.1),
                            supportMat
                        );
                        support.position.set(
                            -0.8,
                            (i * stepHeight) + (stepHeight / 2),
                            -2 + (i * stepDepth) + (stepDepth / 2)
                        );
                        stairs.add(support);
                        
                        const support2 = new THREE.Mesh(
                            new THREE.BoxGeometry(0.1, stepHeight, 0.1),
                            supportMat.clone()
                        );
                        support2.position.set(
                            0.8,
                            (i * stepHeight) + (stepHeight / 2),
                            -2 + (i * stepDepth) + (stepDepth / 2)
                        );
                        stairs.add(support2);
                    }
                    stairs.userData.isStairs = true;
                    stairs.userData.collisionBox = new THREE.Box3().setFromObject(stairs);
                    return stairs;
                }
            },
            corner_stairs_left: {
                name: '\ud83e\ude9c Corner Stairs (Left)',
                cost: { wood: 10, stone: 3 },
                create: async () => {
                    const stairs = new THREE.Group();
                    // L-shaped stairs - narrower to not block walls
                    // Total height: 3 units (one floor), fits within floor tile
                    const totalSteps = 10;
                    const stepHeight = 0.3;
                    const stepDepth = 0.4;
                    const stairWidth = 1; // Narrower - was 2
                    
                    // First run - 5 steps going straight (forward in Z direction)
                    // Positioned to one side to leave room for walls
                    for (let i = 0; i < 5; i++) {
                        const step = new THREE.Mesh(
                            new THREE.BoxGeometry(stairWidth, stepHeight, stepDepth),
                            new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 })
                        );
                        step.position.set(
                            0.5, // Offset to right, leaving left side clear
                            (i * stepHeight) + (stepHeight / 2),
                            -2 + (i * stepDepth) + (stepDepth / 2)
                        );
                        step.castShadow = true;
                        step.receiveShadow = true;
                        stairs.add(step);
                    }
                    
                    // Corner platform - smaller and centered
                    const platform = new THREE.Mesh(
                        new THREE.BoxGeometry(1.2, stepHeight, 1.2),
                        new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 })
                    );
                    platform.position.set(
                        0,
                        (5 * stepHeight) + (stepHeight / 2),
                        0.1
                    );
                    platform.castShadow = true;
                    platform.receiveShadow = true;
                    stairs.add(platform);
                    
                    // Second run - 5 steps turning left (going in -X direction)
                    // Positioned to leave room for walls on the other side
                    for (let i = 0; i < 5; i++) {
                        const step = new THREE.Mesh(
                            new THREE.BoxGeometry(stepDepth, stepHeight, stairWidth),
                            new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 })
                        );
                        step.position.set(
                            -0.2 - (i * stepDepth) - (stepDepth / 2),
                            ((5 + i) * stepHeight) + (stepHeight / 2),
                            0.5 // Offset to keep it from blocking walls
                        );
                        step.castShadow = true;
                        step.receiveShadow = true;
                        stairs.add(step);
                    }
                    
                    stairs.userData.isStairs = true;
                    stairs.userData.isCornerStairs = true;
                    stairs.userData.collisionBox = new THREE.Box3().setFromObject(stairs);
                    return stairs;
                }
            },
            stone_corner_stairs_left: {
                name: '\ud83e\ude9c Stone Corner Stairs (Left)',
                cost: { stone: 8 },
                create: async () => {
                    const stairs = new THREE.Group();
                    const stoneMat = await createStoneMaterial(0x808080, 0.9);
                    const stepHeight = 0.3;
                    const stepDepth = 0.4;
                    const stairWidth = 1;
                    
                    // First run
                    for (let i = 0; i < 5; i++) {
                        const step = new THREE.Mesh(
                            new THREE.BoxGeometry(stairWidth, stepHeight, stepDepth),
                            stoneMat.clone()
                        );
                        step.position.set(
                            0.5,
                            (i * stepHeight) + (stepHeight / 2),
                            -2 + (i * stepDepth) + (stepDepth / 2)
                        );
                        step.castShadow = true;
                        step.receiveShadow = true;
                        stairs.add(step);
                    }
                    
                    // Platform
                    const platform = new THREE.Mesh(
                        new THREE.BoxGeometry(1.2, stepHeight, 1.2),
                        stoneMat.clone()
                    );
                    platform.position.set(0.1, 1.5 + stepHeight / 2, 0.1);
                    platform.castShadow = true;
                    platform.receiveShadow = true;
                    stairs.add(platform);
                    
                    // Second run (turning left - going in -X direction)
                    for (let i = 0; i < 4; i++) {
                        const step = new THREE.Mesh(
                            new THREE.BoxGeometry(stepDepth, stepHeight, stairWidth),
                            stoneMat.clone()
                        );
                        step.position.set(
                            -0.2 - (i * stepDepth) - (stepDepth / 2),
                            (6 + i) * stepHeight + (stepHeight / 2),
                            0.5
                        );
                        step.castShadow = true;
                        step.receiveShadow = true;
                        stairs.add(step);
                    }
                    
                    stairs.userData.isStairs = true;
                    stairs.userData.isCornerStairs = true;
                    stairs.userData.collisionBox = new THREE.Box3().setFromObject(stairs);
                    return stairs;
                }
            },
            metal_corner_stairs_left: {
                name: '\ud83e\ude9c Metal Corner Stairs (Left)',
                cost: { iron_ingot: 4 },
                create: async () => {
                    const stairs = new THREE.Group();
                    const metalMat = await createMetalMaterial(0xb8b8b8, 0.3);
                    const stepHeight = 0.3;
                    const stepDepth = 0.4;
                    const stairWidth = 1;
                    
                    // First run
                    for (let i = 0; i < 5; i++) {
                        const step = new THREE.Mesh(
                            new THREE.BoxGeometry(stairWidth, 0.1, stepDepth),
                            metalMat.clone()
                        );
                        step.position.set(
                            0.5,
                            (i * stepHeight) + stepHeight,
                            -2 + (i * stepDepth) + (stepDepth / 2)
                        );
                        step.castShadow = true;
                        step.receiveShadow = true;
                        stairs.add(step);
                    }
                    
                    // Platform
                    const platform = new THREE.Mesh(
                        new THREE.BoxGeometry(1.2, 0.1, 1.2),
                        metalMat.clone()
                    );
                    platform.position.set(0.1, 1.8, 0.1);
                    platform.castShadow = true;
                    platform.receiveShadow = true;
                    stairs.add(platform);
                    
                    // Second run (turning left - going in -X direction)
                    for (let i = 0; i < 4; i++) {
                        const step = new THREE.Mesh(
                            new THREE.BoxGeometry(stepDepth, 0.1, stairWidth),
                            metalMat.clone()
                        );
                        step.position.set(
                            -0.2 - (i * stepDepth) - (stepDepth / 2),
                            (6 + i) * stepHeight + stepHeight,
                            0.5
                        );
                        step.castShadow = true;
                        step.receiveShadow = true;
                        stairs.add(step);
                    }
                    
                    stairs.userData.isStairs = true;
                    stairs.userData.isCornerStairs = true;
                    stairs.userData.collisionBox = new THREE.Box3().setFromObject(stairs);
                    return stairs;
                }
            },
            corner_stairs_right: {
                name: '\ud83e\ude9c Corner Stairs (Right)',
                cost: { wood: 10, stone: 3 },
                create: async () => {
                    const stairs = new THREE.Group();
                    // L-shaped stairs - narrower to not block walls (mirrored from left)
                    // Total height: 3 units (one floor), fits within floor tile
                    const totalSteps = 10;
                    const stepHeight = 0.3;
                    const stepDepth = 0.4;
                    const stairWidth = 1; // Narrower - was 2
                    
                    // First run - 5 steps going straight (forward in Z direction)
                    // Positioned to one side to leave room for walls
                    for (let i = 0; i < 5; i++) {
                        const step = new THREE.Mesh(
                            new THREE.BoxGeometry(stairWidth, stepHeight, stepDepth),
                            new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 })
                        );
                        step.position.set(
                            -0.5, // Offset to left (opposite of left stairs)
                            (i * stepHeight) + (stepHeight / 2),
                            -2 + (i * stepDepth) + (stepDepth / 2)
                        );
                        step.castShadow = true;
                        step.receiveShadow = true;
                        stairs.add(step);
                    }
                    
                    // Corner platform - smaller and centered
                    const platform = new THREE.Mesh(
                        new THREE.BoxGeometry(1.2, stepHeight, 1.2),
                        new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 })
                    );
                    platform.position.set(
                        0,
                        (5 * stepHeight) + (stepHeight / 2),
                        0.1
                    );
                    platform.castShadow = true;
                    platform.receiveShadow = true;
                    stairs.add(platform);
                    
                    // Second run - 5 steps turning right (going in +X direction)
                    // Positioned to leave room for walls on the other side
                    for (let i = 0; i < 5; i++) {
                        const step = new THREE.Mesh(
                            new THREE.BoxGeometry(stepDepth, stepHeight, stairWidth),
                            new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 })
                        );
                        step.position.set(
                            0.2 + (i * stepDepth) + (stepDepth / 2),
                            ((5 + i) * stepHeight) + (stepHeight / 2),
                            0.5 // Offset to keep it from blocking walls
                        );
                        step.castShadow = true;
                        step.receiveShadow = true;
                        stairs.add(step);
                    }
                    
                    stairs.userData.isStairs = true;
                    stairs.userData.isCornerStairs = true;
                    stairs.userData.collisionBox = new THREE.Box3().setFromObject(stairs);
                    return stairs;
                }
            },
            stone_corner_stairs_right: {
                name: '\ud83e\ude9c Stone Corner Stairs (Right)',
                cost: { stone: 8 },
                create: async () => {
                    const stairs = new THREE.Group();
                    const stoneMat = await createStoneMaterial(0x808080, 0.9);
                    const stepHeight = 0.3;
                    const stepDepth = 0.4;
                    const stairWidth = 1;
                    
                    // First run
                    for (let i = 0; i < 5; i++) {
                        const step = new THREE.Mesh(
                            new THREE.BoxGeometry(stairWidth, stepHeight, stepDepth),
                            stoneMat.clone()
                        );
                        step.position.set(
                            -0.5,
                            (i * stepHeight) + (stepHeight / 2),
                            -2 + (i * stepDepth) + (stepDepth / 2)
                        );
                        step.castShadow = true;
                        step.receiveShadow = true;
                        stairs.add(step);
                    }
                    
                    // Platform
                    const platform = new THREE.Mesh(
                        new THREE.BoxGeometry(1.2, stepHeight, 1.2),
                        stoneMat.clone()
                    );
                    platform.position.set(-0.1, 1.5 + stepHeight / 2, 0.1);
                    platform.castShadow = true;
                    platform.receiveShadow = true;
                    stairs.add(platform);
                    
                    // Second run (turning right - going in +X direction)
                    for (let i = 0; i < 4; i++) {
                        const step = new THREE.Mesh(
                            new THREE.BoxGeometry(stepDepth, stepHeight, stairWidth),
                            stoneMat.clone()
                        );
                        step.position.set(
                            0.2 + (i * stepDepth) + (stepDepth / 2),
                            (6 + i) * stepHeight + (stepHeight / 2),
                            0.5
                        );
                        step.castShadow = true;
                        step.receiveShadow = true;
                        stairs.add(step);
                    }
                    
                    stairs.userData.isStairs = true;
                    stairs.userData.isCornerStairs = true;
                    stairs.userData.collisionBox = new THREE.Box3().setFromObject(stairs);
                    return stairs;
                }
            },
            metal_corner_stairs_right: {
                name: '\ud83e\ude9c Metal Corner Stairs (Right)',
                cost: { iron_ingot: 4 },
                create: async () => {
                    const stairs = new THREE.Group();
                    const metalMat = await createMetalMaterial(0xb8b8b8, 0.3);
                    const stepHeight = 0.3;
                    const stepDepth = 0.4;
                    const stairWidth = 1;
                    
                    // First run
                    for (let i = 0; i < 5; i++) {
                        const step = new THREE.Mesh(
                            new THREE.BoxGeometry(stairWidth, 0.1, stepDepth),
                            metalMat.clone()
                        );
                        step.position.set(
                            -0.5,
                            (i * stepHeight) + stepHeight,
                            -2 + (i * stepDepth) + (stepDepth / 2)
                        );
                        step.castShadow = true;
                        step.receiveShadow = true;
                        stairs.add(step);
                    }
                    
                    // Platform
                    const platform = new THREE.Mesh(
                        new THREE.BoxGeometry(1.2, 0.1, 1.2),
                        metalMat.clone()
                    );
                    platform.position.set(-0.1, 1.8, 0.1);
                    platform.castShadow = true;
                    platform.receiveShadow = true;
                    stairs.add(platform);
                    
                    // Second run (turning right - going in +X direction)
                    for (let i = 0; i < 4; i++) {
                        const step = new THREE.Mesh(
                            new THREE.BoxGeometry(stepDepth, 0.1, stairWidth),
                            metalMat.clone()
                        );
                        step.position.set(
                            0.2 + (i * stepDepth) + (stepDepth / 2),
                            (6 + i) * stepHeight + stepHeight,
                            0.5
                        );
                        step.castShadow = true;
                        step.receiveShadow = true;
                        stairs.add(step);
                    }
                    
                    stairs.userData.isStairs = true;
                    stairs.userData.isCornerStairs = true;
                    stairs.userData.collisionBox = new THREE.Box3().setFromObject(stairs);
                    return stairs;
                }
            },
            ladder: {
                name: '\ud83e\ude9c Ladder',
                cost: { wood: 4 },
                create: async () => {
                    const ladder = new THREE.Group();
                    
                    // Two vertical rails
                    const railGeo = new THREE.BoxGeometry(0.15, 3, 0.15);
                    const railMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 });
                    
                    const leftRail = new THREE.Mesh(railGeo, railMat);
                    leftRail.position.set(-0.4, 1.5, 0);
                    leftRail.castShadow = true;
                    leftRail.receiveShadow = true;
                    ladder.add(leftRail);
                    
                    const rightRail = new THREE.Mesh(railGeo, railMat);
                    rightRail.position.set(0.4, 1.5, 0);
                    rightRail.castShadow = true;
                    rightRail.receiveShadow = true;
                    ladder.add(rightRail);
                    
                    // Rungs (horizontal steps)
                    const rungGeo = new THREE.BoxGeometry(0.8, 0.1, 0.1);
                    const rungMat = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.9 });
                    
                    for (let i = 0; i < 8; i++) {
                        const rung = new THREE.Mesh(rungGeo, rungMat);
                        rung.position.set(0, 0.3 + (i * 0.4), 0);
                        rung.castShadow = true;
                        rung.receiveShadow = true;
                        ladder.add(rung);
                    }
                    
                    ladder.userData.isLadder = true;
                    ladder.userData.collisionBox = new THREE.Box3().setFromObject(ladder);
                    return ladder;
                }
            },
            workbench: {
                name: '\ud83d\udd27 Workbench',
                cost: { wood: 10, stone: 5 },
                create: async () => {
                    const workbench = new THREE.Group();

                    // Load GLB model from repo
                    await _loadAssetGLB('Workbench.glb');
                    const _glbInst = _instantiateGLB('Workbench.glb', 3.0);
                    if (_glbInst) workbench.add(_glbInst);

                    workbench.userData.isWorkbench = true;
                    return workbench;
                }
            },
            campfire: {
                name: '\ud83d\udd25 Campfire',
                cost: { wood: 5, stone: 3 },
                create: async () => {
                    const campfire = new THREE.Group();

                    // Load GLB model from repo
                    await _loadAssetGLB('camp fire.glb');
                    const _glbInst = _instantiateGLB('camp fire.glb', 1.0);
                    if (_glbInst) campfire.add(_glbInst);

                    campfire.userData.fireLight = null;
                    campfire.userData.fireGlow = null;
                    campfire.userData.particleTimer = 0;
                    campfire.userData.smokeTimer = 0;
                    campfire.userData.isCampfire = true;
                    campfire.userData.smeltingState = createSmeltingState(3000);
                    campfire.userData._smeltMs = 3000;
                    return campfire;
                }
            },
            cooking_station: {
                name: '\ud83c\udf73 Cooking Station',
                cost: { stone: 12, iron_ingot: 4, wood: 6 },
                create: async () => {
                    const oven = new THREE.Group();

                    // Load GLB model from repo
                    await _loadAssetGLB('cooking station.glb');
                    const _glbInst = _instantiateGLB('cooking station.glb', 3.0);
                    if (_glbInst) oven.add(_glbInst);

                    oven.userData.ovenDoor = null;
                    oven.userData.ovenGlow = null;
                    oven.userData.fireLight = null;
                    oven.userData.isCookingStation = true;
                    oven.userData.cookingState = createCookingStationState();
                    oven.userData.smokeTimer = 0;
                    return oven;
                }
            },
            sleeping_bag: {
                name: '\ud83d\udecf\ufe0f Sleeping Bag',
                cost: { fiber: 10, wood: 2 },
                create: async () => {
                    const bag = new THREE.Group();

                    //  Textures (cached in IndexedDB) 
                    async function makeBagTex() {
                        let cv = await textureCache.loadTexture('sb2_bag_tex');
                        if (!cv) {
                            textureCache.cacheStats.generated++;
                            cv = document.createElement('canvas'); cv.width = 256; cv.height = 256;
                            const ctx = cv.getContext('2d');
                            // Dark brown base
                            const g = ctx.createLinearGradient(0,0,0,256);
                            g.addColorStop(0, '#2a1a0e'); g.addColorStop(0.5,'#3a2410'); g.addColorStop(1,'#241508');
                            ctx.fillStyle = g; ctx.fillRect(0,0,256,256);
                            // Fabric micro-noise
                            for (let i=0;i<4000;i++) {
                                const a = Math.random()*0.07;
                                ctx.fillStyle = Math.random()>0.5 ? `rgba(255,200,150,${a})` : `rgba(0,0,0,${a})`;
                                ctx.fillRect(Math.random()*256, Math.random()*256, 1, Math.random()<0.3?2:1);
                            }
                            // Lengthwise quilted seam lines (3 channels = 2 seams + edges)
                            ctx.strokeStyle = 'rgba(0,0,0,0.55)'; ctx.lineWidth = 2.5;
                            [64, 128, 192].forEach(x => {
                                ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,256); ctx.stroke();
                            });
                            // Subtle cross-stitch dashes along seams
                            ctx.strokeStyle = 'rgba(80,50,20,0.4)'; ctx.lineWidth = 1; ctx.setLineDash([4,5]);
                            [64, 128, 192].forEach(x => {
                                ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,256); ctx.stroke();
                            });
                            ctx.setLineDash([]);
                            // Slight sheen along top of each channel
                            [32, 96, 160, 224].forEach(cx => {
                                const sh = ctx.createLinearGradient(cx-28,0,cx+28,0);
                                sh.addColorStop(0,'rgba(255,255,255,0)');
                                sh.addColorStop(0.5,'rgba(255,255,255,0.06)');
                                sh.addColorStop(1,'rgba(255,255,255,0)');
                                ctx.fillStyle = sh; ctx.fillRect(cx-28,0,56,256);
                            });
                            await textureCache.saveTexture('sb2_bag_tex', cv);
                        }
                        const t = new THREE.CanvasTexture(cv);
                        t.wrapS = t.wrapT = THREE.RepeatWrapping;
                        t.repeat.set(1, 1);
                        return t;
                    }

                    async function makePillowTex() {
                        let cv = await textureCache.loadTexture('sb2_pillow_tex');
                        if (!cv) {
                            textureCache.cacheStats.generated++;
                            cv = document.createElement('canvas'); cv.width = 128; cv.height = 128;
                            const ctx = cv.getContext('2d');
                            // Tan/beige fur-like pillow
                            const g = ctx.createLinearGradient(0,0,128,128);
                            g.addColorStop(0,'#c8a870'); g.addColorStop(0.5,'#b89460'); g.addColorStop(1,'#a88050');
                            ctx.fillStyle = g; ctx.fillRect(0,0,128,128);
                            // Fur texture strokes
                            ctx.strokeStyle = 'rgba(80,50,20,0.15)'; ctx.lineWidth = 1;
                            for (let i=0;i<80;i++) {
                                const x=Math.random()*128, y=Math.random()*128;
                                ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+(Math.random()-0.5)*8, y+4+Math.random()*6); ctx.stroke();
                            }
                            // Top sheen
                            const sh = ctx.createLinearGradient(0,0,0,50);
                            sh.addColorStop(0,'rgba(255,255,255,0.18)'); sh.addColorStop(1,'rgba(255,255,255,0)');
                            ctx.fillStyle = sh; ctx.fillRect(0,0,128,50);
                            await textureCache.saveTexture('sb2_pillow_tex', cv);
                        }
                        return new THREE.CanvasTexture(cv);
                    }

                    const bagTex    = await makeBagTex();
                    const pillowTex = await makePillowTex();

                    // Dark brown fabric material
                    const bagMat = new THREE.MeshStandardMaterial({
                        map: bagTex, roughness: 0.92, metalness: 0.0
                    });
                    // Slightly darker for the underside/base
                    const baseMat = new THREE.MeshStandardMaterial({
                        color: 0x1a0e06, roughness: 0.95, metalness: 0.0
                    });
                    // Black edge binding
                    const edgeMat = new THREE.MeshStandardMaterial({
                        color: 0x0a0a0a, roughness: 0.85, metalness: 0.0
                    });
                    const pillowMat = new THREE.MeshStandardMaterial({
                        map: pillowTex, roughness: 0.88, metalness: 0.0
                    });

                    //  Flat base pad (thin, lies on ground) 
                    const base = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.04, 0.88), baseMat);
                    base.position.set(0, 0.02, 0);
                    base.receiveShadow = true;
                    bag.add(base);

                    //  3 lengthwise puff channels 
                    // Each channel is a rounded box (cylinder rotated)  wide, flat, puffy
                    // Channels sit side by side along Z axis
                    const channelPositions = [-0.27, 0, 0.27]; // Z offsets for 3 channels
                    channelPositions.forEach((zOff, idx) => {
                        // Main channel body  CylinderGeometry lying on its side
                        const chGeo = new THREE.CylinderGeometry(0.13, 0.13, 1.82, 12, 1);
                        const ch = new THREE.Mesh(chGeo, bagMat);
                        ch.rotation.z = Math.PI / 2;
                        ch.position.set(0, 0.1, zOff);
                        ch.castShadow = true;
                        bag.add(ch);

                        // Foot taper  narrower cap at foot end
                        const taperGeo = new THREE.CylinderGeometry(0.07, 0.13, 0.18, 10, 1);
                        const taper = new THREE.Mesh(taperGeo, bagMat);
                        taper.rotation.z = Math.PI / 2;
                        taper.position.set(-0.98, 0.08, zOff);
                        taper.castShadow = true;
                        bag.add(taper);

                        // Head end cap (rounded)
                        const headCap = new THREE.Mesh(new THREE.SphereGeometry(0.13, 8, 6, 0, Math.PI), bagMat);
                        headCap.rotation.z = -Math.PI / 2;
                        headCap.position.set(0.91, 0.1, zOff);
                        bag.add(headCap);

                        // Foot end cap
                        const footCap = new THREE.Mesh(new THREE.SphereGeometry(0.07, 8, 6, 0, Math.PI), bagMat);
                        footCap.rotation.z = Math.PI / 2;
                        footCap.position.set(-1.05, 0.08, zOff);
                        bag.add(footCap);
                    });

                    //  Black perimeter binding 
                    // Long sides
                    const sideBindGeo = new THREE.BoxGeometry(2.1, 0.06, 0.04);
                    [-0.46, 0.46].forEach(z => {
                        const b = new THREE.Mesh(sideBindGeo, edgeMat);
                        b.position.set(0, 0.03, z);
                        bag.add(b);
                    });
                    // Short ends
                    const endBindGeo = new THREE.BoxGeometry(0.04, 0.06, 0.96);
                    [-1.03, 0.96].forEach(x => {
                        const b = new THREE.Mesh(endBindGeo, edgeMat);
                        b.position.set(x, 0.03, 0);
                        bag.add(b);
                    });

                    //  Zipper along right side (dark strip) 
                    const zipMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.6, metalness: 0.2 });
                    const zipStrip = new THREE.Mesh(new THREE.BoxGeometry(1.9, 0.03, 0.025), zipMat);
                    zipStrip.position.set(0, 0.165, 0.455);
                    bag.add(zipStrip);
                    // Zipper pull tab
                    const tabMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.3, metalness: 0.8 });
                    const tab = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.055, 0.02), tabMat);
                    tab.position.set(0.5, 0.15, 0.47);
                    bag.add(tab);

                    //  Small tan pillow at head end 
                    // Puffy pillow body
                    const pillowBody = new THREE.Mesh(new THREE.BoxGeometry(0.42, 0.09, 0.70), pillowMat);
                    pillowBody.position.set(0.82, 0.205, 0);
                    pillowBody.castShadow = true;
                    bag.add(pillowBody);
                    // Pillow rounded edges (4 quarter-cylinders)
                    const pillowEdgeMat = pillowMat;
                    const pEdgeGeo = new THREE.CylinderGeometry(0.045, 0.045, 0.42, 8);
                    [-0.35, 0.35].forEach(z => {
                        const pe = new THREE.Mesh(pEdgeGeo, pillowEdgeMat);
                        pe.rotation.z = Math.PI / 2;
                        pe.position.set(0.82, 0.205, z);
                        bag.add(pe);
                    });
                    // Pillow top puff (slight bulge)
                    const pillowPuff = new THREE.Mesh(new THREE.BoxGeometry(0.38, 0.04, 0.62), pillowMat);
                    pillowPuff.position.set(0.82, 0.26, 0);
                    bag.add(pillowPuff);

                    bag.userData.isSleepingBag = true;
                    bag.userData.collisionBox = new THREE.Box3().setFromObject(bag);
                    return bag;
                }
            },
            building_bench: {
                name: '\ud83e\ude9a Building Bench',
                create: async () => {
                    const bench = new THREE.Group();

                    // Load GLB model from repo
                    await _loadAssetGLB('Buillding table.glb');
                    const _glbInst = _instantiateGLB('Buillding table.glb', 3.0);
                    if (_glbInst) { _glbInst.rotation.y = Math.PI / 2; bench.add(_glbInst); }

                    bench.userData.isBuildingBench = true;
                    return bench;
                }
            },
            furnace: {
                name: '\ud83d\udd25 Furnace',
                create: async () => {
                    const furnace = new THREE.Group();

                    // Load GLB model from repo
                    await _loadAssetGLB('Furnace.glb');
                    const _glbInst = _instantiateGLB('Furnace.glb', 3.0);
                    if (_glbInst) furnace.add(_glbInst);

                    furnace.userData.doorOpening = null;
                    furnace.userData.fireGlow = null;
                    furnace.userData.fireLight = null;
                    furnace.userData.particleTimer = 0;
                    furnace.userData.smokeTimer = 0;
                    furnace.userData.isFurnace = true;
                    furnace.userData.smeltingState = createSmeltingState(5000);
                    furnace.userData._smeltMs = 5000;
                    return furnace;
                }
            },
            storage_box: {
                name: '\ud83d\udce6 Large Storage',
                cost: { wood: 8, stone: 2 },
                create: async () => {
                    const box = new THREE.Group();

                    await _loadAssetGLB('Large Storage.glb');
                    const _glbInst = _instantiateGLB('Large Storage.glb', 2.0);
                    if (_glbInst) box.add(_glbInst);

                    box.userData.isStorageBox = true;
                    box.userData.storageInventory = new Array(26).fill(null);
                    return box;
                }
            },
            small_storage_box: {
                name: '\ud83d\udce6 Small Storage',
                cost: { wood: 4, stone: 1 },
                create: async () => {
                    const box = new THREE.Group();

                    await _loadAssetGLB('small storage.glb');
                    const _glbInst = _instantiateGLB('small storage.glb', 0.75);
                    if (_glbInst) box.add(_glbInst);

                    box.userData.isStorageBox = true;
                    box.userData.isSmallStorage = true;
                    box.userData.storageInventory = new Array(14).fill(null);
                    return box;
                }
            },
            storage_shelf: {
                name: '\ud83d\udce6 Storage Shelf',
                cost: { iron_ingot: 4 },
                create: async () => {
                    const shelf = new THREE.Group();
                    
                    // Vertical supports (4 corners)
                    const supportGeo = new THREE.BoxGeometry(0.1, 2.0, 0.1);
                    const supportMat = new THREE.MeshStandardMaterial({ 
                        color: 0x888888,
                        metalness: 0.7,
                        roughness: 0.3
                    });
                    
                    [[-0.7, -0.7], [-0.7, 0.7], [0.7, -0.7], [0.7, 0.7]].forEach(([x, z]) => {
                        const support = new THREE.Mesh(supportGeo, supportMat);
                        support.position.set(x, 1.0, z);
                        support.castShadow = true;
                        shelf.add(support);
                    });
                    
                    // Two shelves
                    const shelfGeo = new THREE.BoxGeometry(1.6, 0.05, 1.6);
                    const shelfMat = new THREE.MeshStandardMaterial({ 
                        color: 0x666666,
                        metalness: 0.6,
                        roughness: 0.4
                    });
                    
                    [0.7, 1.4].forEach(y => {
                        const shelfPlate = new THREE.Mesh(shelfGeo, shelfMat);
                        shelfPlate.position.y = y;
                        shelfPlate.castShadow = true;
                        shelfPlate.receiveShadow = true;
                        shelf.add(shelfPlate);
                    });
                    
                    shelf.userData.isShelf = true;
                    
                    return shelf;
                }
            },
            wall_shelf: {
                name: '\ud83d\udce6 Wall Shelf',
                cost: { wood: 6, iron_ingot: 2 },
                create: async () => {
                    const ws = new THREE.Group();

                    await _loadAssetGLB('Wall Shelf.glb');
                    const _glbInst = _instantiateGLB('Wall Shelf.glb', 1.5);
                    if (_glbInst) ws.add(_glbInst);

                    ws.userData.isWallShelf = true;
                    return ws;
                }
            },
            planter_box: {
                name: '\ud83c\udf31 Planter Box (4 Slot)',
                cost: { wood: 12, stone: 4 },
                create: async () => {
                    return _buildPlanterMesh(2.2, 0.9, 4, [-0.75,-0.25,0.25,0.75], [0]);
                }
            },
            large_planter: {
                name: '\ud83c\udf31 Large Planter (12 Slot)',
                cost: { wood: 28, stone: 10 },
                create: async () => {
                    // 3 rows  4 columns, square box
                    const cols = 4, rows = 3;
                    const xPositions = [-0.82,-0.27,0.27,0.82];
                    const zPositions = [-0.42,0,0.42];
                    const slots = [];
                    for (let r=0; r<rows; r++) for (let c=0; c<cols; c++) slots.push({x:xPositions[c],z:zPositions[r]});
                    return _buildPlanterMesh(2.4, 1.4, 12, slots.map(s=>s.x), slots.map(s=>s.z));
                }
            },
            sewing_table: {
                name: '\ud83e\uddf5 Sewing Table',
                cost: { wood: 8, iron_ingot: 3 },
                create: async () => {
                    const table = new THREE.Group();

                    // Load GLB model from repo
                    await _loadAssetGLB('Sewing bench.glb');
                    const _glbInst = _instantiateGLB('Sewing bench.glb', 1.0);
                    if (_glbInst) table.add(_glbInst);

                    table.userData.isSewingTable = true;
                    return table;
                }
            },
            recycler: {
                name: '\u267b\ufe0f Recycler',
                cost: { iron_ingot: 15, wood: 5 },
                create: async () => {
                    const recycler = new THREE.Group();
                    
                    // Legs (4 corners)
                    const legGeo = new THREE.BoxGeometry(0.12, 1.0, 0.12);
                    const legMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.7 });
                    [[-0.9, -0.7], [0.9, -0.7], [-0.9, 0.7], [0.9, 0.7]].forEach(([x, z]) => {
                        const leg = new THREE.Mesh(legGeo, legMat);
                        leg.position.set(x, 0.5, z);
                        leg.castShadow = true;
                        recycler.add(leg);
                    });
                    
                    // Frame connecting legs (to prevent gaps)
                    const frameGeo = new THREE.BoxGeometry(2.0, 0.08, 1.6);
                    const frameMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.7 });
                    const lowerFrame = new THREE.Mesh(frameGeo, frameMat);
                    lowerFrame.position.y = 1.0;
                    lowerFrame.castShadow = true;
                    lowerFrame.receiveShadow = true;
                    recycler.add(lowerFrame);
                    
                    // Main body (green metal box)
                    const body = new THREE.Mesh(
                        new THREE.BoxGeometry(2.0, 0.6, 1.6),
                        new THREE.MeshStandardMaterial({ color: 0x4A6B3A, roughness: 0.6, metalness: 0.4 })
                    );
                    body.position.y = 1.3;
                    body.castShadow = true;
                    body.receiveShadow = true;
                    recycler.add(body);
                    
                    // Control panel (front side)
                    const panel = new THREE.Mesh(
                        new THREE.BoxGeometry(0.6, 0.4, 0.05),
                        new THREE.MeshStandardMaterial({ color: 0xBBBBBB, roughness: 0.4, metalness: 0.6 })
                    );
                    panel.position.set(0.3, 1.2, 0.82);
                    panel.castShadow = true;
                    recycler.add(panel);
                    
                    // Green indicator light on panel (will be used to show running state)
                    const light = new THREE.Mesh(
                        new THREE.CircleGeometry(0.05, 16),
                        new THREE.MeshBasicMaterial({ 
                            color: 0x00FF00,
                            side: THREE.DoubleSide
                        })
                    );
                    light.position.set(0.3, 1.3, 0.85);
                    light.visible = false; // Hidden by default, shown when running
                    recycler.add(light);
                    recycler.userData.statusLight = light; // Store reference
                    
                    // Hopper/funnel on top (yellow/gold)
                    const hopperBottom = new THREE.Mesh(
                        new THREE.BoxGeometry(1.8, 0.2, 1.4),
                        new THREE.MeshStandardMaterial({ color: 0xDAA520, roughness: 0.5 })
                    );
                    hopperBottom.position.y = 1.7;
                    hopperBottom.castShadow = true;
                    recycler.add(hopperBottom);
                    
                    // Hopper top (angled sides)
                    const hopperGeo = new THREE.CylinderGeometry(1.0, 0.9, 0.4, 4);
                    const hopperTop = new THREE.Mesh(
                        hopperGeo,
                        new THREE.MeshStandardMaterial({ color: 0xDAA520, roughness: 0.5 })
                    );
                    hopperTop.rotation.y = Math.PI / 4;
                    hopperTop.position.y = 2.0;
                    hopperTop.castShadow = true;
                    recycler.add(hopperTop);
                    
                    // Hopper opening cover (to prevent seeing inside body)
                    const hopperCover = new THREE.Mesh(
                        new THREE.BoxGeometry(1.7, 0.1, 1.3),
                        new THREE.MeshStandardMaterial({ color: 0x4A6B3A, roughness: 0.6 })
                    );
                    hopperCover.position.y = 1.65;
                    hopperCover.receiveShadow = true;
                    recycler.add(hopperCover);
                    
                    // Hopper grate/bars on top
                    const barMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8 });
                    for (let i = -0.6; i <= 0.6; i += 0.2) {
                        const bar = new THREE.Mesh(
                            new THREE.BoxGeometry(0.04, 0.02, 1.4),
                            barMat
                        );
                        bar.position.set(i, 2.21, 0);
                        recycler.add(bar);
                    }
                    
                    // Large wheel/drum on left side
                    const drum = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.35, 0.35, 0.3, 16),
                        new THREE.MeshStandardMaterial({ color: 0x5A6B4A, roughness: 0.5, metalness: 0.5 })
                    );
                    drum.rotation.z = Math.PI / 2;
                    drum.position.set(-1.1, 1.3, 0);
                    drum.castShadow = true;
                    recycler.add(drum);
                    
                    // Drum details
                    const drumDetail = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.3, 0.32, 16),
                        new THREE.MeshStandardMaterial({ color: 0x3A4A2A, roughness: 0.6 })
                    );
                    drumDetail.rotation.z = Math.PI / 2;
                    drumDetail.position.set(-1.1, 1.3, 0);
                    recycler.add(drumDetail);
                    
                    // Red valve/handle on drum
                    const valve = new THREE.Mesh(
                        new THREE.TorusGeometry(0.12, 0.03, 8, 16),
                        new THREE.MeshStandardMaterial({ color: 0xCC0000, roughness: 0.4, metalness: 0.7 })
                    );
                    valve.position.set(-1.25, 1.3, 0);
                    valve.castShadow = true;
                    recycler.add(valve);
                    
                    // Recycling symbol on side
                    const symbolBg = new THREE.Mesh(
                        new THREE.CircleGeometry(0.2, 16),
                        new THREE.MeshStandardMaterial({ 
                            color: 0xFFFFFF, 
                            roughness: 0.3,
                            side: THREE.DoubleSide
                        })
                    );
                    symbolBg.rotation.y = -Math.PI / 2; // Face outward
                    symbolBg.position.set(-0.3, 1.3, 0.81);
                    recycler.add(symbolBg);
                    
                    // Create recycling arrows (simplified triangles)
                    const arrowGeo = new THREE.ConeGeometry(0.08, 0.15, 3);
                    const arrowMat = new THREE.MeshStandardMaterial({ color: 0x2E7D32 });
                    for (let i = 0; i < 3; i++) {
                        const arrow = new THREE.Mesh(arrowGeo, arrowMat);
                        arrow.rotation.z = (i * Math.PI * 2 / 3) + Math.PI / 2;
                        arrow.position.set(-0.3 + Math.cos(i * Math.PI * 2 / 3) * 0.12, 1.3 + Math.sin(i * Math.PI * 2 / 3) * 0.12, 0.82);
                        recycler.add(arrow);
                    }
                    
                    // Outlet chute (bottom right)
                    const chute = new THREE.Mesh(
                        new THREE.BoxGeometry(0.3, 0.2, 0.3),
                        new THREE.MeshStandardMaterial({ color: 0x4A4A4A, roughness: 0.6, metalness: 0.5 })
                    );
                    chute.position.set(0.85, 0.9, 0.7);
                    chute.castShadow = true;
                    recycler.add(chute);
                    
                    recycler.userData.isRecycler = true;
                    recycler.userData.isProcessing = false;
                    recycler.userData.drum = drum; // Store reference for rotation animation
                    recycler.userData.hopper = hopperBottom; // Store reference for vibration
                    
                    return recycler;
                }
            },
            water_catcher: {
                name: ' Well',
                cost: { wood: 8, stone: 4, fiber: 6 },
                create: async () => {
                    const wcGroup = new THREE.Group();

                    // Load GLB model
                    await _loadAssetGLB('Well.glb');
                    const _glbInst = _instantiateGLB('Well.glb', 3.0);
                    if (_glbInst) {
                        // Fix overly dark materials  GLB has baked AO/vertex colours that
                        // make it appear almost black. Brighten each mesh material to match
                        // other placed objects in the scene.
                        _glbInst.traverse(c => {
                            if (!c.isMesh || !c.material) return;
                            const mats = Array.isArray(c.material) ? c.material : [c.material];
                            mats.forEach(mat => {
                                if (!mat) return;
                                // Lift the base colour towards a visible range
                                if (mat.color) {
                                    const hsl = {};
                                    mat.color.getHSL(hsl);
                                    // If lightness is below 0.25 the model will look black in scene lighting
                                    if (hsl.l < 0.25) mat.color.setHSL(hsl.h, hsl.s, Math.max(hsl.l * 3.5, 0.28));
                                }
                                // Kill baked AO that darkens everything
                                mat.aoMapIntensity = 0;
                                // Ensure roughness isn't absorbing all light
                                if (mat.roughness > 0.95) mat.roughness = 0.82;
                                mat.needsUpdate = true;
                            });
                        });
                        wcGroup.add(_glbInst);
                    }

                    wcGroup.userData.isWaterCatcher = true;
                    return wcGroup;
                }
            },
            floor_rug_red: {
                name: '\ud83d\udfe5 Red Floor Rug',
                cost: { fiber: 8 },
                create: async () => {
                    const group = new THREE.Group();
                    
                    // Main rug body with fabric texture
                    const rugMat = await createFabricMaterial(0xCC0000, 0.9);
                    const rug = new THREE.Mesh(
                        new THREE.PlaneGeometry(2, 3, 10, 15),
                        rugMat
                    );
                    rug.rotation.x = -Math.PI / 2;
                    rug.position.y = 0.01;
                    rug.receiveShadow = true;
                    
                    // Add slight bumps/waves to rug surface for realism
                    const positions = rug.geometry.attributes.position;
                    for (let i = 0; i < positions.count; i++) {
                        const x = positions.getX(i);
                        const y = positions.getY(i);
                        const wave = Math.sin(x * 3) * Math.sin(y * 2) * 0.015;
                        positions.setZ(i, wave);
                    }
                    rug.geometry.computeVertexNormals();
                    group.add(rug);
                    
                    // Braided/woven border
                    const borderThickness = 0.12;
                    const borderHeight = 0.02;
                    const borderMat = new THREE.MeshStandardMaterial({ 
                        color: 0x880000,
                        roughness: 0.85
                    });
                    
                    const borders = [
                        { w: 2, h: borderThickness, x: 0, z: -1.5 + borderThickness/2 },
                        { w: 2, h: borderThickness, x: 0, z: 1.5 - borderThickness/2 },
                        { w: borderThickness, h: 3, x: -1 + borderThickness/2, z: 0 },
                        { w: borderThickness, h: 3, x: 1 - borderThickness/2, z: 0 }
                    ];
                    
                    borders.forEach(b => {
                        const border = new THREE.Mesh(
                            new THREE.BoxGeometry(b.w, borderHeight, b.h),
                            borderMat.clone()
                        );
                        border.position.set(b.x, 0.025, b.z);
                        border.receiveShadow = true;
                        group.add(border);
                        
                        // Braided detail on border
                        const braidGeo = new THREE.BoxGeometry(b.w * 0.95, 0.01, b.h * 0.5);
                        const braid = new THREE.Mesh(braidGeo, borderMat.clone());
                        braid.position.set(b.x, 0.035, b.z);
                        group.add(braid);
                    });
                    
                    // Corner tassels
                    const tasselMat = new THREE.MeshStandardMaterial({ 
                        color: 0xFFD700,
                        roughness: 0.8
                    });
                    
                    const corners = [
                        [-1, -1.5], [1, -1.5], [-1, 1.5], [1, 1.5]
                    ];
                    
                    corners.forEach(([x, z]) => {
                        // Tassel bundle
                        for (let i = 0; i < 5; i++) {
                            const tasselGeo = new THREE.CylinderGeometry(0.008, 0.005, 0.12, 4);
                            const tassel = new THREE.Mesh(tasselGeo, tasselMat);
                            tassel.position.set(
                                x + (Math.random() - 0.5) * 0.03,
                                0.06,
                                z + (Math.random() - 0.5) * 0.03
                            );
                            tassel.rotation.x = Math.PI / 2;
                            tassel.rotation.z = Math.random() * 0.2 - 0.1;
                            group.add(tassel);
                        }
                        
                        // Knot at base of tassels
                        const knot = new THREE.Mesh(
                            new THREE.SphereGeometry(0.02, 6, 6),
                            tasselMat.clone()
                        );
                        knot.position.set(x, 0.015, z);
                        group.add(knot);
                    });
                    
                    // Decorative pattern - central medallion
                    const patternMat = new THREE.MeshStandardMaterial({ 
                        color: 0xFFD700,
                        roughness: 0.7,
                        metalness: 0.1
                    });
                    
                    // Center circle
                    const centerCircle = new THREE.Mesh(
                        new THREE.CircleGeometry(0.3, 16),
                        patternMat
                    );
                    centerCircle.rotation.x = -Math.PI / 2;
                    centerCircle.position.y = 0.03;
                    group.add(centerCircle);
                    
                    // Radiating diamond pattern around center
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const distance = 0.5;
                        const diamond = new THREE.Mesh(
                            new THREE.PlaneGeometry(0.15, 0.15),
                            patternMat.clone()
                        );
                        diamond.rotation.x = -Math.PI / 2;
                        diamond.rotation.z = Math.PI / 4;
                        diamond.position.set(
                            Math.cos(angle) * distance,
                            0.03,
                            Math.sin(angle) * distance
                        );
                        group.add(diamond);
                    }
                    
                    // Small decorative dots
                    for (let i = -1; i <= 1; i++) {
                        for (let j = -2; j <= 2; j++) {
                            if (Math.abs(i) + Math.abs(j) > 1 && Math.abs(i) + Math.abs(j) <= 2) {
                                const dot = new THREE.Mesh(
                                    new THREE.CircleGeometry(0.05, 8),
                                    patternMat.clone()
                                );
                                dot.rotation.x = -Math.PI / 2;
                                dot.position.set(i * 0.6, 0.03, j * 0.7);
                                group.add(dot);
                            }
                        }
                    }
                    
                    // Mark as non-collidable
                    group.userData.isWalkable = true;
                    group.userData.noCollision = true;
                    
                    return group;
                }
            },
            floor_rug_blue: {
                name: '\ud83d\udfe6 Blue Floor Rug',
                cost: { fiber: 8 },
                create: async () => {
                    const group = new THREE.Group();
                    
                    // Main rug body - blue
                    const rug = new THREE.Mesh(
                        new THREE.PlaneGeometry(2, 3),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x0066CC,
                            roughness: 0.9,
                            side: THREE.DoubleSide
                        })
                    );
                    rug.rotation.x = -Math.PI / 2;
                    rug.position.y = 0.01;
                    rug.receiveShadow = true;
                    group.add(rug);
                    
                    // Navy border
                    const borderThickness = 0.15;
                    const borders = [
                        { w: 2, h: borderThickness, x: 0, z: -1.5 + borderThickness/2 },
                        { w: 2, h: borderThickness, x: 0, z: 1.5 - borderThickness/2 },
                        { w: borderThickness, h: 3, x: -1 + borderThickness/2, z: 0 },
                        { w: borderThickness, h: 3, x: 1 - borderThickness/2, z: 0 }
                    ];
                    
                    borders.forEach(b => {
                        const border = new THREE.Mesh(
                            new THREE.PlaneGeometry(b.w, b.h),
                            new THREE.MeshStandardMaterial({ 
                                color: 0x003388,
                                roughness: 0.85,
                                side: THREE.DoubleSide
                            })
                        );
                        border.rotation.x = -Math.PI / 2;
                        border.position.set(b.x, 0.02, b.z);
                        border.receiveShadow = true;
                        group.add(border);
                    });
                    
                    // Decorative pattern - white stripes
                    const stripeGeo = new THREE.PlaneGeometry(1.5, 0.15);
                    const stripeMat = new THREE.MeshStandardMaterial({ 
                        color: 0xFFFFFF,
                        roughness: 0.8,
                        side: THREE.DoubleSide
                    });
                    
                    // Horizontal stripes
                    [-1, 0, 1].forEach(z => {
                        const stripe = new THREE.Mesh(stripeGeo, stripeMat);
                        stripe.rotation.x = -Math.PI / 2;
                        stripe.position.set(0, 0.03, z * 0.7);
                        stripe.receiveShadow = true;
                        group.add(stripe);
                    });
                    
                    group.userData.isWalkable = true;
                    group.userData.noCollision = true;
                    
                    return group;
                }
            },
            floor_rug_green: {
                name: '\ud83d\udfe9 Green Floor Rug',
                cost: { fiber: 8 },
                create: async () => {
                    const group = new THREE.Group();
                    
                    // Main rug body - green
                    const rug = new THREE.Mesh(
                        new THREE.PlaneGeometry(2, 3),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x00AA00,
                            roughness: 0.9,
                            side: THREE.DoubleSide
                        })
                    );
                    rug.rotation.x = -Math.PI / 2;
                    rug.position.y = 0.01;
                    rug.receiveShadow = true;
                    group.add(rug);
                    
                    // Dark green border
                    const borderThickness = 0.15;
                    const borders = [
                        { w: 2, h: borderThickness, x: 0, z: -1.5 + borderThickness/2 },
                        { w: 2, h: borderThickness, x: 0, z: 1.5 - borderThickness/2 },
                        { w: borderThickness, h: 3, x: -1 + borderThickness/2, z: 0 },
                        { w: borderThickness, h: 3, x: 1 - borderThickness/2, z: 0 }
                    ];
                    
                    borders.forEach(b => {
                        const border = new THREE.Mesh(
                            new THREE.PlaneGeometry(b.w, b.h),
                            new THREE.MeshStandardMaterial({ 
                                color: 0x006600,
                                roughness: 0.85,
                                side: THREE.DoubleSide
                            })
                        );
                        border.rotation.x = -Math.PI / 2;
                        border.position.set(b.x, 0.02, b.z);
                        border.receiveShadow = true;
                        group.add(border);
                    });
                    
                    // Decorative pattern - brown/tan circular pattern
                    const circleGeo = new THREE.CircleGeometry(0.2, 16);
                    const circleMat = new THREE.MeshStandardMaterial({ 
                        color: 0xD2691E,
                        roughness: 0.8,
                        side: THREE.DoubleSide
                    });
                    
                    // Grid of circles
                    for (let x = -0.6; x <= 0.6; x += 0.6) {
                        for (let z = -1.2; z <= 1.2; z += 0.6) {
                            const circle = new THREE.Mesh(circleGeo, circleMat);
                            circle.rotation.x = -Math.PI / 2;
                            circle.position.set(x, 0.03, z);
                            circle.receiveShadow = true;
                            group.add(circle);
                        }
                    }
                    
                    group.userData.isWalkable = true;
                    group.userData.noCollision = true;
                    
                    return group;
                }
            },
            curtain_red: {
                name: '\ud83d\udd34 Red Curtain',
                cost: { cloth: 2 },
                create: async () => {
                    const curtainGroup = new THREE.Group();
                    
                    // Fabric material with texture
                    const fabricMat = await createFabricMaterial(0xCC0000, 0.85);
                    
                    // Create left curtain panel with folds
                    const leftPanelGroup = new THREE.Group();
                    const numFolds = 5;
                    const foldWidth = 0.7 / numFolds;
                    
                    for (let i = 0; i < numFolds; i++) {
                        // Create curved fold segments
                        const foldGeo = new THREE.PlaneGeometry(foldWidth, 1.5, 1, 8);
                        const positions = foldGeo.attributes.position;
                        
                        // Apply wave/fold effect to vertices
                        for (let j = 0; j < positions.count; j++) {
                            const y = positions.getY(j);
                            const waveOffset = Math.sin((i + j * 0.1) * Math.PI) * 0.08;
                            positions.setZ(j, waveOffset);
                            
                            // Slight taper at bottom for draping effect
                            if (y < 0) {
                                const tapering = (y + 0.75) / 0.75;
                                positions.setX(j, positions.getX(j) * (0.9 + tapering * 0.1));
                            }
                        }
                        foldGeo.computeVertexNormals();
                        
                        const fold = new THREE.Mesh(foldGeo, fabricMat.clone());
                        fold.position.x = -0.35 + (i * foldWidth);
                        fold.castShadow = true;
                        fold.receiveShadow = true;
                        leftPanelGroup.add(fold);
                    }
                    
                    leftPanelGroup.position.set(-1.45, 0, 0);
                    curtainGroup.add(leftPanelGroup);
                    
                    // Create right curtain panel with folds (mirrored)
                    const rightPanelGroup = new THREE.Group();
                    for (let i = 0; i < numFolds; i++) {
                        const foldGeo = new THREE.PlaneGeometry(foldWidth, 1.5, 1, 8);
                        const positions = foldGeo.attributes.position;
                        
                        for (let j = 0; j < positions.count; j++) {
                            const y = positions.getY(j);
                            const waveOffset = Math.sin((i + j * 0.1) * Math.PI) * 0.08;
                            positions.setZ(j, -waveOffset); // Mirrored
                            
                            if (y < 0) {
                                const tapering = (y + 0.75) / 0.75;
                                positions.setX(j, positions.getX(j) * (0.9 + tapering * 0.1));
                            }
                        }
                        foldGeo.computeVertexNormals();
                        
                        const fold = new THREE.Mesh(foldGeo, fabricMat.clone());
                        fold.position.x = -0.35 + (i * foldWidth);
                        fold.castShadow = true;
                        fold.receiveShadow = true;
                        rightPanelGroup.add(fold);
                    }
                    
                    rightPanelGroup.position.set(1.45, 0, 0);
                    curtainGroup.add(rightPanelGroup);
                    
                    // Decorative hem at bottom
                    const hemMat = new THREE.MeshStandardMaterial({ 
                        color: 0x880000,
                        roughness: 0.7,
                        metalness: 0.1
                    });
                    
                    const leftHem = new THREE.Mesh(
                        new THREE.BoxGeometry(0.7, 0.05, 0.02),
                        hemMat
                    );
                    leftHem.position.set(-1.45, -0.77, 0);
                    curtainGroup.add(leftHem);
                    
                    const rightHem = new THREE.Mesh(
                        new THREE.BoxGeometry(0.7, 0.05, 0.02),
                        hemMat.clone()
                    );
                    rightHem.position.set(1.45, -0.77, 0);
                    curtainGroup.add(rightHem);
                    
                    // Curtain rod with decorative ends
                    const rodMat = await createMetalMaterial(0x7A7A7A, 0.3);
                    const rod = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.03, 0.03, 3.6, 12),
                        rodMat
                    );
                    rod.rotation.z = Math.PI / 2;
                    rod.position.y = 0.85;
                    curtainGroup.add(rod);
                    
                    // Decorative finials on rod ends
                    for (let x of [-1.9, 1.9]) {
                        const finial = new THREE.Mesh(
                            new THREE.SphereGeometry(0.06, 12, 12),
                            rodMat.clone()
                        );
                        finial.position.set(x, 0.85, 0);
                        curtainGroup.add(finial);
                    }
                    
                    // Curtain rings
                    const ringMat = await createMetalMaterial(0x555555, 0.4);
                    for (let i = 0; i < 7; i++) {
                        const ring = new THREE.Mesh(
                            new THREE.TorusGeometry(0.04, 0.01, 8, 12),
                            ringMat.clone()
                        );
                        ring.rotation.x = Math.PI / 2;
                        ring.position.set(-1.5 + i * 0.5, 0.85, 0);
                        curtainGroup.add(ring);
                    }
                    
                    return curtainGroup;
                }
            },
            curtain_blue: {
                name: '\ud83d\udd35 Blue Curtain',
                cost: { cloth: 2 },
                create: async () => {
                    const curtainGroup = new THREE.Group();
                    
                    const leftPanel = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.7, 1.5),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x0066CC,
                            roughness: 0.8,
                            side: THREE.DoubleSide
                        })
                    );
                    leftPanel.position.set(-1.45, 0, 0);
                    leftPanel.castShadow = true;
                    leftPanel.receiveShadow = true;
                    curtainGroup.add(leftPanel);
                    
                    const rightPanel = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.7, 1.5),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x0066CC,
                            roughness: 0.8,
                            side: THREE.DoubleSide
                        })
                    );
                    rightPanel.position.set(1.45, 0, 0);
                    rightPanel.castShadow = true;
                    rightPanel.receiveShadow = true;
                    curtainGroup.add(rightPanel);
                    
                    const rod = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.03, 0.03, 3.6, 8),
                        new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.7 })
                    );
                    rod.rotation.z = Math.PI / 2;
                    rod.position.y = 0.85;
                    curtainGroup.add(rod);
                    
                    return curtainGroup;
                }
            },
            curtain_green: {
                name: '\ud83d\udfe2 Green Curtain',
                cost: { cloth: 2 },
                create: async () => {
                    const curtainGroup = new THREE.Group();
                    
                    const leftPanel = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.7, 1.5),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x00AA00,
                            roughness: 0.8,
                            side: THREE.DoubleSide
                        })
                    );
                    leftPanel.position.set(-1.45, 0, 0);
                    leftPanel.castShadow = true;
                    leftPanel.receiveShadow = true;
                    curtainGroup.add(leftPanel);
                    
                    const rightPanel = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.7, 1.5),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x00AA00,
                            roughness: 0.8,
                            side: THREE.DoubleSide
                        })
                    );
                    rightPanel.position.set(1.45, 0, 0);
                    rightPanel.castShadow = true;
                    rightPanel.receiveShadow = true;
                    curtainGroup.add(rightPanel);
                    
                    const rod = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.03, 0.03, 3.6, 8),
                        new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.7 })
                    );
                    rod.rotation.z = Math.PI / 2;
                    rod.position.y = 0.85;
                    curtainGroup.add(rod);
                    
                    return curtainGroup;
                }
            },
            curtain_white: {
                name: '\u2b1c White Curtain',
                cost: { cloth: 2 },
                create: async () => {
                    const curtainGroup = new THREE.Group();
                    
                    const leftPanel = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.7, 1.5),
                        new THREE.MeshStandardMaterial({ 
                            color: 0xF5F5F5,
                            roughness: 0.8,
                            side: THREE.DoubleSide
                        })
                    );
                    leftPanel.position.set(-1.45, 0, 0);
                    leftPanel.castShadow = true;
                    leftPanel.receiveShadow = true;
                    curtainGroup.add(leftPanel);
                    
                    const rightPanel = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.7, 1.5),
                        new THREE.MeshStandardMaterial({ 
                            color: 0xF5F5F5,
                            roughness: 0.8,
                            side: THREE.DoubleSide
                        })
                    );
                    rightPanel.position.set(1.45, 0, 0);
                    rightPanel.castShadow = true;
                    rightPanel.receiveShadow = true;
                    curtainGroup.add(rightPanel);
                    
                    const rod = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.03, 0.03, 3.6, 8),
                        new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.7 })
                    );
                    rod.rotation.z = Math.PI / 2;
                    rod.position.y = 0.85;
                    curtainGroup.add(rod);
                    
                    return curtainGroup;
                }
            },
            curtain_beige: {
                name: '\ud83d\udfe4 Beige Curtain',
                cost: { cloth: 2 },
                create: async () => {
                    const curtainGroup = new THREE.Group();
                    
                    const leftPanel = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.7, 1.5),
                        new THREE.MeshStandardMaterial({ 
                            color: 0xD2B48C,
                            roughness: 0.8,
                            side: THREE.DoubleSide
                        })
                    );
                    leftPanel.position.set(-1.45, 0, 0);
                    leftPanel.castShadow = true;
                    leftPanel.receiveShadow = true;
                    curtainGroup.add(leftPanel);
                    
                    const rightPanel = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.7, 1.5),
                        new THREE.MeshStandardMaterial({ 
                            color: 0xD2B48C,
                            roughness: 0.8,
                            side: THREE.DoubleSide
                        })
                    );
                    rightPanel.position.set(1.45, 0, 0);
                    rightPanel.castShadow = true;
                    rightPanel.receiveShadow = true;
                    curtainGroup.add(rightPanel);
                    
                    const rod = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.03, 0.03, 3.6, 8),
                        new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.7 })
                    );
                    rod.rotation.z = Math.PI / 2;
                    rod.position.y = 0.85;
                    curtainGroup.add(rod);
                    
                    return curtainGroup;
                }
            }
        };
        
        function updateBuildingMenu() {
            const list = document.getElementById('building-list');
            list.innerHTML = '';
            
            // Group buildings by category
            const categories = {
                'Structure': [],
                'Doors & Frames': [],
                'Stairs & Ladders': [],
                'Crafting Stations': [],
                'Storage & Furniture': [],
                'Decorations': []
            };
            
            for (let id in buildingTypes) {
                const building = buildingTypes[id];
                
                let categoryName = 'Structure';
                if (id.includes('door') || id.includes('frame') || id.includes('window')) {
                    categoryName = 'Doors & Frames';
                } else if (id.includes('stairs') || id.includes('ladder')) {
                    categoryName = 'Stairs & Ladders';
                } else if (id === 'campfire' || id === 'workbench' || id === 'building_bench' || 
                           id === 'furnace' || id === 'sewing_table' || id === 'recycler') {
                    categoryName = 'Crafting Stations';
                } else if (id.includes('storage') || id === 'sleeping_bag' || id.includes('shelf')) {
                    categoryName = 'Storage & Furniture';
                } else if (id.includes('rug') || id.includes('curtain')) {
                    categoryName = 'Decorations';
                }
                
                categories[categoryName].push({ id, building });
            }
            
            // Create grid for each category
            for (let categoryName in categories) {
                if (categories[categoryName].length === 0) continue;
                
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'menu-category';
                
                const titleDiv = document.createElement('div');
                titleDiv.className = 'category-title';
                titleDiv.textContent = categoryName;
                categoryDiv.appendChild(titleDiv);
                
                const gridDiv = document.createElement('div');
                gridDiv.className = 'category-grid';
                
                categories[categoryName].forEach(({ id, building }) => {
                    const canBuild = Object.entries(building.cost).every(
                        ([resource, amount]) => inventory[resource] >= amount
                    );
                    
                    const item = document.createElement('div');
                    item.className = 'grid-item' + (canBuild ? '' : ' disabled');
                    
                    const icon = itemIcons[id] || '\u2753';
                    const costText = Object.entries(building.cost)
                        .map(([r, a]) => `${a} ${r}`)
                        .join(', ');
                    
                    item.innerHTML = `
                        <div class="grid-item-icon">${icon}</div>
                        <div class="grid-item-name">${building.name.replace(/^[^\s]+\s/, '')}</div>
                        <div class="grid-item-cost">${costText}</div>
                    `;
                    
                    if (canBuild) {
                        item.onclick = () => startBuilding(id);
                    }
                    
                    gridDiv.appendChild(item);
                });
                
                categoryDiv.appendChild(gridDiv);
                list.appendChild(categoryDiv);
            }
        }
        
        // Shared preview materials reused for every placement ghost
        const _previewMat = new THREE.MeshStandardMaterial({
            color: 0x00ff00, emissive: new THREE.Color(0x00ff00), emissiveIntensity: 0.3,
            transparent: true, opacity: 0.6, roughness: 0.7, metalness: 0.1, side: THREE.DoubleSide
        });
        const _previewMatStairs = new THREE.MeshStandardMaterial({
            color: 0x00ff00, emissive: new THREE.Color(0x00ff00), emissiveIntensity: 0.6,
            transparent: true, opacity: 0.8, roughness: 0.7, metalness: 0.1,
            side: THREE.DoubleSide, depthWrite: false
        });
        // Cached raycaster/vector  never allocate inside updateBuildPreview (60fps)
        const _buildRaycaster = new THREE.Raycaster();
        const _buildCenter    = new THREE.Vector2(0, 0);
        let   _buildFloorCache = null;
        let   _buildFloorLen   = -1;

        async function startBuilding(type) {
            buildMode = type;
            document.getElementById('build-info').style.display = 'block';
            document.getElementById('build-info').textContent = 'Left click to place, Right click/ESC to cancel, R to rotate';
            
            if (buildPreview) scene.remove(buildPreview);
            buildPreview = await buildAndPlaceModel(type);
            buildPreview.traverse((child) => {
                if (child.isMesh) {
                    child.userData.originalMaterial = child.material;
                    child.material = _previewMat;
                    child.renderOrder = 999;
                }
            });
            buildPreview.visible = true;
            scene.add(buildPreview);
        }
        
        function updateBuildPreview() {
            if (!buildMode || !buildPreview) return;
            
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(camera.quaternion);
            const distance = 5;
            
            let targetPos = camera.position.clone().add(forward.multiplyScalar(distance));
            let stairsHitSurface = null; // STAIRS ONLY: Track what surface was hit
            
            // For stairs and floor-placeable items, use raycast to find actual surface position
            if (buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right' || 
                buildMode === 'floor' || buildMode === 'ceiling' || 
                buildMode === 'campfire' || buildMode === 'workbench' || buildMode === 'furnace' || buildMode === 'cooking_station' ||
                buildMode === 'water_catcher' ||
                buildMode === 'storage_box' || buildMode === 'small_storage_box' || buildMode === 'sleeping_bag' || buildMode === 'building_bench' || buildMode === 'sewing_table' || buildMode === 'wall_shelf') {
                const raycaster = _buildRaycaster;
                raycaster.setFromCamera(_buildCenter, camera);
                if (!_buildFloorCache || _buildFloorLen !== buildings.length) {
                    _buildFloorCache = buildings.filter(b => isFloorOrCeiling(b.userData.buildingType));
                    _buildFloorLen = buildings.length;
                }
                const isBoxMode = buildMode === 'storage_box' || buildMode === 'small_storage_box';
                const shelfTargets = isBoxMode ? buildings.filter(b => b.userData.isShelf) : [];
                const buildingsToCheck = shelfTargets.length ? [..._buildFloorCache, ...shelfTargets] : _buildFloorCache;
                
                const intersects = raycaster.intersectObjects(buildingsToCheck, true);
                
                if (intersects.length > 0 && intersects[0].distance < 15) {
                    // Found a surface, use that position
                    targetPos = intersects[0].point.clone();
                    
                    // STAIRS ONLY: Track what was hit
                    if (buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') {
                        let hitObject = intersects[0].object;
                        while (hitObject.parent && !hitObject.userData.buildingType) {
                            hitObject = hitObject.parent;
                        }
                        stairsHitSurface = hitObject.userData.buildingType;
                    }
                } else {
                    // No building surface, check ground plane intersection
                    const groundY = 0;
                    if (forward.y < 0) { // Only if looking downward
                        const t = (groundY - camera.position.y) / forward.y;
                        if (t > 0 && t < 20) { // Within reasonable distance
                            targetPos = camera.position.clone().add(forward.clone().multiplyScalar(t));
                            targetPos.y = groundY;
                            if (buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') {
                                stairsHitSurface = 'ground';
                            }
                        }
                    }
                }
            }
            
            // Ensure preview is visible and in front of camera
            buildPreview.visible = true;
            
            // Rust-like snapping system
            if (snapToGrid) {
                const gridSize = 4; // 4-unit grid for walls/foundations
                
                // Find nearest building to snap to
                let bestSnap = null;
                let bestSnapDist = Infinity;
                
                for (let building of buildings) {
                    const buildingType = building.userData.buildingType;
                    const buildingRot = building.rotation.y;
                    
                    // Snap walls to walls, floors to floors
                    if (buildMode === 'wall' || buildMode === 'window_wall' || buildMode === 'door_frame' || 
                        buildMode === 'single_door_wall' || buildMode === 'double_door_wall') {
                        // Wall-to-wall snapping (walls are 4 units wide)
                        if (buildingType === 'wall' || buildingType === 'window_wall' || buildingType === 'door_frame' ||
                            buildingType === 'single_door_wall' || buildingType === 'double_door_wall') {
                            // Calculate direction based on rotation
                            const rotNormalized = buildingRot % (Math.PI * 2);
                            
                            let snapPositions = [];
                            
                            // If wall is horizontal (facing N/S)
                            if (Math.abs(Math.sin(rotNormalized)) < 0.5) {
                                snapPositions = [
                                    { x: building.position.x + 4, z: building.position.z, rot: buildingRot },     // Right
                                    { x: building.position.x - 4, z: building.position.z, rot: buildingRot },     // Left
                                    // Perpendicular snaps
                                    { x: building.position.x + 2, z: building.position.z + 2, rot: buildingRot + Math.PI / 2 },
                                    { x: building.position.x - 2, z: building.position.z + 2, rot: buildingRot + Math.PI / 2 },
                                    { x: building.position.x + 2, z: building.position.z - 2, rot: buildingRot + Math.PI / 2 },
                                    { x: building.position.x - 2, z: building.position.z - 2, rot: buildingRot + Math.PI / 2 }
                                ];
                            } else {
                                // Wall is vertical (facing E/W)
                                snapPositions = [
                                    { x: building.position.x, z: building.position.z + 4, rot: buildingRot },     // Front
                                    { x: building.position.x, z: building.position.z - 4, rot: buildingRot },     // Back
                                    // Perpendicular snaps
                                    { x: building.position.x + 2, z: building.position.z + 2, rot: buildingRot - Math.PI / 2 },
                                    { x: building.position.x + 2, z: building.position.z - 2, rot: buildingRot - Math.PI / 2 },
                                    { x: building.position.x - 2, z: building.position.z + 2, rot: buildingRot - Math.PI / 2 },
                                    { x: building.position.x - 2, z: building.position.z - 2, rot: buildingRot - Math.PI / 2 }
                                ];
                            }
                            
                            for (let snap of snapPositions) {
                                const dist = Math.sqrt(Math.pow(targetPos.x - snap.x, 2) + Math.pow(targetPos.z - snap.z, 2));
                                if (dist < bestSnapDist && dist < 6) {
                                    bestSnapDist = dist;
                                    bestSnap = {
                                        x: snap.x,
                                        z: snap.z,
                                        y: building.position.y,
                                        rotation: snap.rot
                                    };
                                }
                            }
                            
                            // Vertical wall stacking - walls can stack directly above other walls with ceiling in between
                            const horizDist = Math.sqrt(
                                Math.pow(targetPos.x - building.position.x, 2) + 
                                Math.pow(targetPos.z - building.position.z, 2)
                            );
                            // If placing directly above this wall (same X/Z position)
                            if (horizDist < 2.0) {
                                // Look for any ceiling above this wall
                                let ceilingAbove = null;
                                let closestCeilingDist = Infinity;
                                
                                for (let otherBuilding of buildings) {
                                    if (otherBuilding.userData.buildingType === 'ceiling') {
                                        // Check if ceiling is above this wall
                                        if (otherBuilding.position.y > building.position.y + 1.0) {
                                            // Check if ceiling is near this wall's X/Z position
                                            const ceilingHorizDist = Math.sqrt(
                                                Math.pow(building.position.x - otherBuilding.position.x, 2) + 
                                                Math.pow(building.position.z - otherBuilding.position.z, 2)
                                            );
                                            if (ceilingHorizDist < 3) {
                                                const vertDist = otherBuilding.position.y - building.position.y;
                                                if (vertDist < closestCeilingDist) {
                                                    closestCeilingDist = vertDist;
                                                    ceilingAbove = otherBuilding;
                                                }
                                            }
                                        }
                                    }
                                }
                                
                                // If found ceiling above, snap new wall to sit on it
                                if (ceilingAbove && horizDist < bestSnapDist) {
                                    bestSnapDist = horizDist;
                                    bestSnap = {
                                        x: building.position.x,
                                        z: building.position.z,
                                        y: ceilingAbove.position.y + 0.1 + 1.5, // Ceiling Y + thickness + half wall height
                                        rotation: building.rotation.y
                                    };
                                }
                            }
                        }
                        
                        // Wall-to-floor/ceiling edge snapping (floors/ceilings are 4x4)
                        if (isFloorOrCeiling(buildingType)) {
                            // Snap to floor/ceiling edges - walls sit exactly at edge
                            const edgePositions = [
                                { x: building.position.x + 2, z: building.position.z, rot: Math.PI / 2 },      // East edge
                                { x: building.position.x - 2, z: building.position.z, rot: Math.PI / 2 },      // West edge
                                { x: building.position.x, z: building.position.z + 2, rot: 0 },                // South edge
                                { x: building.position.x, z: building.position.z - 2, rot: 0 }                 // North edge
                            ];
                            
                            for (let snap of edgePositions) {
                                const dist = Math.sqrt(Math.pow(targetPos.x - snap.x, 2) + Math.pow(targetPos.z - snap.z, 2));
                                if (dist < bestSnapDist && dist < 6) {
                                    bestSnapDist = dist;
                                    let wallY;
                                    if (buildingType === 'ceiling') {
                                        // For ceilings, walls sit on top (ceiling is the floor of upper level)
                                        wallY = building.position.y + 0.1 + 1.5; // Ceiling Y + ceiling thickness + half wall height
                                    } else {
                                        // For floors, walls sit on top
                                        wallY = building.position.y + 0.1 + 1.5; // Floor Y + floor thickness + half wall height
                                    }
                                    bestSnap = {
                                        x: snap.x,
                                        z: snap.z,
                                        y: wallY,
                                        rotation: snap.rot
                                    };
                                }
                            }
                        }
                    } else if (buildMode === 'floor') {
                        // Floor-to-floor and floor-to-ceiling snapping (4x4 floors)
                        if (isFloorOrCeiling(buildingType)) {
                            // Horizontal snapping (same level)
                            const snapPositions = [
                                { x: building.position.x + 4, z: building.position.z, y: building.position.y },
                                { x: building.position.x - 4, z: building.position.z, y: building.position.y },
                                { x: building.position.x, z: building.position.z + 4, y: building.position.y },
                                { x: building.position.x, z: building.position.z - 4, y: building.position.y }
                            ];
                            
                            // Add vertical stacking - floor directly above ceiling (for multi-story)
                            if (buildingType.includes('ceiling')) {
                                snapPositions.push(
                                    { x: building.position.x, z: building.position.z, y: building.position.y + 3.2 } // Place floor above ceiling
                                );
                            }
                            
                            for (let snap of snapPositions) {
                                const dist = Math.sqrt(
                                    Math.pow(targetPos.x - snap.x, 2) + 
                                    Math.pow(targetPos.z - snap.z, 2) +
                                    Math.pow(targetPos.y - snap.y, 2) * 0.5 // Vertical distance matters less
                                );
                                if (dist < bestSnapDist && dist < 6) {
                                    bestSnapDist = dist;
                                    bestSnap = {
                                        x: snap.x,
                                        z: snap.z,
                                        y: snap.y,
                                        rotation: building.rotation.y
                                    };
                                }
                            }
                        }
                    } else if (buildMode === 'ceiling') {
                        // Ceiling-to-ceiling horizontal snapping (same height level)
                        if (buildingType === 'ceiling') {
                            const snapPositions = [
                                { x: building.position.x + 4, z: building.position.z },
                                { x: building.position.x - 4, z: building.position.z },
                                { x: building.position.x, z: building.position.z + 4 },
                                { x: building.position.x, z: building.position.z - 4 }
                            ];
                            
                            for (let snap of snapPositions) {
                                const dist = Math.sqrt(Math.pow(targetPos.x - snap.x, 2) + Math.pow(targetPos.z - snap.z, 2));
                                if (dist < bestSnapDist && dist < 6) {
                                    bestSnapDist = dist;
                                    bestSnap = {
                                        x: snap.x,
                                        z: snap.z,
                                        y: building.position.y, // Keep same height as existing ceiling
                                        rotation: 0
                                    };
                                }
                            }
                        }
                        // Ceiling snaps to wall tops  ceiling panel centre sits directly above the wall centre
                        if (buildingType === 'wall' || buildingType === 'window_wall' ||
                            buildingType === 'door_frame' || buildingType === 'single_door_wall' ||
                            buildingType === 'double_door_wall') {
                            const wallRot = building.rotation.y;
                            const rotNorm = wallRot % (Math.PI * 2);
                            // Ceiling snaps centred on the wall position (wall edge = ceiling edge)
                            // Offer two ceiling panel centres: one on each side of the wall
                            let offX, offZ;
                            if (Math.abs(Math.sin(rotNorm)) < 0.5) {
                                // Wall faces N/S  offset along Z
                                offX = 0; offZ = 2;
                            } else {
                                // Wall faces E/W  offset along X
                                offX = 2; offZ = 0;
                            }
                            const ceilY = building.position.y + 1.6;
                            const snapPositions = [
                                { x: building.position.x + offX, z: building.position.z + offZ, y: ceilY },
                                { x: building.position.x - offX, z: building.position.z - offZ, y: ceilY }
                            ];
                            for (let snap of snapPositions) {
                                const dist = Math.sqrt(Math.pow(targetPos.x - snap.x, 2) + Math.pow(targetPos.z - snap.z, 2));
                                if (dist < bestSnapDist && dist < 4) {
                                    bestSnapDist = dist;
                                    bestSnap = { x: snap.x, z: snap.z, y: snap.y, rotation: 0 };
                                }
                            }
                        }
                    } else if (buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') {
                        // STAIRS: Snap to 2-unit grid for clean alignment
                        if (isFloorOrCeiling(buildingType)) {
                            const dist = Math.sqrt(
                                Math.pow(targetPos.x - building.position.x, 2) + 
                                Math.pow(targetPos.z - building.position.z, 2)
                            );
                            if (dist < 5) {
                                // Snap to 2-unit grid
                                const stairGrid = 2;
                                const snappedX = Math.round(targetPos.x / stairGrid) * stairGrid;
                                const snappedZ = Math.round(targetPos.z / stairGrid) * stairGrid;
                                
                                bestSnap = {
                                    x: snappedX,
                                    z: snappedZ,
                                    y: building.position.y,
                                    rotation: buildRotation,
                                    snapToCeiling: buildingType === 'ceiling',
                                    ceilingRef: buildingType === 'ceiling' ? building : null
                                };
                            }
                        }
                    }
                }
                
                // Apply best snap if found
                if (bestSnap) {
                    targetPos.x = bestSnap.x;
                    targetPos.z = bestSnap.z;
                    targetPos.y = bestSnap.y;
                    buildRotation = bestSnap.rotation;
                } else if (buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') {
                    // STAIRS: Always snap to grid
                    const stairGrid = 2;
                    targetPos.x = Math.round(targetPos.x / stairGrid) * stairGrid;
                    targetPos.z = Math.round(targetPos.z / stairGrid) * stairGrid;
                } else if (buildMode === 'storage_box' || buildMode === 'small_storage_box') {
                    // Storage boxes: shelf snap handles positioning  skip grid snap
                } else if (buildMode === 'ceiling' || buildMode === 'ladder_ceiling') {
                    // Ceiling centres sit at half-grid offset (wall grid is 0,4,8  ceiling centres at 2,6,10)
                    targetPos.x = Math.round((targetPos.x - 2) / gridSize) * gridSize + 2;
                    targetPos.z = Math.round((targetPos.z - 2) / gridSize) * gridSize + 2;
                } else {
                    // No snap point found, use grid snapping
                    targetPos.x = Math.round(targetPos.x / gridSize) * gridSize;
                    targetPos.z = Math.round(targetPos.z / gridSize) * gridSize;
                }
            }
            
            buildPreview.position.copy(targetPos);
            
            // Check if there's a floor underneath to snap to
            let floorHeight = 0;
            let onFloor = false;
            
            // STAIRS: Use raycast hit surface
            if ((buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') && stairsHitSurface === 'floor') {
                onFloor = true;
                for (let building of buildings) {
                    if (building.userData.buildingType && building.userData.buildingType.includes('floor')) {
                        const floorBox = new THREE.Box3().setFromObject(building);
                        if (targetPos.x >= floorBox.min.x && targetPos.x <= floorBox.max.x &&
                            targetPos.z >= floorBox.min.z && targetPos.z <= floorBox.max.z) {
                            floorHeight = floorBox.max.y;
                            break;
                        }
                    }
                }
            } else if (buildMode !== 'stairs' && buildMode !== 'corner_stairs_left' && buildMode !== 'corner_stairs_right') {
                // Non-stairs: Original detection
                for (let building of buildings) {
                    if (building.userData.buildingType && building.userData.buildingType.includes('floor')) {
                        const floorBox = new THREE.Box3().setFromObject(building);
                        // Check if preview is above this floor
                        if (targetPos.x >= floorBox.min.x && targetPos.x <= floorBox.max.x &&
                            targetPos.z >= floorBox.min.z && targetPos.z <= floorBox.max.z) {
                            floorHeight = floorBox.max.y;
                            onFloor = true;
                        }
                    }
                }
            }
            
            // Universal ceiling detection - check if there's a ceiling below target position
            let ceilingBelow = null;
            
            // STAIRS: Use raycast hit surface
            if ((buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') && stairsHitSurface === 'ceiling') {
                for (let building of buildings) {
                    if (building.userData.buildingType === 'ceiling') {
                        const ceilingBox = new THREE.Box3().setFromObject(building);
                        if (targetPos.x >= ceilingBox.min.x && targetPos.x <= ceilingBox.max.x &&
                            targetPos.z >= ceilingBox.min.z && targetPos.z <= ceilingBox.max.z) {
                            ceilingBelow = building;
                            break;
                        }
                    }
                }
            } else if (buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') {
                // STAIRS but didn't hit ceiling - no ceiling
                ceilingBelow = null;
            } else {
                // Non-stairs: Original detection
                // STAIRS FIX: Skip ceiling detection if raycast already hit a floor
                const stairsHitFloor = ((buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') && onFloor);
                
                // First check if stairs snapped to a ceiling edge
                if ((buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') && bestSnap && bestSnap.snapToCeiling && bestSnap.ceilingRef) {
                    ceilingBelow = bestSnap.ceilingRef;
                } else if (!stairsHitFloor) {
                    // Regular ceiling detection (skip for stairs that hit floor)
                    for (let building of buildings) {
                        if (building.userData.buildingType === 'ceiling') {
                            const ceilingBox = new THREE.Box3().setFromObject(building);
                            // Check if target position is within or above this ceiling (horizontally aligned)
                            if (targetPos.x >= ceilingBox.min.x && targetPos.x <= ceilingBox.max.x &&
                                targetPos.z >= ceilingBox.min.z && targetPos.z <= ceilingBox.max.z &&
                                targetPos.y >= ceilingBox.min.y - 2) { // Allow pointing AT or ABOVE ceiling (2 units below to 100 units above)
                                // Found a ceiling at/below target - use the highest one
                                if (!ceilingBelow || building.position.y > ceilingBelow.position.y) {
                                    ceilingBelow = building;
                                }
                            }
                        }
                    }
                }
            }
            const ceilingHeight = ceilingBelow ? ceilingBelow.position.y + 0.1 : 0;
            const onCeiling = ceilingBelow !== null;
            
            // Set height based on building type and whether on floor or ceiling
            if (buildMode === 'floor') {
                // Floors can clip into terrain, stay at ground level
                buildPreview.position.y = 0.1;
            } else if (buildMode === 'ceiling' || buildMode === 'ladder_ceiling') {
                // Ceilings and ladder_ceilings place based on surrounding structures - check for highest relevant level
                // First check if already on a ceiling (for stacking multiple stories)
                if (onCeiling) {
                    // Already on a ceiling, check for walls at this level
                    let wallAtThisLevel = null;
                    let highestWallY = 0;
                    
                    for (let building of buildings) {
                        if (building.userData.buildingType === 'wall' || 
                            building.userData.buildingType === 'window_wall' || 
                            building.userData.buildingType === 'door_frame' ||
                            building.userData.buildingType === 'single_door_wall' ||
                            building.userData.buildingType === 'double_door_wall') {
                            const dist = Math.sqrt(
                                Math.pow(targetPos.x - building.position.x, 2) + 
                                Math.pow(targetPos.z - building.position.z, 2)
                            );
                            // Look for walls near this position and at the ceiling level or above
                            if (dist < 4 && building.position.y >= ceilingHeight) {
                                if (building.position.y > highestWallY) {
                                    highestWallY = building.position.y;
                                    wallAtThisLevel = building;
                                }
                            }
                        }
                    }
                    
                    if (wallAtThisLevel) {
                        // Place ceiling at top of these upper-level walls
                        buildPreview.position.y = wallAtThisLevel.position.y + 1.6;
                    } else {
                        // No walls at this level, place 3 units above the existing ceiling
                        buildPreview.position.y = ceilingHeight + 3.0;
                    }
                } else if (onFloor) {
                    // On a floor, place 3 units above
                    buildPreview.position.y = floorHeight + 3.0;
                } else {
                    // No floor/ceiling detected, check for walls nearby
                    let wallFound = false;
                    for (let building of buildings) {
                        if (building.userData.buildingType === 'wall' || 
                            building.userData.buildingType === 'window_wall' || 
                            building.userData.buildingType === 'door_frame' ||
                            building.userData.buildingType === 'single_door_wall' ||
                            building.userData.buildingType === 'double_door_wall') {
                            const dist = Math.sqrt(
                                Math.pow(targetPos.x - building.position.x, 2) + 
                                Math.pow(targetPos.z - building.position.z, 2)
                            );
                            if (dist < 4) {
                                buildPreview.position.y = building.position.y + 1.6;
                                wallFound = true;
                                break;
                            }
                        }
                    }
                    if (!wallFound) {
                        // No structures nearby, use default ceiling height
                        buildPreview.position.y = 3.1;
                    }
                }
            } else if (buildMode === 'door') {
                // Doors check for door frames to snap to
                let snappedToFrame = false;
                let closestFrame = null;
                let closestDist = Infinity;
                
                // First try raycasting to see if looking at a door frame
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                const doorFrames = buildings.filter(b => b.userData.isDoorFrame);
                const intersects = raycaster.intersectObjects(doorFrames, true);
                
                if (intersects.length > 0 && intersects[0].distance < 10) {
                    // Found a door frame we're looking at
                    let frameBuilding = intersects[0].object;
                    while (frameBuilding.parent && !frameBuilding.userData.isDoorFrame) {
                        frameBuilding = frameBuilding.parent;
                    }
                    
                    if (frameBuilding.userData.isDoorFrame) {
                        closestFrame = frameBuilding;
                        snappedToFrame = true;
                    }
                }
                
                // If raycast didn't work, find closest door frame within range
                if (!snappedToFrame) {
                    for (let building of buildings) {
                        if (building.userData.isDoorFrame) {
                            const dist = Math.sqrt(
                                Math.pow(targetPos.x - building.position.x, 2) + 
                                Math.pow(targetPos.z - building.position.z, 2)
                            );
                            if (dist < 5 && dist < closestDist) { // Check within 5 units
                                closestDist = dist;
                                closestFrame = building;
                                snappedToFrame = true;
                            }
                        }
                    }
                }
                
                if (snappedToFrame && closestFrame) {
                    // Snap to the closest door frame
                    buildPreview.position.x = closestFrame.position.x;
                    buildPreview.position.z = closestFrame.position.z;
                    buildPreview.position.y = closestFrame.position.y;
                    // Door needs to be perpendicular to frame to fill the opening (90 degrees)
                    buildPreview.rotation.y = closestFrame.rotation.y + Math.PI / 2;
                } else {
                    // No frame, place at floor or ground level
                    if (onFloor) {
                        buildPreview.position.y = floorHeight + 1.4;
                    } else {
                        buildPreview.position.y = 1.4;
                    }
                }
            } else if (buildMode === 'door_frame' || buildMode === 'double_door_frame') {
                // Door frames sit on floor OR on ceiling (for multi-story)
                if (onCeiling) {
                    buildPreview.position.y = ceilingHeight + 1.5;
                } else if (onFloor) {
                    buildPreview.position.y = floorHeight + 1.5;
                } else {
                    buildPreview.position.y = 1.5;
                }
            } else if (buildMode === 'wall' || buildMode === 'window_wall' || buildMode === 'single_door_wall' || buildMode === 'double_door_wall') {
                // Walls and door walls sit on floor OR on ceiling (for multi-story)
                if (onCeiling) {
                    buildPreview.position.y = ceilingHeight + 1.5;
                } else if (onFloor) {
                    buildPreview.position.y = floorHeight + 1.5;
                } else {
                    buildPreview.position.y = 1.5;
                }
            } else if (buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') {
                // Stairs should sit ON TOP of floors/ceilings, not inside them
                // Bottom of stairs should be at the floor surface
                if (onCeiling) {
                    // Sitting on ceiling - bottom of stairs at ceiling top
                    buildPreview.position.y = ceilingHeight + 0.15; // Ceiling thickness + small offset
                } else if (onFloor) {
                    // Sitting on floor - bottom of stairs at floor top
                    buildPreview.position.y = floorHeight + 0.15; // Floor thickness + small offset
                } else {
                    // Ground level - bottom at ground
                    buildPreview.position.y = 0.15;
                }
            } else if (buildMode === 'ladder') {
                // Ladders snap to walls and can stack vertically
                let closestWall = null;
                let minDist = Infinity;
                
                // Find closest wall at any height
                for (let building of buildings) {
                    if (building.userData.buildingType === 'wall' || 
                        building.userData.buildingType === 'window_wall' ||
                        building.userData.buildingType === 'single_door_wall' ||
                        building.userData.buildingType === 'double_door_wall') {
                        const dist = Math.sqrt(
                            Math.pow(targetPos.x - building.position.x, 2) + 
                            Math.pow(targetPos.z - building.position.z, 2)
                        );
                        // Check if wall is at a relevant height (within 10 units of target)
                        const heightDiff = Math.abs(targetPos.y - building.position.y);
                        if (dist < minDist && dist < 5 && heightDiff < 10) {
                            minDist = dist;
                            closestWall = building;
                        }
                    }
                }
                
                if (closestWall) {
                    // Snap to wall position and rotation
                    buildPreview.rotation.y = closestWall.rotation.y;
                    
                    // Position ladder flush against wall (0.3 units offset from wall center)
                    const wallAngle = closestWall.rotation.y;
                    const offsetX = Math.sin(wallAngle) * 0.3;
                    const offsetZ = Math.cos(wallAngle) * 0.3;
                    
                    buildPreview.position.x = closestWall.position.x + offsetX;
                    buildPreview.position.z = closestWall.position.z + offsetZ;
                    
                    // Check for existing ladders at this wall position to allow stacking
                    // Find the highest ladder that's below our target position
                    let stackOnLadder = null;
                    let highestLadderBelow = -Infinity;
                    
                    for (let building of buildings) {
                        if (building.userData.isLadder) {
                            const distToLadder = Math.sqrt(
                                Math.pow(buildPreview.position.x - building.position.x, 2) + 
                                Math.pow(buildPreview.position.z - building.position.z, 2)
                            );
                            // Check if this ladder is at the same wall position
                            if (distToLadder < 0.5) {
                                const ladderTop = building.position.y + 1.5; // Top of this ladder
                                // If this ladder is below where we're trying to place and is the highest so far
                                if (ladderTop <= targetPos.y && ladderTop > highestLadderBelow) {
                                    highestLadderBelow = ladderTop;
                                    stackOnLadder = building;
                                }
                            }
                        }
                    }
                    
                    // Determine placement height
                    if (stackOnLadder) {
                        // Stack directly on top of existing ladder
                        buildPreview.position.y = stackOnLadder.position.y + 3; // 3 units is ladder height
                    } else if (onCeiling && !onFloor && Math.abs(targetPos.y - ceilingHeight) < 2) {
                        // Place on ceiling if looking near a ceiling
                        buildPreview.position.y = ceilingHeight;
                    } else if (onFloor) {
                        buildPreview.position.y = floorHeight;
                    } else {
                        buildPreview.position.y = 0;
                    }
                } else {
                    // No wall nearby, place on floor/ground like normal object
                    if (onCeiling) {
                        buildPreview.position.y = ceilingHeight;
                    } else if (onFloor) {
                        buildPreview.position.y = floorHeight;
                    } else {
                        buildPreview.position.y = 0;
                    }
                }
            } else if (buildMode === 'curtain_red' || buildMode === 'curtain_blue' || buildMode === 'curtain_green' || buildMode === 'curtain_white' || buildMode === 'curtain_beige') {
                // Curtains snap to window walls - placed on inside wall facing player
                let closestWindow = null;
                let minDist = Infinity;
                
                // Find closest window wall
                for (let building of buildings) {
                    if (building.userData.buildingType === 'window_wall') {
                        const dist = Math.sqrt(
                            Math.pow(targetPos.x - building.position.x, 2) + 
                            Math.pow(targetPos.z - building.position.z, 2)
                        );
                        if (dist < minDist && dist < 5) {
                            minDist = dist;
                            closestWindow = building;
                        }
                    }
                }
                
                if (closestWindow) {
                    // Get wall rotation
                    const wallAngle = closestWindow.rotation.y;
                    
                    // Determine which side of the wall the player is on
                    const wallX = closestWindow.position.x;
                    const wallZ = closestWindow.position.z;
                    const playerX = camera.position.x;
                    const playerZ = camera.position.z;
                    
                    // Calculate vector from wall to player
                    const toPlayerX = playerX - wallX;
                    const toPlayerZ = playerZ - wallZ;
                    
                    // Wall normal direction
                    const wallNormalX = Math.sin(wallAngle);
                    const wallNormalZ = Math.cos(wallAngle);
                    
                    // Dot product to determine which side player is on
                    const dotProduct = toPlayerX * wallNormalX + toPlayerZ * wallNormalZ;
                    
                    // Place curtain on the side facing the player (inside)
                    // Offset by -0.2 units on the side facing player
                    const offsetMultiplier = dotProduct > 0 ? -0.2 : 0.2;
                    const offsetX = Math.sin(wallAngle) * offsetMultiplier;
                    const offsetZ = Math.cos(wallAngle) * offsetMultiplier;
                    
                    buildPreview.position.x = closestWindow.position.x + offsetX;
                    buildPreview.position.z = closestWindow.position.z + offsetZ;
                    buildPreview.position.y = closestWindow.position.y;
                    
                    // Rotate to face same direction as wall
                    buildPreview.rotation.y = closestWindow.rotation.y;
                } else {
                    // No window nearby, place like normal object
                    if (onCeiling) {
                        buildPreview.position.y = ceilingHeight;
                    } else if (onFloor) {
                        buildPreview.position.y = floorHeight;
                    } else {
                        buildPreview.position.y = 0;
                    }
                }
            } else if (buildMode === 'floor_rug_red' || buildMode === 'floor_rug_blue' || buildMode === 'floor_rug_green') {
                // Floor rugs sit flat on floors or ground
                if (onFloor) {
                    buildPreview.position.y = floorHeight + 0.01; // Slightly above floor to prevent z-fighting
                } else {
                    buildPreview.position.y = 0.01; // Ground level
                }
            } else if (buildMode === 'wall_shelf') {
                // Wall shelf: raycast against wall faces for precise flush placement
                const _wsRay = _buildRaycaster;
                _wsRay.setFromCamera(_buildCenter, camera);
                const _wsWalls = buildings.filter(b => {
                    const bt = b.userData.buildingType;
                    return bt === 'wall' || bt === 'window_wall' || bt === 'single_door_wall' || bt === 'double_door_wall';
                });
                const _wsHits = _wsRay.intersectObjects(_wsWalls, true);
                let _wsSnapped = false;
                if (_wsHits.length > 0 && _wsHits[0].distance < 10) {
                    const hit = _wsHits[0];
                    const normal = hit.face ? hit.face.normal.clone() : new THREE.Vector3(0, 0, 1);
                    const normalMatrix = new THREE.Matrix3().getNormalMatrix(hit.object.matrixWorld);
                    normal.applyMatrix3(normalMatrix).normalize();
                    if (Math.abs(normal.y) < 0.5) {
                        // Offset along the face normal so the shelf back sits on the wall surface
                        const shelfDepth = 0.22;
                        buildPreview.position.copy(hit.point).addScaledVector(normal, shelfDepth);
                        const wallParent = hit.object.parent || hit.object;
                        buildPreview.position.y = Math.max(0.4, Math.min(hit.point.y, wallParent.position.y + 2.5));
                        buildPreview.rotation.y = Math.atan2(normal.x, normal.z);
                        _wsSnapped = true;
                    }
                }
                if (!_wsSnapped) {
                    // Fallback: nearest wall, offset to face surface
                    let closestWall = null, minWallDist = Infinity;
                    for (const building of buildings) {
                        const bt = building.userData.buildingType;
                        if (bt === 'wall' || bt === 'window_wall' || bt === 'single_door_wall' || bt === 'double_door_wall') {
                            const dx = targetPos.x - building.position.x;
                            const dz = targetPos.z - building.position.z;
                            const dist = Math.sqrt(dx*dx + dz*dz);
                            if (dist < minWallDist && dist < 5) { minWallDist = dist; closestWall = building; }
                        }
                    }
                    if (closestWall) {
                        const wallAngle = closestWall.rotation.y;
                        // wall half-thickness (~0.07) + shelf model back depth (~0.22)
                        const faceOffset = 0.29;
                        buildPreview.position.x = closestWall.position.x + Math.sin(wallAngle) * faceOffset;
                        buildPreview.position.z = closestWall.position.z + Math.cos(wallAngle) * faceOffset;
                        const shelfY = Math.max(0.5, Math.min(targetPos.y, closestWall.position.y + 2.5));
                        buildPreview.position.y = shelfY;
                        buildPreview.rotation.y = wallAngle;
                    } else {
                        if (onFloor) buildPreview.position.y = floorHeight + 1.2;
                        else buildPreview.position.y = 1.2;
                    }
                }
            } else if (buildMode === 'sewing_table') {
                // Sewing table clips to any surface: floor, ceiling, or wall
                const _stRay = _buildRaycaster;
                _stRay.setFromCamera(_buildCenter, camera);
                // Raycast against all buildings (floors, walls, ceilings) and ground
                const _stTargets = [...buildings];
                const _stHits = _stRay.intersectObjects(_stTargets, true);
                if (_stHits.length > 0 && _stHits[0].distance < 12) {
                    const hit = _stHits[0];
                    const normal = hit.face ? hit.face.normal.clone() : new THREE.Vector3(0,1,0);
                    // Transform normal to world space
                    const normalMatrix = new THREE.Matrix3().getNormalMatrix(hit.object.matrixWorld);
                    normal.applyMatrix3(normalMatrix).normalize();
                    // Place on hit point, offset slightly along normal so it sits flush
                    buildPreview.position.copy(hit.point).addScaledVector(normal, 0.05);
                    // Rotate to face along wall/surface normal (yaw only for vertical surfaces)
                    if (Math.abs(normal.y) < 0.5) {
                        // Wall or ceiling-like surface  align rotation to face outward
                        buildPreview.rotation.y = Math.atan2(normal.x, normal.z);
                    }
                    // For floor/ceiling surfaces keep existing buildRotation
                } else if (onCeiling) {
                    buildPreview.position.y = ceilingHeight;
                } else if (onFloor) {
                    buildPreview.position.y = floorHeight;
                } else {
                    buildPreview.position.y = 0;
                }
            } else {
                // Other objects sit on floor/ceiling/ground  storage boxes also snap to shelves
                if (buildMode === 'storage_box' || buildMode === 'small_storage_box') {
                    const boxFootprint = buildMode === 'storage_box' ? 1.2 : 0.6;
                    const shelfLevels  = [0.725, 1.425];
                    let bestShelfSnap = null;
                    let bestShelfDist = Infinity;
                    for (const building of buildings) {
                        if (!building.userData.isShelf) continue;
                        const dx = targetPos.x - building.position.x;
                        const dz = targetPos.z - building.position.z;
                        const horizDist = Math.sqrt(dx*dx + dz*dz);
                        if (horizDist > 2.0) continue;
                        const shelfRot = building.rotation.y;
                        const localX = dx * Math.cos(-shelfRot) - dz * Math.sin(-shelfRot);
                        const localZ = dx * Math.sin(-shelfRot) + dz * Math.cos(-shelfRot);
                        const halfShelf = 0.8 - boxFootprint / 2;
                        const clampedX = Math.max(-halfShelf, Math.min(halfShelf, localX));
                        const clampedZ = Math.max(-halfShelf, Math.min(halfShelf, localZ));
                        let bestLevel = shelfLevels[0]; let bestLevelDiff = Infinity;
                        for (const lvl of shelfLevels) {
                            const diff = Math.abs(targetPos.y - (building.position.y + lvl));
                            if (diff < bestLevelDiff) { bestLevelDiff = diff; bestLevel = lvl; }
                        }
                        const wx = building.position.x + clampedX * Math.cos(shelfRot) - clampedZ * Math.sin(shelfRot);
                        const wz = building.position.z + clampedX * Math.sin(shelfRot) + clampedZ * Math.cos(shelfRot);
                        if (horizDist < bestShelfDist) {
                            bestShelfDist = horizDist;
                            bestShelfSnap = { x: wx, y: building.position.y + bestLevel, z: wz };
                        }
                    }
                    if (bestShelfSnap) {
                        buildPreview.position.set(bestShelfSnap.x, bestShelfSnap.y, bestShelfSnap.z);
                    } else if (onCeiling) {
                        buildPreview.position.y = ceilingHeight;
                    } else if (onFloor) {
                        buildPreview.position.y = floorHeight;
                    } else {
                        buildPreview.position.y = 0;
                    }
                } else if (onCeiling) {
                    buildPreview.position.y = ceilingHeight;
                } else if (onFloor) {
                    buildPreview.position.y = floorHeight;
                } else {
                    buildPreview.position.y = 0;
                }
            }
            
            // Apply rotation
            buildPreview.rotation.y = buildRotation;
            
            // Update preview color based on validity
            const canPlace = !checkBuildingCollision(buildPreview);
            const previewColor = canPlace ? 0x00ff00 : 0xff0000;
            const emissiveColor = new THREE.Color(previewColor);
            
            buildPreview.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material.color.setHex(previewColor);
                    if (child.material.emissive) {
                        child.material.emissive.copy(emissiveColor);
                    }
                    // STAIRS: Force visibility
                    child.visible = true;
                    if (buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') {
                        child.material.transparent = true;
                        child.material.opacity = 0.8;
                        child.material.needsUpdate = true;
                    }
                }
            });
            
            // Ensure the whole preview is visible
            buildPreview.visible = true;
            
            // STAIRS: Extra visibility enforcement
            if (buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') {
                buildPreview.renderOrder = 1000;
                buildPreview.frustumCulled = false;
            }
        }
        
        function checkBuildingCollision(testBuilding) {
            // Stairs NEVER collide with anything - check this FIRST before any calculations
            if (buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') {
                return false;
            }
            
            // Floor rugs NEVER collide - they're just decorative and walkable
            if (buildMode === 'floor_rug_red' || buildMode === 'floor_rug_blue' || buildMode === 'floor_rug_green') {
                return false;
            }
            
            // Curtains and sewing table can overlap with surfaces
            if (buildMode === 'sewing_table' || buildMode === 'wall_shelf') {
                return false; // These items clip to surfaces, skip collision check
            }
            if (buildMode === 'curtain_red' || buildMode === 'curtain_blue' || buildMode === 'curtain_green' || 
                buildMode === 'curtain_white' || buildMode === 'curtain_beige') {
                // Only check collision with other curtains
                for (let building of buildings) {
                    if (building.userData.buildingType && building.userData.buildingType.startsWith('curtain_')) {
                        const dist = Math.sqrt(
                            Math.pow(testBuilding.position.x - building.position.x, 2) + 
                            Math.pow(testBuilding.position.z - building.position.z, 2)
                        );
                        if (dist < 1.0) {
                            return true; // Collision with another curtain
                        }
                    }
                }
                return false; // No collision
            }
            
            const testBox = new THREE.Box3().setFromObject(testBuilding);
            
            // Special handling for ceilings and ladder_ceilings - almost never collide
            if (buildMode === 'ceiling' || buildMode === 'ladder_ceiling') {
                for (let building of buildings) {
                    if (building.userData.buildingType === 'ceiling' || building.userData.isLadderCeiling) {
                        const heightDiff = Math.abs(testBuilding.position.y - building.position.y);
                        const horizDist = Math.sqrt(
                            Math.pow(testBuilding.position.x - building.position.x, 2) + 
                            Math.pow(testBuilding.position.z - building.position.z, 2)
                        );
                        // Only collide if at same height AND same horizontal position (exact overlap)
                        if (heightDiff < 0.5 && horizDist < 1.0) {
                            return true; // Collision - trying to place ceiling exactly where another one is
                        }
                    }
                }
                return false; // No collision - ceilings can be placed freely
            }
            
            for (let building of buildings) {
                // Allow floors and ceilings to overlap with each other slightly (same level foundations)
                // But allow different height levels for multi-story buildings
                if ((buildMode.includes('floor') || buildMode.includes('ceiling')) && 
                    (isFloorOrCeiling(building.userData.buildingType))) {
                    const heightDiff = Math.abs(testBuilding.position.y - building.position.y);
                    if (heightDiff < 0.3) {
                        // Same level floors/ceilings can be adjacent
                        continue;
                    }
                    // Allow floors/ceilings at different heights (multi-story)
                    if (heightDiff > 2) {
                        // Different levels, no collision
                        continue;
                    }
                }
                
                // Allow walls to be adjacent when snapping (edge-to-edge, no overlap)
                // Applies to walls, window walls, door frames, and door walls
                if ((buildMode === 'wall' || buildMode === 'window_wall' || buildMode === 'door_frame' || 
                     buildMode === 'single_door_wall' || buildMode === 'double_door_wall') && 
                    (building.userData.buildingType === 'wall' || building.userData.buildingType === 'window_wall' || 
                     building.userData.buildingType === 'door_frame' || building.userData.buildingType === 'single_door_wall' ||
                     building.userData.buildingType === 'double_door_wall')) {
                    const distance = Math.sqrt(
                        Math.pow(testBuilding.position.x - building.position.x, 2) + 
                        Math.pow(testBuilding.position.z - building.position.z, 2)
                    );
                    // If walls are 4 units apart (edge-to-edge), allow placement
                    // Or if walls are ~2.83 units apart (diagonal corner placement), allow it
                    const edgeToEdge = Math.abs(distance - 4) < 0.5;
                    const cornerToCorner = Math.abs(distance - 2.83) < 0.5; // sqrt(2*2 + 2*2) = 2.83
                    
                    if (edgeToEdge || cornerToCorner) {
                        continue;
                    }
                }
                
                // Ceilings can be placed above floors - always skip collision check with floors
                if ((buildMode.includes('ceiling')) && building.userData.buildingType && building.userData.buildingType.includes('floor')) {
                    continue; // Always allow ceilings above floors, regardless of height
                }
                
                // Allow ceilings and ladder_ceilings to be above walls and door walls - skip collision check entirely
                if ((buildMode === 'ceiling' || buildMode === 'ladder_ceiling') && 
                    (building.userData.buildingType === 'wall' || building.userData.buildingType === 'window_wall' || 
                     building.userData.buildingType === 'door_frame' || building.userData.buildingType === 'single_door_wall' ||
                     building.userData.buildingType === 'double_door_wall')) {
                    // Skip collision check - ceilings can be placed on/near all types of walls
                    continue;
                }
                
                // Allow walls to be above ceilings (for multi-story buildings)
                if ((buildMode === 'wall' || buildMode === 'window_wall' || buildMode === 'door_frame' ||
                     buildMode === 'single_door_wall' || buildMode === 'double_door_wall' || buildMode === 'double_door_frame') && 
                    building.userData.buildingType === 'ceiling') {
                    // Always allow walls above ceilings - no collision check needed
                    continue;
                }
                
                // Allow ladders to stack vertically on same wall but not overlap horizontally
                if (buildMode === 'ladder' && building.userData.isLadder) {
                    const horizontalDist = Math.sqrt(
                        Math.pow(testBuilding.position.x - building.position.x, 2) + 
                        Math.pow(testBuilding.position.z - building.position.z, 2)
                    );
                    const verticalDist = Math.abs(testBuilding.position.y - building.position.y);
                    
                    // Allow vertical stacking (same horizontal position, different heights)
                    if (horizontalDist < 0.5 && verticalDist > 2.5) {
                        continue; // Ladders stacking vertically - no collision
                    }
                }
                
                // Allow ladders to sit on floors/ceilings and against walls
                if (buildMode === 'ladder') {
                    if (isFloorOrCeiling(building.userData.buildingType) ||
                        building.userData.buildingType === 'wall' || building.userData.buildingType === 'window_wall' ||
                        building.userData.buildingType === 'single_door_wall' || building.userData.buildingType === 'double_door_wall' ||
                        building.userData.isLadderCeiling) {
                        continue; // Skip collision with floors, ceilings, walls, and ladder ceilings
                    }
                }
                
                // Allow ladder_ceiling to ignore ladder collisions
                if (buildMode === 'ladder_ceiling' && building.userData.isLadder) {
                    continue; // Ladder ceilings pass through ladders
                }
                
                // Allow objects to sit on top of floors or ceilings (workbench, furnace, etc)
                if (isFloorOrCeiling(building.userData.buildingType)) {
                    // Skip collision for objects on floors/ceilings
                    continue;
                }
                
                // Allow sleeping bags and small objects to be placed more freely
                // They can overlap with floors as long as they're on top
                if (buildMode === 'sleeping_bag' || buildMode === 'campfire' || buildMode === 'workbench' || 
                    buildMode === 'furnace' || buildMode === 'cooking_station' || buildMode === 'storage_box' || buildMode === 'small_storage_box' || buildMode === 'building_bench') {
                    if (isFloorOrCeiling(building.userData.buildingType)) {
                        continue;
                    }
                }
                
                // Storage boxes (large and small) can be placed on shelves  skip collision with the shelf itself
                if ((buildMode === 'storage_box' || buildMode === 'small_storage_box') && building.userData.isShelf) {
                    continue;
                }
                
                // Allow doors to be placed in door frames
                if (buildMode === 'door' && building.userData.isDoorFrame) {
                    // Check if the door is snapped to this door frame (same position and rotation)
                    const distance = Math.sqrt(
                        Math.pow(testBuilding.position.x - building.position.x, 2) + 
                        Math.pow(testBuilding.position.z - building.position.z, 2)
                    );
                    const heightDiff = Math.abs(testBuilding.position.y - building.position.y);
                    // Door is rotated 90 degrees from frame when closed
                    const expectedDoorRot = building.rotation.y + Math.PI / 2;
                    const rotDiff = Math.abs(testBuilding.rotation.y - expectedDoorRot);
                    const rotDiffNormalized = Math.min(rotDiff, Math.abs(rotDiff - Math.PI * 2));
                    // If door is snapped to door frame (same position and correct rotation), allow placement
                    if (distance < 0.5 && heightDiff < 0.5 && rotDiffNormalized < 0.2) {
                        continue;
                    }
                }
                
                // Always calculate fresh bounding box for accurate collision detection
                // Cached boxes can become stale when objects move/rotate
                const buildingBox = new THREE.Box3().setFromObject(building);
                
                if (testBox.intersectsBox(buildingBox)) {
                    return true; // Collision detected
                }
            }
            return false; // No collision
        }
        
        async function placeBuilding() {
            if (!buildMode) return;
            
            // Check distance from player (max 8 meters)
            const distanceToBuilding = camera.position.distanceTo(buildPreview.position);
            if (distanceToBuilding > 8) {
                showMessage('\u26a0\ufe0f Too far away! Must be within 8 meters.');
                return;
            }
            
            // Check if we have the item
            if (!inventory[buildMode] || inventory[buildMode] <= 0) {
                showMessage('\u274c You don\'t have this item!');
                cancelBuilding();
                return;
            }
            
            // Check for collision
            if (checkBuildingCollision(buildPreview)) {
                showMessage('\u274c Cannot place here - collision detected!');
                return;
            }
            
            // Consume one item from inventory
            inventory[buildMode]--;
            
            const building = await buildAndPlaceModel(buildMode);
            building.position.copy(buildPreview.position);
            building.rotation.copy(buildPreview.rotation);
            building.userData.type = 'building';
            building.userData.buildingType = buildMode;
            
            // Set specific userData flags based on building type
            if (buildMode === 'campfire') {
                building.userData.isCampfire = true;
            } else if (buildMode === 'furnace') {
                building.userData.isFurnace = true;
            } else if (buildMode === 'cooking_station') {
                building.userData.isCookingStation = true;
            } else if (buildMode === 'workbench') {
                building.userData.isWorkbench = true;
            } else if (buildMode === 'building_bench') {
                building.userData.isBuildingBench = true;
            } else if (buildMode === 'sewing_table') {
                building.userData.isSewingTable = true;
            } else if (buildMode === 'recycler') {
                building.userData.isRecycler = true;
            } else if (buildMode === 'water_catcher') {
                building.userData.isWaterCatcher = true;
            } else if (buildMode === 'storage_box') {
                building.userData.isStorageBox = true;
            } else if (buildMode === 'small_storage_box') {
                building.userData.isStorageBox = true;
                building.userData.isSmallStorage = true;
                if (!building.userData.storageInventory) {
                    building.userData.storageInventory = new Array(14).fill(null);
                }
            } else if (buildMode === 'ladder') {
                building.userData.isLadder = true;
            } else if (buildMode === 'stairs' || buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') {
                building.userData.isStairs = true;
                if (buildMode === 'corner_stairs_left' || buildMode === 'corner_stairs_right') {
                    building.userData.isCornerStairs = true;
                }
            } else if (buildMode === 'ladder_ceiling') {
                building.userData.isLadderCeiling = true;
            } else if (buildMode === 'door') {
                building.userData.isDoor = true;
                building.userData.isOpen = false;
                building.userData.initialRotation = buildPreview.rotation.y; // Store initial rotation
            } else if (buildMode === 'door_frame') {
                building.userData.isDoorFrame = true;
            } else if (buildMode === 'sleeping_bag') {
                building.userData.isSleepingBag = true;
            } else if (buildMode === 'storage_shelf') {
                building.userData.isShelf = true;
            } else if (buildMode === 'wall_shelf') {
                building.userData.isWallShelf = true;
            } else if (buildMode === 'planter_box') {
                building.userData.isPlanterBox = true;
                building.userData.seeds = [null, null, null, null];
                const _pxArr = [-0.75,-0.25,0.25,0.75];
                building.userData.slotPositions = _pxArr;
                building.userData.slotZPositions = [0,0,0,0];
                building.userData.slotDefs = _pxArr.map(x=>({x,z:0}));
                building.userData.wateredThisRain = false;
                building.traverse(child => { if (child.name === 'plantContainer') building.userData.plantContainer = child; });
            } else if (buildMode === 'large_planter') {
                building.userData.isPlanterBox = true;
                const _lpX = [-0.82,-0.27,0.27,0.82], _lpZ = [-0.42,0,0.42];
                const _lpDefs = [];
                for (let r=0;r<3;r++) for (let c=0;c<4;c++) _lpDefs.push({x:_lpX[c],z:_lpZ[r]});
                building.userData.slotDefs = _lpDefs;
                building.userData.slotPositions = _lpDefs.map(d=>d.x);
                building.userData.slotZPositions = _lpDefs.map(d=>d.z);
                building.userData.seeds = new Array(12).fill(null);
                building.userData.wateredThisRain = false;
                building.traverse(child => { if (child.name === 'plantContainer') building.userData.plantContainer = child; });
            } else if (buildMode === 'floor_rug_red' || buildMode === 'floor_rug_blue' || buildMode === 'floor_rug_green') {
                building.userData.isRug = true;
            } else if (buildMode === 'curtain_red' || buildMode === 'curtain_blue' || buildMode === 'curtain_green' || 
                       buildMode === 'curtain_white' || buildMode === 'curtain_beige') {
                building.userData.isCurtain = true;
            }
            
            // Add collision box
            building.userData.collisionBox = new THREE.Box3().setFromObject(building);
            
            buildings.push(building);
            scene.add(building);
            
            playCollectSound();
            showMessage(`Built ${buildingTypes[buildMode].name}!`);
            
            scene.remove(buildPreview);
            buildPreview = null;
            buildMode = null;
            buildRotation = 0;
            document.getElementById('build-info').style.display = 'none';
            updateUI();
        }
        
        function cancelBuilding() {
            if (buildPreview) {
                scene.remove(buildPreview);
                buildPreview = null;
            }
            buildMode = null;
            document.getElementById('build-info').style.display = 'none';
        }
        
        // ===== CONTROLS =====
        const keys = {};
        const mouse = { x: 0, y: 0, locked: false };
        const moveSpeed = 0.045; // Reduced to 30% of original
        const sprintSpeed = 0.101; // 50% faster than before (was 0.0675, now 0.101)
        const sensitivity = 0.002;
        let isJumping = false;
        let onLadder = false; // Track if player is currently on a ladder
        let jumpVelocity = 0;
        const jumpStrength = 0.1875; // Quarter of original jump height
        const gravity = 0.015;
        let playerY = 1.7; // Player eye height from ground
        let stamina = 100;
        const maxStamina = 100;
        const staminaDrainRate = 0.5; // Stamina drain per frame when sprinting
        const staminaRegenRate = 0.3; // Stamina regen per frame when not sprinting
        let staminaDepletedTime = 0; // Track when stamina hit minimum
        const staminaRegenDelay = 5000; // 5 seconds delay in milliseconds

        //  BUFF SYSTEM 
        // Each buff: { endTime: ms timestamp }
        const activeBuffs = {
            veggi_stew: null,  // stamina drain -50%
            meat_stew:  null,  // +30% max health
            hearty:     null,  // double gathering resources
        };
        const BUFF_DURATION = 600000; // 10 real-time minutes in ms

        function applyBuff(id) {
            activeBuffs[id] = { endTime: Date.now() + BUFF_DURATION };
            updateBuffHUD();
        }

        function tickBuffs() {
            const now = Date.now();
            let changed = false;
            for (const id in activeBuffs) {
                if (activeBuffs[id] && now >= activeBuffs[id].endTime) {
                    activeBuffs[id] = null;
                    changed = true;
                    if (id === 'meat_stew') {
                        // Clamp health back to 100 if it was inflated
                        health = Math.min(100, health);
                        updateUI();
                    }
                    showMessage(` ${id === 'veggi_stew' ? 'Stamina Saver' : id === 'meat_stew' ? 'Fortified' : 'Double Gathering'} buff has worn off.`);
                }
            }
            if (changed) updateBuffHUD();
        }

        function updateBuffHUD() {
            const hud = document.getElementById('buff-hud');
            if (!hud) return;
            hud.innerHTML = '';
            const now = Date.now();
            const defs = {
                veggi_stew: { icon: '', label: 'Stamina Saver (-50% drain)' },
                meat_stew:  { icon: '', label: 'Fortified (+30% max health)' },
                hearty:     { icon: '', label: 'Double Gathering' },
            };
            for (const [id, buff] of Object.entries(activeBuffs)) {
                if (!buff) continue;
                const secsLeft = Math.max(0, Math.ceil((buff.endTime - now) / 1000));
                const mins = Math.floor(secsLeft / 60);
                const secs = secsLeft % 60;
                const timeStr = mins > 0 ? `${mins}m ${secs}s` : `${secs}s`;
                const el = document.createElement('div');
                el.className = 'buff-indicator';
                el.innerHTML = `${defs[id].icon} ${defs[id].label} <span class="buff-indicator-timer">${timeStr}</span>`;
                hud.appendChild(el);
            }
        }
        
        document.addEventListener('keydown', async (e) => {
            keys[e.key.toLowerCase()] = true;
            
            // Jump with Space
            if (e.key === ' ' && !isJumping && !isDead && !onLadder) {
                isJumping = true;
                jumpVelocity = jumpStrength;
            }
            
            if (e.key === 'Escape') {
                e.preventDefault();
                
                // Check if any menus are open first
                const craftingOpen = document.getElementById('crafting-menu').style.display === 'block';
                const workbenchOpen = document.getElementById('workbench-menu').style.display === 'block';
                const furnaceOpen = document.getElementById('furnace-menu').style.display === 'block';
                const campfireOpen = document.getElementById('campfire-menu').style.display === 'block';
                const recyclerOpen = document.getElementById('recycler-menu').style.display === 'block';
                const waterCatcherOpen = document.getElementById('water-catcher-menu').style.display === 'block';
                const cookingStationOpen = document.getElementById('cooking-station-menu').style.display === 'block';
                const inventoryOpen = document.getElementById('inventory-panel').style.display === 'block';
                const storageOpen = document.getElementById('storage-panel').style.display === 'block';
                const planterOpen = document.getElementById('planter-panel').style.display === 'block';
                const backpackOpen = document.getElementById('backpack-panel').style.display === 'block';
                const adminOpen = document.getElementById('admin-menu').style.display === 'block';
                
                // Close everything and re-lock pointer  works for any open menu
                const anyOpen = craftingOpen || workbenchOpen || furnaceOpen || campfireOpen ||
                    recyclerOpen || waterCatcherOpen || cookingStationOpen || inventoryOpen ||
                    storageOpen || planterOpen || backpackOpen || adminOpen || buildMode;
                if (anyOpen) {
                    closeAllUI();
                } else {
                    // No menus open, toggle pause menu
                    togglePause();
                }
            } else if (e.key === 'p' || e.key === 'P') {
                // Toggle third-person camera
                toggleThirdPerson();
            } else if (e.key === '`' || e.key === '~') {
                // Toggle admin menu
                if (document.getElementById('admin-menu').style.display === 'block') {
                    closeAdminMenu();
                } else {
                    openAdminMenu();
                }
            } else if (e.key === 'Tab') {
                e.preventDefault();
                toggleInventory();
            } else if (e.key === 'c' || e.key === 'C') {
                toggleCraftingMenu();
            } else if (e.key === 'f' || e.key === 'F') {
                toggleFlashlight();
            } else if (e.key === 'r' || e.key === 'R') {
                // Check if holding pistol - reload it
                const heldItem = hotbar[selectedHotbarSlot].item;
                if (heldItem === 'pistol') {
                    reloadPistol();
                } else if (buildPreview) {
                    // Rotate building preview
                    buildRotation += Math.PI / 2;
                    if (buildRotation >= Math.PI * 2) buildRotation = 0;
                    showMessage('\ud83d\udd04 Rotated building');
                }
            } else if (e.key === 'g' || e.key === 'G') {
                // Toggle snapping
                if (buildMode) {
                    snapToGrid = !snapToGrid;
                    showMessage(snapToGrid ? '\ud83d\udd27 Snapping: ON' : '\ud83d\udd27 Snapping: OFF');
                }
            } else if (e.key === 'e' || e.key === 'E') {
                // Try to interact with buildings (doors, crafting stations, etc.)
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

                // Check death backpacks first (they live outside the buildings array)
                if (deathBackpacks.length > 0) {
                    const bpHits = raycaster.intersectObjects(deathBackpacks, true);
                    if (bpHits.length > 0 && bpHits[0].distance < 4) {
                        let t = bpHits[0].object;
                        while (t.parent && !t.userData.isDeathBackpack) t = t.parent;
                        if (t.userData.isDeathBackpack) { openBackpack(t); return; }
                    }
                }

                const intersects = raycaster.intersectObjects(buildings, true);
                
                if (intersects.length > 0 && intersects[0].distance < 5) {
                    let target = intersects[0].object;
                    while (target.parent && !target.userData.buildingType && !target.userData.isDoor && !target.userData.isStorageBox && !target.userData.isWorkbench && !target.userData.isBuildingBench && !target.userData.isSewingTable && !target.userData.isRecycler && !target.userData.isWaterCatcher && !target.userData.isFurnace && !target.userData.isCampfire && !target.userData.isDoorFrame && !target.userData.isSleepingBag && !target.userData.isPlanterBox) {
                        target = target.parent;
                    }
                    
                    // Check for building upgrade with building hammer equipped FIRST
                    const heldItem = hotbar[selectedHotbarSlot].item;
                    if (heldItem === 'building_hammer' && target.userData.buildingType) {
                        const upgradeInfo = getUpgradeInfo(target.userData.buildingType);
                        
                        if (upgradeInfo.canUpgrade) {
                            // Check if player has resources
                            if (hasResources(upgradeInfo.cost)) {
                                // Deduct resources
                                deductResources(upgradeInfo.cost);
                                updateUI();
                                
                                // Store position, rotation, and special data
                                const pos = target.position.clone();
                                const rot = target.rotation.clone();
                                const wasOpen = target.userData.isOpen;
                                const smeltingState = target.userData.smeltingState;
                                const storageInventory = target.userData.storageInventory;
                                const hasCodeLock = target.userData.hasCodeLock;
                                const codeLock = target.userData.codeLock;
                                
                                // Remove old building
                                scene.remove(target);
                                const index = buildings.indexOf(target);
                                if (index > -1) {
                                    buildings.splice(index, 1);
                                }
                                
                                // Create upgraded building via the same pipeline as normal placement
                                // (bypassing the cache for this type so we get clean, untinted materials)
                                _modelCache.delete(upgradeInfo.nextTier);
                                const newBuilding = await buildAndPlaceModel(upgradeInfo.nextTier);
                                // Reset any preview tint left on materials
                                newBuilding.traverse(child => {
                                    if (child.isMesh && child.material) {
                                        const mats = Array.isArray(child.material) ? child.material : [child.material];
                                        mats.forEach(mat => {
                                            if (mat) {
                                                mat.color.setHex(mat.userData._origColor !== undefined ? mat.userData._origColor : 0xffffff);
                                                if (mat.emissive) mat.emissive.setHex(0x000000);
                                                mat.transparent = mat.userData._origTransparent !== undefined ? mat.userData._origTransparent : false;
                                                mat.opacity = mat.userData._origOpacity !== undefined ? mat.userData._origOpacity : 1.0;
                                                mat.needsUpdate = true;
                                            }
                                        });
                                        child.visible = true;
                                    }
                                });
                                newBuilding.visible = true;
                                newBuilding.position.copy(pos);
                                newBuilding.rotation.copy(rot);
                                newBuilding.userData.type = 'building';
                                newBuilding.userData.buildingType = upgradeInfo.nextTier;
                                newBuilding.userData.collisionBox = new THREE.Box3().setFromObject(newBuilding);
                                
                                // Set specific flags based on building type
                                const buildType = upgradeInfo.nextTier;
                                if (buildType.includes('stairs')) {
                                    newBuilding.userData.isStairs = true;
                                    if (buildType.includes('corner')) {
                                        newBuilding.userData.isCornerStairs = true;
                                    }
                                } else if (buildType.includes('door_wall')) {
                                    newBuilding.userData.isDoor = true;
                                    if (buildType.includes('single')) {
                                        newBuilding.userData.doorType = 'single';
                                    } else if (buildType.includes('double')) {
                                        newBuilding.userData.doorType = 'double';
                                    }
                                } else if (buildType === 'ladder') {
                                    newBuilding.userData.isLadder = true;
                                } else if (buildType === 'ladder_ceiling') {
                                    newBuilding.userData.isLadderCeiling = true;
                                }
                                
                                // Restore special properties
                                if (wasOpen !== undefined) {
                                    newBuilding.userData.isOpen = wasOpen;
                                }
                                if (smeltingState) {
                                    Object.assign(newBuilding.userData.smeltingState, smeltingState);
                                }
                                if (storageInventory) {
                                    newBuilding.userData.storageInventory = [...storageInventory];
                                }
                                
                                // Restore code lock if door had one
                                if (hasCodeLock && codeLock) {
                                    newBuilding.userData.hasCodeLock = true;
                                    newBuilding.userData.codeLock = codeLock;
                                    createCodeLockModel(newBuilding);
                                }
                                
                                buildings.push(newBuilding);
                                scene.add(newBuilding);
                                
                                const tierName = upgradeInfo.currentTier === 1 ? 'Stone' : 'Metal';
                                showMessage(`\u2b06\ufe0f Upgraded to ${tierName}! (Tier ${upgradeInfo.currentTier + 1}/${upgradeInfo.maxTier})`);
                                playCollectSound();
                                return;
                            } else {
                                // Show what's needed
                                let needed = [];
                                for (const resource in upgradeInfo.cost) {
                                    const has = inventory[resource] || 0;
                                    const need = upgradeInfo.cost[resource];
                                    if (has < need) {
                                        needed.push(`${need - has} ${resource}`);
                                    }
                                }
                                showMessage(`\u26a0\ufe0f Need: ${needed.join(', ')}`);
                                return;
                            }
                        } else if (upgradeInfo.maxed) {
                            showMessage('\u2b06\ufe0f Already max tier!');
                            return;
                        }
                    }
                    
                    // Open/close door (only if not upgrading)
                    if (target.userData.isDoor) {
                        // Check if player is holding a code lock to install it
                        const heldItem = hotbar[selectedHotbarSlot].item;
                        if (heldItem === 'code_lock' && inventory.code_lock > 0) {
                            // Check if door is closed
                            if (target.userData.isOpen) {
                                showMessage('\ud83d\udeaa Close the door first!');
                                return;
                            }
                            
                            // Check if door already has a code lock
                            if (target.userData.hasCodeLock) {
                                showMessage('\ud83d\udd12 Door already has a code lock!');
                                return;
                            }
                            
                            // Install code lock
                            inventory.code_lock--;
                            updateUI();
                            openCodeLockSetUI(target);
                            return;
                        }
                        
                        // Check if door has a code lock
                        if (target.userData.hasCodeLock) {
                            // Check if trying to open
                            if (!target.userData.isOpen) {
                                // Door is closed and locked - need code
                                openCodeLockEnterUI(target);
                                return;
                            } else {
                                // Door is open - just close it
                                target.userData.isOpen = false;
                                
                                if (target.userData.doorType === 'single') {
                                    target.userData.doorGroup.rotation.y = 0;
                                } else if (target.userData.doorType === 'double') {
                                    target.userData.leftDoorGroup.rotation.y = 0;
                                    target.userData.rightDoorGroup.rotation.y = 0;
                                } else {
                                    const initialRotation = target.userData.initialRotation || 0;
                                    target.userData.rotation.y = initialRotation;
                                }
                                
                                playDoorCloseSound();
                                showMessage('\ud83d\udd12 Door closed and locked');
                                return;
                            }
                        }
                        
                        // Normal door operation (no code lock)
                        const wasOpen = target.userData.isOpen;
                        target.userData.isOpen = !target.userData.isOpen;
                        
                        if (target.userData.doorType === 'single') {
                            // Single door - rotate on hinge (90 degrees inward)
                            const doorGroup = target.userData.doorGroup;
                            if (target.userData.isOpen) {
                                doorGroup.rotation.y = -Math.PI / 2; // Swing 90 degrees inward (to the left)
                            } else {
                                doorGroup.rotation.y = 0; // Back to closed
                            }
                        } else if (target.userData.doorType === 'double') {
                            // Double doors - both rotate on hinges inward (same direction)
                            const leftDoorGroup = target.userData.leftDoorGroup;
                            const rightDoorGroup = target.userData.rightDoorGroup;
                            if (target.userData.isOpen) {
                                leftDoorGroup.rotation.y = -Math.PI / 2; // Left door swings left (inward)
                                rightDoorGroup.rotation.y = Math.PI / 2; // Right door swings right (inward)
                            } else {
                                leftDoorGroup.rotation.y = 0; // Back to closed
                                rightDoorGroup.rotation.y = 0; // Back to closed
                            }
                        } else {
                            // Old style rotating door
                            const initialRotation = target.userData.initialRotation || 0;
                            if (target.userData.isOpen) {
                                target.rotation.y = initialRotation + Math.PI / 2;
                            } else {
                                target.rotation.y = initialRotation;
                            }
                        }
                        
                        // Play appropriate door sound
                        if (target.userData.isOpen) {
                            playDoorOpenSound();
                            showMessage('\ud83d\udd13 Door opened');
                        } else {
                            playDoorCloseSound();
                            showMessage('\ud83d\udd12 Door closed');
                        }
                        return;
                    }
                    
                    if (target.userData.isStorageBox) {
                        openStorageBox(target);
                        return;
                    } else if (target.userData.isWorkbench) {
                        openWorkbenchMenu(target);
                        return;
                    } else if (target.userData.isBuildingBench) {
                        if (document.getElementById('workbench-menu').style.display !== 'block') openBuildingBenchMenu(target);
                        return;
                    } else if (target.userData.isSewingTable) {
                        if (document.getElementById('workbench-menu').style.display !== 'block') openSewingTableMenu(target);
                        return;
                    } else if (target.userData.isRecycler) {
                        openRecyclerMenu(target);
                        return;
                    } else if (target.userData.isWaterCatcher) {
                        openWaterCatcherMenu(target);
                        return;
                    } else if (target.userData.isFurnace) {
                        openFurnaceMenu(target);
                        return;
                    } else if (target.userData.isCookingStation) {
                        openCookingStationMenu(target);
                        return;
                    } else if (target.userData.isCampfire) {
                        openCampfireMenu(target);
                        return;
                    } else if (target.userData.isSleepingBag) {
                        // Set spawn point
                        spawnPoint = {
                            x: target.position.x,
                            y: target.position.y + 1.7,
                            z: target.position.z
                        };
                        showMessage('\ud83d\udecf\ufe0f Spawn point set!');
                        playCollectSound();
                        return;
                    } else if (target.userData.isPlanterBox) {
                        // Check if player is looking at a specific grown plant slot
                        // by finding which slot the raycast hit is closest to
                        const hitPoint = intersects[0].point;
                        const planterWorldPos = target.position;
                        const planterRot = target.rotation.y;
                        // Transform hit point to planter local space
                        const dx = hitPoint.x - planterWorldPos.x;
                        const dz = hitPoint.z - planterWorldPos.z;
                        const localHitX = dx * Math.cos(-planterRot) - dz * Math.sin(-planterRot);
                        // Find closest slot
                        const slots = target.userData.slotPositions || [-0.75,-0.25,0.25,0.75];
                        let closestSlot = -1, closestDist = Infinity;
                        slots.forEach((sx, si) => {
                            const d = Math.abs(localHitX - sx);
                            if (d < closestDist) { closestDist = d; closestSlot = si; }
                        });
                        const seed = closestSlot >= 0 ? target.userData.seeds[closestSlot] : null;
                        if (seed && seed.grown) {
                            harvestPlant(target, closestSlot);
                        } else if (seed && !seed.grown) {
                            showMessage(`\u23f3 Growing... ${Math.round((seed.waterCount/4)*100)}%  needs more rain`);
                        } else {
                            openPlanterBox(target);
                        }
                        return;
                    }
                }
            } else if (e.key >= '1' && e.key <= '6') {
                selectedHotbarSlot = parseInt(e.key) - 1;
                updateHotbar();
                updateHeldItem();
                
                // Show tooltip for newly selected item
                const selectedSlot = hotbar[selectedHotbarSlot];
                if (selectedSlot.item && inventory[selectedSlot.item] > 0) {
                    showHotbarTooltip(selectedSlot.item);
                    // Auto-hide after 2 seconds
                    setTimeout(() => {
                        hideHotbarTooltip();
                    }, 2000);
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });
        
        // ===== CENTRAL UI POINTER-LOCK MANAGER =====
        // Every menu open/close goes through these two helpers.
        //  GLOBAL UI MANAGER 
        // Simple: uiOpen() frees the mouse. closeAllUI() hides every menu and re-locks.
        // No counters  ESC or any close button calls closeAllUI() and it always works.

        // Helper: position inventory panel on the right side when a container is open
        function positionInventoryRight(panel) {
            panel.style.left = 'auto';
            panel.style.right = '20px';
            panel.style.top = '50%';
            panel.style.transform = 'translateY(-50%)';
        }

        // Helper: reset inventory panel to centered (standalone open)
        function resetInventoryCenter(panel) {
            panel.style.left = '50%';
            panel.style.right = '';
            panel.style.top = '50%';
            panel.style.transform = 'translate(-50%, -50%)';
        }

        function uiOpen() {
            // Release pointer lock so cursor is free
            if (document.pointerLockElement) document.exitPointerLock();
        }

        let _hasUserGesture = false;

        function _tryLock() {
            if (!_hasUserGesture || isPaused) return;
            if (!document.pointerLockElement) {
                try {
                    const req = renderer.domElement.requestPointerLock();
                    if (req && typeof req.catch === 'function') req.catch(() => {});
                } catch(e) {}
            }
        }

        // Close every menu panel and re-acquire pointer lock.
        // Call this from ALL close buttons, ESC, and anywhere a menu is dismissed.
        function closeAllUI() {
            // Hide every menu/panel
            const _ids = ['crafting-menu','workbench-menu','furnace-menu','campfire-menu',
                          'recycler-menu','water-catcher-menu','cooking-station-menu',
                          'storage-panel','planter-panel','backpack-panel','admin-menu',
                          'code-lock-menu','settings-menu'];
            _ids.forEach(id => { const el = document.getElementById(id); if (el) el.style.display = 'none'; });
            // Inventory panel  also reset positioning
            const _inv = document.getElementById('inventory-panel');
            if (_inv) { _inv.style.display = 'none'; _inv.style.left = ''; _inv.style.right = ''; _inv.style.top = ''; _inv.style.transform = ''; }
            // Reset menu positioning overrides
            ['furnace-menu','campfire-menu'].forEach(id => {
                const el = document.getElementById(id); if (el) { el.style.left = ''; el.style.transform = ''; }
            });
            // Clear all station/object references
            currentWorkbench = null; currentBuildingBench = null; currentSewingTable = null;
            currentFurnace = null; currentCampfire = null;
            currentStorageBox = null; currentPlanterBox = null; currentBackpack = null;
            currentCookingStation = null; currentWaterCatcher = null;
            if (typeof waterCatcherState !== 'undefined') waterCatcherState.isOpen = false;
            // Cancel any active build mode
            if (typeof cancelBuilding === 'function') cancelBuilding();
            // Re-acquire pointer lock after a short delay
            setTimeout(_tryLock, 80);
        }

        // Legacy aliases so existing open/close functions still compile
        function uiClose() { closeAllUI(); }
        function uiForceCloseAll() { closeAllUI(); }

        // Global ESC safety net  fires before anything else, guaranteed to close all UI
        document.addEventListener('keydown', function _globalEscHandler(e) {
            if (e.key !== 'Escape') return;
            // Check if any game menu is visible
            const _menuIds = ['crafting-menu','workbench-menu','furnace-menu','campfire-menu',
                              'recycler-menu','water-catcher-menu','cooking-station-menu',
                              'inventory-panel','storage-panel','planter-panel','backpack-panel',
                              'admin-menu','code-lock-menu','settings-menu'];
            const anyVisible = _menuIds.some(id => {
                const el = document.getElementById(id);
                return el && el.style.display === 'block';
            });
            if (anyVisible) {
                e.stopImmediatePropagation();
                closeAllUI();
            }
        }, true); // capture phase  runs before game keydown handlers

        // Also call uiClose whenever the browser releases the lock externally
        // (e.g. user presses Escape while a menu is already open \ufffd don't re-lock)

        document.addEventListener('pointerlockchange', () => {
            mouse.locked = document.pointerLockElement === renderer.domElement;
        });
        
        renderer.domElement.addEventListener('click', () => {
            _hasUserGesture = true;
            if (!mouse.locked) {
                renderer.domElement.requestPointerLock();
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!mouse.locked) return;

            if (isThirdPerson) {
                // In 3rd-person: mouse drives the orbit angles directly.
                // camera.rotation is set by lookAt() each frame  don't touch it here.
                tp_orbitYaw   -= e.movementX * sensitivity;
                tp_orbitPitch -= e.movementY * sensitivity;
                tp_orbitPitch  = Math.max(-0.4, Math.min(0.8, tp_orbitPitch));
            } else {
                // 1st-person: mouse drives camera rotation directly
                camera.rotation.y -= e.movementX * sensitivity;
                camera.rotation.x -= e.movementY * sensitivity;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                camera.rotation.z = 0;
                camera.rotation.order = 'YXZ';
            }
        });
        
        document.addEventListener('mousedown', async (e) => {
            if (!mouse.locked) return;
            
            if (e.button === 0) { // Left click
                const heldItem = hotbar[selectedHotbarSlot].item;
                
                // Check if holding food/consumable item - consume it instead of attacking
                const foodItems = ['berries', 'mushroom', 'roasted_mushroom', 'meat', 'cooked_meat', 'bandage', 'medkit',
                    'pumpkin','wheat','cabbage','cucumber','potato','carrot','hemp_fiber','corn',
                    'mushroom_crop','red_berries','black_berries','strawberry','tomato'];
                if (foodItems.includes(heldItem) && inventory[heldItem] > 0) {
                    consumeItem(heldItem);
                    return; // Don't attack when consuming
                }
                
                if (buildMode) {
                    placeBuilding();
                } else if (heldItem === 'pistol') {
                    // Shoot pistol
                    shootPistol();
                } else if (heldItem === 'bow' && inventory.arrows > 0) {
                    // Shoot arrow
                    shootArrow();
                } else {
                    // Check if trying to place a building/crafting station from hotbar
                    const placeables = ['wall', 'window_wall', 'floor', 'ceiling', 'ladder_ceiling', 'stairs', 'corner_stairs_left', 'corner_stairs_right', 'ladder', 'door_frame', 'door', 'single_door_wall', 'double_door_wall', 'double_door_frame', 'campfire', 'workbench', 'building_bench', 'furnace', 'storage_box', 'sleeping_bag', 'small_storage_box', 'storage_shelf', 'wall_shelf', 'sewing_table', 'recycler', 'water_catcher', 'floor_rug_red', 'floor_rug_blue', 'floor_rug_green', 'curtain_red', 'curtain_blue', 'curtain_green', 'curtain_white', 'curtain_beige', 'planter_box', 'large_planter', 'cooking_station'];
                    
                    if (placeables.includes(heldItem) && inventory[heldItem] > 0) {
                        handleBuildingPlacement();
                    } else {
                        handleAttack();
                    }
                }
            } else if (e.button === 2) { // Right click
                if (buildMode) {
                    cancelBuilding();
                } else {
                    // Check if holding building hammer - remove buildings
                    const heldItem = hotbar[selectedHotbarSlot].item;
                    if (heldItem === 'building_hammer') {
                        // Raycast to find building to remove
                        const raycaster = new THREE.Raycaster();
                        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                        const intersects = raycaster.intersectObjects(buildings, true);
                        
                        if (intersects.length > 0) {
                            // Check distance first
                            if (intersects[0].distance > 8) {
                                showMessage('\u26a0\ufe0f Too far away! Must be within 8 meters.');
                                return;
                            }
                            
                            let target = intersects[0].object;
                            // Find the root building object
                            while (target.parent && !buildings.includes(target)) {
                                target = target.parent;
                            }
                            
                            // Check if it's a placed building
                            const buildingIndex = buildings.indexOf(target);
                            if (buildingIndex !== -1) {
                                const buildingType = target.userData.buildingType;
                                
                                // If removing a ceiling, check for wall gap and auto-fill
                                if (buildingType === 'ceiling') {
                                    const ceilingPos = target.position;
                                    const ceilingY = ceilingPos.y;
                                    
                                    // Find all walls at approximately the same height
                                    let wallsNearby = [];
                                    for (let building of buildings) {
                                        if (building.userData.buildingType === 'wall' || 
                                            building.userData.buildingType === 'window_wall' ||
                                            building.userData.buildingType === 'single_door_wall' ||
                                            building.userData.buildingType === 'double_door_wall') {
                                            const heightMatch = Math.abs(building.position.y - ceilingY) < 0.5;
                                            if (heightMatch) {
                                                const dist = Math.sqrt(
                                                    Math.pow(building.position.x - ceilingPos.x, 2) + 
                                                    Math.pow(building.position.z - ceilingPos.z, 2)
                                                );
                                                // Check if wall is adjacent (within reasonable distance)
                                                if (dist < 6 && dist > 2) {
                                                    wallsNearby.push(building);
                                                }
                                            }
                                        }
                                    }
                                    
                                    // If there are 2 or more walls nearby, likely a gap that needs filling
                                    if (wallsNearby.length >= 2) {
                                        // Determine which wall type to use (most common)
                                        const wallType = wallsNearby[0].userData.buildingType;
                                        
                                        // Determine rotation based on nearby walls
                                        // Try to match the rotation of walls that are in line with the ceiling
                                        let bestRotation = wallsNearby[0].rotation.y;
                                        
                                        // Create replacement wall at ceiling position
                                        const replacementWall = await buildingTypes[wallType].create();
                                        replacementWall.position.set(ceilingPos.x, ceilingY, ceilingPos.z);
                                        replacementWall.rotation.y = bestRotation;
                                        
                                        replacementWall.userData.type = 'building';
                                        replacementWall.userData.buildingType = wallType;
                                        replacementWall.userData.collisionBox = new THREE.Box3().setFromObject(replacementWall);
                                        
                                        buildings.push(replacementWall);
                                        scene.add(replacementWall);
                                        
                                        showMessage(`\u2705 Gap filled with ${wallType}!`);
                                    }
                                }
                                
                                // Remove from scene and array
                                scene.remove(target);
                                buildings.splice(buildingIndex, 1);
                                
                                showMessage(`\ud83d\uddd1\ufe0f Removed ${buildingType}!`);
                                playHitSound();
                                
                                // Refund half materials (optional)
                                if (buildingTypes[buildingType] && buildingTypes[buildingType].cost) {
                                    const costs = buildingTypes[buildingType].cost;
                                    Object.keys(costs).forEach(resource => {
                                        const refund = Math.floor(costs[resource] / 2);
                                        inventory[resource] = (inventory[resource] || 0) + refund;
                                    });
                                    updateUI();
                                }
                            }
                        }
                    }
                }
            }
        });
        
        // Mouse wheel for hotbar scrolling
        document.addEventListener('wheel', (e) => {
            if (!mouse.locked) return;
            
            e.preventDefault();
            
            if (e.deltaY > 0) {
                // Scroll down - next slot
                selectedHotbarSlot = (selectedHotbarSlot + 1) % hotbar.length;
            } else {
                // Scroll up - previous slot
                selectedHotbarSlot = (selectedHotbarSlot - 1 + hotbar.length) % hotbar.length;
            }
            
            updateHotbar();
            updateHeldItem();
            
            // Show tooltip for newly selected item
            const selectedSlot = hotbar[selectedHotbarSlot];
            if (selectedSlot.item && inventory[selectedSlot.item] > 0) {
                showHotbarTooltip(selectedSlot.item);
                // Auto-hide after 2 seconds
                setTimeout(() => {
                    hideHotbarTooltip();
                }, 2000);
            }
        }, { passive: false });
        
        document.addEventListener('contextmenu', (e) => e.preventDefault());
        
        function toggleCraftingMenu() {
            const menu = document.getElementById('crafting-menu');
            const isVisible = menu.style.display === 'block';
            
            if (isVisible) {
                menu.style.display = 'none';
                uiClose();
            } else {
                menu.style.display = 'block';
                uiOpen();
                updateCraftingMenu();
            }
        }
        
        // ===== ARROW SHOOTING SYSTEM =====
        const arrows = [];
        
        function shootArrow() {
            if (inventory.arrows <= 0) {
                showMessage('\u26a0\ufe0f No arrows!');
                return;
            }
            
            inventory.arrows--;
            animateTool();
            updateUI();
            
            // Hide the nocked arrow on the bow temporarily
            const bowModel = heldItemGroup.children[0];
            if (bowModel && bowModel.userData.arrow) {
                bowModel.userData.arrow.visible = false;
                // Show it again after animation
                setTimeout(() => {
                    if (bowModel.userData.arrow) {
                        bowModel.userData.arrow.visible = true;
                    }
                }, 500);
            }
            
            // Create arrow projectile
            const arrow = new THREE.Group();
            
            // Arrow shaft - built along Z axis (forward)
            const shaftGeo = new THREE.CylinderGeometry(0.01, 0.01, 0.6, 6);
            const shaftMat = new THREE.MeshStandardMaterial({ 
                color: 0x8B6914,
                roughness: 0.7
            });
            const shaft = new THREE.Mesh(shaftGeo, shaftMat);
            shaft.rotation.x = Math.PI / 2; // Point along Z axis
            arrow.add(shaft);
            
            // Arrow tip (sharp point)
            const tipGeo = new THREE.ConeGeometry(0.015, 0.05, 6);
            const tipMat = new THREE.MeshStandardMaterial({ 
                color: 0x666666,
                metalness: 0.7,
                roughness: 0.3
            });
            const tip = new THREE.Mesh(tipGeo, tipMat);
            tip.rotation.x = -Math.PI / 2; // Point forward along Z
            tip.position.z = -0.325; // Tip at front
            arrow.add(tip);
            
            // Fletching
            for (let i = 0; i < 3; i++) {
                const fletchGeo = new THREE.PlaneGeometry(0.025, 0.06);
                const fletchMat = new THREE.MeshStandardMaterial({
                    color: 0xff3300,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7
                });
                const fletch = new THREE.Mesh(fletchGeo, fletchMat);
                fletch.position.z = 0.28; // Fletching at back
                fletch.rotation.y = (i * Math.PI * 2 / 3);
                arrow.add(fletch);
            }
            
            // Get bow position in world space
            const bowWorldPos = new THREE.Vector3();
            if (bowModel) {
                bowModel.getWorldPosition(bowWorldPos);
            } else {
                bowWorldPos.copy(camera.position);
            }
            
            // Get direction from camera
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);
            
            // Position arrow at bow location, slightly forward
            arrow.position.copy(bowWorldPos);
            arrow.position.add(direction.clone().multiplyScalar(0.3));
            
            // Offset to right side where bow is held
            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(camera.quaternion);
            arrow.position.add(right.multiplyScalar(0.15));
            arrow.position.y -= 0.15;
            
            // Rotate arrow to face direction
            arrow.lookAt(arrow.position.clone().add(direction));
            
            arrow.userData.velocity = direction.multiplyScalar(1.2); // Fast arrow speed
            arrow.userData.gravity = -0.01; // Arrow drops over distance
            arrow.userData.life = 300; // Arrow lifespan in frames
            arrow.userData.type = 'arrow';
            
            arrows.push(arrow);
            scene.add(arrow);
            
            // Bow shooting sound
            playBowShootSound();
        }
        
        function updateArrows() {
            for (let i = arrows.length - 1; i >= 0; i--) {
                const arrow = arrows[i];
                
                // Move arrow
                arrow.position.add(arrow.userData.velocity);
                
                // Apply gravity
                arrow.userData.velocity.y -= 0.015;
                
                // Update arrow rotation to face velocity
                const lookTarget = arrow.position.clone().add(arrow.userData.velocity);
                arrow.lookAt(lookTarget);
                
                // Check collisions
                const raycaster = new THREE.Raycaster(
                    arrow.position,
                    arrow.userData.velocity.clone().normalize(),
                    0,
                    arrow.userData.velocity.length() + 0.5
                );
                
                const targets = [...enemies, ...window.animals, ...window.squirrels];
                const intersects = raycaster.intersectObjects(targets, true);
                
                if (intersects.length > 0) {
                    let target = intersects[0].object;
                    while (target.parent && !target.userData.type) {
                        target = target.parent;
                    }
                    
                    // Deal damage
                    if (target.userData.type === 'enemy') {
                        target.userData.health -= 50;
                        if (target.userData.health <= 0) {
                            scene.remove(target);
                            enemies.splice(enemies.indexOf(target), 1);
                            showMessage('Enemy defeated!');
                        }
                    } else if (target.userData.type === 'scorpion') {
                        target.userData.health -= 25;
                        if (target.userData.health <= 0) {
                            scene.remove(target);
                            scorpions.splice(scorpions.indexOf(target), 1);
                            showMessage(' Scorpion killed!');
                        }
                    } else if (target.userData.type === 'coyote') {
                        target.userData.health -= 30;
                        if (target.userData.health <= 0) {
                            scene.remove(target);
                            coyotes.splice(coyotes.indexOf(target), 1);
                            inventory.meat += 2; updateUI();
                            showMessage(' Coyote killed! +2 Meat');
                        } else {
                            target.userData.state = 'chase'; // Arrow makes it aggro
                        }
                    } else if (target.userData.type === 'animal') {
                        target.userData.health -= 50;
                        if (target.userData.health <= 0) {
                            inventory.meat += 2;
                            scene.remove(target);
                            window.animals.splice(window.animals.indexOf(target), 1);
                            showMessage('+ 2 Meat');
                            updateUI();
                        }
                    } else if (target.userData.type === 'squirrel') {
                        target.userData.health -= 50;
                        if (target.userData.health <= 0) {
                            inventory.meat += 1;
                            scene.remove(target);
                            window.squirrels.splice(window.squirrels.indexOf(target), 1);
                            showMessage('+ 1 Meat');
                            updateUI();
                        }
                    }
                    
                    // Remove arrow
                    scene.remove(arrow);
                    arrows.splice(i, 1);
                    continue;
                }
                
                // Remove arrow if too old or hit ground
                arrow.userData.life--;
                if (arrow.userData.life <= 0 || arrow.position.y < 0) {
                    scene.remove(arrow);
                    arrows.splice(i, 1);
                }
            }
        }
        
        // ===== PISTOL SYSTEM =====
        const bullets = [];
        const particles = []; // For muzzle flash and bullet trail particles
        
        function shootPistol() {
            // Check if reloading
            if (pistolState.isReloading) {
                return;
            }
            
            // Check if clip is empty
            if (pistolState.currentClip <= 0) {
                playPistolClickSound();
                showMessage('\u26a0\ufe0f No ammo in clip! Press R to reload');
                return;
            }
            
            // Fire bullet
            pistolState.currentClip--;
            updateAmmoDisplay();
            
            // Recoil animation
            animatePistolRecoil();
            
            // Muzzle flash
            createMuzzleFlash();
            
            // Gun sound
            playPistolSound();
            
            // Create bullet
            const bullet = new THREE.Group();
            
            // Bullet core (bright)
            const bulletGeo = new THREE.SphereGeometry(0.025, 6, 6);
            const bulletMat = new THREE.MeshBasicMaterial({ 
                color: 0xffff00,
                emissive: 0xffff00,
                emissiveIntensity: 3,
                transparent: true,
                opacity: 1
            });
            const bulletMesh = new THREE.Mesh(bulletGeo, bulletMat);
            bullet.add(bulletMesh);
            
            // Bullet glow halo
            const haloGeo = new THREE.SphereGeometry(0.04, 8, 8);
            const haloMat = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                transparent: true,
                opacity: 0.5,
                depthWrite: false
            });
            const halo = new THREE.Mesh(haloGeo, haloMat);
            bullet.add(halo);
            
            // Get direction from camera (very accurate - no spread)
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);
            
            // Position bullet at gun barrel end (in front of camera)
            bullet.position.copy(camera.position);
            bullet.position.add(direction.clone().multiplyScalar(0.6));
            
            // Offset slightly right and down to match gun position
            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(camera.quaternion);
            bullet.position.add(right.multiplyScalar(0.15));
            bullet.position.y -= 0.1;
            
            bullet.userData.velocity = direction.multiplyScalar(2.5); // Very fast bullet
            bullet.userData.life = 120;
            bullet.userData.type = 'bullet';
            bullet.userData.lastPosition = bullet.position.clone();
            bullet.userData.direction = direction.clone();
            
            bullets.push(bullet);
            scene.add(bullet);
            
            // Create particle trail behind bullet
            bullet.userData.createTrailParticle = function() {
                if (Math.random() > 0.3) return; // Don't create every frame
                
                const trailGeo = new THREE.SphereGeometry(0.015, 4, 4);
                const trailMat = new THREE.MeshBasicMaterial({
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 0.8,
                    depthWrite: false
                });
                const trail = new THREE.Mesh(trailGeo, trailMat);
                trail.position.copy(this.lastPosition);
                
                trail.userData.life = 0;
                trail.userData.maxLife = 8;
                trail.userData.startSize = trail.scale.x;
                
                scene.add(trail);
                particles.push(trail);
            };
        }
        
        function reloadPistol() {
            // Check if already reloading
            if (pistolState.isReloading) {
                return;
            }
            
            // Check if clip is full
            if (pistolState.currentClip >= pistolState.clipSize) {
                showMessage('\ud83d\udd2b Clip is full!');
                return;
            }
            
            // Check if have ammo
            if (inventory.pistol_ammo <= 0) {
                showMessage('\u26a0\ufe0f No ammo available!');
                return;
            }
            
            // Start reload
            pistolState.isReloading = true;
            pistolState.reloadStartTime = Date.now();
            showMessage('\ud83d\udd04 Reloading...');
            
            // Play reload sound
            playReloadSound();
            
            // Animate reload
            animatePistolReload();
        }
        
        function updatePistolReload() {
            if (!pistolState.isReloading) return;
            
            const elapsed = Date.now() - pistolState.reloadStartTime;
            
            if (elapsed >= pistolState.reloadDuration) {
                // Reload complete
                const ammoNeeded = pistolState.clipSize - pistolState.currentClip;
                const ammoToAdd = Math.min(ammoNeeded, inventory.pistol_ammo);
                
                pistolState.currentClip += ammoToAdd;
                inventory.pistol_ammo -= ammoToAdd;
                
                pistolState.isReloading = false;
                updateAmmoDisplay();
                updateUI();
                showMessage('\u2705 Reload complete!');
            }
        }
        
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // Create trail particles
                if (bullet.userData.createTrailParticle) {
                    bullet.userData.createTrailParticle();
                }
                
                // Move bullet
                bullet.userData.lastPosition = bullet.position.clone();
                bullet.position.add(bullet.userData.velocity);
                
                // Check collisions with enemies/animals
                const raycaster = new THREE.Raycaster(
                    bullet.position,
                    bullet.userData.velocity.clone().normalize(),
                    0,
                    bullet.userData.velocity.length() + 0.5
                );
                
                const targets = [...enemies, ...window.animals, ...window.squirrels];
                const intersects = raycaster.intersectObjects(targets, true);
                
                if (intersects.length > 0) {
                    let target = intersects[0].object;
                    while (target.parent && !target.userData.type) {
                        target = target.parent;
                    }
                    
                    // Deal heavy damage (more than sword/arrow)
                    if (target.userData.type === 'enemy') {
                        target.userData.health -= 80; // High damage
                        if (target.userData.health <= 0) {
                            scene.remove(target);
                            enemies.splice(enemies.indexOf(target), 1);
                            showMessage('\u2620\ufe0f Enemy eliminated!');
                        }
                    } else if (target.userData.type === 'scorpion') {
                        target.userData.health -= 25; // One-shot a scorpion
                        if (target.userData.health <= 0) {
                            scene.remove(target);
                            scorpions.splice(scorpions.indexOf(target), 1);
                            showMessage(' Scorpion eliminated!');
                        }
                    } else if (target.userData.type === 'coyote') {
                        target.userData.health -= 50;
                        if (target.userData.health <= 0) {
                            scene.remove(target);
                            coyotes.splice(coyotes.indexOf(target), 1);
                            inventory.meat += 2; updateUI();
                            showMessage(' Coyote eliminated! +2 Meat');
                        } else {
                            target.userData.state = 'chase';
                        }
                    } else if (target.userData.type === 'animal') {
                        target.userData.health -= 100; // One-shot animals
                        if (target.userData.health <= 0) {
                            inventory.meat += 2;
                            scene.remove(target);
                            window.animals.splice(window.animals.indexOf(target), 1);
                            showMessage('+ 2 Meat');
                            updateUI();
                        }
                    } else if (target.userData.type === 'squirrel') {
                        target.userData.health -= 100;
                        if (target.userData.health <= 0) {
                            inventory.meat += 1;
                            scene.remove(target);
                            window.squirrels.splice(window.squirrels.indexOf(target), 1);
                            showMessage('+ 1 Meat');
                            updateUI();
                        }
                    }
                    
                    // Remove bullet
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                    continue;
                }
                
                // Check collision with buildings/walls
                const buildingIntersects = raycaster.intersectObjects(buildings, true);
                if (buildingIntersects.length > 0 && buildingIntersects[0].distance < 0.5) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                    continue;
                }
                
                // Remove bullet if too old or hit ground
                bullet.userData.life--;
                if (bullet.userData.life <= 0 || bullet.position.y < 0) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                }
            }
        }
        
        function createMuzzleFlash() {
            // Get gun barrel position
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);
            
            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(camera.quaternion);
            
            const flashPosition = camera.position.clone();
            flashPosition.add(direction.clone().multiplyScalar(0.7));
            flashPosition.add(right.multiplyScalar(0.15));
            flashPosition.y -= 0.1;
            
            // PARTICLE-BASED MUZZLE FLASH
            
            // Main flash burst (expanding sphere of particles)
            for (let i = 0; i < 20; i++) {
                const angle1 = Math.random() * Math.PI * 2;
                const angle2 = Math.random() * Math.PI;
                
                const particleGeo = new THREE.SphereGeometry(0.02 + Math.random() * 0.02, 4, 4);
                const particleMat = new THREE.MeshBasicMaterial({
                    color: i < 10 ? 0xffff00 : 0xff8800,
                    transparent: true,
                    opacity: 0.9,
                    depthWrite: false
                });
                const particle = new THREE.Mesh(particleGeo, particleMat);
                
                particle.position.copy(flashPosition);
                
                // Radial velocity
                const vel = new THREE.Vector3(
                    Math.sin(angle2) * Math.cos(angle1),
                    Math.sin(angle2) * Math.sin(angle1),
                    Math.cos(angle2)
                );
                vel.normalize().multiplyScalar(0.15 + Math.random() * 0.1);
                
                // Bias forward
                vel.add(direction.clone().multiplyScalar(0.3));
                
                particle.userData.velocity = vel;
                particle.userData.life = 0;
                particle.userData.maxLife = 8 + Math.floor(Math.random() * 5);
                particle.userData.startSize = particle.scale.x;
                
                scene.add(particle);
                particles.push(particle);
            }
            
            // Hot gas particles (faster, smaller)
            for (let i = 0; i < 15; i++) {
                const particleGeo = new THREE.SphereGeometry(0.01, 3, 3);
                const particleMat = new THREE.MeshBasicMaterial({
                    color: i < 7 ? 0xffffff : 0xffaa00,
                    transparent: true,
                    opacity: 0.8,
                    depthWrite: false
                });
                const particle = new THREE.Mesh(particleGeo, particleMat);
                
                particle.position.copy(flashPosition);
                
                // Forward cone
                const spread = 0.3;
                const vel = direction.clone();
                vel.x += (Math.random() - 0.5) * spread;
                vel.y += (Math.random() - 0.5) * spread;
                vel.z += (Math.random() - 0.5) * spread * 0.5;
                vel.normalize().multiplyScalar(0.4 + Math.random() * 0.2);
                
                particle.userData.velocity = vel;
                particle.userData.life = 0;
                particle.userData.maxLife = 12 + Math.floor(Math.random() * 6);
                particle.userData.startSize = particle.scale.x;
                
                scene.add(particle);
                particles.push(particle);
            }
            
            // Smoke puff (slower, larger, grey)
            for (let i = 0; i < 8; i++) {
                const particleGeo = new THREE.SphereGeometry(0.04 + Math.random() * 0.03, 4, 4);
                const grey = 0.3 + Math.random() * 0.4;
                const particleMat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(grey, grey, grey),
                    transparent: true,
                    opacity: 0.6,
                    depthWrite: false
                });
                const particle = new THREE.Mesh(particleGeo, particleMat);
                
                particle.position.copy(flashPosition);
                particle.position.add(direction.clone().multiplyScalar(0.1));
                
                const vel = direction.clone();
                vel.x += (Math.random() - 0.5) * 0.4;
                vel.y += (Math.random() - 0.5) * 0.4 + 0.1; // Slight upward drift
                vel.z += (Math.random() - 0.5) * 0.2;
                vel.normalize().multiplyScalar(0.08 + Math.random() * 0.05);
                
                particle.userData.velocity = vel;
                particle.userData.life = 0;
                particle.userData.maxLife = 30 + Math.floor(Math.random() * 15);
                particle.userData.startSize = particle.scale.x;
                
                scene.add(particle);
                particles.push(particle);
            }
            
            // Bright core flash (instant, fades fast)
            const coreGeo = new THREE.SphereGeometry(0.08, 8, 8);
            const coreMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 1,
                depthWrite: false
            });
            const core = new THREE.Mesh(coreGeo, coreMat);
            core.position.copy(flashPosition);
            scene.add(core);
            
            let coreFrame = 0;
            const animateCore = () => {
                coreFrame++;
                if (coreFrame >= 4) {
                    scene.remove(core);
                    return;
                }
                core.material.opacity = 1 - (coreFrame / 4);
                core.scale.set(1 + coreFrame * 0.3, 1 + coreFrame * 0.3, 1 + coreFrame * 0.3);
                requestAnimationFrame(animateCore);
            };
            animateCore();
            
            // Smoke puff
            const smokeGeo = new THREE.SphereGeometry(0.08, 8, 8);
            const smokeMat = new THREE.MeshBasicMaterial({
                color: 0x555555,
                transparent: true,
                opacity: 0.3,
                depthWrite: false
            });
            const smoke = new THREE.Mesh(smokeGeo, smokeMat);
            smoke.position.copy(flashPosition);
            scene.add(smoke);
            
            // Animate smoke
            let smokeFrame = 0;
            const animateSmoke = () => {
                smokeFrame++;
                if (smokeFrame >= 25) {
                    scene.remove(smoke);
                    return;
                }
                smoke.position.add(direction.clone().multiplyScalar(0.015));
                smoke.scale.multiplyScalar(1.06);
                smoke.material.opacity = 0.3 * (1 - smokeFrame / 25);
                requestAnimationFrame(animateSmoke);
            };
            animateSmoke();
        }
        
        function animatePistolRecoil() {
            if (!heldItemGroup.children[0]) return;
            
            const recoilDuration = 100; // ms
            const startPos = heldItemGroup.position.clone();
            const startRot = heldItemGroup.rotation.clone();
            const startTime = Date.now();
            
            const animate = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / recoilDuration, 1);
                
                if (progress < 0.3) {
                    // Recoil back
                    const kick = (progress / 0.3);
                    heldItemGroup.position.z = startPos.z + kick * 0.1;
                    heldItemGroup.rotation.x = startRot.x - kick * 0.3;
                } else {
                    // Return to normal
                    const recovery = (progress - 0.3) / 0.7;
                    heldItemGroup.position.z = startPos.z + (1 - recovery) * 0.1;
                    heldItemGroup.rotation.x = startRot.x - (1 - recovery) * 0.3;
                }
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    heldItemGroup.position.copy(startPos);
                    heldItemGroup.rotation.copy(startRot);
                }
            };
            
            animate();
        }
        
        function animatePistolReload() {
            if (!heldItemGroup.children[0]) return;
            
            const model = heldItemGroup.children[0];
            const magazine = model.userData.magazine;
            if (!magazine) return;
            
            const reloadDuration = pistolState.reloadDuration;
            const startTime = Date.now();
            const startMagPos = magazine.position.clone();
            
            const animate = () => {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / reloadDuration;
                
                if (progress < 0.3) {
                    // Drop mag
                    magazine.position.y = startMagPos.y - (progress / 0.3) * 0.3;
                } else if (progress < 0.6) {
                    // Mag out of view
                    magazine.position.y = startMagPos.y - 0.5;
                } else {
                    // New mag in
                    const insertProgress = (progress - 0.6) / 0.4;
                    magazine.position.y = startMagPos.y - 0.3 + (insertProgress * 0.3);
                }
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    magazine.position.copy(startMagPos);
                }
            };
            
            animate();
        }
        
        function updateAmmoDisplay() {
            const ammoCounter = document.getElementById('ammo-counter');
            if (ammoCounter && currentHeldItem === 'pistol') {
                ammoCounter.textContent = `${pistolState.currentClip} / ${inventory.pistol_ammo}`;
            }
        }
        
        function playBowShootSound() {
            const now = audioContext.currentTime;
            
            // String release - fast snap
            const snap = audioContext.createOscillator();
            const snapGain = audioContext.createGain();
            
            snap.type = 'square';
            snap.frequency.setValueAtTime(600, now);
            snap.frequency.exponentialRampToValueAtTime(200, now + 0.05);
            
            snapGain.gain.setValueAtTime(0.25, now);
            snapGain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
            
            snap.connect(snapGain);
            snapGain.connect(audioContext.destination);
            
            snap.start(now);
            snap.stop(now + 0.08);
            
            // Bow limb vibration
            const vib = audioContext.createOscillator();
            const vibGain = audioContext.createGain();
            
            vib.type = 'sine';
            vib.frequency.setValueAtTime(120, now + 0.02);
            vib.frequency.exponentialRampToValueAtTime(80, now + 0.2);
            
            vibGain.gain.setValueAtTime(0.15, now + 0.02);
            vibGain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
            
            vib.connect(vibGain);
            vibGain.connect(audioContext.destination);
            
            vib.start(now + 0.02);
            vib.stop(now + 0.25);
            
            // Arrow whoosh
            const whoosh = audioContext.createOscillator();
            const whooshGain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            whoosh.type = 'sawtooth';
            whoosh.frequency.setValueAtTime(400, now);
            whoosh.frequency.exponentialRampToValueAtTime(150, now + 0.15);
            
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(800, now);
            
            whooshGain.gain.setValueAtTime(0.12, now);
            whooshGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
            
            whoosh.connect(filter);
            filter.connect(whooshGain);
            whooshGain.connect(audioContext.destination);
            
            whoosh.start(now);
            whoosh.stop(now + 0.15);
        }
        

        
        // ===== TOOL SOUNDS =====
        function playAxeSwingSound() {
            const now = audioContext.currentTime;
            
            // Whoosh sound for swing
            const whoosh = audioContext.createOscillator();
            const whooshGain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            whoosh.type = 'sawtooth';
            whoosh.frequency.setValueAtTime(400, now);
            whoosh.frequency.exponentialRampToValueAtTime(200, now + 0.15);
            
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(800, now);
            
            whooshGain.gain.setValueAtTime(0.15, now);
            whooshGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
            
            whoosh.connect(filter);
            filter.connect(whooshGain);
            whooshGain.connect(audioContext.destination);
            
            whoosh.start(now);
            whoosh.stop(now + 0.15);
        }
        
        function playPickaxeSwingSound() {
            const now = audioContext.currentTime;
            
            // Sharp metallic whoosh
            const whoosh = audioContext.createOscillator();
            const whooshGain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            whoosh.type = 'square';
            whoosh.frequency.setValueAtTime(600, now);
            whoosh.frequency.exponentialRampToValueAtTime(300, now + 0.12);
            
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(400, now);
            
            whooshGain.gain.setValueAtTime(0.12, now);
            whooshGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
            
            whoosh.connect(filter);
            filter.connect(whooshGain);
            whooshGain.connect(audioContext.destination);
            
            whoosh.start(now);
            whoosh.stop(now + 0.12);
        }
        
        function playSwordSwingSound() {
            const now = audioContext.currentTime;
            
            // Fast blade whoosh
            const whoosh = audioContext.createOscillator();
            const whooshGain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            whoosh.type = 'sawtooth';
            whoosh.frequency.setValueAtTime(800, now);
            whoosh.frequency.exponentialRampToValueAtTime(300, now + 0.2);
            
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(1000, now);
            filter.Q.setValueAtTime(2, now);
            
            whooshGain.gain.setValueAtTime(0.18, now);
            whooshGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
            
            whoosh.connect(filter);
            filter.connect(whooshGain);
            whooshGain.connect(audioContext.destination);
            
            whoosh.start(now);
            whoosh.stop(now + 0.2);
        }
        
        function playHammerSwingSound() {
            const now = audioContext.currentTime;
            
            // Heavy whoosh
            const whoosh = audioContext.createOscillator();
            const whooshGain = audioContext.createGain();
            
            whoosh.type = 'sine';
            whoosh.frequency.setValueAtTime(250, now);
            whoosh.frequency.exponentialRampToValueAtTime(100, now + 0.18);
            
            whooshGain.gain.setValueAtTime(0.2, now);
            whooshGain.gain.exponentialRampToValueAtTime(0.01, now + 0.18);
            
            whoosh.connect(whooshGain);
            whooshGain.connect(audioContext.destination);
            
            whoosh.start(now);
            whoosh.stop(now + 0.18);
        }
        
        function playAxeHitSound() { /* replaced by wood chop MP3 */ }
        
        function playPickaxeHitSound() { /* replaced by stonemine MP3 */ }
        
        function playSwordHitSound() {
            const now = audioContext.currentTime;
            
            // Sharp metallic hit
            const hit = audioContext.createOscillator();
            const hitGain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            hit.type = 'square';
            hit.frequency.setValueAtTime(800, now);
            hit.frequency.exponentialRampToValueAtTime(400, now + 0.06);
            
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(500, now);
            
            hitGain.gain.setValueAtTime(0.22, now);
            hitGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            
            hit.connect(filter);
            filter.connect(hitGain);
            hitGain.connect(audioContext.destination);
            
            hit.start(now);
            hit.stop(now + 0.1);
        }
        
        function playHammerHitSound() {
            const now = audioContext.currentTime;
            
            // Heavy metallic clang
            const clang = audioContext.createOscillator();
            const clangGain = audioContext.createGain();
            
            clang.type = 'square';
            clang.frequency.setValueAtTime(350, now);
            clang.frequency.exponentialRampToValueAtTime(180, now + 0.15);
            
            clangGain.gain.setValueAtTime(0.35, now);
            clangGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
            
            clang.connect(clangGain);
            clangGain.connect(audioContext.destination);
            
            clang.start(now);
            clang.stop(now + 0.2);
        }
        
        // Sound functions for pistol
        // Preload pistol shot sound
        let _pistolBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/pistolshot.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _pistolBuffer = buf; console.log('Pistol sound loaded OK'); })
            .catch(e => { console.error('Pistol sound fetch error:', e); });

        function playPistolSound() {
            if (!_pistolBuffer) return;
            const source = audioContext.createBufferSource();
            source.buffer = _pistolBuffer;
            source.playbackRate.value = 0.95 + Math.random() * 0.1; // slight pitch variation
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(1.0, audioContext.currentTime);
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);
            source.start();
        }
        
        function playPistolClickSound() {
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const now = audioCtx.currentTime;
            
            // Metallic click
            const click = audioCtx.createOscillator();
            const clickGain = audioCtx.createGain();
            click.connect(clickGain);
            clickGain.connect(audioCtx.destination);
            
            click.type = 'square';
            click.frequency.setValueAtTime(1200, now);
            click.frequency.exponentialRampToValueAtTime(800, now + 0.01);
            
            clickGain.gain.setValueAtTime(0.15, now);
            clickGain.gain.exponentialRampToValueAtTime(0.01, now + 0.02);
            
            click.start(now);
            click.stop(now + 0.02);
        }
        
        // Preload pistol reload sound
        let _reloadBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/pistolreload.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _reloadBuffer = buf; console.log('Pistol reload sound loaded OK'); })
            .catch(e => { console.error('Pistol reload sound fetch error:', e); });

        function playReloadSound() {
            if (!_reloadBuffer) return;
            const source = audioContext.createBufferSource();
            source.buffer = _reloadBuffer;
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(1.0, audioContext.currentTime);
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);
            source.start();
        }
        
        function toggleFlashlight() {
            flashlightOn = !flashlightOn;
            flashlight.intensity = flashlightOn ? 1.5 : 0;
            showMessage(flashlightOn ? '\ud83d\udd26 Flashlight ON' : '\ud83d\udd26 Flashlight OFF');
        }
        
        function checkPlayerCollision(newPos) {
            const playerRadius = 0.4;

            // ?? Nature obstacles: fast radius check in XZ ??
            const allNature = [
                ...treePositions.map(p => ({ ...p, r: (p.radius || 2) * 0.55 })),
                ...rockPositions.map(p => ({ ...p, r: (p.radius || 1.5) * 0.7 })),
                ...orePositions.map(p => ({ ...p, r: 0.9 })),
                ...sulfurPositions.map(p => ({ ...p, r: 0.9 })),
                ...bushPositions.map(p => ({ ...p, r: 0.8 })),
                ...desertFormationColliders,
                ...cactiPositions.map(p => ({ x: p.x, z: p.z, r: p.radius })),
            ];
            for (const ob of allNature) {
                const dx = newPos.x - ob.x, dz = newPos.z - ob.z;
                if (dx*dx + dz*dz < (playerRadius + ob.r) * (playerRadius + ob.r)) return true;
            }

            const playerBox = new THREE.Box3(
                new THREE.Vector3(newPos.x - playerRadius, newPos.y - 1.7, newPos.z - playerRadius),
                new THREE.Vector3(newPos.x + playerRadius, newPos.y, newPos.z + playerRadius)
            );
            
            for (let building of buildings) {
                // Don't collide with open doors
                if (building.userData.isDoor && building.userData.isOpen) continue;
                
                // Don't collide with door frames (walkable)
                if (building.userData.isDoorFrame) continue;
                
                // Don't collide with sleeping bags (walkable)
                if (building.userData.isSleepingBag) continue;
                
                // Don't collide with rugs (walkable decorations)
                if (building.userData.isRug || building.userData.noCollision) continue;
                
                // Don't collide with curtains (just decorative)
                if (building.userData.isCurtain) continue;
                
                // Don't collide with floors, ceilings, or ladder_ceilings (can walk on/under them)
                if (isFloorOrCeiling(building.userData.buildingType) || 
                    building.userData.isLadderCeiling) continue;
                
                // Don't collide with stairs (handle separately)
                if (building.userData.isStairs) continue;
                
                _reusableBox.setFromObject(building); // reuse ? no allocation
                if (playerBox.intersectsBox(_reusableBox)) {
                    return true; // Collision detected
                }
            }
            return false; // No collision
        }
        
        // Shared obstacle check for enemies/animals (XZ radius only, no buildings)
        function collidesWithNature(pos, radius) {
            const checks = [
                ...treePositions.map(p => ({ x: p.x, z: p.z, r: (p.radius || 2) * 0.55 })),
                ...rockPositions.map(p => ({ x: p.x, z: p.z, r: (p.radius || 1.5) * 0.7 })),
                ...orePositions.map(p => ({ x: p.x, z: p.z, r: 0.9 })),
                ...sulfurPositions.map(p => ({ x: p.x, z: p.z, r: 0.9 })),
                ...bushPositions.map(p => ({ x: p.x, z: p.z, r: 0.9 })),
                ...desertFormationColliders,
                ...cactiPositions.map(p => ({ x: p.x, z: p.z, r: p.radius })),
            ];
            for (const ob of checks) {
                const dx = pos.x - ob.x, dz = pos.z - ob.z;
                if (dx*dx + dz*dz < (radius + ob.r) * (radius + ob.r)) return true;
            }
            return false;
        }

        function checkStairsHeight() {
            let onStairs = false;
            for (let building of buildings) {
                if (building.userData.isStairs) {
                    _reusableBox.setFromObject(building); // reuse
                    // Check if player is within stairs XZ bounds
                    if (camera.position.x >= _reusableBox.min.x - 0.5 && camera.position.x <= _reusableBox.max.x + 0.5 &&
                        camera.position.z >= _reusableBox.min.z - 0.5 && camera.position.z <= _reusableBox.max.z + 0.5) {
                        
                        // Calculate local position relative to stairs center
                        const localX = camera.position.x - building.position.x;
                        const localZ = camera.position.z - building.position.z;
                        
                        // Rotate back by stairs rotation to get relative position
                        const rotation = -building.rotation.y;
                        const rotatedZ = localZ * Math.cos(rotation) - localX * Math.sin(rotation);
                        
                        // Progress from 0 (bottom) to 1 (top) based on rotated Z position
                        // Stairs go from -2 to +2 in local space (4 units)
                        const progress = Math.max(0, Math.min(1, (rotatedZ + 2) / 4));
                        
                        const stairHeight = progress * 3; // Stairs go up 3 units total
                        const targetHeight = building.position.y + stairHeight + 1.7;
                        
                        // Only set player height if they're close to the stair height (not jumping high above)
                        if (Math.abs(playerY - targetHeight) < 2) {
                            playerY = targetHeight;
                            camera.position.y = playerY;
                            isJumping = false; // Cancel jump when on stairs
                            jumpVelocity = 0;
                            onStairs = true;
                        }
                        break;
                    }
                }
            }
            return onStairs;
        }
        
        // ===== MOVEMENT =====
        // ===== FOOTSTEP SOUND SYSTEM =====
        let footstepTimer = 0;
        let lastFootstepSurface = 'grass';

        // Detect which surface the player is standing on
        function detectSurface() {
            const px = camera.position.x, pz = camera.position.z;
            const py = playerY; // from jump/movement scope ? approximate via camera

            // Check if standing on a placed floor
            for (let building of buildings) {
                const bt = building.userData.buildingType;
                if (!isFloorOrCeiling(bt)) continue;
                const box = new THREE.Box3().setFromObject(building);
                if (px >= box.min.x && px <= box.max.x && pz >= box.min.z && pz <= box.max.z) {
                    const floorTop = box.max.y;
                    if (Math.abs(camera.position.y - 1.7 - floorTop) < 0.5) {
                        if (bt === 'metal_floor') return 'metal';
                        if (bt === 'stone_floor') return 'stone';
                        return 'wood'; // default floor = wood
                    }
                }
            }

            // Check if standing near a rock or ore (dirt patch)
            for (let rp of rockPositions) {
                const d = Math.sqrt((px - rp.x) ** 2 + (pz - rp.z) ** 2);
                // Check if on dirt patch (larger radius) or on rock itself (smaller radius)
                if (d < rp.radius * 1.7) return 'dirt'; // Dirt patch around rock
                if (d < rp.radius * 0.9) return 'stone'; // On the rock itself
            }
            for (let op of orePositions) {
                const d = Math.sqrt((px - op.x) ** 2 + (pz - op.z) ** 2);
                // Check if on dirt patch (larger radius) or on ore itself (smaller radius)
                if (d < op.radius * 1.7) return 'dirt'; // Dirt patch around ore
                if (d < op.radius * 0.9) return 'stone'; // On the ore itself
            }

            return 'grass';
        }

        // Play a footstep for the given surface
        function playFootstep(surface) {
            const now = audioContext.currentTime;
            const vol = volumeSettings.footsteps;
            if (vol <= 0) return;

            if (surface === 'grass') {
                // Deep thud ? sub-bass noise burst (was dirt)
                const bufSize = audioContext.sampleRate * 0.14;
                const buf = audioContext.createBuffer(1, bufSize, audioContext.sampleRate);
                const d = buf.getChannelData(0);
                for (let i = 0; i < bufSize; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufSize * 0.38));
                const src = audioContext.createBufferSource();
                src.buffer = buf;
                const lp = audioContext.createBiquadFilter();
                lp.type = 'lowpass'; lp.frequency.value = 220; // was 900
                lp.Q.value = 2.0;
                const g = audioContext.createGain();
                g.gain.setValueAtTime(vol * 0.7, now);
                g.gain.exponentialRampToValueAtTime(0.001, now + 0.16);
                src.connect(lp); lp.connect(g); g.connect(audioContext.destination);
                src.start(now); src.stop(now + 0.18);

            } else if (surface === 'dirt') {
                // Soft low rustle ? very short, filtered to low-mid band (was grass)
                const bufSize = audioContext.sampleRate * 0.1;
                const buf = audioContext.createBuffer(1, bufSize, audioContext.sampleRate);
                const d = buf.getChannelData(0);
                for (let i = 0; i < bufSize; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufSize * 0.45));
                const src = audioContext.createBufferSource();
                src.buffer = buf;
                const hp = audioContext.createBiquadFilter();
                hp.type = 'highpass'; hp.frequency.value = 120; // was 800 ? much lower
                const lp = audioContext.createBiquadFilter();
                lp.type = 'lowpass'; lp.frequency.value = 700; // was 3500 ? much lower
                const g = audioContext.createGain();
                g.gain.setValueAtTime(vol * 0.6, now);
                g.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
                src.connect(hp); hp.connect(lp); lp.connect(g); g.connect(audioContext.destination);
                src.start(now); src.stop(now + 0.14);

            } else if (surface === 'wood') {
                // Hollow low knock ? deeper sine thud
                const osc = audioContext.createOscillator();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(60 + Math.random() * 20, now); // was 160
                osc.frequency.exponentialRampToValueAtTime(32, now + 0.12); // was 80
                const g = audioContext.createGain();
                g.gain.setValueAtTime(vol * 0.55, now);
                g.gain.exponentialRampToValueAtTime(0.001, now + 0.14);
                osc.connect(g); g.connect(audioContext.destination);
                osc.start(now); osc.stop(now + 0.16);
                // low-mid click layer
                const bufSize = audioContext.sampleRate * 0.04;
                const buf = audioContext.createBuffer(1, bufSize, audioContext.sampleRate);
                const dd = buf.getChannelData(0);
                for (let i = 0; i < bufSize; i++) dd[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufSize * 0.18));
                const src = audioContext.createBufferSource();
                src.buffer = buf;
                const bp = audioContext.createBiquadFilter();
                bp.type = 'bandpass'; bp.frequency.value = 350; // was 2500
                bp.Q.value = 1.5;
                const g2 = audioContext.createGain();
                g2.gain.setValueAtTime(vol * 0.3, now);
                src.connect(bp); bp.connect(g2); g2.connect(audioContext.destination);
                src.start(now); src.stop(now + 0.05);

            } else if (surface === 'stone') {
                // Hard low clack ? lower bandpass
                const bufSize = audioContext.sampleRate * 0.08;
                const buf = audioContext.createBuffer(1, bufSize, audioContext.sampleRate);
                const d = buf.getChannelData(0);
                for (let i = 0; i < bufSize; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufSize * 0.14));
                const src = audioContext.createBufferSource();
                src.buffer = buf;
                const bp = audioContext.createBiquadFilter();
                bp.type = 'bandpass'; bp.frequency.value = 320; // was 1800
                bp.Q.value = 2.5;
                const g = audioContext.createGain();
                g.gain.setValueAtTime(vol * 0.7, now);
                g.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                src.connect(bp); bp.connect(g); g.connect(audioContext.destination);
                src.start(now); src.stop(now + 0.12);

            } else if (surface === 'metal') {
                // Lower metallic clang ? deeper resonance
                [90, 96].forEach(freq => { // was 320, 327
                    const osc = audioContext.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.value = freq + Math.random() * 6;
                    const g = audioContext.createGain();
                    g.gain.setValueAtTime(vol * 0.4, now);
                    g.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
                    osc.connect(g); g.connect(audioContext.destination);
                    osc.start(now); osc.stop(now + 0.28);
                });
                // mid-body thud layer
                const bufSize = audioContext.sampleRate * 0.04;
                const buf = audioContext.createBuffer(1, bufSize, audioContext.sampleRate);
                const dd = buf.getChannelData(0);
                for (let i = 0; i < bufSize; i++) dd[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufSize * 0.12));
                const src = audioContext.createBufferSource();
                src.buffer = buf;
                const bp = audioContext.createBiquadFilter();
                bp.type = 'bandpass'; bp.frequency.value = 500; // was 4000
                bp.Q.value = 2;
                const g = audioContext.createGain();
                g.gain.setValueAtTime(vol * 0.45, now);
                src.connect(bp); bp.connect(g); g.connect(audioContext.destination);
                src.start(now); src.stop(now + 0.05);
            }
        }

        function updateMovement() {
            if (isDead) return;
            // 3rd-person: movement and camera are handled entirely in updateThirdPerson().
            // We still run gravity/jump/ladder below so physics works in both modes.
            if (isThirdPerson) return;

            const forward = new THREE.Vector3(0, 0, -1);
            const right = new THREE.Vector3(1, 0, 0);
            forward.applyQuaternion(camera.quaternion);
            right.applyQuaternion(camera.quaternion);
            forward.y = 0; right.y = 0;
            forward.normalize(); right.normalize();

            const isSprinting = keys['shift'] && stamina > 10 && (keys['w'] || keys['s'] || keys['a'] || keys['d']);
            const currentSpeed = isSprinting ? sprintSpeed : moveSpeed;

            if (isSprinting) {
                const drainMult = activeBuffs.veggi_stew ? 0.5 : 1.0;
                stamina = Math.max(5, stamina - staminaDrainRate * drainMult);
                if (stamina <= 5) staminaDepletedTime = Date.now();
            } else {
                const timeSinceDepletion = Date.now() - staminaDepletedTime;
                if (stamina > 5 || timeSinceDepletion > staminaRegenDelay)
                    stamina = Math.min(maxStamina, stamina + staminaRegenRate * 0.5);
            }

            if (keys['w']) {
                const newPos = camera.position.clone().addScaledVector(forward,  currentSpeed);
                if (!checkPlayerCollision(newPos)) camera.position.copy(newPos);
            }
            if (keys['s']) {
                const newPos = camera.position.clone().addScaledVector(forward, -currentSpeed);
                if (!checkPlayerCollision(newPos)) camera.position.copy(newPos);
            }
            if (keys['a']) {
                const newPos = camera.position.clone().addScaledVector(right,   -currentSpeed);
                if (!checkPlayerCollision(newPos)) camera.position.copy(newPos);
            }
            if (keys['d']) {
                const newPos = camera.position.clone().addScaledVector(right,    currentSpeed);
                if (!checkPlayerCollision(newPos)) camera.position.copy(newPos);
            }

            const isMovingNow = keys['w'] || keys['s'] || keys['a'] || keys['d'];
            if (isMovingNow && !isJumping && !onLadder) {
                const stepInterval = isSprinting ? 0.32 : 0.52; // s between steps
                footstepTimer += 0.016; // ~60fps delta
                if (footstepTimer >= stepInterval) {
                    footstepTimer = 0;
                    const surface = detectSurface();
                    playFootstep(surface);
                }
            } else {
                footstepTimer = 0;
            }
            
            // Check if on stairs and adjust Y position
            const onStairs = checkStairsHeight();
            
            // Check if near a ladder and allow climbing - treat stacked ladders as one continuous ladder
            onLadder = false; // Reset each frame
            let ladderTop = -Infinity;
            let ladderBottom = Infinity;
            let ladderPosition = null;
            
            // First, find all ladders at the same position (stacked ladders)
            const nearbyLadders = [];
            for (let building of buildings) {
                if (building.userData.isLadder) {
                    const distToLadder = Math.sqrt(
                        Math.pow(camera.position.x - building.position.x, 2) + 
                        Math.pow(camera.position.z - building.position.z, 2)
                    );
                    
                    // Closer range - must be within 0.8 units (was 1.5)
                    if (distToLadder <= 0.8) {
                        nearbyLadders.push(building);
                    }
                }
            }
            
            // If we found nearby ladders, treat them as one continuous ladder system
            if (nearbyLadders.length > 0) {
                // Find the combined top and bottom of all stacked ladders at this position
                for (let ladder of nearbyLadders) {
                    const ladderBox = new THREE.Box3().setFromObject(ladder);
                    ladderTop = Math.max(ladderTop, ladderBox.max.y);
                    ladderBottom = Math.min(ladderBottom, ladderBox.min.y);
                    if (!ladderPosition) {
                        ladderPosition = { x: ladder.position.x, z: ladder.position.z };
                    }
                }
                
                // Check if player is within the combined ladder's vertical range (with larger buffer)
                if (camera.position.y >= ladderBottom - 1.0 && camera.position.y <= ladderTop + 2.0) {
                    onLadder = true;
                    
                    // Use E key to climb up
                    if (keys['e']) {
                        // Smooth climbing animation - fixed speed regardless of framerate
                        const climbSpeed = 0.08;
                        camera.position.y += climbSpeed;
                        
                        // Check for ladder_ceiling exit point near the ladder top
                        let ladderCeilingExit = null;
                        for (let building of buildings) {
                            if (building.userData.isLadderCeiling) {
                                // Check if this ladder ceiling is near the ladder horizontally
                                const distToCeiling = Math.sqrt(
                                    Math.pow(building.position.x - ladderPosition.x, 2) + 
                                    Math.pow(building.position.z - ladderPosition.z, 2)
                                );
                                // Check if ceiling is near the ladder top vertically
                                const heightDiff = Math.abs(building.position.y - ladderTop);
                                
                                if (distToCeiling < 2.5 && heightDiff < 2.0) {
                                    ladderCeilingExit = building;
                                    break;
                                }
                            }
                        }
                        
                        // Auto-detach when reaching the top
                        if (camera.position.y >= ladderTop - 1.5) {
                            if (ladderCeilingExit) {
                                // Exit onto ladder ceiling - treat its Y position as the floor surface
                                // Place player standing on it (camera at floor + eye height)
                                camera.position.y = ladderCeilingExit.position.y + 1.7;
                            } else {
                                // No ladder ceiling - calculate from ladder top
                                // ladderTop is the top of the ladder mesh
                                // Player feet should be at ladderTop, camera at ladderTop + 1.7
                                camera.position.y = ladderTop + 1.7;
                            }
                            onLadder = false;
                        }
                    }
                    // Use S key to climb down
                    if (keys['s']) {
                        const climbDownSpeed = 0.06;
                        camera.position.y -= climbDownSpeed;
                    }
                    
                    // Cancel jumping/falling when on ladder
                    isJumping = false;
                    jumpVelocity = 0;
                }
            }
            
            // Apply gravity if not on stairs, not on ladder, and not jumping
            if (!onStairs && !onLadder && !isJumping) {
                // Check if there's a floor/ceiling under the player
                let groundLevel = 1.7;
                let onGround = false;
                
                for (let building of buildings) {
                    if (isFloorOrCeiling(building.userData.buildingType)) {
                        const box = new THREE.Box3().setFromObject(building);
                        // Check if player is standing on this floor/ceiling
                        if (camera.position.x >= box.min.x && camera.position.x <= box.max.x &&
                            camera.position.z >= box.min.z && camera.position.z <= box.max.z) {
                            const floorTop = box.max.y + 1.7;
                            if (Math.abs(playerY - floorTop) < 0.3) {
                                groundLevel = floorTop;
                                onGround = true;
                                break;
                            }
                        }
                    }
                }
                
                // If player is above ground level and not on a floor, start falling
                if (playerY > groundLevel) {
                    isJumping = true;
                    jumpVelocity = -0.1; // Start falling
                }
            }
            
            // Jump physics
            if (isJumping) {
                playerY += jumpVelocity;
                jumpVelocity -= gravity;
                
                // Land on ground or on floor/ceiling
                let groundLevel = 1.7;
                for (let building of buildings) {
                    if (isFloorOrCeiling(building.userData.buildingType)) {
                        const box = new THREE.Box3().setFromObject(building);
                        const playerBox = new THREE.Box3(
                            new THREE.Vector3(camera.position.x - 0.3, playerY - 1.7, camera.position.z - 0.3),
                            new THREE.Vector3(camera.position.x + 0.3, playerY, camera.position.z + 0.3)
                        );
                        if (box.intersectsBox(playerBox) && playerY > box.max.y) {
                            groundLevel = Math.max(groundLevel, box.max.y + 1.7);
                        }
                    }
                }
                
                if (playerY <= groundLevel) {
                    playerY = groundLevel;
                    isJumping = false;
                    jumpVelocity = 0;
                }
            }
            
            // Keep player at correct height
            camera.position.y = playerY;
            
            // Update flashlight position
            if (flashlightOn) {
                flashlight.position.copy(camera.position);
                const target = new THREE.Vector3(0, 0, -1);
                target.applyQuaternion(camera.quaternion);
                target.add(camera.position);
                flashlight.target.position.copy(target);
            }
        }
        
        // ===== ATTACK AND GATHER SYSTEM =====
        function handleAttack() {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            const allObjects = [...trees, ...rocks, ...metalOres, ...sulfurOres, ...window.animals, ...enemies, ...berryBushes, ...grassBlades, ...desertGrassTufts, ...cacti, ...groundCollectibles, ...wildPlants, ...buildings];
            const intersects = raycaster.intersectObjects(allObjects, true);
            
            if (intersects.length > 0) {
                const distance = intersects[0].distance;
                
                // Check if within reach (5 units = about 1 meter in game scale)
                if (distance > 5) {
                    showMessage('\u26a0\ufe0f Too far away!');
                    return;
                }
                
                let target = intersects[0].object;
                while (target.parent && !target.userData.type && !target.userData.isWildPlant && !target.userData.buildingType && !target.userData.isDoor && !target.userData.isStorageBox && !target.userData.isWorkbench && !target.userData.isBuildingBench && !target.userData.isSewingTable && !target.userData.isRecycler && !target.userData.isWaterCatcher && !target.userData.isFurnace && !target.userData.isCampfire && !target.userData.isDoorFrame && !target.userData.isSleepingBag && !target.userData.isPlanterBox) {
                    target = target.parent;
                }
                
                const heldItem = hotbar[selectedHotbarSlot].item;
                
                // Animate tool
                animateTool();

                // Wild plant harvest
                if (target.userData.isWildPlant) {
                    if (!target.userData.harvestable) {
                        const minsLeft = Math.ceil((target.userData.respawnAt - Date.now()) / 60000);
                        showMessage(` Regrowth in ~${minsLeft} min`);
                        return;
                    }
                    const map = _harvestMap[target.userData.seedType];
                    if (map) {
                        inventory[map.produce] = (inventory[map.produce]||0) + map.count;
                        inventory[target.userData.seedType] = (inventory[target.userData.seedType]||0) + map.seedReturn;
                        const pName = itemDisplayNames[map.produce]||map.produce;
                        showMessage(` Harvested wild ${pName}! +${map.count} ${pName} +${map.seedReturn} seed(s)`);
                    }
                    playPlantSound();

                    // Remove from scene and wildPlants array entirely
                    scene.remove(target);
                    const wi = wildPlants.indexOf(target);
                    if (wi !== -1) wildPlants.splice(wi, 1);

                    // Schedule a respawn at a new random location after 15 real minutes
                    const seedType = target.userData.seedType;
                    setTimeout(() => {
                        // Find a valid new position (same logic as initial spawn)
                        let nx, nz, valid = false, attempts = 0;
                        do {
                            nx = (Math.random() - 0.5) * 160;
                            nz = 10 + Math.random() * 70;
                            if (Math.sqrt(nx*nx + nz*nz) < 18) { attempts++; continue; }
                            valid = true;
                            for (const pos of [...treePositions, ...rockPositions, ...bushPositions]) {
                                if (Math.sqrt((nx-pos.x)**2+(nz-pos.z)**2) < 4) { valid = false; break; }
                            }
                            // Also avoid other wild plants
                            for (const wp of wildPlants) {
                                if (Math.sqrt((nx-wp.position.x)**2+(nz-wp.position.z)**2) < 3) { valid = false; break; }
                            }
                            attempts++;
                        } while (!valid && attempts < 120);
                        if (!valid) return; // couldn't find spot, skip this respawn

                        const _wsc = {wheat_seed:7.5,corn_seed:6.8,hemp_seed:6.5,red_berry_seed:1.2,black_berry_seed:1.2,tomato_seed:0.625,pumpkin_seed:5.0,cucumber_seed:2.5,potato_seed:2.5,carrot_seed:2.5,cabbage_seed:2.5,mushroom_seed:2.5,strawberry_seed:2.5};
                        const fresh = buildPlantModel(seedType, 4, _wsc[seedType] || 2.5);
                        fresh.position.set(nx, 0, nz);
                        fresh.rotation.y = Math.random() * Math.PI * 2;
                        fresh.userData.isWildPlant = true;
                        fresh.userData.seedType    = seedType;
                        fresh.userData.harvestable = true;
                        fresh.userData.respawnAt   = 0;
                        scene.add(fresh);
                        wildPlants.push(fresh);
                    }, 15 * 60 * 1000); // 15 real minutes

                    updateUI();
                    return;
                }
                
                // Ground collectibles - no tool needed
                if (target.userData.type === 'stick_pickup' || target.userData.type === 'mushroom_pickup' || target.userData.type === 'rock_pickup') {
                    const collectible = target.userData.collectible;
                    const amount = target.userData.amount;
                    
                    inventory[collectible] += amount;
                    if (target.userData.type === 'mushroom_pickup') playPlantSound(); else playCollectSound();
                    showMessage(`+ ${amount} ${collectible}`);
                    scene.remove(target);
                    groundCollectibles.splice(groundCollectibles.indexOf(target), 1);
                    updateUI();
                    return;
                }
                
                if (target.userData.type === 'tree') {
                    // Sharp stone OR axe can harvest trees
                    if (heldItem !== 'axe' && heldItem !== 'sharp_stone' && heldItem !== 'stone_axe') {
                        showMessage('\ud83e\ude93 Need an axe or sharp stone to chop trees!');
                        return;
                    }
                    
                    target.userData.health--;
                    playTreeChopSound(); // Custom tree chop sound
                    playAxeHitSound(); // Tool impact sound
                    
                    // Shake tree on hit
                    const originalRotation = target.rotation.z;
                    target.rotation.z = originalRotation + (Math.random() - 0.5) * 0.1;
                    setTimeout(() => {
                        if (target.parent) target.rotation.z = originalRotation;
                    }, 100);
                    
                    if (target.userData.health <= 0) {
                        // Axe gives 2x resources compared to sharp stone
                        const heartyMult = activeBuffs.hearty ? 2 : 1;
                        const woodAmount = ((heldItem === 'axe' || heldItem === 'stone_axe') ? 4 : 2) * heartyMult;
                        const sticksAmount = ((heldItem === 'axe' || heldItem === 'stone_axe') ? 2 : 1) * heartyMult;
                        
                        inventory.wood += woodAmount;
                        inventory.sticks += sticksAmount;
                        
                        // Animate tree falling
                        const treePos = target.position.clone();
                        // Use userData.trunkHeight (set on both GLB and procedural trees at spawn).
                        // GLB trees have no CylinderGeometry so geometry.parameters.height throws.
                        const trunkHeight = target.userData.trunkHeight
                            || (target.children[0]?.geometry?.parameters?.height)
                            || 5;
                        
                        playTreeFallSound(); // Tree falling sound
                        
                        // Fall animation
                        let fallProgress = 0;
                        const fallDuration = 80; // frames (~1.3 seconds at 60fps)
                        const fallDirection = Math.random() * Math.PI * 2; // Random direction
                        
                        target.userData.falling = true;
                        target.userData.fallProgress = 0;
                        target.userData.fallDuration = fallDuration;
                        target.userData.fallDirection = fallDirection;
                        target.userData.onFallComplete = async () => {
                            // Remove fallen tree from collision immediately
                            if (target.userData._posEntry && target.userData._posArray) {
                                const idx = target.userData._posArray.indexOf(target.userData._posEntry);
                                if (idx !== -1) target.userData._posArray.splice(idx, 1);
                            }

                            // Remove fallen tree
                            scene.remove(target);
                            trees.splice(trees.indexOf(target), 1);
                            
                            // Create stump
                            const stump = await createTreeStump(treePos.x, treePos.z, trunkHeight);
                            
                            // Add to respawn queue (5 minutes = 300000ms)
                            stumpRespawnQueue.push({
                                stump: stump,
                                respawnTime: Date.now() + 300000,
                                position: { x: treePos.x, z: treePos.z }
                            });
                        };
                        
                        showMessage(`+ ${woodAmount} Wood, + ${sticksAmount} Sticks`);
                    }
                } else if (target.userData.type === 'rock') {
                    // Sharp stone or pickaxe for rocks
                    if (heldItem !== 'pickaxe' && heldItem !== 'sharp_stone' && heldItem !== 'stone_pickaxe') {
                        showMessage('\u26cf\ufe0f Need a pickaxe or sharp stone to mine rocks!');
                        return;
                    }
                    
                    target.userData.health--;
                    playRockMineSound(); // Custom rock mining sound
                    playPickaxeHitSound(); // Tool impact sound
                    
                    // Shrink rock with each hit
                    const healthPercent = target.userData.health / target.userData.maxHealth;
                    const scale = 0.5 + (healthPercent * 0.5); // Shrinks from 100% to 50% size
                    target.scale.set(scale, scale, scale);
                    
                    // Shake effect
                    const originalY = target.position.y;
                    target.position.y = originalY + 0.05;
                    setTimeout(() => {
                        if (target.parent) target.position.y = originalY;
                    }, 50);
                    
                    if (target.userData.health <= 0) {
                        // Pickaxe gives 2x resources
                        const heartyMult = activeBuffs.hearty ? 2 : 1;
                        const stoneAmount = ((heldItem === 'pickaxe' || heldItem === 'stone_pickaxe') ? 4 : 2) * heartyMult;
                        inventory.stone += stoneAmount;
                        
                        // Store position before removal
                        const rockPos = target.position.clone();
                        
                        // Remove from collision arrays immediately
                        if (target.userData._posEntry && target.userData._posArray) {
                            const idx = target.userData._posArray.indexOf(target.userData._posEntry);
                            if (idx !== -1) target.userData._posArray.splice(idx, 1);
                        }

                        // Poof effect as it disappears
                        target.scale.set(0.1, 0.1, 0.1);
                        setTimeout(() => {
                            scene.remove(target);
                            rocks.splice(rocks.indexOf(target), 1);
                            
                            // Add to respawn queue (5 minutes)
                            rockRespawnQueue.push({
                                respawnTime: Date.now() + 300000,
                                originalPosition: rockPos
                            });
                        }, 100);
                        
                        showMessage(`+ ${stoneAmount} Stone`);
                    }
                } else if (target.userData.type === 'metal_ore') {
                    // Need pickaxe for metal ore
                    if (heldItem !== 'pickaxe' && heldItem !== 'stone_pickaxe') {
                        showMessage('\u26cf\ufe0f Need a pickaxe to mine metal ore!');
                        return;
                    }
                    
                    target.userData.health--;
                    playOreMineSound(); // Custom ore mining sound
                    playPickaxeHitSound(); // Tool impact sound
                    
                    // Shrink ore with each hit
                    const healthPercent = target.userData.health / target.userData.maxHealth;
                    const scale = 0.4 + (healthPercent * 0.6); // Shrinks from 100% to 40% size
                    target.scale.set(scale, scale, scale);
                    
                    // Metallic flash effect
                    target.children.forEach(child => {
                        if (child.material) {
                            const originalEmissive = child.material.emissive ? child.material.emissive.getHex() : 0;
                            child.material.emissive = new THREE.Color(0x888888);
                            child.material.emissiveIntensity = 0.5;
                            setTimeout(() => {
                                if (child.material) {
                                    child.material.emissive = new THREE.Color(originalEmissive);
                                    child.material.emissiveIntensity = 0;
                                }
                            }, 100);
                        }
                    });
                    
                    if (target.userData.health <= 0) {
                        // Pickaxe gives full yield
                        const heartyMult = activeBuffs.hearty ? 2 : 1;
                        inventory.iron_ore += 3 * heartyMult;
                        
                        // Store position before removal
                        const orePos = target.position.clone();

                        // Remove from collision arrays immediately
                        if (target.userData._posEntry && target.userData._posArray) {
                            const idx = target.userData._posArray.indexOf(target.userData._posEntry);
                            if (idx !== -1) target.userData._posArray.splice(idx, 1);
                        }
                        
                        // Sparkle effect as it disappears
                        target.scale.set(0.1, 0.1, 0.1);
                        setTimeout(() => {
                            scene.remove(target);
                            metalOres.splice(metalOres.indexOf(target), 1);
                            
                            // Add to respawn queue (5 minutes)
                            oreRespawnQueue.push({
                                respawnTime: Date.now() + 300000,
                                originalPosition: orePos,
                                type: 'metal'
                            });
                        }, 150);
                        
                        showMessage('+ 3 Iron Ore');
                    }
                } else if (target.userData.type === 'sulfur_ore') {
                    // Need pickaxe or stone pickaxe for sulfur ore
                    if (heldItem !== 'pickaxe' && heldItem !== 'stone_pickaxe') {
                        showMessage('\u26cf\ufe0f Need a pickaxe to mine sulfur!');
                        return;
                    }

                    target.userData.health--;
                    playOreMineSound();
                    playPickaxeHitSound();

                    // Shrink with each hit
                    const healthPercent = target.userData.health / target.userData.maxHealth;
                    const scale = 0.4 + (healthPercent * 0.6);
                    target.scale.set(scale, scale, scale);

                    // Green flash on hit
                    target.children.forEach(child => {
                        if (child.material) {
                            const origEmissive = child.material.emissive ? child.material.emissive.getHex() : 0;
                            const origIntensity = child.material.emissiveIntensity || 0;
                            child.material.emissive = new THREE.Color(0x44cc00);
                            child.material.emissiveIntensity = 0.6;
                            setTimeout(() => {
                                if (child.material) {
                                    child.material.emissive = new THREE.Color(origEmissive);
                                    child.material.emissiveIntensity = origIntensity;
                                }
                            }, 100);
                        }
                    });

                    if (target.userData.health <= 0) {
                        const heartyMult = activeBuffs.hearty ? 2 : 1;
                        const sulfurAmount = ((heldItem === 'pickaxe') ? 4 : 2) * heartyMult;
                        inventory.sulfur_ore += sulfurAmount;

                        const orePos = target.position.clone();

                        // Remove from collision arrays immediately
                        if (target.userData._posEntry && target.userData._posArray) {
                            const idx = target.userData._posArray.indexOf(target.userData._posEntry);
                            if (idx !== -1) target.userData._posArray.splice(idx, 1);
                        }

                        target.scale.set(0.1, 0.1, 0.1);
                        setTimeout(() => {
                            scene.remove(target);
                            sulfurOres.splice(sulfurOres.indexOf(target), 1);
                            oreRespawnQueue.push({
                                respawnTime: Date.now() + 300000,
                                originalPosition: orePos,
                                type: 'sulfur'
                            });
                        }, 150);

                        showMessage(`\u26cf\ufe0f + ${sulfurAmount} Sulfur Ore`);
                        updateUI();
                    }
                } else if (target.userData.type === 'animal') {
                    // Any weapon can hunt
                    if (!['sword', 'spear', 'axe', 'pickaxe', 'sharp_stone'].includes(heldItem)) {
                        showMessage('\u2694\ufe0f Need a weapon or tool to hunt!');
                        return;
                    }
                    
                    // Damage: Sword > Spear > Tools > Sharp Stone
                    let damageAmount = 10;
                    if (heldItem === 'sword') damageAmount = 60;
                    else if (heldItem === 'spear') damageAmount = 50;
                    else if (heldItem === 'axe' || heldItem === 'pickaxe') damageAmount = 25;
                    else if (heldItem === 'sharp_stone') damageAmount = 15;
                    
                    target.userData.health -= damageAmount;
                    playHitSound();
                    
                    if (target.userData.health <= 0) {
                        const heartyMult = activeBuffs.hearty ? 2 : 1;
                        inventory.meat += 2 * heartyMult;
                        scene.remove(target);
                        window.animals.splice(window.animals.indexOf(target), 1);
                        showMessage(`+ ${2 * heartyMult} Meat`);
                    }
                } else if (target.userData.type === 'enemy') {
                    // Any weapon or tool can fight
                    if (!['sword', 'spear', 'axe', 'pickaxe', 'sharp_stone'].includes(heldItem)) {
                        showMessage('\u2694\ufe0f Need a weapon or tool to fight!');
                        return;
                    }
                    
                    // Damage: Sword > Spear > Tools > Sharp Stone
                    let damageAmount = 5;
                    if (heldItem === 'sword') damageAmount = 50;
                    else if (heldItem === 'spear') damageAmount = 40;
                    else if (heldItem === 'axe' || heldItem === 'pickaxe') damageAmount = 20;
                    else if (heldItem === 'sharp_stone') damageAmount = 10;
                    
                    target.userData.health -= damageAmount;
                    playHitSound();
                    
                    if (heldItem === 'axe' || heldItem === 'pickaxe' || heldItem === 'sharp_stone') {
                        showMessage(`\u26a0\ufe0f ${heldItem} is not very effective against enemies!`);
                    }
                    
                    if (target.userData.health <= 0) {
                        scene.remove(target);
                        enemies.splice(enemies.indexOf(target), 1);
                        showMessage('\u2705 Enemy defeated!');
                    }
                } else if (target.userData.type === 'scorpion') {
                    // Scorpions can be killed with any weapon or tool (they're small)
                    if (!['sword', 'spear', 'axe', 'pickaxe', 'sharp_stone'].includes(heldItem)) {
                        showMessage(' Use a weapon or tool to kill the scorpion!');
                        return;
                    }
                    let scorpDmg = 5;
                    if (heldItem === 'sword') scorpDmg = 25;
                    else if (heldItem === 'spear') scorpDmg = 20;
                    else if (heldItem === 'axe' || heldItem === 'pickaxe') scorpDmg = 15;
                    else if (heldItem === 'sharp_stone') scorpDmg = 8;
                    target.userData.health -= scorpDmg;
                    playHitSound();
                    if (target.userData.health <= 0) {
                        scene.remove(target);
                        scorpions.splice(scorpions.indexOf(target), 1);
                        showMessage(' Scorpion killed!');
                    } else {
                        showMessage(` Hit scorpion! (${Math.max(0, target.userData.health)}/${target.userData.maxHealth} HP)`);
                    }
                } else if (target.userData.type === 'coyote') {
                    if (!['sword', 'spear', 'axe', 'pickaxe', 'sharp_stone'].includes(heldItem)) {
                        showMessage(' Use a weapon to fight the coyote!');
                        return;
                    }
                    let coyDmg = 8;
                    if (heldItem === 'sword') coyDmg = 30;
                    else if (heldItem === 'spear') coyDmg = 25;
                    else if (heldItem === 'axe' || heldItem === 'pickaxe') coyDmg = 18;
                    else if (heldItem === 'sharp_stone') coyDmg = 10;
                    target.userData.health -= coyDmg;
                    target.userData.state = 'chase';
                    playHitSound();
                    if (target.userData.health <= 0) {
                        scene.remove(target);
                        coyotes.splice(coyotes.indexOf(target), 1);
                        inventory.meat += 2; updateUI();
                        showMessage(' Coyote killed! +2 Meat');
                    } else {
                        showMessage(` Hit coyote! (${Math.max(0, target.userData.health)}/${target.userData.maxHealth} HP)`);
                    }
                } else if (target.userData.type === 'berryBush') {
                    // Berry bushes give berries + small fiber
                    const bush = target;
                    let collected = 0;
                    bush.userData.berries.forEach(berry => {
                        if (berry.userData.isVisible) {
                            berry.visible = false;
                            berry.userData.isVisible = false;
                            berry.userData.respawnTime = 3600;
                            collected++;
                        }
                    });
                    
                    if (collected > 0) {
                        const heartyMult = activeBuffs.hearty ? 2 : 1;
                        inventory.berries += collected * heartyMult;
                        // Berry bushes give 1 fiber (less than regular grass which gives 2)
                        inventory.fiber += 1 * heartyMult;
                        playPlantSound(); // Custom berry picking sound
                        showMessage(`+ ${collected * heartyMult} Berries, + ${heartyMult} Fiber`);
                    }
                } else if (grassBlades.includes(target)) {
                    // Grass gives good fiber
                    const heartyMult = activeBuffs.hearty ? 2 : 1;
                    inventory.fiber += 2 * heartyMult;
                    playPlantSound();
                    showMessage(`+ ${2 * heartyMult} Fiber`);
                    scene.remove(target);
                    grassBlades.splice(grassBlades.indexOf(target), 1);
                } else if (desertGrassTufts.includes(target)) {
                    // Desert grass tufts give 1-2 fiber
                    const heartyMult = activeBuffs.hearty ? 2 : 1;
                    const fiberAmount = (1 + Math.floor(Math.random() * 2)) * heartyMult;
                    inventory.fiber += fiberAmount;
                    playPlantSound();
                    showMessage('\ud83c\udf3f +' + fiberAmount + ' Fiber');
                    scene.remove(target);
                    desertGrassTufts.splice(desertGrassTufts.indexOf(target), 1);
                } else if (cacti.includes(target)) {
                    // Cacti give cloth when harvested  then disappear and respawn elsewhere
                    if (!target.userData.hasCloth) {
                        showMessage(' Already harvested  come back later');
                        return;
                    }
                    const heartyMult = activeBuffs.hearty ? 2 : 1;
                    const clothAmount = (1 + Math.floor(Math.random() * 2)) * heartyMult;
                    inventory.cloth = (inventory.cloth || 0) + clothAmount;
                    playPlantSound();
                    showMessage(' +' + clothAmount + ' Cloth');

                    // Remove from scene, cacti array, and cactiPositions collision
                    scene.remove(target);
                    const ci = cacti.indexOf(target);
                    if (ci !== -1) cacti.splice(ci, 1);
                    // Remove matching position entry
                    const cpIdx = cactiPositions.findIndex(p => Math.abs(p.x - target.position.x) < 0.1 && Math.abs(p.z - target.position.z) < 0.1);
                    if (cpIdx !== -1) cactiPositions.splice(cpIdx, 1);

                    // Respawn a new cactus at a different desert location after ~5 real minutes
                    setTimeout(() => {
                        const dcMargin  = 8;
                        const dcCenterZ = -desertOffset + 0.5;
                        const dcHalf    = groundSize / 2 - dcMargin;
                        const dcXMin    = -groundSize / 2 + dcMargin;
                        const dcXMax    =  groundSize / 2 - dcMargin;
                        const dcZMin    = dcCenterZ - dcHalf;
                        const dcZMax    = dcCenterZ + dcHalf - 18;
                        let fx, fz, valid = false, attempts = 0;
                        do {
                            fx = dcXMin + Math.random() * (dcXMax - dcXMin);
                            fz = dcZMin + Math.random() * (dcZMax - dcZMin);
                            valid = true;
                            for (const ob of desertFormationColliders) {
                                if (Math.sqrt((fx-ob.x)**2+(fz-ob.z)**2) < ob.r + 1.5) { valid=false; break; }
                            }
                            if (valid) {
                                for (const p of [...rockPositions, ...orePositions, ...sulfurPositions, ...cactiPositions]) {
                                    if (Math.sqrt((fx-p.x)**2+(fz-p.z)**2) < 4) { valid=false; break; }
                                }
                            }
                            attempts++;
                        } while (!valid && attempts < 80);
                        if (valid) createCactus(fx, fz);
                    }, 5 * 60 * 1000); // 5 real minutes
                } // end else if (cacti)
                
                updateUI();
            }
        }
        
        // Handle building placement from hotbar
        async function handleBuildingPlacement() {
            const heldItem = hotbar[selectedHotbarSlot].item;
            
            // Check if held item is a buildable/placeable
            const placeables = ['wall', 'window_wall', 'floor', 'ceiling', 'ladder_ceiling', 'stairs', 'corner_stairs_left', 'corner_stairs_right', 'ladder', 'door_frame', 'door', 'single_door_wall', 'double_door_wall', 'double_door_frame', 'campfire', 'workbench', 'building_bench', 'furnace', 'storage_box', 'sleeping_bag', 'small_storage_box', 'storage_shelf', 'wall_shelf', 'sewing_table', 'recycler', 'water_catcher', 'floor_rug_red', 'floor_rug_blue', 'floor_rug_green', 'curtain_red', 'curtain_blue', 'curtain_green', 'curtain_white', 'curtain_beige', 'planter_box', 'large_planter', 'cooking_station'];
            
            if (placeables.includes(heldItem) && inventory[heldItem] > 0) {
                // Check if this item has a create function in buildingTypes
                if (!buildingTypes[heldItem]) {
                    showMessage(`\u274c Cannot place ${heldItem}!`);
                    return;
                }
                
                // Enter build mode with this item
                buildMode = heldItem;
                
                if (buildPreview) scene.remove(buildPreview);
                buildPreview = await buildAndPlaceModel(heldItem);
                buildPreview.traverse((child) => {
                    if (child.isMesh) {
                        child.userData.originalMaterial = child.material;
                        const isStairs = (heldItem === 'stairs' || heldItem === 'corner_stairs_left' || heldItem === 'corner_stairs_right');
                        child.material = isStairs ? _previewMatStairs : _previewMat;
                        child.renderOrder = isStairs ? 1000 : 999;
                        if (isStairs) { child.castShadow = false; child.receiveShadow = false; }
                    }
                });
                
                // Ensure the preview is visible
                buildPreview.visible = true;
                if (heldItem === 'stairs' || heldItem === 'corner_stairs_left' || heldItem === 'corner_stairs_right') {
                    buildPreview.renderOrder = 1000;
                }
                
                scene.add(buildPreview);
                document.getElementById('build-info').style.display = 'block';
                document.getElementById('build-info').textContent = 'Left click to place, R to rotate, ESC to cancel';
            }
        }
        
        // ===== DAY/NIGHT CYCLE =====
        function updateDayNight() {
            gameTime++;
            // Update time of day (if not paused by admin)
            if (!timeIsPaused) {
                time += 0.0005; // ~24 hours = 40 minutes real time
                
                if (time >= 24) {
                    time = 0;
                    day++;
                }
            }
            
            // Update sun position
            const sunAngle = (time / 24) * Math.PI * 2 - Math.PI / 2;
            sun.position.x = Math.cos(sunAngle) * 100;
            sun.position.y = Math.sin(sunAngle) * 100 + 20;
            sun.position.z = 50;
            
            // Smooth day/night blend using a 0?1 curve
            // Dawn: 5?7, Day: 7?17, Dusk: 17?19, Night: 19?5
            let dayBlend; // 1 = full day, 0 = full night
            if (time >= 7 && time < 17) {
                dayBlend = 1;
            } else if (time >= 5 && time < 7) {
                dayBlend = (time - 5) / 2; // dawn ramp
            } else if (time >= 17 && time < 19) {
                dayBlend = 1 - (time - 17) / 2; // dusk ramp
            } else {
                dayBlend = 0;
            }

            const daySkyTop    = new THREE.Color(0x1a8fff);
            const daySkyBot    = new THREE.Color(0xd4eeff);
            const nightSkyTop  = new THREE.Color(0x020510); // near-black blue
            const nightSkyBot  = new THREE.Color(0x05081a); // very dark blue-black

            // Calculate normal sky colors based on time of day
            const normalTop = nightSkyTop.clone().lerp(daySkyTop, dayBlend);
            const normalBot = nightSkyBot.clone().lerp(daySkyBot, dayBlend);
            
            // Storm sky colors that adapt to time of day
            // Day storm: lighter grey, Night storm: very dark grey
            const stormDaySkyTop = new THREE.Color(0x505055); // Medium-dark grey for day
            const stormDaySkyBot = new THREE.Color(0x606068); // Lighter grey for day
            const stormNightSkyTop = new THREE.Color(0x0a0a0f); // Very dark grey for night
            const stormNightSkyBot = new THREE.Color(0x15151a); // Dark grey for night
            
            // Lerp storm colors based on day/night
            const stormSkyTop = stormNightSkyTop.clone().lerp(stormDaySkyTop, dayBlend);
            const stormSkyBot = stormNightSkyBot.clone().lerp(stormDaySkyBot, dayBlend);
            
            // Initialize rain transition progress if not exists
            if (typeof window.rainTransitionProgress === 'undefined') {
                window.rainTransitionProgress = 0;
            }
            
            // Smoothly transition rain progress (0 = clear, 1 = storm)
            const transitionSpeed = 0.008; // Adjust for faster/slower transition
            if (isRaining) {
                window.rainTransitionProgress = Math.min(1, window.rainTransitionProgress + transitionSpeed);
            } else {
                window.rainTransitionProgress = Math.max(0, window.rainTransitionProgress - transitionSpeed);
            }
            
            // Lerp between normal and storm colors based on transition progress
            const curTop = normalTop.clone().lerp(stormSkyTop, window.rainTransitionProgress);
            const curBot = normalBot.clone().lerp(stormSkyBot, window.rainTransitionProgress);

            sky.material.uniforms.topColor.value.copy(curTop);
            sky.material.uniforms.bottomColor.value.copy(curBot);

            // Lighting ? Balanced brightness
            const lightIntensity   = 0.05 + dayBlend * (1.2 + Math.sin(Math.max(0, dayBlend) * Math.PI) * 0.5);
            const ambientIntensity = 0.02 + dayBlend * (0.35 + Math.sin(Math.max(0, dayBlend) * Math.PI) * 0.15);
            sun.intensity = lightIntensity;
            ambientLight.intensity = ambientIntensity;
            hemiLight.intensity = 0.1 + dayBlend * 0.45;

            // Fog colour matches sky bottom
            const fogHex = curBot.getHex();
            scene.fog.color.setHex(fogHex);
            renderer.setClearColor(fogHex);

            // Stars: fade in as night comes, twinkle each frame
            const nightBlend = 1 - dayBlend;
            // Update twinkle phases
            let starNeedsUpdate = false;
            if (nightBlend > 0.01) {
                starNeedsUpdate = true;
                const colorAttr = stars.geometry.attributes.color;
                for (let i = 0; i < STAR_COUNT; i++) {
                    starTwinklePhase[i] += starTwinkleSpeed[i];
                    const twinkle = starBaseOpacity[i] * (0.6 + 0.4 * Math.sin(starTwinklePhase[i]));
                    const brightness = twinkle * nightBlend;
                    colorAttr.setXYZ(i,
                        starColors[i * 3]     * brightness,
                        starColors[i * 3 + 1] * brightness,
                        starColors[i * 3 + 2] * brightness
                    );
                }
                colorAttr.needsUpdate = true;
            }
            starMat.opacity = nightBlend > 0.01 ? nightBlend : 0;

            // Night enemy spawning
            if (dayBlend === 0 && gameTime % 300 === 0) {
                spawnEnemies();
            }
            
            // Keep shadow frustum centred on player so quality is always tight around them
            sun.target.position.set(camera.position.x, 0, camera.position.z);
            sun.target.updateMatrixWorld();
            sun.shadow.camera.updateProjectionMatrix();

            // Update time display
            const hours = Math.floor(time);
            const minutes = Math.floor((time % 1) * 60);
            const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            const icon = dayBlend > 0.5 ? '\u2600\ufe0f' : dayBlend > 0 ? '\ud83c\udf05' : '\ud83c\udf19';
            document.getElementById('time').textContent = `${icon} ${timeString}`;
            
            // Update stats - constant drain rate, food faster than water
            // Hunger drains every 1000 frames (~16.7 seconds at 60fps)
            // Thirst drains every 1400 frames (~23.3 seconds at 60fps)
            if (gameTime % 1000 === 0) {
                hunger = Math.max(0, hunger - 1);
                updateUI();
            }
            
            if (gameTime % 1400 === 0) {
                thirst = Math.max(0, thirst - 1);
                updateUI();
            }
            
            // Health damage when stats are empty
            if (gameTime % 240 === 0) {
                if (hunger === 0) health = Math.max(0, health - 2);
                if (thirst === 0) health = Math.max(0, health - 3);
                
                if (health <= 0) {
                    die();
                }
                
                updateUI();
            }
        }
        
        // ===== ENEMY AI (Slower movement with eye animation) =====
        function updateEnemies() {
            enemies.forEach((enemy, index) => {
                const distance = camera.position.distanceTo(enemy.position);
                
                // Initialize stuck timer if it doesn't exist
                if (!enemy.userData.stuckTimer) {
                    enemy.userData.stuckTimer = 0;
                }
                if (!enemy.userData.lastPosition) {
                    enemy.userData.lastPosition = enemy.position.clone();
                }
                if (!enemy.userData.wanderTarget) {
                    enemy.userData.wanderTarget = null;
                }
                if (!enemy.userData.positionCheckTimer) {
                    enemy.userData.positionCheckTimer = 0;
                }
                
                // Check if enemy is stuck (hasn't moved much in last second)
                enemy.userData.positionCheckTimer++;
                if (enemy.userData.positionCheckTimer >= 60) { // Check every 60 frames (~1 second)
                    const moveDistance = enemy.position.distanceTo(enemy.userData.lastPosition);
                    
                    if (moveDistance < 0.5 && distance < 30) { // If barely moved while chasing
                        enemy.userData.stuckTimer++;
                    } else {
                        enemy.userData.stuckTimer = 0;
                    }
                    
                    enemy.userData.lastPosition = enemy.position.clone();
                    enemy.userData.positionCheckTimer = 0;
                }
                
                // If stuck for 20 seconds (20 checks), switch to wander mode
                if (enemy.userData.stuckTimer >= 20) {
                    // Generate a random wander target if don't have one
                    if (!enemy.userData.wanderTarget) {
                        const randomAngle = Math.random() * Math.PI * 2;
                        const randomDistance = 20 + Math.random() * 30;
                        enemy.userData.wanderTarget = new THREE.Vector3(
                            enemy.position.x + Math.cos(randomAngle) * randomDistance,
                            enemy.position.y,
                            enemy.position.z + Math.sin(randomAngle) * randomDistance
                        );
                        showMessage('\ud83d\udc63 Enemy is wandering...');
                    }
                }
                
                // Change to angry eyes when close
                if (distance < 10) {
                    if (!enemy.userData.isAngry) {
                        enemy.userData.isAngry = true;
                        if (enemy.userData.normalEyes) {
                            enemy.userData.normalEyes.forEach(eye => eye.visible = false);
                        }
                        if (enemy.userData.angryEyes) {
                            enemy.userData.angryEyes.forEach(eye => eye.visible = true);
                        }
                    }
                } else {
                    if (enemy.userData.isAngry) {
                        enemy.userData.isAngry = false;
                        if (enemy.userData.normalEyes) {
                            enemy.userData.normalEyes.forEach(eye => eye.visible = true);
                        }
                        if (enemy.userData.angryEyes) {
                            enemy.userData.angryEyes.forEach(eye => eye.visible = false);
                        }
                    }
                }
                


                // Sound effect - proximity-based, quieter, stops during attacks
                if (!enemy.userData.soundTimer) enemy.userData.soundTimer = 0;
                enemy.userData.soundTimer += 0.016;
                
                // Only make idle sounds if not recently attacking
                const timeSinceAttack = Date.now() - (enemy.userData.lastAttackTime || 0);
                const canMakeIdleSound = timeSinceAttack > 2000; // 2 seconds after attack
                
                if (enemy.userData.soundTimer > 2 + Math.random() * 3 && canMakeIdleSound) {
                    enemy.userData.soundTimer = 0;
                    
                    // Proximity-based volume: silent beyond 15m, audible at 5m, very loud when close
                    const maxHearDistance = 15; // Can hear up to 15 units away
                    const optimalDistance = 5; // Clear at 5 meters
                    
                    if (distance < maxHearDistance) {
                        let volume = 0;
                        
                        if (distance <= 1) {
                            // Very close (right next to you) - very loud
                            volume = 0.5;
                        } else if (distance <= optimalDistance) {
                            // 1-5 meters - loud to medium
                            const factor = (distance - 1) / (optimalDistance - 1);
                            volume = 0.5 * (1 - factor * 0.6); // 0.5 to 0.2
                        } else {
                            // 5-15 meters - medium to very quiet
                            const factor = (distance - optimalDistance) / (maxHearDistance - optimalDistance);
                            volume = 0.2 * (1 - factor); // 0.2 to 0
                        }
                        
                        if (volume > 0.02) { // Only play if audible
                            playEnemySound(volume);
                        }
                    }
                }
                
                // Determine behavior: wander or chase
                if (enemy.userData.wanderTarget) {
                    // Wander mode - move towards wander target
                    const distToTarget = enemy.position.distanceTo(enemy.userData.wanderTarget);
                    
                    if (distToTarget < 2) {
                        // Reached wander target, reset and go back to chase mode
                        enemy.userData.wanderTarget = null;
                        enemy.userData.stuckTimer = 0;
                    } else {
                        // Move towards wander target
                        const direction = new THREE.Vector3()
                            .subVectors(enemy.userData.wanderTarget, enemy.position)
                            .normalize();
                        
                        // Keep enemy on ground - only move in X/Z plane
                        direction.y = 0;
                        direction.normalize();
                        
                        const moveAmount = 0.025;
                        const newPos = enemy.position.clone().add(direction.multiplyScalar(moveAmount));
                        // Keep Y at terrain level
                        newPos.y = enemy.position.y;
                        
                        // Check collision with buildings
                        const enemyRadius = 0.5;
                        const enemyBox = new THREE.Box3(
                            new THREE.Vector3(newPos.x - enemyRadius, newPos.y - 1, newPos.z - enemyRadius),
                            new THREE.Vector3(newPos.x + enemyRadius, newPos.y + 1, newPos.z + enemyRadius)
                        );
                        
                        let canMove = true;
                        if (collidesWithNature(newPos, enemyRadius)) canMove = false;
                        if (canMove) for (let building of buildings) {
                            if (building.userData.isDoor && building.userData.isOpen) continue;
                            
                            const buildingBox = new THREE.Box3().setFromObject(building);
                            if (enemyBox.intersectsBox(buildingBox)) {
                                canMove = false;
                                break;
                            }
                        }
                    }
                } else {
                    // Chase player only when close and has line of sight
                    if (distance < 30) {
                        // Check line of sight - can enemy see player through walls?
                        const raycaster = new THREE.Raycaster();
                        raycaster.set(enemy.position, new THREE.Vector3()
                            .subVectors(camera.position, enemy.position)
                            .normalize());
                        
                        const wallIntersects = raycaster.intersectObjects(buildings, true);
                        let hasLineOfSight = true;
                        
                        // Check if any wall blocks the view
                        if (wallIntersects.length > 0) {
                            const wallDistance = wallIntersects[0].distance;
                            if (wallDistance < distance) {
                                hasLineOfSight = false;
                            }
                        }
                        
                        // Only chase if can see player
                        if (hasLineOfSight) {
                            const direction = new THREE.Vector3()
                                .subVectors(camera.position, enemy.position)
                                .normalize();
                            
                            // Keep enemy on ground - only move in X/Z plane, not Y
                            direction.y = 0;
                            direction.normalize();
                            
                            // Calculate new position
                            const moveAmount = 0.025;
                            const newPos = enemy.position.clone().add(direction.multiplyScalar(moveAmount));
                            // Keep Y at terrain/floor level
                            newPos.y = enemy.position.y;
                            
                            // Check collision with buildings before moving
                            const enemyRadius = 0.5;
                            const enemyBox = new THREE.Box3(
                                new THREE.Vector3(newPos.x - enemyRadius, newPos.y - 1, newPos.z - enemyRadius),
                                new THREE.Vector3(newPos.x + enemyRadius, newPos.y + 1, newPos.z + enemyRadius)
                            );
                            
                            let canMove = true;
                            if (collidesWithNature(newPos, enemyRadius)) canMove = false;
                            if (canMove) for (let building of buildings) {
                                // Skip open doors
                                if (building.userData.isDoor && building.userData.isOpen) continue;
                                
                                const buildingBox = new THREE.Box3().setFromObject(building);
                                if (enemyBox.intersectsBox(buildingBox)) {
                                    canMove = false;
                                    break;
                                }
                            }
                            
                            if (canMove) {
                                enemy.position.copy(newPos);
                            }
                            
                            // Face player
                            const angle = Math.atan2(direction.x, direction.z);
                            enemy.rotation.y = angle;
                        }
                    }
                }
                
                // Attack player
                if (distance < 2) {
                    const currentTime = Date.now();
                    if (currentTime - enemy.userData.lastAttackTime > 1000) {
                        health = Math.max(0, health - 10);
                        enemy.userData.lastAttackTime = currentTime;
                        // Proximity-based volume for attack sound
                        const attackDist = camera.position.distanceTo(enemy.position);
                        const maxAttackHear = 20;
                        const attackVol = Math.max(0, (1 - attackDist / maxAttackHear)) * volumeSettings.enemies * 0.95;
                        if (attackVol > 0.01) playEnemyAttackSound(attackVol);
                        showMessage('\ud83d\udca5 Enemy attacked! -10 health');
                        updateUI();
                        
                        if (health <= 0) {
                            die();
                        }
                    }
                }
                
                // Remove if too far or if daytime
                if (distance > 80 || (time >= 6 && time < 18)) {
                    scene.remove(enemy);
                    enemies.splice(index, 1);
                }
            });
        }
        
        // ===== ANIMAL AI (Original behavior with fixed ground positioning) =====
        function updateAnimals() {
            if (!window.animals) return;
            
            window.animals.forEach(animal => {
                // Sound effect - each animal has its own random interval
                if (!animal.userData.soundTimer) animal.userData.soundTimer = 0;
                if (!animal.userData.soundInterval) {
                    // Each animal gets a random interval between 20-60 seconds
                    animal.userData.soundInterval = 20 + Math.random() * 40;
                }
                
                animal.userData.soundTimer += 0.016;
                
                if (animal.userData.soundTimer > animal.userData.soundInterval) {
                    animal.userData.soundTimer = 0;
                    // Set new random interval for next sound
                    animal.userData.soundInterval = 20 + Math.random() * 40;
                    
                    const distance = camera.position.distanceTo(animal.position);
                    const maxHearDistance = 5; // Can barely hear up to 5 units away
                    const optimalDistance = 1; // Full volume within 1 meter
                    
                    if (distance < maxHearDistance) {
                        let volume = 0;
                        
                        if (distance <= optimalDistance) {
                            // Within 1 meter - full volume (0.15)
                            volume = 0.15;
                        } else {
                            // Beyond 1 meter - very rapid falloff, almost silent
                            const falloffFactor = (distance - optimalDistance) / (maxHearDistance - optimalDistance);
                            // Exponential falloff for very faint sound
                            volume = 0.15 * Math.pow(1 - falloffFactor, 4); // Power of 4 for steep falloff
                        }
                        
                        if (volume > 0.01) { // Only play if volume is audible
                            playAnimalSound(volume);
                        }
                    }
                }
                
                // Movement
                const animalNextPos = animal.position.clone().add(animal.userData.velocity);
                if (collidesWithNature(animalNextPos, 0.4)) {
                    // Bounce off obstacle  pick a new random direction
                    animal.userData.velocity.set(
                        (Math.random() - 0.5) * 0.02,
                        0,
                        (Math.random() - 0.5) * 0.02
                    );
                    // Stuck detection: count consecutive blocked frames
                    animal.userData.stuckFrames = (animal.userData.stuckFrames || 0) + 1;
                    if (animal.userData.stuckFrames > 60) {
                        // Try up to 16 escape directions at increasing radii
                        let freed = false;
                        for (let attempt = 0; attempt < 16 && !freed; attempt++) {
                            const angle = Math.random() * Math.PI * 2;
                            const radius = 0.5 + (attempt * 0.25);
                            const escapePos = new THREE.Vector3(
                                animal.position.x + Math.cos(angle) * radius,
                                animal.position.y,
                                animal.position.z + Math.sin(angle) * radius
                            );
                            if (!collidesWithNature(escapePos, 0.4)) {
                                animal.position.copy(escapePos);
                                animal.userData.velocity.set(
                                    Math.cos(angle) * 0.015,
                                    0,
                                    Math.sin(angle) * 0.015
                                );
                                freed = true;
                            }
                        }
                        animal.userData.stuckFrames = 0;
                    }
                } else {
                    animal.position.copy(animalNextPos);
                    animal.userData.stuckFrames = 0;
                }
                
                if (Math.random() < 0.01) {
                    animal.userData.velocity.set(
                        (Math.random() - 0.5) * 0.02,
                        0,
                        (Math.random() - 0.5) * 0.02
                    );
                }
                
                if (Math.abs(animal.position.x) > 80 || Math.abs(animal.position.z) > 80) {
                    animal.userData.velocity.multiplyScalar(-1);
                }
                
                // Keep at ground level - fixed height
                animal.position.y = 0.3;

                // Gentle head bob when moving
                animal.userData.animTime += 0.04;
                const at = animal.userData.animTime;
                const moving = animal.userData.velocity.length() > 0.001;
                if (animal.userData.head) {
                    animal.userData.head.rotation.x = moving ? Math.sin(at * 6.5) * 0.07 : 0;
                }
                
                // Face movement direction
                if (animal.userData.velocity.length() > 0.001) {
                    const yawAngle = Math.atan2(animal.userData.velocity.x, animal.userData.velocity.z);
                    animal.rotation.y = yawAngle;
                }
            });
        }
        
        // ===== SQUIRREL AI (Original behavior with fixed ground positioning) =====
        function updateSquirrels() {
            if (!window.squirrels) return;
            
            window.squirrels.forEach(squirrel => {
                // Sound effect - each squirrel has its own random interval
                if (!squirrel.userData.soundTimer) squirrel.userData.soundTimer = 0;
                if (!squirrel.userData.soundInterval) {
                    // Each squirrel gets a random interval between 30-90 seconds
                    squirrel.userData.soundInterval = 30 + Math.random() * 60;
                }
                
                squirrel.userData.soundTimer += 0.016;
                
                if (squirrel.userData.soundTimer > squirrel.userData.soundInterval) {
                    squirrel.userData.soundTimer = 0;
                    // Set new random interval for next sound
                    squirrel.userData.soundInterval = 30 + Math.random() * 60;
                    
                    const distance = camera.position.distanceTo(squirrel.position);
                    const maxHearDistance = 5; // Can barely hear up to 5 units away
                    const optimalDistance = 1; // Full volume within 1 meter
                    
                    if (distance < maxHearDistance) {
                        let volume = 0;
                        
                        if (distance <= optimalDistance) {
                            // Within 1 meter - full volume (0.15)
                            volume = 0.15;
                        } else {
                            // Beyond 1 meter - very rapid falloff, almost silent
                            const falloffFactor = (distance - optimalDistance) / (maxHearDistance - optimalDistance);
                            // Exponential falloff for very faint sound
                            volume = 0.15 * Math.pow(1 - falloffFactor, 4); // Power of 4 for steep falloff
                        }
                        
                        if (volume > 0.01) { // Only play if volume is audible
                            playSquirrelSound(volume);
                        }
                    }
                }
                
                // Quick movement
                const squirrelNextPos = squirrel.position.clone().add(squirrel.userData.velocity);
                if (collidesWithNature(squirrelNextPos, 0.25)) {
                    squirrel.userData.velocity.set(
                        (Math.random() - 0.5) * 0.03,
                        0,
                        (Math.random() - 0.5) * 0.03
                    );
                    // Stuck detection
                    squirrel.userData.stuckFrames = (squirrel.userData.stuckFrames || 0) + 1;
                    if (squirrel.userData.stuckFrames > 60) {
                        let freed = false;
                        for (let attempt = 0; attempt < 16 && !freed; attempt++) {
                            const angle = Math.random() * Math.PI * 2;
                            const radius = 0.4 + (attempt * 0.2);
                            const escapePos = new THREE.Vector3(
                                squirrel.position.x + Math.cos(angle) * radius,
                                squirrel.position.y,
                                squirrel.position.z + Math.sin(angle) * radius
                            );
                            if (!collidesWithNature(escapePos, 0.25)) {
                                squirrel.position.copy(escapePos);
                                squirrel.userData.velocity.set(
                                    Math.cos(angle) * 0.02,
                                    0,
                                    Math.sin(angle) * 0.02
                                );
                                freed = true;
                            }
                        }
                        squirrel.userData.stuckFrames = 0;
                    }
                } else {
                    squirrel.position.copy(squirrelNextPos);
                    squirrel.userData.stuckFrames = 0;
                }
                
                if (Math.random() < 0.05) {
                    squirrel.userData.velocity.set(
                        (Math.random() - 0.5) * 0.03,
                        0,
                        (Math.random() - 0.5) * 0.03
                    );
                }
                
                // Animate tail sway and body bob
                squirrel.userData.animTime += 0.05;
                const t = squirrel.userData.animTime;
                const moving = squirrel.userData.velocity.length() > 0.002;

                // Tail sways side-to-side lazily, wags faster when moving
                if (squirrel.userData.tailGroup) {
                    const wagSpeed = moving ? 6.0 : 1.8;
                    const wagAmp   = moving ? 0.22 : 0.10;
                    squirrel.userData.tailGroup.rotation.z = Math.sin(t * wagSpeed) * wagAmp;
                    // Subtle forward/back flick
                    squirrel.userData.tailGroup.rotation.x = Math.sin(t * wagSpeed * 0.5) * 0.08;
                }

                // Body bobs when running
                if (moving) {
                    squirrel.position.y = 0.15 + Math.abs(Math.sin(t * 8)) * 0.018;
                } else {
                    squirrel.position.y = 0.15;
                }
                
                // Face movement direction
                if (squirrel.userData.velocity.length() > 0.001) {
                    const yawAngle = Math.atan2(squirrel.userData.velocity.x, squirrel.userData.velocity.z);
                    squirrel.rotation.y = yawAngle;
                }
            });
        }
        
        // ===== ANIMATIONS =====
        function updateGrass() {
            grassBlades.forEach(grass => {
                const sway = Math.sin(_frameTime * grass.userData.windSpeed + grass.userData.windPhase) * 0.15;
                grass.rotation.x = sway;
            });
            // Desert tufts sway slowly - dry heat droop
            desertGrassTufts.forEach(tuft => {
                const sway = Math.sin(_frameTime * tuft.userData.windSpeed + tuft.userData.windPhase) * 0.09;
                tuft.rotation.x = sway;
                tuft.rotation.z = Math.sin(_frameTime * tuft.userData.windSpeed * 0.7 + tuft.userData.windPhase) * 0.05;
            });
        }
        
        function updateClouds() {
            const darkCloudColor = new THREE.Color(0x3a3a3f); // Dark storm grey
            const brightCloudColor = new THREE.Color(0xffffff); // White clouds
            
            clouds.forEach(cloud => {
                cloud.position.x += cloud.userData.speed;
                if (cloud.position.x > 100) cloud.position.x = -100;
                // Gentle whole-cloud bob and opacity pulse (no children to iterate)
                const float = Math.sin(_frameTime * cloud.userData.floatSpeed + cloud.userData.floatPhase);
                cloud.position.y = cloud.userData.baseY + float * 0.5;
                cloud.material.opacity = cloud.userData.baseOpacity + Math.abs(float) * 0.15;
                
                // Smooth storm color transition
                if (typeof cloud.userData.stormProgress === 'undefined') {
                    cloud.userData.stormProgress = 0;
                }
                
                const cloudTransitionSpeed = 0.01;
                if (isRaining) {
                    cloud.userData.stormProgress = Math.min(1, cloud.userData.stormProgress + cloudTransitionSpeed);
                } else {
                    cloud.userData.stormProgress = Math.max(0, cloud.userData.stormProgress - cloudTransitionSpeed);
                }
                
                // Lerp cloud colors based on storm progress
                const targetColor = brightCloudColor.clone().lerp(darkCloudColor, cloud.userData.stormProgress);
                const targetEmissive = brightCloudColor.clone().lerp(darkCloudColor, cloud.userData.stormProgress);
                const targetIntensity = 0.2 * (1 - cloud.userData.stormProgress * 0.75);
                
                cloud.material.color.copy(targetColor);
                cloud.material.emissive.copy(targetEmissive);
                cloud.material.emissiveIntensity = targetIntensity;
            });
        }
        
        function updateBerryRespawn() {
            // Cactus respawn is now handled by setTimeout in the harvest handler 
            // harvested cacti are removed from scene and respawn at a new desert
            // location after 5 minutes. No frame-counter needed here.

            berryBushes.forEach(bush => {
                bush.userData.berries.forEach(berry => {
                    if (!berry.userData.isVisible && berry.userData.respawnTime > 0) {
                        berry.userData.respawnTime--;
                        if (berry.userData.respawnTime <= 0) {
                            berry.visible = true;
                            berry.userData.isVisible = true;
                        }
                    }
                });
            });
        }

        // Wild plant respawn is now handled by setTimeout in the harvest handler 
        // plants are fully removed from the scene on harvest and a new one is spawned
        // at a fresh location after 15 minutes. Nothing to poll here.
        function updateWildPlantRespawn() { /* intentionally empty */ }
        function updateResourceRespawns() {
            const now = Date.now();
            
            // Check tree stump respawns
            for (let i = stumpRespawnQueue.length - 1; i >= 0; i--) {
                const item = stumpRespawnQueue[i];
                if (now >= item.respawnTime) {
                    // Remove stump
                    if (item.stump && item.stump.parent) {
                        scene.remove(item.stump);
                    }
                    
                    // Find new random position (away from player and other trees)
                    let newX, newZ, validPosition;
                    let attempts = 0;
                    do {
                        validPosition = true;
                        newX = (Math.random() - 0.5) * 180;
                        newZ = (Math.random() - 0.5) * 180;
                        
                        // Not too close to player
                        const distToPlayer = Math.sqrt(
                            Math.pow(newX - camera.position.x, 2) + 
                            Math.pow(newZ - camera.position.z, 2)
                        );
                        if (distToPlayer < 20) {
                            validPosition = false;
                            attempts++;
                            continue;
                        }
                        
                        // Not too close to other trees
                        for (let pos of treePositions) {
                            const dist = Math.sqrt(
                                Math.pow(newX - pos.x, 2) + 
                                Math.pow(newZ - pos.z, 2)
                            );
                            if (dist < 8) {
                                validPosition = false;
                                break;
                            }
                        }
                        attempts++;
                    } while (!validPosition && attempts < 50);
                    
                    // Spawn new tree if valid position found
                    if (validPosition) {
                        createTree(newX, newZ);
                    }
                    
                    // Remove from queue
                    stumpRespawnQueue.splice(i, 1);
                }
            }
            
            // Check rock respawns
            for (let i = rockRespawnQueue.length - 1; i >= 0; i--) {
                const item = rockRespawnQueue[i];
                if (now >= item.respawnTime) {
                    // Find new random position
                    let newX, newZ, validPosition;
                    let attempts = 0;
                    do {
                        validPosition = true;
                        newX = (Math.random() - 0.5) * 180;
                        newZ = (Math.random() - 0.5) * 180;
                        
                        // Not too close to player
                        const distToPlayer = Math.sqrt(
                            Math.pow(newX - camera.position.x, 2) + 
                            Math.pow(newZ - camera.position.z, 2)
                        );
                        if (distToPlayer < 15) {
                            validPosition = false;
                            attempts++;
                            continue;
                        }
                        
                        // Not too close to trees or other rocks
                        for (let pos of [...treePositions, ...rockPositions]) {
                            const dist = Math.sqrt(
                                Math.pow(newX - pos.x, 2) + 
                                Math.pow(newZ - pos.z, 2)
                            );
                            if (dist < 5) {
                                validPosition = false;
                                break;
                            }
                        }
                        attempts++;
                    } while (!validPosition && attempts < 50);
                    
                    // Spawn new rock
                    if (validPosition) {
                        createRock(newX, newZ);
                    }
                    
                    // Remove from queue
                    rockRespawnQueue.splice(i, 1);
                }
            }
            
            // Check ore respawns
            for (let i = oreRespawnQueue.length - 1; i >= 0; i--) {
                const item = oreRespawnQueue[i];
                if (now >= item.respawnTime) {
                    // Find new random position
                    let newX, newZ, validPosition;
                    let attempts = 0;
                    do {
                        validPosition = true;
                        newX = (Math.random() - 0.5) * 180;
                        newZ = (Math.random() - 0.5) * 180;
                        
                        // Not too close to player
                        const distToPlayer = Math.sqrt(
                            Math.pow(newX - camera.position.x, 2) + 
                            Math.pow(newZ - camera.position.z, 2)
                        );
                        if (distToPlayer < 15) {
                            validPosition = false;
                            attempts++;
                            continue;
                        }
                        
                        // Not too close to trees, rocks, or other ores
                        for (let pos of [...treePositions, ...rockPositions, ...orePositions]) {
                            const dist = Math.sqrt(
                                Math.pow(newX - pos.x, 2) + 
                                Math.pow(newZ - pos.z, 2)
                            );
                            if (dist < 6) {
                                validPosition = false;
                                break;
                            }
                        }
                        attempts++;
                    } while (!validPosition && attempts < 50);
                    
                    // Spawn new ore (correct type)
                    if (validPosition) {
                        if (item.type === 'sulfur') {
                            createSulfurOre(newX, newZ);
                        } else {
                            createMetalOre(newX, newZ);
                        }
                    }
                    
                    // Remove from queue
                    oreRespawnQueue.splice(i, 1);
                }
            }
        }
        
        // Tree sway animation
        function updateTrees() {
            trees.forEach(tree => {
                // Check if tree is falling
                if (tree.userData.falling) {
                    tree.userData.fallProgress++;
                    const progress = tree.userData.fallProgress / tree.userData.fallDuration;
                    
                    if (progress < 1) {
                        // Animate falling - rotate around base
                        const fallAngle = progress * (Math.PI / 2); // Fall 90 degrees
                        tree.rotation.x = fallAngle;
                        tree.rotation.y = tree.userData.fallDirection;
                        
                        // Move down slightly as it falls
                        tree.position.y = -progress * 2;
                    } else {
                        // Fall complete
                        if (tree.userData.onFallComplete) {
                            tree.userData.onFallComplete();
                        }
                    }
                } else {
                    // Sway animation  only runs if swayPhase/swaySpeed are set.
                    // GLB trees always have these set at spawn time; guard prevents
                    // NaN rotation (undefined  Math.sin(NaN)  NaN matrix  invisible).
                    if (tree.userData.swayPhase !== undefined && tree.userData.swaySpeed !== undefined) {
                        const sway = Math.sin(_frameTime * tree.userData.swaySpeed + tree.userData.swayPhase) * 0.03;
                        tree.rotation.z = sway;
                        if (tree.userData.dirtPatch) { tree.userData.dirtPatch.rotation.z = -sway; }
                    }
                }
            });
        }
        
        // ===== UI UPDATES =====
        function updateUI() {
            const effectiveMaxHealth = activeBuffs.meat_stew ? 130 : 100;
            const healthPct = (health / effectiveMaxHealth) * 100;
            document.getElementById('health-bar').style.width = Math.min(100, healthPct) + '%';
            document.getElementById('health-text').textContent = `${Math.floor(health)} / ${effectiveMaxHealth}`;
            
            document.getElementById('hunger-bar').style.width = hunger + '%';
            document.getElementById('hunger-text').textContent = `${Math.floor(hunger)} / 100`;
            
            document.getElementById('thirst-bar').style.width = thirst + '%';
            document.getElementById('thirst-text').textContent = `${Math.floor(thirst)} / 100`;
            
            document.getElementById('stamina-bar').style.width = stamina + '%';
            document.getElementById('stamina-text').textContent = `${Math.floor(stamina)} / 100`;
            
            document.getElementById('day').textContent = day;
            
            updateInventoryUI();
            updateHotbar();
        }
        
        // ===== RUST-STYLE DRAGGABLE INVENTORY SYSTEM =====
        let draggedItem = null;
        let draggedFromSlot = null;
        let draggedFromType = null; // 'inventory', 'hotbar', or 'storage'
        let currentStorageBox = null;
        
        // ===== ITEM ICONS =====
        // All emojis are stored as \uXXXX escape sequences so they survive
        // file saves and transfers without corruption. To get the escaped
        // version of any emoji, run this in the browser console:
        //   escapeEmoji('')
        // Then paste the result as the icon value below.
        window.escapeEmoji = str => [...str].map(c => {
            const cp = c.codePointAt(0);
            if (cp <= 0x7F) return c;
            if (cp <= 0xFFFF) return '\\u' + cp.toString(16).padStart(4,'0');
            const hi = Math.floor((cp - 0x10000) / 0x400) + 0xD800;
            const lo = ((cp - 0x10000) % 0x400) + 0xDC00;
            return '\\u' + hi.toString(16).padStart(4,'0') + '\\u' + lo.toString(16).padStart(4,'0');
        }).join('');

        const itemIcons = {
            // Resources - Natural materials
            'sharp_stone': '\ud83e\udea8',
            'wood': '\ud83e\udeb5',
            'stone': '\ud83e\udea8',
            'berries': '\ud83e\uded0',
            'meat': '\ud83e\udd69',
            'cooked_meat': '\ud83c\udf56',
            'sticks': '\ud83e\udeb5',
            'fiber': '\ud83c\udf3f',
            'iron_ore': '\ud83e\udea8',
            'iron_ingot': '\ud83d\udd29',
            'coal': '\ud83e\udea8',
            'sulfur_ore': '\ud83d\udfe1',
            'smelted_sulfur': '\ud83d\udc9b',
            'gunpowder': '\ud83d\udca5',
            'ash': '\ud83d\udca8',
            'meat_stew': '\ud83c\udf72',
            'vegetable_stew': '\ud83c\udf72',
            'berry_jam': '\ud83c\udf53',
            'corn_bread': '\ud83c\udf5e',
            'hearty_meal': '\ud83c\udf7d\ufe0f',
            'cloth': '\ud83e\uddf5',
            // Tools & Weapons
            'arrows': '\ud83c\udff9',
            'axe': '\ud83e\ude93',
            'pickaxe': '\u26cf\ufe0f',
            'sword': '\u2694\ufe0f',
            'spear': '\ud83d\udde1\ufe0f',
            'bow': '\ud83c\udff9',
            'pistol': '\ud83d\udd2b',
            'pistol_ammo': '\ud83d\udd2b',
            'building_hammer': '\ud83d\udd28',
            'code_lock': '\ud83d\udd12',
            // Consumables
            'bandage': '\ud83e\ude79',
            'medkit': '\ud83c\udfe5',
            // Building Structures - Walls & Frames
            'wall': '\ud83e\uddf1',
            'stone_wall': '\ud83e\uddf1',
            'metal_wall': '\ud83e\uddf1',
            'window_wall': '\ud83e\ude9f',
            'stone_window_wall': '\ud83e\ude9f',
            'metal_window_wall': '\ud83e\ude9f',
            'door_frame': '\ud83d\udeaa',
            'door': '\ud83d\udeaa',
            'single_door_wall': '\ud83d\udeaa',
            'stone_single_door_wall': '\ud83d\udeaa',
            'metal_single_door_wall': '\ud83d\udeaa',
            'double_door_wall': '\ud83d\udeaa',
            'stone_double_door_wall': '\ud83d\udeaa',
            'metal_double_door_wall': '\ud83d\udeaa',
            'double_door_frame': '\ud83d\udeaa',
            // Building Structures - Floors & Ceilings
            'floor': '\ud83d\udfeb',
            'stone_floor': '\u2b1c',
            'metal_floor': '\u2b1c',
            'ceiling': '\ud83d\udfeb',
            'stone_ceiling': '\u2b1c',
            'metal_ceiling': '\u2b1c',
            'ladder_ceiling': '\ud83e\ude9c',
            // Building Structures - Stairs & Ladders
            'stairs': '\ud83e\ude9c',
            'stone_stairs': '\ud83e\ude9c',
            'metal_stairs': '\ud83e\ude9c',
            'corner_stairs_left': '\ud83e\ude9c',
            'stone_corner_stairs_left': '\ud83e\ude9c',
            'metal_corner_stairs_left': '\ud83e\ude9c',
            'corner_stairs_right': '\ud83e\ude9c',
            'stone_corner_stairs_right': '\ud83e\ude9c',
            'metal_corner_stairs_right': '\ud83e\ude9c',
            'ladder': '\ud83e\ude9c',
            // Building Objects - Utility
            'sleeping_bag': '\ud83d\udecf\ufe0f',
            'campfire': '\ud83d\udd25',
            'workbench': '\ud83d\udd27',
            'building_bench': '\ud83e\ude9a',
            'furnace': '\ud83d\udd25',
            'cooking_station': '\ud83c\udf73',
            'storage_box': '\ud83d\udce6',
            'small_storage_box': '\ud83d\udce6',
            'storage_shelf': '\ud83d\udce6',
            'wall_shelf': '\ud83d\udce6',
            'sewing_table': '\ud83e\uddf5',
            'recycler': '\u267b\ufe0f',
            'water_catcher': '',
            'water_bottle': '',
            'flour': '',
            'bread': '',
            'blackcurrant_jam': '',
            'strawberry_jam': '',
            'toast_jam': '',
            'ham_sandwich': '',
            'planter_box': '\ud83c\udf31',
            'large_planter': '\ud83c\udf3f',
            'pumpkin_seed': '\ud83c\udf83',
            'wheat_seed': '\ud83c\udf3e',
            'cabbage_seed': '\ud83e\udd66',
            'cucumber_seed': '\ud83e\udd52',
            'potato_seed': '\ud83e\udd54',
            'carrot_seed': '\ud83e\udd55',
            'hemp_seed': '\ud83c\udf3f',
            'corn_seed': '\ud83c\udf3d',
            'mushroom_seed': '\ud83c\udf44',
            'red_berry_seed': '\ud83c\udf53',
            'black_berry_seed': '\ud83e\uded0',
            'strawberry_seed': '\ud83c\udf53',
            'tomato_seed': '\ud83c\udf45',
            'pumpkin': '\ud83c\udf83',
            'wheat': '\ud83c\udf3e',
            'cabbage': '\ud83e\udd66',
            'cucumber': '\ud83e\udd52',
            'potato': '\ud83e\udd54',
            'carrot': '\ud83e\udd55',
            'hemp_fiber': '\ud83c\udf3f',
            'corn': '\ud83c\udf3d',
            'mushroom_crop': '\ud83c\udf44',
            'red_berries': '\ud83c\udf53',
            'black_berries': '\ud83e\uded0',
            'strawberry': '\ud83c\udf53',
            'tomato': '\ud83c\udf45',
            // Decorative
            'floor_rug_red': '\ud83d\udfe5',
            'floor_rug_blue': '\ud83d\udfe6',
            'floor_rug_green': '\ud83d\udfe9',
            'curtain_red': '\ud83d\udd34',
            'curtain_blue': '\ud83d\udd35',
            'curtain_green': '\ud83d\udfe2',
            'curtain_white': '\u2b1c',
            'curtain_beige': '\ud83d\udfe4',
            // Iron Armor (Grey)
            'iron_helmet': '\u26d1\ufe0f',
            'iron_vest': '\ud83e\uddba',
            'iron_gloves': '\ud83e\udde4',
            'iron_pants': '\ud83d\udc56',
            'iron_boots': '\ud83d\udc62',
            // Bronze Armor (Orange)
            'bronze_helmet': '\u26d1\ufe0f',
            'bronze_vest': '\ud83e\uddba',
            'bronze_gloves': '\ud83e\udde4',
            'bronze_pants': '\ud83d\udc56',
            'bronze_boots': '\ud83d\udc62'
        };
        
        // Item display names (with subtitles for items that share icons)
        const itemDisplayNames = {
            'sharp_stone': 'Sharp Stone',
            'wood': 'Wood',
            'stone': 'Stone',
            'berries': 'Berries',
            'meat': 'Raw Meat',
            'cooked_meat': 'Cooked Meat',
            'sticks': 'Sticks',
            'fiber': 'Fiber',
            'iron_ore': 'Iron Ore',
            'iron_ingot': 'Iron Ingot',
            'coal': 'Coal',
            'sulfur_ore': 'Sulfur Ore',
            'smelted_sulfur': 'Smelted Sulfur',
            'gunpowder': 'Gunpowder',
            'ash': 'Ash',
            'meat_stew': 'Meat Stew',
            'vegetable_stew': 'Vegetable Stew',
            'berry_jam': 'Berry Jam',
            'corn_bread': 'Corn Bread',
            'hearty_meal': 'Hearty Meal',
            'cooking_station': 'Cooking Station',
            'cloth': 'Cloth',
            'arrows': 'Arrows',
            'axe': 'Axe',
            'pickaxe': 'Pickaxe',
            'sword': 'Sword',
            'spear': 'Spear',
            'bow': 'Bow',
            'pistol': 'Pistol',
            'pistol_ammo': 'Pistol Ammo',
            'building_hammer': 'Building Hammer',
            'code_lock': 'Code Lock',
            'bandage': 'Bandage',
            'medkit': 'Medkit',
            'wall': 'Wall',
            'stone_wall': 'Stone Wall',
            'metal_wall': 'Metal Wall',
            'window_wall': 'Window Wall',
            'stone_window_wall': 'Stone Window Wall',
            'metal_window_wall': 'Metal Window Wall',
            'door_frame': 'Door Frame',
            'door': 'Door',
            'single_door_wall': 'Single Door Wall',
            'stone_single_door_wall': 'Stone Single Door Wall',
            'metal_single_door_wall': 'Metal Single Door Wall',
            'double_door_wall': 'Double Door Wall',
            'stone_double_door_wall': 'Stone Double Door Wall',
            'metal_double_door_wall': 'Metal Double Door Wall',
            'double_door_frame': 'Double Door Frame',
            'floor': 'Floor',
            'stone_floor': 'Stone Floor',
            'metal_floor': 'Metal Floor',
            'ceiling': 'Ceiling',
            'stone_ceiling': 'Stone Ceiling',
            'metal_ceiling': 'Metal Ceiling',
            'ladder_ceiling': 'Ladder Ceiling',
            'stairs': 'Stairs',
            'stone_stairs': 'Stone Stairs',
            'metal_stairs': 'Metal Stairs',
            'corner_stairs_left': 'Corner Stairs (Left)',
            'stone_corner_stairs_left': 'Stone Corner Stairs (Left)',
            'metal_corner_stairs_left': 'Metal Corner Stairs (Left)',
            'corner_stairs_right': 'Corner Stairs (Right)',
            'stone_corner_stairs_right': 'Stone Corner Stairs (Right)',
            'metal_corner_stairs_right': 'Metal Corner Stairs (Right)',
            'ladder': 'Ladder',
            'sleeping_bag': 'Sleeping Bag',
            'campfire': 'Campfire',
            'workbench': 'Workbench',
            'building_bench': 'Building Bench',
            'furnace': 'Furnace',
            'storage_box': 'Large Storage',
            'small_storage_box': 'Small Storage',
            'storage_shelf': 'Storage Shelf',
            'wall_shelf': 'Wall Shelf',
            'sewing_table': 'Sewing Table',
            'recycler': 'Recycler',
            'water_catcher': 'Well',
            'water_bottle': 'Water Bottle',
            'flour': 'Flour',
            'bread': 'Bread',
            'blackcurrant_jam': 'Blackcurrant Jam',
            'strawberry_jam': 'Strawberry Jam',
            'toast_jam': 'Toast with Jam',
            'ham_sandwich': 'Ham Sandwich',
            'planter_box': 'Planter Box',
            'large_planter': 'Large Planter',
            'pumpkin_seed': 'Pumpkin Seed',
            'wheat_seed': 'Wheat Seed',
            'cabbage_seed': 'Cabbage Seed',
            'cucumber_seed': 'Cucumber Seed',
            'potato_seed': 'Potato Seed',
            'carrot_seed': 'Carrot Seed',
            'hemp_seed': 'Hemp Seed',
            'corn_seed': 'Corn Seed',
            'mushroom_seed': 'Mushroom Seed',
            'red_berry_seed': 'Red Berry Seed',
            'black_berry_seed': 'Black Berry Seed',
            'strawberry_seed': 'Strawberry Seed',
            'tomato_seed': 'Tomato Seed',
            'pumpkin': 'Pumpkin',
            'wheat': 'Wheat',
            'cabbage': 'Cabbage',
            'cucumber': 'Cucumber',
            'potato': 'Potato',
            'carrot': 'Carrot',
            'hemp_fiber': 'Hemp Fiber',
            'corn': 'Corn',
            'mushroom_crop': 'Mushroom',
            'red_berries': 'Red Berries',
            'black_berries': 'Black Berries',
            'strawberry': 'Strawberry',
            'tomato': 'Tomato',
            'floor_rug_red': 'Red Floor Rug',
            'floor_rug_blue': 'Blue Floor Rug',
            'floor_rug_green': 'Green Floor Rug',
            'curtain_red': 'Red Curtain',
            'curtain_blue': 'Blue Curtain',
            'curtain_green': 'Green Curtain',
            'curtain_white': 'White Curtain',
            'curtain_beige': 'Beige Curtain',
            'iron_helmet': 'Iron Helmet',
            'iron_vest': 'Iron Vest',
            'iron_gloves': 'Iron Gloves',
            'iron_pants': 'Iron Pants',
            'iron_boots': 'Iron Boots',
            'bronze_helmet': 'Bronze Helmet',
            'bronze_vest': 'Bronze Vest',
            'bronze_gloves': 'Bronze Gloves',
            'bronze_pants': 'Bronze Pants',
            'bronze_boots': 'Bronze Boots'
        };
        
        // Helper function - gets icon for an item
        function getItemIcon(itemName) {
            const icon = itemIcons[itemName] || '';
            
            // Add color styling for armor icons
            if (itemName && itemName.startsWith('iron_')) {
                return `<span style="filter: grayscale(1) brightness(0.8);">${icon}</span>`;
            } else if (itemName && itemName.startsWith('bronze_')) {
                return `<span style="filter: sepia(1) saturate(3) hue-rotate(10deg) brightness(0.9);">${icon}</span>`;
            }
            
            return icon;
        }
        
        // Helper function - gets display name for an item
        function getItemDisplayName(itemName) {
            if (itemDisplayNames[itemName]) {
                return itemDisplayNames[itemName];
            }
            // Fallback: convert snake_case to Title Case
            return itemName
                .split('_')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }
        
        // Safe fallback map  every icon stored as pure \uXXXX escapes.
        // If itemIcons gets corrupted (U+FFFD replacement chars), this map
        // is used to automatically restore the correct emoji at startup.
        const _iconFallbacks = {
            'sharp_stone':'\ud83e\udea8','wood':'\ud83e\udeb5','stone':'\ud83e\udea8',
            'berries':'\ud83e\uded0','meat':'\ud83e\udd69','cooked_meat':'\ud83c\udf56',
            'sticks':'\ud83e\udeb5','fiber':'\ud83c\udf3f','iron_ore':'\ud83e\udea8',
            'iron_ingot':'\ud83d\udd29','coal':'\ud83e\udea8','sulfur_ore':'\ud83d\udfe1',
            'smelted_sulfur':'\ud83d\udcdb','gunpowder':'\ud83d\udca5','ash':'\ud83d\udca8',
            'cloth':'\ud83e\uddf5','arrows':'\ud83c\udff9','axe':'\ud83e\ude93',
            'pickaxe':'\u26cf\ufe0f','sword':'\u2694\ufe0f','spear':'\ud83d\udde1\ufe0f',
            'bow':'\ud83c\udff9','pistol':'\ud83d\udd2b','pistol_ammo':'\ud83d\udd2b',
            'building_hammer':'\ud83d\udd28','code_lock':'\ud83d\udd12',
            'bandage':'\ud83e\ude79','medkit':'\ud83c\udfe5',
            'wall':'\ud83e\uddf1','stone_wall':'\ud83e\uddf1','metal_wall':'\ud83e\uddf1',
            'window_wall':'\ud83e\ude9f','stone_window_wall':'\ud83e\ude9f','metal_window_wall':'\ud83e\ude9f',
            'door_frame':'\ud83d\udeaa','door':'\ud83d\udeaa',
            'single_door_wall':'\ud83d\udeaa','stone_single_door_wall':'\ud83d\udeaa',
            'metal_single_door_wall':'\ud83d\udeaa','double_door_wall':'\ud83d\udeaa',
            'stone_double_door_wall':'\ud83d\udeaa','metal_double_door_wall':'\ud83d\udeaa',
            'double_door_frame':'\ud83d\udeaa',
            'floor':'\ud83d\udfe7','stone_floor':'\u2b1c','metal_floor':'\u2b1c',
            'ceiling':'\ud83d\udfe7','stone_ceiling':'\u2b1c','metal_ceiling':'\u2b1c',
            'ladder_ceiling':'\ud83e\ude9c','stairs':'\ud83e\ude9c','stone_stairs':'\ud83e\ude9c',
            'metal_stairs':'\ud83e\ude9c','corner_stairs_left':'\ud83e\ude9c',
            'stone_corner_stairs_left':'\ud83e\ude9c','metal_corner_stairs_left':'\ud83e\ude9c',
            'corner_stairs_right':'\ud83e\ude9c','stone_corner_stairs_right':'\ud83e\ude9c',
            'metal_corner_stairs_right':'\ud83e\ude9c','ladder':'\ud83e\ude9c',
            'sleeping_bag':'\ud83d\udecf\ufe0f','campfire':'\ud83d\udd25','workbench':'\ud83d\udd27',
            'building_bench':'\ud83e\ude9a','furnace':'\ud83d\udd25','storage_box':'\ud83d\udce6',
            'small_storage_box':'\ud83d\udce6','storage_shelf':'\ud83d\udce6','wall_shelf':'\ud83d\udce6','planter_box':'\ud83c\udf31','large_planter':'\ud83c\udf3f',
            'pumpkin_seed':'\ud83c\udf83','wheat_seed':'\ud83c\udf3e','cabbage_seed':'\ud83e\udd66',
            'cucumber_seed':'\ud83e\udd52','potato_seed':'\ud83e\udd54','carrot_seed':'\ud83e\udd55',
            'hemp_seed':'\ud83c\udf3f','corn_seed':'\ud83c\udf3d','mushroom_seed':'\ud83c\udf44',
            'red_berry_seed':'\ud83c\udf53','black_berry_seed':'\ud83e\uded0','strawberry_seed':'\ud83c\udf53','tomato_seed':'\ud83c\udf45',
            'pumpkin':'\ud83c\udf83','wheat':'\ud83c\udf3e','cabbage':'\ud83e\udd66','cucumber':'\ud83e\udd52',
            'potato':'\ud83e\udd54','carrot':'\ud83e\udd55','hemp_fiber':'\ud83c\udf3f','corn':'\ud83c\udf3d',
            'mushroom_crop':'\ud83c\udf44','red_berries':'\ud83c\udf53','black_berries':'\ud83e\uded0',
            'strawberry':'\ud83c\udf53','tomato':'\ud83c\udf45',
            'sewing_table':'\ud83e\uddf5','recycler':'\u267b\ufe0f','cooking_station':'\ud83c\udf73',
            'meat_stew':'\ud83c\udf72','vegetable_stew':'\ud83c\udf72','berry_jam':'\ud83c\udf53',
            'corn_bread':'\ud83c\udf5e','hearty_meal':'\ud83c\udf7d\ufe0f',
            'floor_rug_red':'\ud83d\udfe5','floor_rug_blue':'\ud83d\udfe6',
            'floor_rug_green':'\ud83d\udfe9','curtain_red':'\ud83d\udd34',
            'curtain_blue':'\ud83d\udd35','curtain_green':'\ud83d\udfe2',
            'curtain_white':'\u2b1c','curtain_beige':'\ud83d\udfe4',
            'iron_helmet':'\u26d1\ufe0f','iron_vest':'\ud83e\uddba','iron_gloves':'\ud83e\udde4',
            'iron_pants':'\ud83d\udc56','iron_boots':'\ud83d\udc62',
            'bronze_helmet':'\u26d1\ufe0f','bronze_vest':'\ud83e\uddba',
            'bronze_gloves':'\ud83e\udde4','bronze_pants':'\ud83d\udc56','bronze_boots':'\ud83d\udc62'
        };

        // On startup, heal any corrupted icons using the fallback map.
        // A value is corrupted if it contains U+FFFD (the Unicode replacement char)
        // or is empty  both symptoms of a bad file save or encoding mismatch.
        (function sanitizeItemIcons() {
            let healed = 0;
            for (const key in itemIcons) {
                const val = itemIcons[key];
                if (!val || val.includes('\ufffd') || val.trim() === '') {
                    if (_iconFallbacks[key]) {
                        itemIcons[key] = _iconFallbacks[key];
                        healed++;
                    } else {
                        itemIcons[key] = '\u2753'; //   no fallback available
                        console.warn('\u26a0\ufe0f No fallback for corrupted icon: "' + key + '"');
                    }
                }
            }
            if (healed > 0) console.log('\ud83d\ude4c Healed ' + healed + ' corrupted icon(s) from fallback map');
        })();

        // Call this when adding new items to automatically add them to the admin menu
        function registerItem(itemId, icon, category = 'Other Items') {
            // Sanitize: if the icon is corrupted or empty, use fallback
            const safeIcon = (!icon || icon.includes('\ufffd') || icon.trim() === '') ? '\u2753' : icon;
            if (!itemIcons[itemId]) {
                itemIcons[itemId] = safeIcon;
                console.log(`\u2705 Registered new item: ${itemId} with icon ${safeIcon} in category ${category}`);
            } else {
                console.warn(`\u26a0\ufe0f Item ${itemId} already registered with icon ${itemIcons[itemId]}`);
            }
        }
        
        // Validation function - checks all items in game have icons
        function validateAllItemsHaveIcons() {
            const allItems = new Set();
            
            // Collect all items from all sources
            Object.keys(craftingRecipes).forEach(item => allItems.add(item));
            Object.keys(workbenchRecipes).forEach(item => allItems.add(item));
            Object.keys(buildingBenchRecipes).forEach(item => allItems.add(item));
            Object.keys(furnaceRecipes).forEach(item => allItems.add(item));
            Object.keys(buildingTypes).forEach(item => allItems.add(item));
            
            const missingIcons = [];
            allItems.forEach(item => {
                if (!itemIcons[item]) {
                    missingIcons.push(item);
                }
            });
            
            if (missingIcons.length > 0) {
                console.warn('\u26a0\ufe0f Items missing icons:', missingIcons);
                console.warn('Add icons using: registerItem("item_name", "\u2753", "Category Name")');
            } else {
                console.log('\u2705 All items have icons!');
            }
            
            return missingIcons;
        }
        
        // Track item positions in inventory slots
        const inventorySlots = new Array(30).fill(null);
        // Per-slot count overrides for split stacks (null = use global inventory[item] total)
        const inventorySlotCounts = new Array(30).fill(null);

        // Helper: get the effective count displayed for a specific inventory slot
        function getInvSlotCount(slotIndex) {
            const name = inventorySlots[slotIndex];
            if (!name) return 0;
            return inventorySlotCounts[slotIndex] !== null ? inventorySlotCounts[slotIndex] : (inventory[name] || 0);
        }

        // Helper: clear all split-stack tracking for a given item name (consolidate on pickup)
        function clearSplitCounts(itemName) {
            for (let i = 0; i < inventorySlots.length; i++) {
                if (inventorySlots[i] === itemName) inventorySlotCounts[i] = null;
            }
        }
        
        // Box open/close sound
        let _boxAudioBuffer = null;
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/box.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _boxAudioBuffer = buf; console.log('Box sound loaded OK'); })
            .catch(e => { console.error('Box sound fetch error:', e); });

        function playBoxSound() {
            if (!_boxAudioBuffer) { console.log('Box buffer not ready yet'); return; }
            const src = audioContext.createBufferSource();
            src.buffer = _boxAudioBuffer;
            const gain = audioContext.createGain();
            gain.gain.value = volumeSettings.sfx !== undefined ? volumeSettings.sfx : 1.0;
            src.connect(gain);
            gain.connect(audioContext.destination);
            src.start();
        }

        function openStorageBox(storageBox) {
            currentStorageBox = storageBox;
            playBoxSound();
            // Configure layout based on box type
            const isSmall = storageBox.userData.isSmallStorage;
            const panel = document.getElementById('storage-panel');
            const grid  = document.getElementById('storage-grid');
            const header = document.getElementById('storage-header');
            if (isSmall) {
                // 14 slots: 5 cols  3 rows  no scroll needed at 500px
                panel.style.width = '500px';
                grid.style.gridTemplateColumns = 'repeat(5, 1fr)';
                header.querySelector('span').textContent = ' SMALL STORAGE';
            } else {
                // 26 slots: 6 cols  5 rows (last row 2 slots)  no scroll at 560px
                panel.style.width = '560px';
                grid.style.gridTemplateColumns = 'repeat(6, 1fr)';
                header.querySelector('span').textContent = ' LARGE STORAGE';
            }
            // Open both storage and inventory
            panel.style.display = 'block';
            const _ip2 = document.getElementById('inventory-panel');
            positionInventoryRight(_ip2);
            _ip2.style.display = 'block';
            uiOpen();
            updateStorageDisplay();
            updateInventoryDisplay();
        }
        
        function closeStorageBox() {
            closeAllUI();
        }

        // ===== PLANTER BOX SYSTEM =====
        let currentPlanterBox = null;

        // Seeds are items whose name contains 'seed'  extensible as more are added
        function isSeedItem(itemName) {
            return itemName && itemName.toLowerCase().includes('seed');
        }

        function openPlanterBox(planterBox) {
            currentPlanterBox = planterBox;
            const slotCount = planterBox.userData.seeds.length;
            const isLarge = slotCount > 4;
            document.getElementById('planter-title').textContent = isLarge ? ' Large Planter (12 Slots)' : ' Planter Box (4 Slots)';
            const slotsEl = document.getElementById('planter-slots');
            slotsEl.style.gridTemplateColumns = isLarge ? 'repeat(4,1fr)' : 'repeat(4,1fr)';
            document.getElementById('planter-panel').style.display = 'block';
            uiOpen();
            updatePlanterDisplay();
        }

        function closePlanterBox() {
            closeAllUI();
        }

        function updatePlanterDisplay() {
            if (!currentPlanterBox) return;
            const seeds = currentPlanterBox.userData.seeds;
            const slotsEl = document.getElementById('planter-slots');
            slotsEl.innerHTML = '';

            seeds.forEach((seed, i) => {
                const slot = document.createElement('div');
                slot.style.cssText = `
                    background:rgba(0,0,0,0.45); border:2px solid rgba(100,200,80,0.3);
                    border-radius:10px; padding:10px 6px; text-align:center;
                    cursor:pointer; min-height:90px; display:flex; flex-direction:column;
                    align-items:center; justify-content:center; gap:5px;
                    transition:border-color 0.2s, background 0.15s;
                `;

                if (seed) {
                    const icon = itemIcons[seed.type] || '';
                    const growPct = Math.min(100, Math.round((seed.waterCount / 4) * 100));
                    slot.innerHTML = `
                        <div style="font-size:22px">${icon}</div>
                        <div style="font-size:11px;color:rgba(255,255,255,0.8);word-break:break-word">${seed.type.replace(/_seed$/,'').replace(/_/g,' ')}</div>
                        <div style="font-size:10px;color:${seed.grown?'#7dff6a':'rgba(180,255,140,0.7)'}">
                            ${seed.grown ? ' Press E to harvest' : ` ${growPct}%`}
                        </div>
                        <div style="width:100%;height:5px;background:rgba(255,255,255,0.1);border-radius:3px;overflow:hidden">
                            <div style="height:100%;width:${growPct}%;background:linear-gradient(90deg,#4CAF50,#8BC34A);transition:width 0.3s"></div>
                        </div>
                    `;
                    slot.style.borderColor = seed.grown ? 'rgba(80,255,80,0.6)' : 'rgba(80,180,80,0.3)';
                    if (seed.grown) {
                        slot.addEventListener('click', () => harvestPlant(currentPlanterBox, i));
                        slot.title = `Click or press E to harvest ${seed.type.replace(/_seed$/,'').replace(/_/g,' ')}`;
                    } else {
                        slot.addEventListener('contextmenu', e => { e.preventDefault(); removeSeedFromPlanter(i); });
                        slot.title = `Slot ${i+1}: ${seed.type}  waters: ${seed.waterCount}/4 | Right-click to retrieve`;
                    }
                } else {
                    slot.innerHTML = `
                        <div style="font-size:24px;opacity:0.4"></div>
                        <div style="font-size:11px;color:rgba(255,255,255,0.35)">Empty</div>
                        <div style="font-size:10px;color:rgba(255,255,255,0.25)">Click or drag seed here</div>
                    `;
                    slot.addEventListener('click', () => plantSeedInSlot(i));
                }

                // Drag-and-drop: accept seeds from inventory/hotbar
                slot.addEventListener('dragover', e => {
                    if (!seed && draggedItem && isSeedItem(draggedItem) && (inventory[draggedItem] || 0) > 0) {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        slot.style.background = 'rgba(80,200,80,0.25)';
                        slot.style.borderColor = 'rgba(80,255,80,0.7)';
                    }
                });
                slot.addEventListener('dragleave', () => {
                    slot.style.background = 'rgba(0,0,0,0.45)';
                    slot.style.borderColor = seed ? (seed.grown ? 'rgba(80,255,80,0.6)' : 'rgba(80,180,80,0.3)') : 'rgba(100,200,80,0.3)';
                });
                slot.addEventListener('drop', e => {
                    e.preventDefault();
                    slot.style.background = 'rgba(0,0,0,0.45)';
                    slot.style.borderColor = 'rgba(100,200,80,0.3)';
                    if (seed)                             { showMessage(' Slot already occupied!'); return; }
                    if (!draggedItem || !isSeedItem(draggedItem)) { showMessage(' Only seeds can be planted!'); return; }
                    if ((inventory[draggedItem] || 0) <= 0)  { showMessage(' No seeds left!'); return; }
                    inventory[draggedItem]--;
                    currentPlanterBox.userData.seeds[i] = { type: draggedItem, waterCount: 0, grown: false, plantMesh: null };
                    showMessage(` Planted ${draggedItem.replace(/_/g,' ')} in slot ${i + 1}`);
                    updateUI(); updatePlanterDisplay();
                });

                slotsEl.appendChild(slot);
            });

            const statusEl = document.getElementById('planter-status');
            if (isRaining) {
                statusEl.textContent = ' Raining  seeds are being watered!';
                statusEl.style.color = 'rgba(100,180,255,0.9)';
            } else {
                const activeSeeds = seeds.filter(s => s && !s.grown).length;
                statusEl.textContent = activeSeeds > 0 ? ` Waiting for rain to water ${activeSeeds} seed(s)` : '';
                statusEl.style.color = 'rgba(180,255,140,0.75)';
            }
        }

        function plantSeedInSlot(slotIndex) {
            if (!currentPlanterBox) return;
            const available = Object.keys(inventory).filter(k => isSeedItem(k) && inventory[k] > 0);
            if (available.length === 0) { showMessage(' No seeds in inventory!'); return; }
            if (available.length === 1) { _doPlantSeed(slotIndex, available[0]); return; }
            _showSeedPicker(slotIndex, available);
        }

        function _doPlantSeed(slotIndex, seedType) {
            if (!currentPlanterBox || (inventory[seedType] || 0) <= 0) return;
            inventory[seedType]--;
            currentPlanterBox.userData.seeds[slotIndex] = { type: seedType, waterCount: 0, grown: false, plantMesh: null };
            updateUI(); updatePlanterDisplay();
            showMessage(` Planted ${seedType.replace(/_/g,' ')} in slot ${slotIndex + 1}`);
        }

        function _showSeedPicker(slotIndex, seedTypes) {
            const existing = document.getElementById('seed-picker-popup');
            if (existing) existing.remove();
            const popup = document.createElement('div');
            popup.id = 'seed-picker-popup';
            popup.style.cssText = `
                position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
                background:linear-gradient(135deg,rgba(15,35,15,0.98),rgba(10,25,10,0.97));
                border:2px solid rgba(80,200,80,0.45); border-radius:12px;
                padding:18px 20px; z-index:6000; min-width:260px; max-width:360px;
                box-shadow:0 8px 32px rgba(0,0,0,0.7); font-family:'Segoe UI',sans-serif;
                color:white; backdrop-filter:blur(12px);
            `;
            popup.innerHTML = `<div style="font-weight:bold;font-size:15px;margin-bottom:12px;text-align:center;"> Choose seed for slot ${slotIndex+1}</div>`;
            const grid = document.createElement('div');
            grid.style.cssText = 'display:grid;grid-template-columns:repeat(3,1fr);gap:8px;';
            seedTypes.forEach(st => {
                const btn = document.createElement('button');
                btn.style.cssText = `background:rgba(0,0,0,0.5);border:1.5px solid rgba(80,180,80,0.35);border-radius:8px;padding:8px 4px;color:white;cursor:pointer;display:flex;flex-direction:column;align-items:center;gap:3px;font-family:inherit;transition:background 0.15s,border-color 0.15s;`;
                btn.innerHTML = `<span style="font-size:22px">${itemIcons[st]||''}</span><span style="font-size:10px;text-align:center;line-height:1.2">${st.replace(/_seed$/,'').replace(/_/g,' ')}</span><span style="font-size:10px;color:rgba(180,255,140,0.7)">${inventory[st]||0}</span>`;
                btn.onmouseover = () => { btn.style.background='rgba(80,180,80,0.25)'; btn.style.borderColor='rgba(80,255,80,0.6)'; };
                btn.onmouseout  = () => { btn.style.background='rgba(0,0,0,0.5)';       btn.style.borderColor='rgba(80,180,80,0.35)'; };
                btn.onclick = () => { popup.remove(); _doPlantSeed(slotIndex, st); };
                grid.appendChild(btn);
            });
            popup.appendChild(grid);
            const cancel = document.createElement('button');
            cancel.textContent = 'Cancel';
            cancel.style.cssText = 'display:block;width:100%;margin-top:12px;padding:7px;background:rgba(180,0,0,0.5);border:1px solid rgba(255,80,80,0.4);border-radius:6px;color:white;cursor:pointer;font-family:inherit;font-size:13px;';
            cancel.onclick = () => popup.remove();
            popup.appendChild(cancel);
            document.body.appendChild(popup);
            setTimeout(() => {
                document.addEventListener('click', function oc(e) { if (!popup.contains(e.target)) { popup.remove(); document.removeEventListener('click', oc); } });
            }, 100);
        }

        function removeSeedFromPlanter(slotIndex) {
            if (!currentPlanterBox) return;
            const seed = currentPlanterBox.userData.seeds[slotIndex];
            if (!seed) return;
            // Return seed to inventory
            inventory[seed.type] = (inventory[seed.type] || 0) + 1;
            // Remove plant mesh if it exists
            if (seed.plantMesh) {
                currentPlanterBox.userData.plantContainer.remove(seed.plantMesh);
            }
            currentPlanterBox.userData.seeds[slotIndex] = null;
            updateUI();
            updatePlanterDisplay();
            showMessage(` Retrieved seed from slot ${slotIndex + 1}`);
        }

        // Called from updateRain when rain is active  waters all planters in the world
        function waterAllPlanters() {
            for (const building of buildings) {
                if (!building.userData.isPlanterBox) continue;
                if (building.userData.wateredThisRain) continue;
                building.userData.wateredThisRain = true;

                const seeds = building.userData.seeds;
                let anyChanged = false;
                seeds.forEach((seed, i) => {
                    if (!seed || seed.grown) return;
                    seed.waterCount = Math.min(4, seed.waterCount + 1);
                    // Spawn/update plant model at each growth stage
                    spawnPlantModel(building, i, seed.type, seed.waterCount);
                    if (seed.waterCount >= 4) {
                        seed.grown = true;
                    }
                    anyChanged = true;
                });

                if (anyChanged && currentPlanterBox === building) {
                    updatePlanterDisplay();
                }
            }
        }

        // Reset watering flag when rain stops so next rain event can water again
        function resetPlanterWaterFlags() {
            for (const building of buildings) {
                if (building.userData.isPlanterBox) {
                    building.userData.wateredThisRain = false;
                }
            }
        }

        //  PLANT MODEL BUILDER 
        // stage: 1=sprout  2=young  3=maturing  4=fully grown
        // At stage 4, returns a GLB instance if loaded, otherwise falls back to procedural.
        // buildPlantModel: builds realistic plant geometry into a THREE.Group
        // Used by both planter system and wild plant spawning
        function buildPlantModel(seedType, stage, scale=1.0) {
            //  Stage 4: use GLB model if available 
            if (stage === 4 && _plantGLBFiles[seedType]) {
                const glbInst = _buildPlantGLBInstance(seedType, scale);
                if (glbInst) return glbInst;
                // GLB not yet loaded  kick off load and return stage-3 procedural as
                // placeholder (looks better than stage-4 procedural for root veg which
                // shows raw geometry like grey lumps at stage 4).
                _loadPlantGLB(seedType).then(tmpl => {
                    if (!tmpl) return;
                    // Find all planters and wild plants using this seed at stage 4 and refresh
                    const refreshTargets = [];
                    // Planter boxes
                    buildings.forEach(b => {
                        if (!b.userData.seeds) return;
                        b.userData.seeds.forEach((seed, idx) => {
                            if (seed && seed.type === seedType && seed.waterCount >= 4) {
                                refreshTargets.push({ planterBox: b, slotIndex: idx });
                            }
                        });
                    });
                    refreshTargets.forEach(t => spawnPlantModel(t.planterBox, t.slotIndex, seedType, 4));
                    // Wild plants
                    wildPlants.forEach(wp => {
                        if (wp.userData && wp.userData.seedType === seedType && wp.userData.harvestable) {
                            const parent = wp.parent;
                            if (!parent) return;
                            const pos = wp.position.clone();
                            parent.remove(wp);
                            const _wsc2={wheat_seed:7.5,corn_seed:6.8,hemp_seed:6.5,red_berry_seed:1.2,black_berry_seed:1.2,tomato_seed:0.625,pumpkin_seed:5.0,cucumber_seed:2.5,potato_seed:2.5,carrot_seed:2.5,cabbage_seed:2.5,mushroom_seed:2.5,strawberry_seed:2.5};
                            const fresh = buildPlantModel(seedType, 4, _wsc2[seedType] || 2.5);
                            fresh.position.copy(pos);
                            fresh.userData.type      = 'wildPlant';
                            fresh.userData.seedType  = seedType;
                            fresh.userData.harvestable = true;
                            fresh.userData.respawnAt = 0;
                            parent.add(fresh);
                            // Update wildPlants array reference
                            const wi = wildPlants.indexOf(wp);
                            if (wi !== -1) wildPlants[wi] = fresh;
                        }
                    });
                });
                // GLB not ready yet  render as stage 3 (maturing) rather than stage 4
                // procedural which produces ugly raw geometry for root vegetables.
                stage = 3;
            }
            const plant = new THREE.Group();
            const M  = (hex,r=0.8,m=0) => new THREE.MeshStandardMaterial({color:hex,roughness:r,metalness:m});
            const DM = (hex,r=0.8)     => new THREE.MeshStandardMaterial({color:hex,roughness:r,side:THREE.DoubleSide});
            const t  = stage / 4; // growth fraction 0..1

            //  helpers 
            function stk(h,r,col){ const m=new THREE.Mesh(new THREE.CylinderGeometry(r*.65,r,h,7),M(col)); m.position.y=h/2; plant.add(m); return m; }
            function lf(x,y,z,w,h,rx=0,ry=0,rz=0,col=0x4dbe3c){ const m=new THREE.Mesh(new THREE.PlaneGeometry(w,h),DM(col)); m.position.set(x,y,z); m.rotation.set(rx,ry,rz); plant.add(m); return m; }
            function sp(x,y,z,r,col,s=8){ const m=new THREE.Mesh(new THREE.SphereGeometry(r,s,s),M(col)); m.position.set(x,y,z); plant.add(m); return m; }
            function cn(x,y,z,r,h,col,s=8){ const m=new THREE.Mesh(new THREE.ConeGeometry(r,h,s),M(col)); m.position.set(x,y,z); plant.add(m); return m; }
            function cy(x,y,z,rt,rb,h,col,s=8){ const m=new THREE.Mesh(new THREE.CylinderGeometry(rt,rb,h,s),M(col)); m.position.set(x,y,z); plant.add(m); return m; }

            //  PUMPKIN 
            if (seedType === 'pumpkin_seed') {
                const sh = 0.06 + t*0.09; stk(sh, 0.013, 0x4a7c28);
                // Vine sprawl + broad leaves
                const lc = Math.max(2, stage*2);
                for(let i=0;i<lc;i++){
                    const a=i/lc*Math.PI*2, vr=0.05+t*0.07;
                    cy(Math.cos(a)*vr*.5,sh*.6,Math.sin(a)*vr*.5, 0.005,0.008,vr, 0x3a7020, 4);
                    lf(Math.cos(a)*vr*.9,sh*.55,Math.sin(a)*vr*.9, 0.09+t*0.04,0.08+t*0.03, -1.2,a,0, 0x5ab040);
                }
                if(stage>=3){
                    // Realistic ribbed pumpkin
                    const pg=new THREE.Group(); pg.position.set(0,sh+0.01,0);
                    const pr=0.05+t*0.09, py=pr*0.72;
                    for(let r=0;r<8;r++){
                        const ra=r/8*Math.PI*2;
                        const rib=new THREE.Mesh(new THREE.SphereGeometry(pr,8,7),M(stage===4?0xE07C1A:0xBE9010));
                        rib.scale.set(0.52,0.78,0.52); rib.position.set(Math.cos(ra)*pr*.3,0,Math.sin(ra)*pr*.3); pg.add(rib);
                    }
                    // Pumpkin stem
                    const ps=new THREE.Mesh(new THREE.CylinderGeometry(0.007,0.012,0.05,5),M(0x4a2e08));
                    ps.position.y=py+0.01; pg.add(ps);
                    // Curly tendril
                    const tc=new THREE.Mesh(new THREE.TorusGeometry(0.02,0.003,4,8,Math.PI*1.5),M(0x3a7020));
                    tc.position.set(0.03,py+0.04,0); pg.add(tc);
                    plant.add(pg);
                }

            //  WHEAT 
            } else if (seedType === 'wheat_seed') {
                const stalks = stage<2 ? [0] : [-0.042,0,0.042];
                stalks.forEach((ox,si)=>{
                    const h=0.1+t*0.24;
                    const sc2=stage<4?0x5aaa3c:0xC8A800;
                    stk(h,0.007,sc2); // main stalk
                    // Node bumps
                    if(stage>1) for(let n=1;n<3;n++) sp(ox,h*n/3,0,0.009,sc2,5);
                    // Flag leaves at each node
                    if(stage>=2){
                        [-1,1].forEach(side=>{
                            const l2=new THREE.Mesh(new THREE.PlaneGeometry(0.075+t*.02,0.22+t*.05),DM(0x5aaa3c));
                            l2.position.set(side*0.04,h*.48,0); l2.rotation.set(0.1*side,0,side*0.32); plant.add(l2);
                        });
                    }
                    // Ear  realistic elongated seed head
                    if(stage>=3){
                        const earH=0.07+t*.04;
                        const earCol=stage===4?0xD4A800:0x90C038;
                        cy(ox,h+earH/2,0, 0.015,0.011,earH, earCol, 7);
                        // Awns (bristles radiating up)
                        for(let aw=0;aw<8;aw++){
                            const aa=aw/8*Math.PI*2;
                            const awn=new THREE.Mesh(new THREE.CylinderGeometry(.0015,.001,.045,3),M(earCol));
                            awn.position.set(ox+Math.cos(aa)*.012,h+earH*.2+aw*.008,Math.sin(aa)*.012);
                            awn.rotation.set(-Math.cos(aa)*.3,0,-Math.sin(aa)*.3);
                            plant.add(awn);
                        }
                    }
                });

            //  CABBAGE 
            } else if (seedType === 'cabbage_seed') {
                // Concentric layered leaves building into a tight head
                const layerCount = Math.min(stage+1, 5);
                for(let l=0;l<layerCount;l++){
                    const lR=0.03+l*0.038, lCount=4+l*2, ly=l*0.016;
                    const col = l===layerCount-1&&stage===4 ? 0x90e060 : (l<2?0xb8f070:0x60b040);
                    for(let i=0;i<lCount;i++){
                        const a=i/lCount*Math.PI*2+l*.4;
                        const leaf2=new THREE.Mesh(new THREE.SphereGeometry(lR*.7,6,5),DM(col));
                        leaf2.scale.set(1.1,0.28+l*.04,1.1); leaf2.position.set(Math.cos(a)*lR*.7,ly,Math.sin(a)*lR*.7); plant.add(leaf2);
                    }
                }
                // Tight central head stages 3+
                if(stage>=3){
                    const head=new THREE.Mesh(new THREE.SphereGeometry(0.07+t*.018,9,8),M(stage===4?0x68d040:0x88d060));
                    head.scale.set(1,.76,1); head.position.y=layerCount*.018; plant.add(head);
                }

            //  CUCUMBER 
            } else if (seedType === 'cucumber_seed') {
                const h=0.06+t*0.16; stk(h,0.011,0x3a8030);
                // Big coarse leaves alternating
                for(let i=0;i<=stage;i++){
                    const side=i%2===0?1:-1, ly=h*(0.25+i/(stage+1)*.6);
                    lf(side*0.06,ly,0, 0.11+t*.02,0.09+t*.02, 0,0,side*.45, 0x3a8030);
                }
                // Tendril curl
                if(stage>=2){ const tc=new THREE.Mesh(new THREE.TorusGeometry(.03,.003,4,8,Math.PI),M(0x5aaa40)); tc.position.set(0.07,h*.8,0); plant.add(tc); }
                // Cucumbers  dark green ridged cylinder hanging diagonally
                if(stage>=3){
                    const cNum=stage===4?2:1;
                    for(let c=0;c<cNum;c++){
                        const cl=0.12+t*.04, cr=0.018;
                        const cg=new THREE.Group(); cg.position.set(c?-0.07:0.07,h*.68,c?.03:-.03); cg.rotation.z=(c?-1:1)*.45;
                        const body=new THREE.Mesh(new THREE.CylinderGeometry(cr*.88,cr,cl,8),M(stage===4?0x287820:0x48a830)); cg.add(body);
                        // Ridges
                        for(let r=0;r<8;r++){ const ra=r/8*Math.PI*2; const ridge=new THREE.Mesh(new THREE.CylinderGeometry(.003,.003,cl*.9,3),M(0x206818)); ridge.position.set(Math.cos(ra)*cr,0,Math.sin(ra)*cr); cg.add(ridge); }
                        // Yellow blossom end
                        const tip=new THREE.Mesh(new THREE.SphereGeometry(cr*.7,6,5),M(0xE0C020)); tip.position.y=cl/2+.005; cg.add(tip);
                        plant.add(cg);
                    }
                }

            //  POTATO 
            } else if (seedType === 'potato_seed') {
                const h=0.05+t*.13; stk(h,0.013,0x4a9028);
                // Pinnate compound leaves
                const nodes=stage+1;
                for(let n=0;n<nodes;n++){
                    const ny=h*(.22+n/nodes*.65);
                    [-1,1].forEach(side=>{
                        lf(side*.055,ny,0, 0.07+t*.02,0.045+t*.01, 0,0,side*.5, 0x4a9028);
                        if(stage>=3) lf(side*.09,ny-.01,.03, 0.04,0.025, 0,.4,side*.6, 0x4a9028);
                    });
                }
                // White star flowers stage 3+
                if(stage>=3){
                    for(let f=0;f<(stage===4?4:2);f++){
                        const fa=f/(stage===4?4:2)*Math.PI*2;
                        const fg=new THREE.Group(); fg.position.set(Math.cos(fa)*.08,h+.025,Math.sin(fa)*.08);
                        for(let p=0;p<5;p++){ const pa=p/5*Math.PI*2; const petal=new THREE.Mesh(new THREE.PlaneGeometry(.022,.016),DM(0xf0f0e0)); petal.position.set(Math.cos(pa)*.016,0,Math.sin(pa)*.016); petal.rotation.y=pa; fg.add(petal); }
                        const ctr=new THREE.Mesh(new THREE.SphereGeometry(.008,5,4),M(0xf8c820)); fg.add(ctr); plant.add(fg);
                    }
                }
                // Potato tubers at soil level stage 4
                if(stage===4){
                    for(let p=0;p<3;p++){
                        const pa=p/3*Math.PI*2;
                        const tub=new THREE.Mesh(new THREE.SphereGeometry(.032,8,7),M(0xBE8840)); tub.scale.set(.9,.62,1.15); tub.rotation.y=pa;
                        tub.position.set(Math.cos(pa)*.045,.006,Math.sin(pa)*.045); plant.add(tub);
                        // Eyes
                        for(let e=0;e<2;e++){ const ey=new THREE.Mesh(new THREE.SphereGeometry(.005,4,3),M(0x6a3010)); ey.position.set(tub.position.x+(e-.5)*.016,tub.position.y+.016,tub.position.z); plant.add(ey); }
                    }
                }

            //  CARROT 
            } else if (seedType === 'carrot_seed') {
                const h=0.06+t*.16;
                // Feathery umbel tops (carrot fronds)
                const fronds=Math.min(3+stage,8);
                for(let f=0;f<fronds;f++){
                    const fa=f/fronds*Math.PI*2, fh=h*(.7+Math.random()*.3);
                    const fs=new THREE.Mesh(new THREE.CylinderGeometry(.003,.007,fh,4),M(0x5ab038));
                    fs.position.set(Math.cos(fa)*.02*t,fh/2,Math.sin(fa)*.02*t);
                    fs.rotation.set(Math.sin(fa)*.35,0,Math.cos(fa)*.35); plant.add(fs);
                    if(stage>=2) for(let l=0;l<4;l++) lf(Math.cos(fa+.8*l)*.03,fh*(.4+l*.15),Math.sin(fa+.8*l)*.03, .04-.006*l,.028-.003*l, 0,fa+l*.4,0, 0x6ac040);
                }
                // Orange taproot emerging
                if(stage>=2){
                    const cr2=0.017+t*.012, ch=0.06+t*.09, visY=[-0.01,0,.01,.025,.06][stage];
                    const cg=new THREE.Group(); cg.position.y=visY;
                    const body=new THREE.Mesh(new THREE.ConeGeometry(cr2,ch+.04,9),M(0xF07828)); body.rotation.x=Math.PI; cg.add(body);
                    // Surface ridges
                    if(stage>=4) for(let r=0;r<3;r++){ const ring=new THREE.Mesh(new THREE.TorusGeometry(cr2*.85,.003,4,9),M(0xD06010)); ring.position.y=-r*.02; ring.rotation.x=Math.PI/2; cg.add(ring); }
                    plant.add(cg);
                }

            //  HEMP 
            } else if (seedType === 'hemp_seed') {
                const h=0.1+t*.32; stk(h,0.012,0x3a8028);
                // Multi-node plant with palmate fan leaves
                for(let n=0;n<stage+1;n++){
                    const ny=h*(.18+n/(stage+1)*.62);
                    const fingers=Math.min(5+n,7);
                    for(let f=0;f<fingers;f++){
                        const fa=f/fingers*Math.PI*2;
                        lf(Math.cos(fa)*.035+Math.cos(fa)*.02*n/stage,ny,Math.sin(fa)*.035+Math.sin(fa)*.02*n/stage,
                           .032+t*.018,.065+t*.035, -1.25,fa,0, 0x2d7020);
                    }
                }
                // Dense flower/resin bud cluster apex (stage 3+)
                if(stage>=3){
                    const bCol=stage===4?0x9b4ab0:0xb89020;
                    for(let b=0;b<16;b++){
                        const ba=b/16*Math.PI*2, br=.015+Math.random()*.015;
                        const bud=new THREE.Mesh(new THREE.SphereGeometry(.009,5,4),M(bCol)); bud.position.set(Math.cos(ba)*br,h+.015+b*.003,Math.sin(ba)*br); plant.add(bud);
                    }
                    if(stage===4) for(let p=0;p<6;p++){ const pa=p/6*Math.PI*2; const pi=new THREE.Mesh(new THREE.CylinderGeometry(.002,.002,.028,3),M(0xe0a0f0)); pi.position.set(Math.cos(pa)*.018,h+.05,Math.sin(pa)*.018); plant.add(pi); }
                }

            //  CORN 
            } else if (seedType === 'corn_seed') {
                const h=0.1+t*.34; stk(h,.021,0x4a9828);
                // Long arching strap leaves
                for(let s=0;s<Math.min(stage*2,8);s++){
                    const side=s%2===0?1:-1, sy=h*(.22+s/8*.55);
                    const sl=new THREE.Mesh(new THREE.PlaneGeometry(.08+t*.02,.26+t*.07),DM(0x4a9828));
                    sl.position.set(side*.06,sy,0); sl.rotation.set(.2*side,0,side*.38); plant.add(sl);
                }
                // Tassel at top
                if(stage>=2) for(let ts=0;ts<4+stage;ts++){ const ta=ts/(4+stage)*Math.PI*2; const tl=new THREE.Mesh(new THREE.CylinderGeometry(.002,.001,.07+t*.04,3),M(0xd4c040)); tl.position.set(Math.cos(ta)*.018,h+.025+ts*.005,Math.sin(ta)*.018); plant.add(tl); }
                // Ear of corn in husk (stage 3+)
                if(stage>=3){
                    const eg=new THREE.Group(); eg.position.set(.07,h*.6,0); eg.rotation.z=.45;
                    const eH=.12+t*.05, eR=.028;
                    // Husk leaves peeling back at stage 4
                    for(let hl=0;hl<4;hl++){
                        const husk=new THREE.Mesh(new THREE.ConeGeometry(eR+.006,eH*.9,8,1,true),DM(stage===4?0x8a9820:0xa8b820));
                        husk.rotation.set(stage===4?.3*hl:0,hl/4*Math.PI*2,0); eg.add(husk);
                    }
                    // Yellow cob at stage 4
                    if(stage===4){
                        const cob=new THREE.Mesh(new THREE.CylinderGeometry(eR*.85,eR*.75,eH,9),M(0xF0C040)); eg.add(cob);
                        for(let k=0;k<20;k++){ const ka=k/20*Math.PI*2,ky=k%10/10; const kern=new THREE.Mesh(new THREE.SphereGeometry(.006,4,4),M(0xF8D050)); kern.position.set(Math.cos(ka)*eR*.82,(ky-.5)*eH*.85,Math.sin(ka)*eR*.82); eg.add(kern); }
                    }
                    plant.add(eg);
                }

            //  MUSHROOM 
            } else if (seedType === 'mushroom_seed') {
                const sH=[0,.022,.044,.07,.1][stage];
                const cR=[0,.022,.044,.07,.1][stage];
                // Stipe (white stalk)
                const stipe=new THREE.Mesh(new THREE.CylinderGeometry(sH*.36,sH*.48,sH,8),M(0xf0ead8)); stipe.position.y=sH/2; plant.add(stipe);
                // Annulus ring (stage 3+)
                if(stage>=3){ const ann=new THREE.Mesh(new THREE.TorusGeometry(sH*.4,.003,4,10),M(0xd8cebc)); ann.position.y=sH*.58; ann.rotation.x=Math.PI/2; plant.add(ann); }
                // Pileus (cap)  flattened red/brown sphere
                if(stage>=1){
                    const cap=new THREE.Mesh(new THREE.SphereGeometry(cR,10,8),M(0xC41c1c)); cap.scale.set(1,stage>=3?.52:.78,1); cap.position.y=sH; plant.add(cap);
                    // Gills underside
                    if(stage>=3){ const gills=new THREE.Mesh(new THREE.CylinderGeometry(cR*.88,sH*.38,cR*.16,14,1,true),M(0xe8c8b0)); gills.position.y=sH-cR*.04; plant.add(gills); }
                    // White spots (amanita style)
                    const spotN=[0,3,5,7,9][stage]||0;
                    for(let s=0;s<spotN;s++){ const sa=s/spotN*Math.PI*2; const spot=new THREE.Mesh(new THREE.SphereGeometry(cR*.15,5,4),M(0xffffff)); spot.position.set(Math.cos(sa)*cR*.6,sH+cR*.44,Math.sin(sa)*cR*.6); plant.add(spot); }
                }

            //  RED BERRY 
            } else if (seedType === 'red_berry_seed') {
                const h=0.04+t*.11; stk(h,.011,0x2d6020);
                for(let b=0;b<Math.min(stage+1,4);b++){
                    const ba=b/(Math.min(stage+1,4))*Math.PI*2;
                    const brg=new THREE.Mesh(new THREE.CylinderGeometry(.006,.009,h*.7,5),M(0x2d6020));
                    brg.rotation.set(Math.sin(ba)*.55,0,Math.cos(ba)*.55); brg.position.set(Math.cos(ba)*.04*t,h*.38,Math.sin(ba)*.04*t); plant.add(brg);
                    // Oval leaves
                    lf(Math.cos(ba)*.065*t,h*.74,Math.sin(ba)*.065*t, .07,.048, 0,ba,0, 0x3a8028);
                    if(stage>=2) for(let rb=0;rb<stage;rb++){
                        const bra=ba+rb*.6, bR=stage===4?.019:.013;
                        const berry=new THREE.Mesh(new THREE.SphereGeometry(bR,7,6),M(0xcc1111)); berry.position.set(Math.cos(bra)*.07*t,h*.85+rb*.012,Math.sin(bra)*.07*t); plant.add(berry);
                        const cal=new THREE.Mesh(new THREE.ConeGeometry(bR*.4,bR*.5,5),M(0x2d6020)); cal.position.set(berry.position.x,berry.position.y+bR*.85,berry.position.z); plant.add(cal);
                    }
                }

            //  BLACK BERRY 
            } else if (seedType === 'black_berry_seed') {
                const h=0.04+t*.13; stk(h,.012,0x1e4a18);
                for(let b=0;b<Math.min(stage+1,4);b++){
                    const ba=b/(Math.min(stage+1,4))*Math.PI*2;
                    const cane=new THREE.Mesh(new THREE.CylinderGeometry(.006,.01,h*.75,5),M(0x1e4a18));
                    cane.rotation.set(Math.sin(ba)*.6,0,Math.cos(ba)*.6); cane.position.set(Math.cos(ba)*.045*t,h*.38,Math.sin(ba)*.045*t); plant.add(cane);
                    // Thorns
                    if(stage>=2) for(let th=0;th<2;th++){ const thorn=new THREE.Mesh(new THREE.ConeGeometry(.003,.016,4),M(0x2a1a18)); thorn.position.set(Math.cos(ba+th)*.025,h*(.28+th*.14),Math.sin(ba+th)*.025); thorn.rotation.z=Math.PI/3; plant.add(thorn); }
                    lf(Math.cos(ba)*.07*t,h*.72,Math.sin(ba)*.07*t, .065,.048, 0,ba,0, 0x1e5018);
                    // Compound drupes
                    if(stage>=2) for(let rb=0;rb<stage;rb++){
                        const bra=ba+rb*.55, bg=new THREE.Group(); bg.position.set(Math.cos(bra)*.075*t,h*.85+rb*.014,Math.sin(bra)*.075*t);
                        for(let d=0;d<9;d++){ const da=d/9*Math.PI*2, dr=.009; const drupe=new THREE.Mesh(new THREE.SphereGeometry(dr,5,4),M(d%3===0?0x1a0a28:0x100818)); drupe.position.set(Math.cos(da)*dr*1.6,d%3*.004,Math.sin(da)*dr*1.6); bg.add(drupe); }
                        plant.add(bg);
                    }
                }

            //  STRAWBERRY 
            } else if (seedType === 'strawberry_seed') {
                // Low trifoliate rosette
                const lc=Math.min(4+stage*2,12);
                for(let i=0;i<lc;i++){
                    const a=i/lc*Math.PI*2, r2=.032+t*.042;
                    for(let lf2=0;lf2<3;lf2++){
                        const la=a+(lf2-1)*.38;
                        lf(Math.cos(la)*(r2+lf2*.01),.014+t*.01,Math.sin(la)*(r2+lf2*.01), .058+t*.01,.044+t*.01, -1.2,la,0, 0x3d9c28);
                    }
                }
                // Runners (stage 3+)
                if(stage>=3) for(let r3=0;r3<2;r3++){ const run=new THREE.Mesh(new THREE.CylinderGeometry(.003,.003,.09,4),M(0x5ab038)); run.rotation.z=(r3===0?1:-1)*.8; run.position.set(r3===0?.05:-.05,.01,0); plant.add(run); }
                // Fruit  realistic red cone with achenes
                if(stage>=2){
                    const fN=[0,0,1,2,3][stage];
                    const fCol=stage===4?0xe01010:(stage===3?0xe84040:0xf08050);
                    for(let f=0;f<fN;f++){
                        const fa=f/fN*Math.PI*2, fg=new THREE.Group(); fg.position.set(Math.cos(fa)*.06,.048,Math.sin(fa)*.06);
                        const fruit=new THREE.Mesh(new THREE.ConeGeometry(.025,.052,9),M(fCol)); fruit.rotation.x=Math.PI; fg.add(fruit);
                        if(stage===4) for(let s=0;s<12;s++){ const sa=s/12*Math.PI*2,sy=s%6/6; const achene=new THREE.Mesh(new THREE.SphereGeometry(.003,4,3),M(0xf0e8a0)); achene.position.set(Math.cos(sa)*.019,-.01-sy*.028,Math.sin(sa)*.019); fg.add(achene); }
                        // Green calyx
                        for(let s=0;s<5;s++){ const sa=s/5*Math.PI*2; lf(Math.cos(sa)*.018,.026,Math.sin(sa)*.018, .022,.014, -1.2,sa,0, 0x3d9c28); }
                        plant.add(fg);
                    }
                }

            //  TOMATO 
            } else if (seedType === 'tomato_seed') {
                const h=0.07+t*.2; stk(h,.014,0x3a8828);
                // Compound pinnate leaves on side branches
                for(let b=0;b<Math.min(stage,4);b++){
                    const ba=b/Math.min(stage,4)*Math.PI*2, bh=h*(.28+b/Math.min(stage,4)*.58);
                    const brMesh=new THREE.Mesh(new THREE.CylinderGeometry(.007,.011,h*.38,5),M(0x3a8828));
                    brMesh.rotation.set(Math.sin(ba)*.5,0,Math.cos(ba)*.5); brMesh.position.set(Math.cos(ba)*.028*t,bh,Math.sin(ba)*.028*t); plant.add(brMesh);
                    for(let lf3=0;lf3<5;lf3++){ const lfa=ba+(lf3-2)*.48, lr=.038+lf3*.009; lf(Math.cos(lfa)*lr+Math.cos(ba)*.025*t,bh+.01+lf3*.006,Math.sin(lfa)*lr+Math.sin(ba)*.025*t, .06,.04, 0,lfa,0, 0x3a8828); }
                    // Tomatoes on trusses
                    if(stage>=2&&b<stage-1){
                        const tN=stage===4?3:(stage===3?2:1);
                        for(let tom=0;tom<tN;tom++){
                            const tCol=stage===4?0xE01010:(stage===3?0xF04020:0xF0C010);
                            const tR=stage===4?.034:(stage===3?.024:.016);
                            const tmesh=new THREE.Mesh(new THREE.SphereGeometry(tR,9,8),M(tCol));
                            tmesh.position.set(Math.cos(ba)*.08*t+tom*.038,bh+h*.14+tom*.022,Math.sin(ba)*.08*t); plant.add(tmesh);
                            // Calyx star
                            for(let s=0;s<5;s++){ const sa=s/5*Math.PI*2; lf(tmesh.position.x+Math.cos(sa)*.022,tmesh.position.y+tR+.003,tmesh.position.z+Math.sin(sa)*.022, .024,.013, -1.2,sa,0, 0x2d7020); }
                            // Blossom scar
                            const bsc=new THREE.Mesh(new THREE.SphereGeometry(tR*.22,4,3),M(0x6a3010)); bsc.position.set(tmesh.position.x,tmesh.position.y-tR*.88,tmesh.position.z); plant.add(bsc);
                        }
                    }
                }

            //  FALLBACK 
            } else {
                stk(.08+t*.1,.013,0x3a8c2f);
                [-1,1].forEach(side=>lf(side*.04,.1+t*.06,0, .08+t*.02,.05+t*.01, 0,0,side*.5));
            }

            plant.scale.setScalar(scale * ([0,.32,.56,.80,1.0][stage]||1));
            return plant;
        }

        // Per-seedType y-offset table REMOVED  replaced by automatic soil-surface positioning.
        // spawnPlantModel now reads planterBox.userData.dirtY (the actual soil surface height
        // in the planter group's local space) and places every plant at that y, so GLB models
        // always sit on the dirt regardless of their internal geometry origin.
        // Root vegetables (carrot, potato) get a small extra sink so their tops are at soil level.
        const _plantSoilSink = {
            carrot_seed:  0.18,   // sink 18cm so orange taproot is mostly underground
            potato_seed:  0.10,   // tubers half-buried
            strawberry_seed: 0.04,
        };

        function spawnPlantModel(planterBox, slotIndex, seedType, stage) {
            const container = planterBox.userData.plantContainer;
            const existing = planterBox.userData.seeds[slotIndex]?.plantMesh;
            if (existing) container.remove(existing);
            const _slotDefs = planterBox.userData.slotDefs;
            const _sx = _slotDefs ? _slotDefs[slotIndex].x : (planterBox.userData.slotPositions||[])[slotIndex]||0;
            const _sz = _slotDefs ? _slotDefs[slotIndex].z : 0;
            const plant = buildPlantModel(seedType, stage);

            // Soil surface in plantContainer local space = planterBox.userData.dirtY.
            // Procedural plants (stages 1-3) are built with y=0 at their base, so we
            // lift them to dirtY. GLB plants are also grounded at y=0 by _loadPlantGLB,
            // so the same lift applies  then we optionally sink root veg a little extra.
            const dirtY = planterBox.userData.dirtY ?? 0.15;
            const isGLB = stage === 4 && _plantGLBCache[seedType];
            const sink  = isGLB ? (_plantSoilSink[seedType] ?? 0) : 0;
            plant.position.set(_sx, dirtY - sink, _sz);
            container.add(plant);
            if (planterBox.userData.seeds[slotIndex]) planterBox.userData.seeds[slotIndex].plantMesh = plant;
        }

        //  HARVEST MAPPING 
        // seedType  { produce: itemKey, count: n, seedReturn: n }
        const _harvestMap = {
            pumpkin_seed:    { produce: 'pumpkin',      count: 1, seedReturn: 2 },
            wheat_seed:      { produce: 'wheat',        count: 3, seedReturn: 3 },
            cabbage_seed:    { produce: 'cabbage',      count: 1, seedReturn: 2 },
            cucumber_seed:   { produce: 'cucumber',     count: 2, seedReturn: 2 },
            potato_seed:     { produce: 'potato',       count: 2, seedReturn: 2 },
            carrot_seed:     { produce: 'carrot',       count: 2, seedReturn: 2 },
            hemp_seed:       { produce: 'hemp_fiber',   count: 3, seedReturn: 2 },
            corn_seed:       { produce: 'corn',         count: 2, seedReturn: 2 },
            mushroom_seed:   { produce: 'mushroom_crop',count: 2, seedReturn: 1 },
            red_berry_seed:  { produce: 'red_berries',  count: 3, seedReturn: 2 },
            black_berry_seed:{ produce: 'black_berries',count: 3, seedReturn: 2 },
            strawberry_seed: { produce: 'strawberry',   count: 3, seedReturn: 2 },
            tomato_seed:     { produce: 'tomato',       count: 2, seedReturn: 2 },
        };

        function harvestPlant(planterBox, slotIndex) {
            const seed = planterBox.userData.seeds[slotIndex];
            if (!seed || !seed.grown) return;

            const map = _harvestMap[seed.type];
            if (!map) return;

            // Give produce
            inventory[map.produce] = (inventory[map.produce] || 0) + map.count;
            // Return seeds so player can replant
            inventory[seed.type] = (inventory[seed.type] || 0) + map.seedReturn;

            // Remove plant mesh
            if (seed.plantMesh) {
                planterBox.userData.plantContainer.remove(seed.plantMesh);
            }
            // Reset slot
            planterBox.userData.seeds[slotIndex] = null;

            const produceName = itemDisplayNames[map.produce] || map.produce;
            showMessage(`\u2705 Harvested ${map.count}x ${produceName} + ${map.seedReturn} seed(s)!`);
            playCollectSound();
            updateUI();

            // Refresh planter UI if open
            if (currentPlanterBox === planterBox) updatePlanterDisplay();
        }

        function updateStorageDisplay() {
            if (!currentStorageBox) return;
            
            const grid = document.getElementById('storage-grid');
            grid.innerHTML = '';
            
            const storageInventory = currentStorageBox.userData.storageInventory;
            // Use actual capacity from the inventory array (20 for large, 10 for small)
            const slotCount = storageInventory ? storageInventory.length : 26;
            
            for (let i = 0; i < slotCount; i++) {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                slot.dataset.slotIndex = i;
                slot.dataset.slotType = 'storage';
                
                const itemData = storageInventory[i];
                
                if (itemData && itemData.name && itemData.count > 0) {
                    const icon = itemIcons[itemData.name] || '\u2753';
                    
                    slot.innerHTML = `
                        <div class="inventory-slot-icon">${icon}</div>
                        <div class="inventory-slot-name">${itemData.name}</div>
                        <div class="inventory-slot-count">${itemData.count}</div>
                    `;
                    slot.dataset.itemName = itemData.name;
                    slot.draggable = true;
                } else {
                    slot.innerHTML = '<div class="inventory-slot-empty">+</div>';
                }
                
                // Drag events
                slot.addEventListener('dragstart', handleDragStart);
                slot.addEventListener('dragover', handleDragOver);
                slot.addEventListener('drop', handleDrop);
                slot.addEventListener('dragend', handleDragEnd);
                slot.addEventListener('dragleave', handleDragLeave);
                
                // Ctrl+click: move full stack to player inventory
                if (itemData && itemData.name) {
                    slot.addEventListener('click', (e) => {
                        if (e.ctrlKey) {
                            ctrlClickMoveStack('storage', i, itemData.name);
                        }
                    });
                    slot.title = 'Ctrl+click to move stack to inventory';
                }
                
                grid.appendChild(slot);
            }
        }
        
        function toggleInventory() {
            const panel = document.getElementById('inventory-panel');
            const isVisible = panel.style.display === 'block';
            
            if (isVisible) {
                panel.style.display = 'none';
                panel.style.left = '';
                panel.style.right = '';
                panel.style.top = '';
                panel.style.transform = '';
                // Also close any station menus that were open alongside inventory
                const recyclerMenu = document.getElementById('recycler-menu');
                if (recyclerMenu.style.display === 'block') {
                    recyclerMenu.style.display = 'none';
                }
                const furnaceMenu = document.getElementById('furnace-menu');
                if (furnaceMenu.style.display === 'block') {
                    furnaceMenu.style.display = 'none';
                    furnaceMenu.style.left = '';
                    furnaceMenu.style.transform = '';
                    currentFurnace = null;
                }
                const campfireMenu = document.getElementById('campfire-menu');
                if (campfireMenu.style.display === 'block') {
                    campfireMenu.style.display = 'none';
                    campfireMenu.style.left = '';
                    campfireMenu.style.transform = '';
                    currentCampfire = null;
                }
                // Also close storage box if it was open alongside inventory
                const storagePanel = document.getElementById('storage-panel');
                if (storagePanel.style.display === 'block') {
                    storagePanel.style.display = 'none';
                    currentStorageBox = null;
                    // openStorageBox called uiOpen() once for both panels, so one uiClose() below covers both
                }
                uiClose();
            } else {
                panel.style.left = '';
                panel.style.right = '';
                panel.style.top = '';
                panel.style.transform = '';
                panel.style.display = 'block';
                document.getElementById('crafting-menu').style.display = 'none';
                document.getElementById('workbench-menu').style.display = 'none';
                document.getElementById('furnace-menu').style.display = 'none';
                uiOpen();
                updateInventoryDisplay();
            }
        }
        
        // Ctrl+click: move entire stack to the other open container
        function ctrlClickMoveStack(fromType, fromSlotIndex, itemName) {
            if (!itemName) return;
            
            if (fromType === 'inventory' && currentStorageBox) {
                // Move entire stack from inventory to storage
                const count = inventory[itemName] || 0;
                if (count <= 0) return;
                const storageInv = currentStorageBox.userData.storageInventory;
                // Find matching slot or empty slot
                let placed = false;
                for (let i = 0; i < storageInv.length; i++) {
                    if (storageInv[i] && storageInv[i].name === itemName) {
                        storageInv[i].count += count;
                        placed = true;
                        break;
                    }
                }
                if (!placed) {
                    for (let i = 0; i < storageInv.length; i++) {
                        if (!storageInv[i]) {
                            storageInv[i] = { name: itemName, count: count };
                            placed = true;
                            break;
                        }
                    }
                }
                if (placed) {
                    inventory[itemName] = 0;
                    inventorySlots[fromSlotIndex] = null;
                    updateStorageDisplay();
                    updateInventoryDisplay();
                    updateHotbar();
                    playInventoryMoveSound();
                } else {
                    showMessage('\u26a0\ufe0f Storage is full!');
                }
            } else if (fromType === 'storage' && currentStorageBox) {
                // Move entire stack from storage to inventory
                const storageInv = currentStorageBox.userData.storageInventory;
                const slotData = storageInv[fromSlotIndex];
                if (!slotData) return;
                const count = slotData.count;
                // Find matching inventory slot or empty slot
                let placed = false;
                if (inventorySlots.some(s => s === slotData.name)) {
                    if (!inventory[slotData.name]) inventory[slotData.name] = 0;
                    inventory[slotData.name] += count;
                    storageInv[fromSlotIndex] = null;
                    placed = true;
                } else {
                    const emptyIdx = inventorySlots.findIndex(s => s === null);
                    if (emptyIdx !== -1) {
                        if (!inventory[slotData.name]) inventory[slotData.name] = 0;
                        inventory[slotData.name] += count;
                        inventorySlots[emptyIdx] = slotData.name;
                        storageInv[fromSlotIndex] = null;
                        placed = true;
                    }
                }
                if (placed) {
                    updateStorageDisplay();
                    updateInventoryDisplay();
                    updateHotbar();
                    playInventoryMoveSound();
                } else {
                    showMessage('\u26a0\ufe0f Inventory is full!');
                }
            }
        }

        function updateInventoryDisplay() {
            const grid = document.getElementById('inventory-grid');
            grid.innerHTML = '';
            
            // Sync inventory slots with actual inventory
            for (let i = 0; i < inventorySlots.length; i++) {
                if (inventorySlots[i] && inventory[inventorySlots[i]] <= 0) {
                    inventorySlots[i] = null;
                    inventorySlotCounts[i] = null;
                }
                // Clear stale per-slot counts that exceed the global total
                if (inventorySlots[i] && inventorySlotCounts[i] !== null) {
                    if (inventorySlotCounts[i] <= 0) {
                        inventorySlotCounts[i] = null;
                        inventorySlots[i] = null;
                    }
                }
            }

            // Create slots
            for (let i = 0; i < 30; i++) {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                slot.dataset.slotIndex = i;
                slot.dataset.slotType = 'inventory';
                
                const itemName = inventorySlots[i];
                
                if (itemName && inventory[itemName] > 0) {
                    // Use per-slot count if this is a split stack, else use global total
                    const count = getInvSlotCount(i);
                    const icon = getItemIcon(itemName);
                    
                    slot.innerHTML = `
                        <div class="inventory-slot-icon">${icon}</div>
                        <div class="inventory-slot-name">${itemName}</div>
                        <div class="inventory-slot-count">${count}</div>
                    `;
                    slot.dataset.itemName = itemName;
                    slot.draggable = true;
                } else {
                    slot.innerHTML = '<div class="inventory-slot-empty">+</div>';
                }
                
                // Drag events
                slot.addEventListener('dragstart', handleDragStart);
                slot.addEventListener('dragover', handleDragOver);
                slot.addEventListener('drop', handleDrop);
                slot.addEventListener('dragend', handleDragEnd);
                slot.addEventListener('dragleave', handleDragLeave);
                
                // Double-click handler for armor and recycler
                if (itemName) {
                    slot.addEventListener('dblclick', () => {
                        // Check if it's armor
                        if (armorSlotMapping[itemName]) {
                            equipArmor(itemName);
                        } 
                        // Or if recycler is open
                        else if (currentRecycler) {
                            addItemToRecycler(itemName);
                        }
                    });
                    
                    // Ctrl+click: move full stack to storage (if open)
                    slot.addEventListener('click', (e) => {
                        if (e.ctrlKey && currentStorageBox) {
                            ctrlClickMoveStack('inventory', i, itemName);
                        }
                    });
                    
                    if (armorSlotMapping[itemName]) {
                        slot.style.cursor = 'pointer';
                        slot.title = 'Double-click to equip';
                    } else if (currentRecycler) {
                        slot.style.cursor = 'pointer';
                        slot.title = 'Double-click to add to recycler';
                    } else if (currentStorageBox) {
                        slot.title = 'Ctrl+click to move stack to storage';
                    }
                }
                
                grid.appendChild(slot);
            }
            
            // Update armor display
            updateArmorDisplay();
        }
        
        let draggedCtrl = false;
        let draggedCount = 0; // how many were actually picked up (full or half)

        function handleDragStart(e) {
            if (!e.target.dataset.itemName) return;
            draggedItem = e.target.dataset.itemName;
            draggedFromSlot = parseInt(e.target.dataset.slotIndex);
            draggedFromType = e.target.dataset.slotType;
            draggedCtrl = e.ctrlKey;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            
            // Compute how many we're dragging
            if (draggedFromType === 'inventory' || draggedFromType === 'hotbar') {
                // Use per-slot count if this is a split stack, else use global total
                const total = draggedFromType === 'inventory'
                    ? getInvSlotCount(draggedFromSlot)
                    : (inventory[draggedItem] || 0);
                draggedCount = draggedCtrl ? Math.max(1, Math.floor(total / 2)) : total;
            } else if (draggedFromType === 'storage' && currentStorageBox) {
                const storageInv = currentStorageBox.userData.storageInventory;
                const slotData = storageInv[draggedFromSlot];
                const total = slotData ? slotData.count : 0;
                draggedCount = draggedCtrl ? Math.max(1, Math.floor(total / 2)) : total;
            } else if (draggedFromType === 'backpack' && currentBackpack) {
                const slotData = (currentBackpack.userData.backpackContents || [])[draggedFromSlot];
                const total = slotData ? slotData.count : 0;
                draggedCount = draggedCtrl ? Math.max(1, Math.floor(total / 2)) : total;
            } else if (draggedFromType === 'furnace-fuel') {
                const state = currentFurnace && currentFurnace.userData.smeltingState;
                const total = state ? (state.fuelCount || 0) : 0;
                draggedCount = draggedCtrl ? Math.max(1, Math.floor(total / 2)) : total;
            } else if (draggedFromType === 'campfire-fuel') {
                const state = currentCampfire && currentCampfire.userData.smeltingState;
                const total = state ? (state.fuelCount || 0) : 0;
                draggedCount = draggedCtrl ? Math.max(1, Math.floor(total / 2)) : total;
            } else {
                draggedCount = inventory[draggedItem] || 0;
            }
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            if (!e.currentTarget.classList.contains('dragging')) {
                e.currentTarget.classList.add('drag-over');
            }
        }
        
        function handleDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }
        
        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');
            
            if (!draggedItem) return;
            
            const dropSlotType = e.currentTarget.dataset.slotType;
            const dropSlotIndex = parseInt(e.currentTarget.dataset.slotIndex);
            
            // How many to move
            const moveCount = draggedCount;
            
            // Handle drag FROM fuel slot  inventory / hotbar / storage
            if (draggedFromType === 'furnace-fuel' || draggedFromType === 'campfire-fuel') {
                const stationType = draggedFromType === 'furnace-fuel' ? 'furnace' : 'campfire';
                if (dropSlotType === 'inventory' || dropSlotType === 'hotbar' || dropSlotType === 'storage') {
                    _returnFuelToSlot(stationType, draggedCount, dropSlotType, dropSlotIndex);
                }
                draggedItem = null; draggedFromSlot = null; draggedFromType = null; draggedCtrl = false; draggedCount = 0;
                return;
            }

            // Handle dropping on storage slot
            if (dropSlotType === 'storage' && currentStorageBox) {
                const storageInv = currentStorageBox.userData.storageInventory;
                
                if (draggedFromType === 'inventory') {
                    const slotTotal = getInvSlotCount(draggedFromSlot);
                    const total = inventory[draggedItem] || 0;
                    const actual = Math.min(moveCount, slotTotal);
                    if (actual <= 0) return;
                    
                    if (storageInv[dropSlotIndex] && storageInv[dropSlotIndex].name === draggedItem) {
                        storageInv[dropSlotIndex].count += actual;
                    } else if (!storageInv[dropSlotIndex]) {
                        storageInv[dropSlotIndex] = { name: draggedItem, count: actual };
                    } else {
                        // Swap  only if moving full stack
                        if (!draggedCtrl) {
                            const swapItem = storageInv[dropSlotIndex];
                            storageInv[dropSlotIndex] = { name: draggedItem, count: actual };
                            if (!inventory[swapItem.name]) inventory[swapItem.name] = 0;
                            inventory[swapItem.name] += swapItem.count;
                            inventorySlots[draggedFromSlot] = swapItem.name;
                            inventorySlotCounts[draggedFromSlot] = null;
                        } else {
                            // Can't split onto occupied different-item slot
                            return;
                        }
                    }
                    inventory[draggedItem] = Math.max(0, total - actual);
                    // Update per-slot count if this was a split slot
                    if (inventorySlotCounts[draggedFromSlot] !== null) {
                        inventorySlotCounts[draggedFromSlot] = Math.max(0, inventorySlotCounts[draggedFromSlot] - actual);
                        if (inventorySlotCounts[draggedFromSlot] <= 0) { inventorySlotCounts[draggedFromSlot] = null; inventorySlots[draggedFromSlot] = null; }
                    } else {
                        if (inventory[draggedItem] <= 0) inventorySlots[draggedFromSlot] = null;
                    }
                    
                } else if (draggedFromType === 'storage') {
                    const srcData = storageInv[draggedFromSlot];
                    if (!srcData) return;
                    const actual = Math.min(moveCount, srcData.count);
                    if (actual <= 0) return;
                    
                    if (storageInv[dropSlotIndex] && storageInv[dropSlotIndex].name === draggedItem) {
                        storageInv[dropSlotIndex].count += actual;
                        srcData.count -= actual;
                        if (srcData.count <= 0) storageInv[draggedFromSlot] = null;
                    } else if (!storageInv[dropSlotIndex]) {
                        storageInv[dropSlotIndex] = { name: draggedItem, count: actual };
                        srcData.count -= actual;
                        if (srcData.count <= 0) storageInv[draggedFromSlot] = null;
                    } else if (!draggedCtrl) {
                        // Full swap
                        const temp = storageInv[dropSlotIndex];
                        storageInv[dropSlotIndex] = storageInv[draggedFromSlot];
                        storageInv[draggedFromSlot] = temp;
                    }
                    
                } else if (draggedFromType === 'hotbar') {
                    const total = inventory[draggedItem] || 0;
                    const actual = Math.min(moveCount, total);
                    if (actual <= 0) return;
                    
                    if (storageInv[dropSlotIndex] && storageInv[dropSlotIndex].name === draggedItem) {
                        storageInv[dropSlotIndex].count += actual;
                    } else if (!storageInv[dropSlotIndex]) {
                        storageInv[dropSlotIndex] = { name: draggedItem, count: actual };
                    } else if (!draggedCtrl) {
                        const swapItem = storageInv[dropSlotIndex];
                        storageInv[dropSlotIndex] = { name: draggedItem, count: actual };
                        if (!inventory[swapItem.name]) inventory[swapItem.name] = 0;
                        inventory[swapItem.name] += swapItem.count;
                        hotbar[draggedFromSlot].item = swapItem.name;
                    } else {
                        return;
                    }
                    inventory[draggedItem] = Math.max(0, total - actual);
                    if (inventory[draggedItem] <= 0) hotbar[draggedFromSlot].item = null;
                }
                
                updateStorageDisplay();
                updateInventoryDisplay();
                updateHotbar();
            }
            // Handle dropping on backpack slot (move item FROM inventory INTO backpack)
            else if (dropSlotType === 'backpack' && currentBackpack) {
                if (draggedFromType === 'inventory') {
                    const contents = currentBackpack.userData.backpackContents || [];
                    const total = inventory[draggedItem] || 0;
                    const actual = Math.min(moveCount, total);
                    if (actual <= 0) return;
                    const existing = contents[dropSlotIndex];
                    if (existing && existing.name === draggedItem) {
                        existing.count += actual;
                    } else if (!existing) {
                        contents[dropSlotIndex] = { name: draggedItem, count: actual };
                    } else { return; }
                    inventory[draggedItem] = Math.max(0, total - actual);
                    updateBackpackDisplay(); updateInventoryDisplay(); updateUI();
                }
            }
            // Handle dropping on inventory slot
            else if (dropSlotType === 'inventory') {
                if (draggedFromType === 'storage' && currentStorageBox) {
                    const storageInv = currentStorageBox.userData.storageInventory;
                    const storageItem = storageInv[draggedFromSlot];
                    if (!storageItem) return;
                    const actual = Math.min(moveCount, storageItem.count);
                    if (actual <= 0) return;
                    
                    if (!inventory[storageItem.name]) inventory[storageItem.name] = 0;
                    
                    if (inventorySlots[dropSlotIndex] === storageItem.name) {
                        // Dropping onto a slot that already has this item
                        inventory[storageItem.name] += actual;
                        if (inventorySlotCounts[dropSlotIndex] !== null) {
                            inventorySlotCounts[dropSlotIndex] += actual;
                        }
                        storageItem.count -= actual;
                        if (storageItem.count <= 0) storageInv[draggedFromSlot] = null;
                    } else if (!inventorySlots[dropSlotIndex]) {
                        inventory[storageItem.name] += actual;
                        inventorySlots[dropSlotIndex] = storageItem.name;
                        // If this item has split stacks, track this new slot too
                        const existingSlots = inventorySlots.map((s,i) => i).filter(i => i !== dropSlotIndex && inventorySlots[i] === storageItem.name);
                        if (existingSlots.length > 0 && inventorySlotCounts[existingSlots[0]] !== null) {
                            inventorySlotCounts[dropSlotIndex] = actual;
                        } else {
                            inventorySlotCounts[dropSlotIndex] = null;
                            clearSplitCounts(storageItem.name); // consolidate
                        }
                        storageItem.count -= actual;
                        if (storageItem.count <= 0) storageInv[draggedFromSlot] = null;
                    } else if (!draggedCtrl) {
                        // Full swap
                        const swapItemName = inventorySlots[dropSlotIndex];
                        inventory[storageItem.name] += actual;
                        inventorySlots[dropSlotIndex] = storageItem.name;
                        if (swapItemName && inventory[swapItemName] > 0) {
                            storageInv[draggedFromSlot] = { name: swapItemName, count: inventory[swapItemName] };
                            inventory[swapItemName] = 0;
                            inventorySlots[draggedFromSlot] = null;
                        } else {
                            storageInv[draggedFromSlot] = null;
                        }
                    }
                    
                    updateStorageDisplay();
                    updateInventoryDisplay();
                } else if (draggedFromType === 'backpack' && currentBackpack) {
                    // Drag from backpack  inventory slot
                    const contents = currentBackpack.userData.backpackContents || [];
                    const item = contents[draggedFromSlot];
                    if (!item || item.count <= 0) return;
                    const actual = Math.min(moveCount, item.count);
                    if (inventory[item.name] === undefined) inventory[item.name] = 0;
                    inventory[item.name] += actual;
                    item.count -= actual;
                    if (item.count <= 0) contents[draggedFromSlot] = null;
                    checkBackpackEmpty(currentBackpack);
                    updateBackpackDisplay();
                    updateInventoryDisplay();
                    updateUI();
                } else {
                    if (draggedFromType === 'inventory') {
                        const srcTotal = getInvSlotCount(draggedFromSlot);
                        const destItem = inventorySlots[dropSlotIndex];
                        
                        if (destItem === draggedItem) {
                            // Dropping on same item: merge if split, otherwise just keep slot
                            if (inventorySlotCounts[draggedFromSlot] !== null || inventorySlotCounts[dropSlotIndex] !== null) {
                                // Merge split stacks into destination
                                const srcCount = getInvSlotCount(draggedFromSlot);
                                const dstCount = getInvSlotCount(dropSlotIndex);
                                inventorySlotCounts[dropSlotIndex] = dstCount + srcCount;
                                inventorySlotCounts[draggedFromSlot] = null;
                                inventorySlots[draggedFromSlot] = null;
                            } else {
                                // Same item, no split tracking  just rearrange slot pointers
                                const temp = inventorySlots[dropSlotIndex];
                                inventorySlots[dropSlotIndex] = draggedItem;
                                inventorySlots[draggedFromSlot] = temp;
                            }
                        } else if (!destItem) {
                            if (draggedCtrl && srcTotal > 1) {
                                // SPLIT: move half to empty destination slot
                                const half = Math.max(1, Math.floor(srcTotal / 2));
                                inventorySlotCounts[draggedFromSlot] = srcTotal - half;
                                inventorySlots[dropSlotIndex] = draggedItem;
                                inventorySlotCounts[dropSlotIndex] = half;
                                // Note: inventory[draggedItem] total stays the same  split is visual only
                            } else {
                                // Full move to empty slot
                                inventorySlots[dropSlotIndex] = draggedItem;
                                inventorySlotCounts[dropSlotIndex] = inventorySlotCounts[draggedFromSlot]; // carry split count
                                inventorySlots[draggedFromSlot] = null;
                                inventorySlotCounts[draggedFromSlot] = null;
                            }
                        } else if (!draggedCtrl) {
                            // Full swap with a different item
                            const temp = inventorySlots[dropSlotIndex];
                            const tempCount = inventorySlotCounts[dropSlotIndex];
                            inventorySlots[dropSlotIndex] = draggedItem;
                            inventorySlotCounts[dropSlotIndex] = inventorySlotCounts[draggedFromSlot];
                            inventorySlots[draggedFromSlot] = temp;
                            inventorySlotCounts[draggedFromSlot] = tempCount;
                        }
                        // ctrl+drag onto different item  do nothing (can't split onto occupied slot)
                    } else if (draggedFromType === 'hotbar') {
                        const temp = inventorySlots[dropSlotIndex];
                        inventorySlots[dropSlotIndex] = draggedItem;
                        inventorySlotCounts[dropSlotIndex] = null;
                        hotbar[draggedFromSlot].item = temp;
                    }
                    updateInventoryDisplay();
                    updateHotbar();
                }
            }
            // Handle dropping on hotbar slot
            else if (dropSlotType === 'hotbar') {
                if (draggedFromType === 'storage' && currentStorageBox) {
                    const storageInv = currentStorageBox.userData.storageInventory;
                    const storageItem = storageInv[draggedFromSlot];
                    if (!storageItem) return;
                    const actual = Math.min(moveCount, storageItem.count);
                    
                    if (!inventory[storageItem.name]) inventory[storageItem.name] = 0;
                    inventory[storageItem.name] += actual;
                    hotbar[dropSlotIndex].item = storageItem.name;
                    storageItem.count -= actual;
                    if (storageItem.count <= 0) storageInv[draggedFromSlot] = null;
                    
                    updateStorageDisplay();
                    updateHotbar();
                } else {
                    if (draggedFromType === 'inventory') {
                        const temp = hotbar[dropSlotIndex].item;
                        hotbar[dropSlotIndex].item = draggedItem;
                        inventorySlots[draggedFromSlot] = temp;
                    } else if (draggedFromType === 'hotbar') {
                        const temp = hotbar[dropSlotIndex].item;
                        hotbar[dropSlotIndex].item = draggedItem;
                        hotbar[draggedFromSlot].item = temp;
                    }
                    updateInventoryDisplay();
                    updateHotbar();
                }
            }
            playInventoryMoveSound();
        }
        
        // Helper: remove fuel from a station and return it to an inventory/hotbar/storage target
        function _returnFuelToSlot(stationType, amount, dropSlotType, dropSlotIndex) {
            const isF = stationType === 'furnace';
            const state = isF ? (currentFurnace && currentFurnace.userData.smeltingState)
                               : (currentCampfire && currentCampfire.userData.smeltingState);
            if (!state || !state.fuelItem || state.fuelCount <= 0) return false;
            const actual = Math.min(amount, state.fuelCount);
            if (actual <= 0) return false;
            const fuelName = state.fuelItem;
            
            if (dropSlotType === 'inventory') {
                if (!inventory[fuelName]) inventory[fuelName] = 0;
                inventory[fuelName] += actual;
                if (!inventorySlots.includes(fuelName)) {
                    const empty = inventorySlots.findIndex(s => s === null);
                    if (empty !== -1) inventorySlots[empty] = fuelName;
                }
                clearSplitCounts(fuelName);
                updateInventoryDisplay();
            } else if (dropSlotType === 'hotbar') {
                if (!inventory[fuelName]) inventory[fuelName] = 0;
                inventory[fuelName] += actual;
                hotbar[dropSlotIndex].item = fuelName;
                updateHotbar();
            } else if (dropSlotType === 'storage' && currentStorageBox) {
                const storageInv = currentStorageBox.userData.storageInventory;
                let placed = false;
                for (let i = 0; i < storageInv.length; i++) {
                    if (storageInv[i] && storageInv[i].name === fuelName) { storageInv[i].count += actual; placed = true; break; }
                }
                if (!placed) {
                    for (let i = 0; i < storageInv.length; i++) {
                        if (!storageInv[i]) { storageInv[i] = { name: fuelName, count: actual }; placed = true; break; }
                    }
                }
                updateStorageDisplay();
            }
            
            state.fuelCount -= actual;
            if (state.fuelCount <= 0) { state.fuelCount = 0; state.fuelItem = null; }
            updateSmeltingDisplay(stationType);
            return true;
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('.drag-over').forEach(el => {
                el.classList.remove('drag-over');
            });
            draggedItem = null;
            draggedFromSlot = null;
            draggedFromType = null;
            draggedCtrl = false;
            draggedCount = 0;
        }
        
        function updateInventoryUI() {
            // Sync new items into empty slots
            for (let itemName in inventory) {
                if (inventory[itemName] > 0) {
                    const slotsForItem = inventorySlots.map((s, i) => i).filter(i => inventorySlots[i] === itemName);
                    const inHotbar = hotbar.some(slot => slot.item === itemName);
                    if (slotsForItem.length === 0 && !inHotbar) {
                        // No slot yet  place in first empty slot, consolidate any split counts
                        clearSplitCounts(itemName);
                        const emptyIndex = inventorySlots.findIndex(slot => slot === null);
                        if (emptyIndex !== -1) {
                            inventorySlots[emptyIndex] = itemName;
                        }
                    } else if (slotsForItem.length > 0) {
                        // Item already has slots. Check if counts are tracked and total has changed
                        const tracked = slotsForItem.filter(i => inventorySlotCounts[i] !== null);
                        if (tracked.length > 0) {
                            const trackedTotal = tracked.reduce((s, i) => s + inventorySlotCounts[i], 0);
                            const untrackedSlots = slotsForItem.filter(i => inventorySlotCounts[i] === null);
                            if (trackedTotal > inventory[itemName]) {
                                // Items were removed: scale down proportionally
                                const scale = inventory[itemName] / trackedTotal;
                                let remaining = inventory[itemName];
                                tracked.forEach((idx, j) => {
                                    if (j === tracked.length - 1) {
                                        inventorySlotCounts[idx] = remaining;
                                    } else {
                                        const newCount = Math.floor(inventorySlotCounts[idx] * scale);
                                        inventorySlotCounts[idx] = newCount;
                                        remaining -= newCount;
                                    }
                                    if (inventorySlotCounts[idx] <= 0) {
                                        inventorySlotCounts[idx] = null;
                                        inventorySlots[idx] = null;
                                    }
                                });
                            } else if (trackedTotal < inventory[itemName] && untrackedSlots.length === 0) {
                                // Items were added and no untracked slot  consolidate all into first slot (clear split)
                                clearSplitCounts(itemName);
                                // Remove duplicate slots, keep only first
                                for (let j = 1; j < slotsForItem.length; j++) {
                                    inventorySlots[slotsForItem[j]] = null;
                                }
                            }
                        }
                    }
                }
            }
            
            if (document.getElementById('inventory-panel').style.display === 'block') {
                updateInventoryDisplay();
            }
        }
        
        // Make inventory draggable \ufffd header + all edge handles
        let isDraggingInventory = false;
        let inventoryOffset = { x: 0, y: 0 };

        function startInventoryDrag(e) {
            isDraggingInventory = true;
            const panel = document.getElementById('inventory-panel');
            const rect = panel.getBoundingClientRect();
            panel.style.transform = 'none';
            panel.style.left = rect.left + 'px';
            panel.style.top  = rect.top  + 'px';
            inventoryOffset.x = e.clientX - rect.left;
            inventoryOffset.y = e.clientY - rect.top;
            e.preventDefault();
        }

        document.getElementById('inventory-header').addEventListener('mousedown', startInventoryDrag);
        document.querySelectorAll('#inventory-panel .drag-edge').forEach(el => {
            el.addEventListener('mousedown', startInventoryDrag);
        });
        
        document.getElementById('close-inventory').addEventListener('click', toggleInventory);
        document.getElementById('close-storage').addEventListener('click', closeStorageBox);
        document.getElementById('close-planter').addEventListener('click', closePlanterBox);
        document.getElementById('close-backpack').addEventListener('click', closeBackpack);
        
        // Make storage panel draggable
        let isDraggingStorage = false;
        let storageOffset = { x: 0, y: 0 };
        
        document.getElementById('storage-header').addEventListener('mousedown', (e) => {
            isDraggingStorage = true;
            const panel = document.getElementById('storage-panel');
            const rect = panel.getBoundingClientRect();
            storageOffset.x = e.clientX - rect.left;
            storageOffset.y = e.clientY - rect.top;
        });

        // Planter panel drag
        let isDraggingPlanter = false;
        let planterOffset = { x: 0, y: 0 };
        document.getElementById('planter-header').addEventListener('mousedown', (e) => {
            isDraggingPlanter = true;
            const panel = document.getElementById('planter-panel');
            const rect = panel.getBoundingClientRect();
            planterOffset.x = e.clientX - rect.left;
            planterOffset.y = e.clientY - rect.top;
        });
        
        document.addEventListener('mousemove', (e) => {
            if (isDraggingInventory) {
                const panel = document.getElementById('inventory-panel');
                panel.style.left = (e.clientX - inventoryOffset.x) + 'px';
                panel.style.top = (e.clientY - inventoryOffset.y) + 'px';
                panel.style.transform = 'none';
            }
            if (isDraggingStorage) {
                const panel = document.getElementById('storage-panel');
                panel.style.left = (e.clientX - storageOffset.x) + 'px';
                panel.style.top = (e.clientY - storageOffset.y) + 'px';
                panel.style.transform = 'none';
            }
            if (isDraggingPlanter) {
                const panel = document.getElementById('planter-panel');
                panel.style.left = (e.clientX - planterOffset.x) + 'px';
                panel.style.top = (e.clientY - planterOffset.y) + 'px';
                panel.style.transform = 'none';
            }
        });
        
        document.addEventListener('mouseup', () => {
            isDraggingInventory = false;
            isDraggingStorage = false;
            isDraggingPlanter = false;
        });
        
        // Armor slot event listeners for unequipping
        document.querySelectorAll('.armor-slot').forEach(slot => {
            slot.addEventListener('click', () => {
                const slotName = slot.dataset.slot;
                if (armorSlots[slotName]) {
                    unequipArmor(slotName);
                }
            });
        });
        
        function updateHotbar() {
            const hotbarEl = document.getElementById('hotbar');
            hotbarEl.innerHTML = '';
            
            hotbar.forEach((slot, index) => {
                const slotEl = document.createElement('div');
                slotEl.className = 'hotbar-slot' + (index === selectedHotbarSlot ? ' selected' : '');
                slotEl.dataset.hotbarIndex = index;
                slotEl.dataset.slotIndex = index;
                slotEl.dataset.slotType = 'hotbar';
                
                let itemIcon = '';
                let itemCount = '';
                
                if (slot.item && inventory[slot.item] > 0) {
                    itemIcon = getItemIcon(slot.item);
                    itemCount = inventory[slot.item];
                    slotEl.dataset.itemName = slot.item;
                    slotEl.draggable = true;
                } else if (slot.item && inventory[slot.item] === 0) {
                    // Clear slot if item count is 0
                    slot.item = null;
                }
                
                slotEl.innerHTML = `
                    <div class="hotbar-slot-number">${index + 1}</div>
                    <div class="hotbar-slot-icon">${itemIcon}</div>
                    <div class="hotbar-slot-count">${itemCount}</div>
                `;
                
                // Hover to show item name
                slotEl.addEventListener('mouseenter', () => {
                    if (slot.item) {
                        showHotbarTooltip(slot.item);
                    }
                });
                
                slotEl.addEventListener('mouseleave', () => {
                    hideHotbarTooltip();
                });
                
                // Allow dragging and dropping
                slotEl.addEventListener('dragstart', handleDragStart);
                slotEl.addEventListener('dragover', handleDragOver);
                slotEl.addEventListener('drop', handleDrop);
                slotEl.addEventListener('dragleave', handleDragLeave);
                slotEl.addEventListener('dragend', handleDragEnd);
                
                slotEl.onclick = () => {
                    selectedHotbarSlot = index;
                    updateHotbar();
                    updateHeldItem();
                };
                
                // Right click to remove from hotbar
                slotEl.oncontextmenu = (e) => {
                    e.preventDefault();
                    if (slot.item) {
                        showMessage(`Removed ${slot.item} from hotbar`);
                        slot.item = null;
                        updateHotbar();
                    }
                };
                
                hotbarEl.appendChild(slotEl);
            });
        }
        
        function showHotbarTooltip(itemName) {
            const tooltip = document.getElementById('hotbar-tooltip');
            
            // Get formatted display name
            const formattedName = getItemDisplayName(itemName);
            
            // Get item icon
            const icon = getItemIcon(itemName);
            
            tooltip.textContent = `${icon} ${formattedName}`;
            tooltip.classList.add('visible');
        }
        
        function hideHotbarTooltip() {
            const tooltip = document.getElementById('hotbar-tooltip');
            tooltip.classList.remove('visible');
        }
        
        function showMessage(text) {
            const msg = document.getElementById('message');
            msg.textContent = text;
            msg.style.display = 'block';
            setTimeout(() => {
                msg.style.display = 'none';
            }, 3000);
        }
        
        // ===== MINIMAP =====
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        minimapCanvas.width = 180;
        minimapCanvas.height = 180;
        
        function updateMinimap() {
            minimapCtx.fillStyle = 'rgba(40, 90, 30, 0.9)';
            minimapCtx.fillRect(0, 0, 180, 180);
            
            const scale = 1.5;
            const centerX = 90;
            const centerY = 90;
            
            // Draw trees
            minimapCtx.fillStyle = 'rgba(0, 100, 0, 0.7)';
            trees.forEach(tree => {
                const x = centerX + (tree.position.x - camera.position.x) * scale;
                const y = centerY + (tree.position.z - camera.position.z) * scale;
                if (x >= 0 && x <= 180 && y >= 0 && y <= 180) {
                    minimapCtx.beginPath();
                    minimapCtx.arc(x, y, 3, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
            });
            
            // Draw rocks
            minimapCtx.fillStyle = 'rgba(128, 128, 128, 0.7)';
            rocks.forEach(rock => {
                const x = centerX + (rock.position.x - camera.position.x) * scale;
                const y = centerY + (rock.position.z - camera.position.z) * scale;
                if (x >= 0 && x <= 180 && y >= 0 && y <= 180) {
                    minimapCtx.fillRect(x - 2, y - 2, 4, 4);
                }
            });
            
            // Draw enemies
            minimapCtx.fillStyle = 'rgba(255, 0, 0, 0.9)';
            enemies.forEach(enemy => {
                const x = centerX + (enemy.position.x - camera.position.x) * scale;
                const y = centerY + (enemy.position.z - camera.position.z) * scale;
                if (x >= 0 && x <= 180 && y >= 0 && y <= 180) {
                    minimapCtx.beginPath();
                    minimapCtx.arc(x, y, 4, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
            });
            
            // Draw death backpack markers
            deathBackpacks.forEach(bp => {
                const mx = centerX + (bp.userData.deathPos.x - camera.position.x) * scale;
                const my = centerY + (bp.userData.deathPos.z - camera.position.z) * scale;
                if (mx >= 4 && mx <= 176 && my >= 4 && my <= 176) {
                    minimapCtx.strokeStyle = 'rgba(255, 90, 20, 0.95)';
                    minimapCtx.lineWidth = 2;
                    minimapCtx.beginPath();
                    minimapCtx.arc(mx, my, 7, 0, Math.PI * 2);
                    minimapCtx.stroke();
                    minimapCtx.font = '11px sans-serif';
                    minimapCtx.textAlign = 'center';
                    minimapCtx.textBaseline = 'middle';
                    minimapCtx.fillText('', mx, my);
                }
            });

            // Draw player
            minimapCtx.fillStyle = 'rgba(52, 152, 219, 1)';
            minimapCtx.beginPath();
            minimapCtx.arc(centerX, centerY, 5, 0, Math.PI * 2);
            minimapCtx.fill();
            
            // Draw direction indicator
            minimapCtx.strokeStyle = 'white';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.moveTo(centerX, centerY);
            const angle = camera.rotation.y;
            minimapCtx.lineTo(
                centerX + Math.sin(angle) * 10,
                centerY + Math.cos(angle) * 10
            );
            minimapCtx.stroke();
        }
        
        // ===== DEATH BACKPACK SYSTEM =====
        const deathBackpacks = [];
        let currentBackpack  = null;

        function createBackpackModel() {
            const bp = new THREE.Group();
            const fabricMat = new THREE.MeshStandardMaterial({ color: 0x3d2a18, roughness: 0.95, metalness: 0.0 });
            const strapMat  = new THREE.MeshStandardMaterial({ color: 0x251810, roughness: 0.9,  metalness: 0.0 });
            const buckMat   = new THREE.MeshStandardMaterial({ color: 0x8a7a3a, roughness: 0.35, metalness: 0.75 });
            const pocketMat = new THREE.MeshStandardMaterial({ color: 0x2e1e0e, roughness: 0.95, metalness: 0.0 });

            // Main body
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.65, 0.28), fabricMat);
            body.position.set(0, 0.40, 0); body.castShadow = true; bp.add(body);

            // Top flap
            const flap = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.12, 0.30), fabricMat);
            flap.position.set(0, 0.76, 0); flap.castShadow = true; bp.add(flap);

            // Front pocket
            const pocket = new THREE.Mesh(new THREE.BoxGeometry(0.44, 0.30, 0.09), pocketMat);
            pocket.position.set(0, 0.28, 0.185); pocket.castShadow = true; bp.add(pocket);

            // Pocket zipper strip
            const zip = new THREE.Mesh(new THREE.BoxGeometry(0.46, 0.022, 0.022), buckMat);
            zip.position.set(0, 0.44, 0.19); bp.add(zip);

            // Shoulder straps
            [-0.20, 0.20].forEach(sx => {
                const strap = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.55, 0.05), strapMat);
                strap.position.set(sx, 0.38, -0.12); strap.rotation.x = 0.18; bp.add(strap);
            });

            // Side compression straps
            [-1, 1].forEach(side => {
                const cs = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, 0.30), strapMat);
                cs.position.set(side * 0.30, 0.38, 0.0); bp.add(cs);
                const bk = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.055, 0.04), buckMat);
                bk.position.set(side * 0.30, 0.38, 0.15); bp.add(bk);
            });

            // Top carry handle
            const handle = new THREE.Mesh(
                new THREE.TorusGeometry(0.075, 0.018, 8, 12, Math.PI), strapMat);
            handle.rotation.x = Math.PI / 2;
            handle.position.set(0, 0.84, 0.0); bp.add(handle);

            // Soul orb  glows to show the pack has contents
            const orbMat = new THREE.MeshBasicMaterial({ color: 0xff2200, transparent: true, opacity: 0.85 });
            const orb = new THREE.Mesh(new THREE.SphereGeometry(0.065, 10, 10), orbMat);
            orb.position.set(0, 0.28, 0.245); bp.add(orb);
            bp.userData.orb = orb;

            // Point light
            const glow = new THREE.PointLight(0xff3300, 0.8, 4.0);
            glow.position.set(0, 0.4, 0.2); bp.add(glow);
            bp.userData.glowLight = glow;

            bp.userData.isDeathBackpack = true;
            return bp;
        }

        function spawnDeathBackpack() {
            const contents = [];

            // Capture entire inventory
            for (const [name, count] of Object.entries(inventory)) {
                if (count > 0) { contents.push({ name, count }); inventory[name] = 0; }
            }
            // Clear hotbar slot references
            hotbar.forEach(slot => { if (slot.item) slot.item = null; });
            // Capture armor slots
            for (const [slot, item] of Object.entries(armorSlots)) {
                if (item) { contents.push({ name: item, count: 1 }); armorSlots[slot] = null; }
            }

            if (contents.length === 0) return;

            const bp = createBackpackModel();
            bp.position.set(
                camera.position.x + (Math.random() - 0.5) * 0.6,
                0,
                camera.position.z + (Math.random() - 0.5) * 0.6
            );
            bp.rotation.y = Math.random() * Math.PI * 2;
            bp.userData.backpackContents = contents;
            bp.userData.deathPos = { x: bp.position.x, z: bp.position.z };
            scene.add(bp);
            deathBackpacks.push(bp);
            updateUI();
            updateHotbar();
        }

        function updateDeathBackpacks() {
            if (deathBackpacks.length === 0) return;
            const t = performance.now() * 0.003;
            for (const bp of deathBackpacks) {
                if (bp.userData.orb) {
                    bp.userData.orb.material.opacity = 0.5 + Math.sin(t * 2.2) * 0.35;
                    bp.userData.orb.scale.setScalar(0.88 + Math.sin(t * 2.2) * 0.14);
                }
                if (bp.userData.glowLight) {
                    bp.userData.glowLight.intensity = 0.4 + Math.sin(t * 2.2) * 0.35;
                }
            }
        }

        function openBackpack(bp) {
            currentBackpack = bp;
            const panel = document.getElementById('backpack-panel');
            panel.style.display = 'block';
            const invPanel = document.getElementById('inventory-panel');
            positionInventoryRight(invPanel);
            invPanel.style.display = 'block';
            uiOpen();
            updateBackpackDisplay();
            updateInventoryDisplay();
        }

        function closeBackpack() {
            closeAllUI();
        }

        function updateBackpackDisplay() {
            if (!currentBackpack) return;
            const grid = document.getElementById('backpack-grid');
            grid.innerHTML = '';
            const contents = currentBackpack.userData.backpackContents || [];
            contents.forEach((itemData, i) => {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                slot.dataset.slotIndex = i;
                slot.dataset.slotType = 'backpack';
                if (itemData && itemData.name && itemData.count > 0) {
                    const icon = itemIcons[itemData.name] || '';
                    slot.innerHTML = `<div class="inventory-slot-icon">${icon}</div><div class="inventory-slot-name">${itemData.name}</div><div class="inventory-slot-count">${itemData.count}</div>`;
                    slot.dataset.itemName = itemData.name;
                    slot.draggable = true;
                    slot.addEventListener('click', ev => { if (ev.ctrlKey) takeFromBackpack(i); });
                    slot.title = 'Ctrl+click to take all';
                } else {
                    slot.innerHTML = '<div class="inventory-slot-empty">+</div>';
                }
                slot.addEventListener('dragstart', handleDragStart);
                slot.addEventListener('dragover',  handleDragOver);
                slot.addEventListener('drop',       handleDrop);
                slot.addEventListener('dragend',    handleDragEnd);
                slot.addEventListener('dragleave',  handleDragLeave);
                grid.appendChild(slot);
            });
        }

        function takeFromBackpack(slotIndex) {
            if (!currentBackpack) return;
            const contents = currentBackpack.userData.backpackContents;
            const item = contents[slotIndex];
            if (!item || item.count <= 0) return;
            if (inventory[item.name] !== undefined) inventory[item.name] += item.count;
            else inventory[item.name] = item.count;
            contents[slotIndex] = null;
            updateUI();
            updateBackpackDisplay();
            checkBackpackEmpty(currentBackpack);
        }

        function checkBackpackEmpty(bp) {
            const contents = bp.userData.backpackContents || [];
            if (!contents.some(c => c && c.count > 0)) {
                if (currentBackpack === bp) closeBackpack();
                scene.remove(bp);
                const idx = deathBackpacks.indexOf(bp);
                if (idx > -1) deathBackpacks.splice(idx, 1);
            }
        }

        // ===== DEATH & RESPAWN =====
        function die() {
            isDead = true;
            document.getElementById('death-screen').style.display = 'flex';
            document.getElementById('survival-time').textContent = day;

            // Release pointer lock so cursor is free on the death screen
            uiOpen();

            // Stop all creature sounds
            stopAllCoyoteSounds();

            // Drop death backpack with all player items
            spawnDeathBackpack();
            
            // Create death camera
            deathCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
            deathCamera.position.copy(camera.position);
            deathCamera.position.y += 10;
            deathCamera.lookAt(camera.position);
        }
        
        function respawn() {
            isDead = false;
            health = 100;
            hunger = 100;
            thirst = 100;
            stamina = 100;
            day = 1;
            time = 6;
            gameTime = 0;
            
            // Respawn at spawn point
            camera.position.set(spawnPoint.x, spawnPoint.y, spawnPoint.z);
            camera.rotation.set(0, 0, 0);
            
            document.getElementById('death-screen').style.display = 'none';
            deathCamera = null;
            
            // Re-acquire pointer lock and resume game input
            uiClose();
            updateUI();
        }
        window.respawn = respawn;
        
        // ===== LOADING =====
        function setLoadingProgress(pct, label) {
            document.getElementById('loadingProgress').style.width = Math.min(100, pct) + '%';
            if (label) document.getElementById('loading-status').textContent = label;
        }
        function finishLoading() {
            setLoadingProgress(100, 'Ready!');
            setTimeout(() => {
                document.getElementById('loadingScreen').classList.add('hidden');
                // Show click-to-play overlay  browsers require a user gesture before
                // AudioContext can run and before requestPointerLock() will succeed.
                // This single click satisfies both requirements cleanly.
                showClickToPlay();
            }, 350);
        }

        // Shared overlay helpers
        const _menuBtnCSS = [
            'display:block','width:260px','padding:16px 0','margin:10px 0',
            'font-size:20px','font-weight:700','letter-spacing:2px','color:#fff',
            'background:transparent','border:2px solid rgba(255,255,255,0.25)',
            'border-radius:10px','cursor:pointer','text-transform:uppercase'
        ].join(';');

        function showClickToPlay() {
            const overlay = document.createElement('div');
            overlay.id = 'crust-main-overlay';
            overlay.style.cssText = [
                'position:fixed','inset:0','z-index:99999',
                'display:flex','flex-direction:column',
                'align-items:center','justify-content:center',
                'background:rgba(0,0,0,0.82)',
                'font-family:Segoe UI,sans-serif','cursor:pointer'
            ].join(';');

            overlay.innerHTML = `
                <style>
                    @keyframes ctpPulse{0%,100%{opacity:0.45}50%{opacity:1}}
                    #crust-main-overlay button:hover{
                        background:rgba(255,255,255,0.12)!important;
                        border-color:rgba(255,255,255,0.6)!important;
                    }
                </style>
                <div style="font-size:52px;font-weight:900;color:#fff;letter-spacing:8px;
                            text-shadow:0 0 40px rgba(255,255,255,0.3);margin-bottom:24px;">CRUST</div>
                <div id="ctp-label" style="font-size:20px;color:rgba(255,255,255,0.7);
                            letter-spacing:3px;animation:ctpPulse 1.6s ease-in-out infinite;">
                    CLICK TO PLAY
                </div>
            `;

            // First click: unlock AudioContext, start music, reveal main menu buttons
            overlay.addEventListener('click', () => {
                audioContext.resume().then(() => { startTheme(); }).catch(() => {});
                _hasUserGesture = true;
                _showMainMenuButtons(overlay);
            }, { once: true });

            document.body.appendChild(overlay);
        }

        function _showMainMenuButtons(overlay) {
            overlay.style.cursor = 'default';
            const label = document.getElementById('ctp-label');
            if (label) label.remove();

            const menu = document.createElement('div');
            menu.id = 'crust-menu-buttons';
            menu.style.cssText = 'display:flex;flex-direction:column;align-items:center;margin-top:10px;';
            menu.innerHTML = `
                <button id="menu-new-game" style="${_menuBtnCSS}">&#127757; New Game</button>
                <button id="menu-load-game" style="${_menuBtnCSS}">&#128194; Load Game</button>
                <button id="menu-options"   style="${_menuBtnCSS}">&#9881;&#65039; Options</button>
            `;
            overlay.appendChild(menu);

            document.getElementById('menu-new-game').addEventListener('click', (e) => {
                e.stopPropagation();
                _enterGame(overlay, false);
            });
            document.getElementById('menu-load-game').addEventListener('click', (e) => {
                e.stopPropagation();
                _enterGame(overlay, true);
            });
            document.getElementById('menu-options').addEventListener('click', (e) => {
                e.stopPropagation();
                overlay.style.display = 'none';
                document.getElementById('settings-menu').style.display = 'block';
                document.getElementById('settings-menu').dataset.calledFromMenu = '1';
            });
        }

        function _enterGame(overlay, loadSave) {
            stopTheme();
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume().catch(() => {});
            }
            startAmbientSounds();
            console.log('\u{1F333} Ambient sounds started');
            if (loadSave) loadGame();
            try {
                const req = renderer.domElement.requestPointerLock();
                if (req && typeof req.catch === 'function') req.catch(() => {});
            } catch(e) {}
            overlay.remove();
        }

        // Also resume AudioContext on any subsequent user interaction
        // (e.g. after alt-tab, the browser may re-suspend it)
        ['click','keydown','pointerdown'].forEach(evt => {
            document.addEventListener(evt, () => {
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().catch(() => {});
                }
            }, { passive: true });
        });
        
        // ===== WINDOW RESIZE =====
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // ===== RAIN SYSTEM =====
        let isRaining = false;
        let rainParticles = null;
        let rainGainNode = null;
        let rainNoiseSource = null;
        let rainScheduleTimer = null;

        let _rainAudioBuffer = null;
        let _eatAudioBuffer = null;
        // Preload eat sound
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/eat.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _eatAudioBuffer = buf; console.log('Eat sound loaded OK'); })
            .catch(e => { console.error('Eat sound fetch error:', e); });

        function playEatSound() {
            if (!_eatAudioBuffer) { console.log('Eat buffer not ready yet'); return; }
            const src = audioContext.createBufferSource();
            src.buffer = _eatAudioBuffer;
            const gain = audioContext.createGain();
            gain.gain.value = volumeSettings.sfx !== undefined ? volumeSettings.sfx : 1.0;
            src.connect(gain);
            gain.connect(audioContext.destination);
            src.start();
        }

        let _plantAudioBuffer = null;
        // Preload plant sound
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/plant.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => { _plantAudioBuffer = buf; console.log('Plant sound loaded OK'); })
            .catch(e => { console.error('Plant sound fetch error:', e); });

        function playPlantSound() {
            if (!_plantAudioBuffer) { console.log('Plant buffer not ready yet'); return; }
            const src = audioContext.createBufferSource();
            src.buffer = _plantAudioBuffer;
            const gain = audioContext.createGain();
            gain.gain.value = volumeSettings.sfx !== undefined ? volumeSettings.sfx : 1.0;
            src.connect(gain);
            gain.connect(audioContext.destination);
            src.start();
        }

        // Preload rain sound
        fetch('https://raw.githubusercontent.com/Jam110uk/Crust-Sounds/main/Rain.mp3')
            .then(r => r.arrayBuffer())
            .then(ab => audioContext.decodeAudioData(ab))
            .then(buf => {
                _rainAudioBuffer = buf;
                console.log('Rain sound loaded OK');
                // If rain already started before the buffer was ready, set up audio now
                if (isRaining && !rainGainNode) {
                    buildRainAudio();
                    if (rainGainNode) {
                        rainGainNode.gain.setValueAtTime(0.001, audioContext.currentTime);
                        rainGainNode.gain.exponentialRampToValueAtTime(
                            volumeSettings.rain,
                            audioContext.currentTime + 4
                        );
                    }
                }
            })
            .catch(e => { console.error('Rain sound fetch error:', e); });

        function buildRainAudio() {
            if (!_rainAudioBuffer) { console.log('Rain buffer not ready yet  will start audio when loaded'); return; }
            rainNoiseSource = audioContext.createBufferSource();
            rainNoiseSource.buffer = _rainAudioBuffer;
            rainNoiseSource.loop = true;
            rainGainNode = audioContext.createGain();
            rainGainNode.gain.value = 0;
            rainNoiseSource.connect(rainGainNode);
            rainGainNode.connect(audioContext.destination);
            rainNoiseSource.start();
        }
        
        // Roof drip sound - for when player is under cover
        function playRoofDripSound() {
            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            osc.type = 'sine';
            const freq = 600 + Math.random() * 400; // Higher pitched than regular drips
            osc.frequency.setValueAtTime(freq, now);
            osc.frequency.exponentialRampToValueAtTime(freq * 0.3, now + 0.1);
            const dg = audioContext.createGain();
            dg.gain.setValueAtTime(volumeSettings.ambient * 0.03, now); // Louder than regular drips
            dg.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
            osc.connect(dg); 
            dg.connect(audioContext.destination);
            osc.start(now); 
            osc.stop(now + 0.15);
        }
        
        // Trigger a lightning strike with sound and visual
        function triggerLightning() {
            if (!isRaining) return;
            
            // Set lightning to active
            lightningActive = true;
            lightningStartTime = Date.now();
            lightningDuration = 1200; // 1.2 second total duration for fade in and out
            
            // Play thunder sound AFTER lightning (simulate light traveling faster than sound)
            // Random delay between 0.3-3 seconds to simulate different distances (sometimes close, sometimes far)
            const thunderDelay = 300 + Math.random() * 2700;
            setTimeout(() => {
                playThunderSound();
            }, thunderDelay);
            
            // Schedule next lightning strike
            if (isRaining) {
                scheduleLightning();
            }
        }
        
        // Schedule next lightning strike during rain
        function scheduleLightning() {
            if (window.lightningTimer) {
                clearTimeout(window.lightningTimer);
            }
            
            // Random delay between 5-25 seconds for next lightning (more variation)
            const delay = 5000 + Math.random() * 20000;
            window.lightningTimer = setTimeout(() => {
                if (isRaining) {
                    triggerLightning();
                }
            }, delay);
        }

        function startRain() {
            if (isRaining) return;
            isRaining = true;
            // Schedule planter watering after a short delay (seeds need some rain time)
            setTimeout(() => {
                if (isRaining) waterAllPlanters();
            }, 8000);

            // --- Visual rain: use LineSegments so each drop is a short vertical streak ---
            const rainCount = 2500;
            const linePositions = new Float32Array(rainCount * 6); // 2 verts per line
            for (let i = 0; i < rainCount; i++) {
                const rx = (Math.random() - 0.5) * 100;
                const ry = Math.random() * 35 + 2;
                const rz = (Math.random() - 0.5) * 100;
                const streak = 0.55; // length of each raindrop streak
                const drift  = 0.18; // horizontal wind drift per streak
                linePositions[i * 6 + 0] = rx;
                linePositions[i * 6 + 1] = ry;
                linePositions[i * 6 + 2] = rz;
                linePositions[i * 6 + 3] = rx - drift;
                linePositions[i * 6 + 4] = ry - streak;
                linePositions[i * 6 + 5] = rz;
            }
            const rainGeo = new THREE.BufferGeometry();
            rainGeo.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
            const rainMat = new THREE.LineBasicMaterial({
                color: 0xaaddff,
                transparent: true,
                opacity: 0, // Start invisible
            });
            rainParticles = new THREE.LineSegments(rainGeo, rainMat);
            rainParticles.frustumCulled = false; // positions update each frame relative to camera
            rainParticles.userData.targetOpacity = 0.75;
            rainParticles.userData.startTime = Date.now();
            rainParticles.userData.fadeDuration = 4000;
            scene.add(rainParticles);

            // --- Audio ---
            buildRainAudio();
            if (!rainGainNode) return; // buffer not ready yet  will retry when loaded
            rainGainNode.gain.setValueAtTime(0.001, audioContext.currentTime);
            rainGainNode.gain.exponentialRampToValueAtTime(
                volumeSettings.rain,
                audioContext.currentTime + 4
            );

            // Wind gets louder during rain - increase by additional 20%
            if (ambientWindGain) {
                const currentWind = ambientWindGain.gain.value;
                ambientWindGain.gain.cancelScheduledValues(audioContext.currentTime);
                ambientWindGain.gain.setValueAtTime(currentWind, audioContext.currentTime);
                ambientWindGain.gain.exponentialRampToValueAtTime(
                    volumeSettings.ambient * 0.175 * 1.2,
                    audioContext.currentTime + 4
                );
            }
            
            // Start lightning strikes during rain
            scheduleLightning();
            
            // Cloud color transition is now handled in updateClouds() function
        }

        function stopRain() {
            if (!isRaining) return;
            isRaining = false; // This will stop new drip sounds from scheduling
            // Reset planter watering flags so next rain event can water again
            resetPlanterWaterFlags();

            if (rainGainNode) {
                // Use exponential ramp for smoother fade (avoids choppy linear fade)
                const currentGain = rainGainNode.gain.value;
                rainGainNode.gain.cancelScheduledValues(audioContext.currentTime);
                rainGainNode.gain.setValueAtTime(currentGain, audioContext.currentTime);
                rainGainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 5);
                setTimeout(() => {
                    if (rainNoiseSource) { try { rainNoiseSource.stop(); } catch(e){} rainNoiseSource = null; }
                    rainGainNode = null;
                }, 5500);
            }

            if (rainParticles) {
                // Mark for fade out
                rainParticles.userData.isFadingOut = true;
                rainParticles.userData.fadeStartTime = Date.now();
                rainParticles.userData.fadeOutDuration = 5000; // 5 seconds to fade out
            }

            if (ambientWindGain) {
                const currentWind = ambientWindGain.gain.value;
                ambientWindGain.gain.cancelScheduledValues(audioContext.currentTime);
                ambientWindGain.gain.setValueAtTime(currentWind, audioContext.currentTime);
                ambientWindGain.gain.exponentialRampToValueAtTime(
                    Math.max(0.001, volumeSettings.ambient * 0.175 * 0.4),
                    audioContext.currentTime + 5
                );
            }
            
            // Stop lightning strikes
            if (window.lightningTimer) {
                clearTimeout(window.lightningTimer);
                window.lightningTimer = null;
            }
            
            // Sky and cloud color restoration is now handled automatically by the animation loop
        }

        function updateRain() {
            if (!rainParticles) return;
            
            const now = Date.now();
            
            // Handle opacity transitions
            if (rainParticles.userData.isFadingOut) {
                // Fading out
                const elapsed = now - rainParticles.userData.fadeStartTime;
                const progress = Math.min(elapsed / rainParticles.userData.fadeOutDuration, 1);
                const opacity = rainParticles.userData.targetOpacity * (1 - progress);
                rainParticles.material.opacity = Math.max(0, opacity);
                
                // Remove when fully faded
                if (progress >= 1) {
                    scene.remove(rainParticles);
                    rainParticles = null;
                    return;
                }
            } else if (isRaining) {
                // Fading in
                const elapsed = now - rainParticles.userData.startTime;
                const progress = Math.min(elapsed / rainParticles.userData.fadeDuration, 1);
                const opacity = rainParticles.userData.targetOpacity * progress;
                rainParticles.material.opacity = opacity;
            }
            
            // Update particle positions
            const pos = rainParticles.geometry.attributes.position;
            const dropSpeed = 0.45;
            const windDrift = 0.05;
            const streak    = 0.55;
            const driftLen  = 0.18;

            // Cache ceiling/floor buildings for performance (only check once per frame, not per particle)
            if (!rainParticles.userData.buildingCache || rainParticles.userData.buildingCacheFrame !== window._frameCount) {
                rainParticles.userData.buildingCache = buildings.filter(b => {
                    const bt = b.userData.buildingType;
                    return bt === 'ceiling' || bt === 'stone_ceiling' || bt === 'metal_ceiling' ||
                           bt === 'floor' || bt === 'stone_floor' || bt === 'metal_floor';
                }).map(b => ({
                    box: new THREE.Box3().setFromObject(b),
                    building: b
                }));
                rainParticles.userData.buildingCacheFrame = window._frameCount || 0;
            }
            
            const cachedBuildings = rainParticles.userData.buildingCache;
            
            // Check more particles per frame for better collision detection
            const particlesPerFrame = 500; // Increased from 100 to 500 for better coverage
            const startIndex = (rainParticles.userData.collisionOffset || 0);
            const endIndex = Math.min(startIndex + particlesPerFrame, pos.count / 2);

            for (let i = 0; i < pos.count / 2; i++) {
                // Top vertex of streak
                let tx = pos.getX(i * 2);
                let ty = pos.getY(i * 2);
                let tz = pos.getZ(i * 2);

                ty -= dropSpeed;
                tx -= windDrift;

                // Only check collision for subset of particles this frame
                let hitBuilding = false;
                if (i >= startIndex && i < endIndex && cachedBuildings.length > 0) {
                    // Quick spatial check: only test buildings near the particle
                    for (let cached of cachedBuildings) {
                        const box = cached.box;
                        
                        // Quick bounds check
                        if (tx >= box.min.x && tx <= box.max.x &&
                            tz >= box.min.z && tz <= box.max.z &&
                            ty <= box.max.y && ty >= box.min.y) {
                            hitBuilding = true;
                            break;
                        }
                    }
                }

                // If hit building or reached ground, respawn at top
                if (ty < 0 || hitBuilding) {
                    tx = camera.position.x + (Math.random() - 0.5) * 100;
                    ty = 35 + Math.random() * 5;
                    tz = camera.position.z + (Math.random() - 0.5) * 100;
                }

                pos.setXYZ(i * 2,     tx,           ty,          tz);
                pos.setXYZ(i * 2 + 1, tx - driftLen, ty - streak, tz);
            }
            
            // Update collision offset for next frame
            rainParticles.userData.collisionOffset = endIndex >= pos.count / 2 ? 0 : endIndex;
            
            pos.needsUpdate = true;

            // Adjust rain volume based on whether player is under a roof
            const underRoof = isPlayerUnderRoof();
            
            if (rainGainNode && isRaining && !rainParticles.userData.isFadingOut) {
                // Only adjust if rain is stable (not fading in or out)
                const elapsed = now - rainParticles.userData.startTime;
                const fadeInComplete = elapsed > rainParticles.userData.fadeDuration;
                
                if (fadeInComplete) {
                    // Base target volume
                    let target = volumeSettings.ambient * 0.65;
                    
                    // Reduce to 50% if under roof
                    if (underRoof) {
                        target *= 0.5;
                    }
                    
                    if (Math.abs(rainGainNode.gain.value - target) > 0.05) {
                        rainGainNode.gain.linearRampToValueAtTime(target, audioContext.currentTime + 0.5);
                    }
                }
            }
            
            // Play roof drip sounds when under roof
            if (underRoof && isRaining) {
                if (!window.roofDripTimer) window.roofDripTimer = 0;
                window.roofDripTimer += 0.016;
                
                if (window.roofDripTimer > 0.3 + Math.random() * 0.4) { // Random drips every 0.3-0.7 seconds
                    window.roofDripTimer = 0;
                    playRoofDripSound();
                }
            }
        }

        // ===== RAIN SPLASH PARTICLES =====
        const SPLASH_MAX = 180;
        const _splashPx   = new Float32Array(SPLASH_MAX);
        const _splashPy   = new Float32Array(SPLASH_MAX);
        const _splashPz   = new Float32Array(SPLASH_MAX);
        const _splashVx   = new Float32Array(SPLASH_MAX);
        const _splashVy   = new Float32Array(SPLASH_MAX);
        const _splashVz   = new Float32Array(SPLASH_MAX);
        const _splashLife = new Float32Array(SPLASH_MAX);
        const _splashMaxL = new Float32Array(SPLASH_MAX);

        const _splashGeo     = new THREE.BufferGeometry();
        const _splashPosArr  = new Float32Array(SPLASH_MAX * 3);
        const _splashPosAttr = new THREE.BufferAttribute(_splashPosArr, 3);
        _splashGeo.setAttribute('position', _splashPosAttr);

        const _splashMat = new THREE.PointsMaterial({
            color: 0xaaddff,
            size: 0.06,
            transparent: true,
            opacity: 0.7,
            depthWrite: false,
            sizeAttenuation: true,
        });
        const _splashPoints = new THREE.Points(_splashGeo, _splashMat);
        _splashPoints.frustumCulled = false;
        scene.add(_splashPoints);

        let _splashSpawnTimer = 0;

        function _spawnSplash(x, z) {
            // Find a dead slot
            for (let i = 0; i < SPLASH_MAX; i++) {
                if (_splashLife[i] > 0) continue;
                const life = 0.28 + Math.random() * 0.18;
                _splashLife[i] = life;
                _splashMaxL[i] = life;
                _splashPx[i]   = x;
                _splashPy[i]   = 0.03;
                _splashPz[i]   = z;
                // Burst outward in a random radial direction, slight upward kick
                const angle = Math.random() * Math.PI * 2;
                const spd   = 0.018 + Math.random() * 0.022;
                _splashVx[i] = Math.cos(angle) * spd;
                _splashVy[i] = 0.025 + Math.random() * 0.03;
                _splashVz[i] = Math.sin(angle) * spd;
                return;
            }
        }

        function updateSplashParticles() {
            if (!isRaining && _splashSpawnTimer === 0) {
                // Park all dead particles
                for (let i = 0; i < SPLASH_MAX; i++) {
                    if (_splashLife[i] <= 0) _splashPosAttr.setXYZ(i, 0, -9999, 0);
                }
            }

            // Spawn new splashes while raining
            if (isRaining) {
                _splashSpawnTimer += 0.016;
                // Spawn ~14 splashes/sec spread randomly around the player
                const spawnRate = 1 / 14;
                while (_splashSpawnTimer >= spawnRate) {
                    _splashSpawnTimer -= spawnRate;
                    const angle = Math.random() * Math.PI * 2;
                    const dist  = 2 + Math.random() * 18;
                    _spawnSplash(
                        camera.position.x + Math.cos(angle) * dist,
                        camera.position.z + Math.sin(angle) * dist
                    );
                }
            } else {
                _splashSpawnTimer = 0;
            }

            // Simulate live splash droplets
            for (let i = 0; i < SPLASH_MAX; i++) {
                if (_splashLife[i] <= 0) {
                    _splashPosAttr.setXYZ(i, 0, -9999, 0);
                    continue;
                }
                _splashLife[i] -= 0.016;
                _splashVy[i]   -= 0.004;   // gravity
                _splashPx[i]   += _splashVx[i];
                _splashPy[i]   += _splashVy[i];
                _splashPz[i]   += _splashVz[i];
                if (_splashPy[i] < 0.01) _splashPy[i] = 0.01;
                _splashPosAttr.setXYZ(i, _splashPx[i], _splashPy[i], _splashPz[i]);
            }
            _splashPosAttr.needsUpdate = true;

            // Fade opacity with rain state
            const anyAlive = _splashLife.some(l => l > 0);
            _splashMat.opacity = isRaining ? 0.7 : (anyAlive ? 0.4 : 0);
        }

        // ===== WET GROUND STATE =====
        let _wetness = 0;   // 0 = dry, 1 = fully soaked
        const _groundDryRoughness   = 0.92;
        const _groundWetRoughness   = 0.22;   // smooth and shiny when wet
        const _groundDryColor       = new THREE.Color(0xffffff);
        const _groundWetColor       = new THREE.Color(0x8899aa); // cool blue-grey, wet look

        function updateWetGround() {
            const wetTarget = isRaining ? 1.0 : 0.0;
            // Soak up fast, dry out slowly (~90s to fully dry)
            const speed = isRaining ? 0.008 : 0.0008;
            _wetness += (wetTarget - _wetness) * speed;
            _wetness  = Math.max(0, Math.min(1, _wetness));

            groundMaterial.roughness = _groundDryRoughness + (_groundWetRoughness - _groundDryRoughness) * _wetness;
            groundMaterial.color.lerpColors(_groundDryColor, _groundWetColor, _wetness * 0.45);
        }

        // Schedule rain randomly: starts 1\u20135 min after load, lasts 1\u20133 min, then 3\u20138 min gap
        function scheduleNextRain() {
            const delay = (60 + Math.random() * 240) * 1000;
            rainScheduleTimer = setTimeout(() => {
                // Never rain in the desert
                if (_biomeBlend > 0.4) {
                    scheduleNextRain(); // just reschedule \u2014 try again later
                    return;
                }
                startRain();
                const duration = (60 + Math.random() * 120) * 1000;
                setTimeout(() => {
                    stopRain();
                    scheduleNextRain();
                }, duration);
            }, delay);
        }
        scheduleNextRain();
        
        // Update lightning flash effect
        function updateLightning() {
            if (!lightningActive) {
                lightningLight.intensity = 0;
                return;
            }
            
            const elapsed = Date.now() - lightningStartTime;
            
            if (elapsed >= lightningDuration) {
                // Lightning finished
                lightningActive = false;
                lightningLight.intensity = 0;
                return;
            }
            
            // Calculate fade in and fade out
            const fadeInDuration = 300; // 300ms fade in
            const peakDuration = 600; // 600ms at peak brightness
            const fadeOutDuration = 300; // 300ms fade out
            
            let intensity = 0;
            
            if (elapsed < fadeInDuration) {
                // Fade in
                intensity = (elapsed / fadeInDuration) * 8.0;
            } else if (elapsed < fadeInDuration + peakDuration) {
                // Peak brightness - flicker slightly for realism
                intensity = 8.0 + (Math.random() - 0.5) * 1.0;
            } else {
                // Fade out
                const fadeOutElapsed = elapsed - fadeInDuration - peakDuration;
                intensity = 8.0 * (1 - (fadeOutElapsed / fadeOutDuration));
            }
            
            lightningLight.intensity = Math.max(0, intensity);
            
            // Move lightning position slightly for each flash
            if (elapsed < 100) {
                lightningLight.position.set(
                    camera.position.x + (Math.random() - 0.5) * 100,
                    50 + Math.random() * 30,
                    camera.position.z + (Math.random() - 0.5) * 100
                );
            }
        }

        // ===== ANIMATION LOOP =====
        let _frameTime = 0;
        let _minimapFrame = 0;
        let _grassFrame = 0;
        let _cloudFrame = 0;
        const _reusableBox = new THREE.Box3(); // reusable Box3 ? avoids per-frame allocation in physics

        // 
        // THIRD-PERSON CAMERA SYSTEM  (rewritten  reference-code pattern)
        // Player body position (tp_playerPos) is independent of camera.
        // Camera orbits around tp_playerPos using tp_orbitYaw/Pitch.
        // 
        let isThirdPerson = false;
        let playerModel   = null;
        let playerMixer   = null;
        let playerClock   = new THREE.Clock();
        let _tpAnim       = null;
        let _tpClips      = {};

        const tp_playerPos  = new THREE.Vector3();   // foot position in world space
        let   tp_orbitYaw   = 0;    // camera orbit horizontal angle
        let   tp_orbitPitch = 0.4;  // camera orbit vertical angle
        const TP_DIST       = 4.5;
        const TP_HEAD       = 1.5;  // head height above foot

        //  Load Player.glb on demand 
        async function _ensurePlayerModel() {
            if (playerModel) return;
            await _loadAssetGLB('Player.glb');
            const tmpl = _assetGLBCache['Player.glb'];
            if (!tmpl) { console.warn('Player.glb not found'); return; }

            // Clone for use in scene
            // Wrap in a container so we can position the container freely
            // without fighting the GLB's internal baked-in transforms
            const _glbInner = tmpl.clone(true);
            _glbFixTextures(_glbInner);
            _glbInner.traverse(c => {
                c.visible = true; c.frustumCulled = false;
                if (c.isMesh) { c.castShadow = true; c.receiveShadow = true; }
            });

            // Scale to ~1.8 m tall
            const bbox = new THREE.Box3().setFromObject(_glbInner);
            const h = bbox.max.y - bbox.min.y;
            if (h > 0) _glbInner.scale.setScalar(1.8 / h);

            // Ground the inner GLB so its feet sit at y=0 of the container
            _glbInner.updateMatrixWorld(true);
            const bbox2 = new THREE.Box3().setFromObject(_glbInner);
            if (isFinite(bbox2.min.y)) _glbInner.position.y -= bbox2.min.y;

            // playerModel is the container  position THIS in the world
            playerModel = new THREE.Group();
            playerModel.add(_glbInner);

            // Mixer drives the inner GLB's skeleton
            playerMixer = new THREE.AnimationMixer(_glbInner);
            const rawClips = tmpl.userData._animClips || {};  // clips stored on original template
            const clipNames = Object.keys(rawClips);
            console.log(' Player.glb clips:', clipNames.join(', ') || '(none)');

            // Map common animation name patterns
            function pickClip(...candidates) {
                for (const cand of candidates) {
                    for (const name of clipNames) {
                        if (name.includes(cand)) return rawClips[name];
                    }
                }
                return clipNames.length ? rawClips[clipNames[0]] : null;
            }
            _tpClips = {
                idle:  pickClip('idle', 'stand', 'bind'),
                walk:  pickClip('walk', 'jog', 'move'),
                run:   pickClip('run', 'sprint', 'walk'),
                jump:  pickClip('jump', 'fall', 'air'),
            };

            scene.add(playerModel);
            console.log(' Player model added to scene');
        }

        //  Play a named animation with crossfade 
        function _tpPlayAnim(name) {
            if (!playerMixer) return;
            const clip = _tpClips[name];
            if (!clip) return;
            const next = playerMixer.clipAction(clip);
            next.setLoop(THREE.LoopRepeat, Infinity);
            if (_tpAnim !== next) {
                next.reset();
                if (_tpAnim) _tpAnim.crossFadeTo(next, 0.15, true);
                next.play();
                _tpAnim = next;
            } else if (!next.isRunning()) {
                next.reset(); next.play();
            }
        }

        //  Toggle 3rd / 1st person 
        async function toggleThirdPerson() {
            isThirdPerson = !isThirdPerson;
            if (isThirdPerson) {
                // Seed player body position from 1st-person camera
                tp_playerPos.set(camera.position.x, camera.position.y - 1.7, camera.position.z);
                // Seed orbit yaw so camera stays behind player on entry
                tp_orbitYaw = camera.rotation.y;
                tp_orbitPitch = 0.4;
                await _ensurePlayerModel();
                heldItemGroup.visible = false;
                if (typeof fpsArmGroup !== 'undefined') fpsArmGroup.visible = false;
                showMessage(' Third-Person Camera (P to toggle)');
            } else {
                // Restore 1st-person camera to player body position
                camera.position.set(tp_playerPos.x, tp_playerPos.y + 1.7, tp_playerPos.z);
                camera.rotation.order = 'YXZ';
                camera.rotation.y = tp_orbitYaw;
                camera.rotation.x = 0;
                camera.rotation.z = 0;
                if (playerModel) playerModel.visible = false;
                heldItemGroup.visible = true;
                // Restore arm visibility based on currently held item
                if (typeof fpsArmGroup !== 'undefined' && currentHeldItem) {
                    const toolItems = ['axe','stone_axe','pickaxe','stone_pickaxe','sword','spear','bow','pistol','hammer','sharp_stone'];
                    fpsArmGroup.visible = toolItems.includes(currentHeldItem);
                }
                showMessage(' First-Person Camera');
            }
        }

        //  Update 3rd-person every frame (called from animate) 
        function updateThirdPerson() {
            if (!isThirdPerson || !playerModel) return;

            // 1. MOVE player body with WASD using tp_orbitYaw as look direction
            //    Camera sits at tp_orbitYaw BEHIND the player, so forward = -orbit direction.
            const fwdX = -Math.sin(tp_orbitYaw);
            const fwdZ = -Math.cos(tp_orbitYaw);
            const rgtX =  Math.cos(tp_orbitYaw);
            const rgtZ = -Math.sin(tp_orbitYaw);

            const isMoving = keys['w'] || keys['s'] || keys['a'] || keys['d'];
            const isSprinting = keys['shift'] && stamina > 10 && isMoving;
            const spd = isSprinting ? sprintSpeed : moveSpeed;

            // Stamina drain/regen
            if (isSprinting) {
                const drainMult = activeBuffs.veggi_stew ? 0.5 : 1.0;
                stamina = Math.max(5, stamina - staminaDrainRate * drainMult);
                if (stamina <= 5) staminaDepletedTime = Date.now();
            } else {
                const timeSinceDepletion = Date.now() - staminaDepletedTime;
                if (stamina > 5 || timeSinceDepletion > staminaRegenDelay)
                    stamina = Math.min(maxStamina, stamina + staminaRegenRate * 0.5);
            }

            let mdx = 0, mdz = 0;
            if (keys['w']) { mdx += fwdX; mdz += fwdZ; }
            if (keys['s']) { mdx -= fwdX; mdz -= fwdZ; }
            if (keys['a']) { mdx -= rgtX; mdz -= rgtZ; }
            if (keys['d']) { mdx += rgtX; mdz += rgtZ; }

            if (mdx !== 0 || mdz !== 0) {
                const len = Math.sqrt(mdx*mdx + mdz*mdz);
                const nx = tp_playerPos.x + (mdx/len) * spd;
                const nz = tp_playerPos.z + (mdz/len) * spd;
                const testPos = new THREE.Vector3(nx, tp_playerPos.y + 1.7, nz);
                if (!checkPlayerCollision(testPos)) {
                    tp_playerPos.x = nx;
                    tp_playerPos.z = nz;
                }
            }

            // Sync playerY for gravity/jump system, then write back
            playerY = tp_playerPos.y + 1.7;
            camera.position.y = playerY; // let the existing jump physics see this
            tp_playerPos.y = playerY - 1.7;

            // 2. PLACE player model at body position
            playerModel.position.copy(tp_playerPos);
            playerModel.visible = true;

            // Smoothly rotate model toward movement direction
            if (isMoving && (mdx !== 0 || mdz !== 0)) {
                const targetYaw = Math.atan2(mdx, mdz);
                const diff = ((targetYaw - playerModel.rotation.y) + Math.PI * 3) % (Math.PI * 2) - Math.PI;
                playerModel.rotation.y += diff * 0.18;
            }

            // 3. ANIMATIONS
            if (isJumping)     _tpPlayAnim('jump');
            else if (isMoving) _tpPlayAnim(isSprinting ? 'run' : 'walk');
            else               _tpPlayAnim('idle');
            if (playerMixer) playerMixer.update(playerClock.getDelta());

            // 4. ORBIT CAMERA around player head (same pattern as reference code)
            const headPos = new THREE.Vector3(
                tp_playerPos.x,
                tp_playerPos.y + TP_HEAD,
                tp_playerPos.z
            );
            const pitch = Math.max(-0.4, Math.min(0.8, tp_orbitPitch));
            const orbitX = Math.sin(tp_orbitYaw) * Math.cos(pitch) * TP_DIST;
            const orbitY = Math.sin(pitch) * TP_DIST;
            const orbitZ = Math.cos(tp_orbitYaw) * Math.cos(pitch) * TP_DIST;
            camera.position.set(
                headPos.x + orbitX,
                Math.max(headPos.y + orbitY, tp_playerPos.y + 0.3),
                headPos.z + orbitZ
            );
            camera.lookAt(headPos);
            // lookAt sets camera.rotation  that's fine, we use tp_orbitYaw/Pitch not camera.rotation
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Don't update game if paused
            if (!isPaused) {
                _frameTime = Date.now() * 0.001; // compute once, used by all update fns
                _minimapFrame++;
                _grassFrame++;
                _cloudFrame++;

                updateMovement();
                updateThirdPerson();
                updateDayNight();
                updateEnemies();
                updateAnimals();
                updateSquirrels();
                if (_grassFrame >= 2)  { updateGrass();   _grassFrame = 0;   } // 30 fps ? imperceptible on gentle sway
                if (_cloudFrame >= 3)  { updateClouds();  _cloudFrame = 0;   } // 20 fps ? clouds move slowly
                updateBerryRespawn();
                updateWildPlantRespawn();
                updateResourceRespawns();
                updateBuildPreview();
                updateTrees();
                if (_minimapFrame >= 6) { updateMinimap(); _minimapFrame = 0; } // 10 fps ? map doesn't need 60
                updateToolAnimation();
                // Tick FPS arm animation mixer
                if (_fpsArmMixer && fpsArmGroup.visible) _fpsArmMixer.update(_fpsArmClock.getDelta());
                // Hide arm in 3rd person
                if (isThirdPerson && fpsArmGroup.visible) fpsArmGroup.visible = false;
                updateArrows();
                updateBullets();
                updatePistolReload();
                updateSmelting();
                updateCookingProcess();
                updateRecycling(16.67);
                updateWaterCatcher(16.67);
                updateHealing();
                updateParticles();
                updateSandParticles();
                updateDeathBackpacks();
                tickBuffs();
                updateBuffHUD();
                updateScorpions();
                spawnScorpions();
                updateCoyotes();
                spawnCoyotes();
                _tickAutoSave(1/60); // autosave every 2 minutes
            }

            // Weather always updates regardless of pause so rain fades out correctly
            updateRain();
            updateLightning();
            updateSplashParticles();
            updateWetGround();
            
            const activeCamera = isDead && deathCamera ? deathCamera : camera;

            // --- Post-processing pipeline (wet ground screen effect) ---
            updateHeatHaze();
            if (_wetness > 0.005) {
                renderer.setRenderTarget(_hazeRT);
                renderer.render(scene, activeCamera);
                renderer.setRenderTarget(null);
                renderer.render(_hazeScene, _hazeCamera);
            } else {
                renderer.render(scene, activeCamera);
            }
        }
        
        // ===== SMELTING SLOT CLICK HANDLERS =====
        // Furnace multi-slot input click handlers
        for (let i = 0; i < 3; i++) {
            document.getElementById(`furnace-input-slot-${i}`).addEventListener('click', () => addToSmeltingSlot('furnace', 'input', i));
        }
        document.getElementById('furnace-fuel-slot').addEventListener('click', () => addToSmeltingSlot('furnace', 'fuel'));
        // Fuel drag-OUT: dragstart/dragend are handled by the global handleDragStart/handleDragEnd
        // which read data-slot-type="furnace-fuel" set by updateSmeltingDisplay
        document.getElementById('furnace-fuel-slot').addEventListener('dragstart', handleDragStart);
        document.getElementById('furnace-fuel-slot').addEventListener('dragend', handleDragEnd);
        document.getElementById('furnace-output-slot-0').addEventListener('click', () => addToSmeltingSlot('furnace', 'output', 0));
        document.getElementById('furnace-output-slot-1').addEventListener('click', () => addToSmeltingSlot('furnace', 'output', 1));
        document.getElementById('furnace-waste-slot').addEventListener('click', () => addToSmeltingSlot('furnace', 'waste'));

        // Campfire click handlers
        document.getElementById('campfire-input-slot').addEventListener('click', () => addToSmeltingSlot('campfire', 'input'));
        document.getElementById('campfire-fuel-slot').addEventListener('click', () => addToSmeltingSlot('campfire', 'fuel'));
        document.getElementById('campfire-fuel-slot').addEventListener('dragstart', handleDragStart);
        document.getElementById('campfire-fuel-slot').addEventListener('dragend', handleDragEnd);
        document.getElementById('campfire-output-slot').addEventListener('click', () => addToSmeltingSlot('campfire', 'output'));
        document.getElementById('campfire-waste-slot').addEventListener('click', () => addToSmeltingSlot('campfire', 'waste'));

        // Drag-and-drop support for furnace input slots
        for (let i = 0; i < 3; i++) {
            const slotEl = document.getElementById(`furnace-input-slot-${i}`);
            slotEl.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                slotEl.classList.add('drag-over');
            });
            slotEl.addEventListener('dragleave', () => slotEl.classList.remove('drag-over'));
            slotEl.addEventListener('drop', (e) => {
                e.preventDefault();
                slotEl.classList.remove('drag-over');
                if (!draggedItem) return;
                if (!FURNACE_VALID_ORES.includes(draggedItem)) {
                    showMessage('\u26a0\ufe0f Only ores can be placed in the furnace!');
                    draggedItem = null; draggedFromSlot = null; draggedFromType = null; draggedCtrl = false;
                    return;
                }
                // Use draggedCount (half if ctrl was held)
                const amountToMove = draggedCount;
                const state = currentFurnace && currentFurnace.userData.smeltingState;
                if (state) {
                    const slotData = state.inputSlots[i];
                    if (slotData && slotData.item !== draggedItem) {
                        showMessage('\u26a0\ufe0f That slot already contains a different ore!');
                    } else {
                        if (!slotData) state.inputSlots[i] = { item: draggedItem, count: 0 };
                        state.inputSlots[i].count += amountToMove;
                        // Deduct from source
                        if (draggedFromType === 'inventory') {
                            inventory[draggedItem] = Math.max(0, (inventory[draggedItem] || 0) - amountToMove);
                            if (inventorySlotCounts[draggedFromSlot] !== null) {
                                inventorySlotCounts[draggedFromSlot] = Math.max(0, inventorySlotCounts[draggedFromSlot] - amountToMove);
                                if (inventorySlotCounts[draggedFromSlot] <= 0) { inventorySlotCounts[draggedFromSlot] = null; inventorySlots[draggedFromSlot] = null; }
                            } else if (inventory[draggedItem] <= 0) { inventorySlots[draggedFromSlot] = null; }
                        } else if (draggedFromType === 'hotbar') {
                            inventory[draggedItem] = Math.max(0, (inventory[draggedItem] || 0) - amountToMove);
                            if (inventory[draggedItem] <= 0) hotbar[draggedFromSlot].item = null;
                        }
                        updateSmeltingDisplay('furnace');
                    }
                }
                updateInventoryDisplay();
                updateHotbar();
                draggedItem = null; draggedFromSlot = null; draggedFromType = null; draggedCtrl = false; draggedCount = 0;
            });
        }

        // Drag-and-drop support for furnace FUEL slot
        (function() {
            const fuelSlot = document.getElementById('furnace-fuel-slot');
            fuelSlot.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                fuelSlot.classList.add('drag-over');
            });
            fuelSlot.addEventListener('dragleave', () => fuelSlot.classList.remove('drag-over'));
            fuelSlot.addEventListener('drop', (e) => {
                e.preventDefault();
                fuelSlot.classList.remove('drag-over');
                if (!draggedItem) return;
                const FURNACE_FUELS = ['wood', 'sticks'];
                if (!FURNACE_FUELS.includes(draggedItem)) {
                    showMessage(' Only wood or sticks can be used as fuel!');
                    draggedItem = null; draggedFromSlot = null; draggedFromType = null; draggedCtrl = false; draggedCount = 0;
                    return;
                }
                const amountToMove = draggedCount;
                const state = currentFurnace && currentFurnace.userData.smeltingState;
                if (state) {
                    if (state.fuelItem && state.fuelItem !== draggedItem) {
                        showMessage(' Remove existing fuel first!');
                    } else {
                        if (!state.fuelItem) state.fuelItem = draggedItem;
                        state.fuelCount += amountToMove;
                        if (draggedFromType === 'inventory') {
                            inventory[draggedItem] = Math.max(0, (inventory[draggedItem] || 0) - amountToMove);
                            if (inventorySlotCounts[draggedFromSlot] !== null) {
                                inventorySlotCounts[draggedFromSlot] = Math.max(0, inventorySlotCounts[draggedFromSlot] - amountToMove);
                                if (inventorySlotCounts[draggedFromSlot] <= 0) { inventorySlotCounts[draggedFromSlot] = null; inventorySlots[draggedFromSlot] = null; }
                            } else if (inventory[draggedItem] <= 0) { inventorySlots[draggedFromSlot] = null; }
                        } else if (draggedFromType === 'hotbar') {
                            inventory[draggedItem] = Math.max(0, (inventory[draggedItem] || 0) - amountToMove);
                            if (inventory[draggedItem] <= 0) hotbar[draggedFromSlot].item = null;
                        }
                        updateSmeltingDisplay('furnace');
                    }
                }
                updateInventoryDisplay();
                updateHotbar();
                draggedItem = null; draggedFromSlot = null; draggedFromType = null; draggedCtrl = false; draggedCount = 0;
            });
        })();

        // Drag-and-drop support for campfire FUEL slot
        (function() {
            const fuelSlot = document.getElementById('campfire-fuel-slot');
            fuelSlot.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                fuelSlot.classList.add('drag-over');
            });
            fuelSlot.addEventListener('dragleave', () => fuelSlot.classList.remove('drag-over'));
            fuelSlot.addEventListener('drop', (e) => {
                e.preventDefault();
                fuelSlot.classList.remove('drag-over');
                if (!draggedItem) return;
                const CAMPFIRE_FUELS = ['wood', 'sticks'];
                if (!CAMPFIRE_FUELS.includes(draggedItem)) {
                    showMessage(' Only wood or sticks can be used as fuel!');
                    draggedItem = null; draggedFromSlot = null; draggedFromType = null; draggedCtrl = false; draggedCount = 0;
                    return;
                }
                const amountToMove = draggedCount;
                const state = currentCampfire && currentCampfire.userData.smeltingState;
                if (state) {
                    if (state.fuelItem && state.fuelItem !== draggedItem) {
                        showMessage(' Remove existing fuel first!');
                    } else {
                        if (!state.fuelItem) state.fuelItem = draggedItem;
                        state.fuelCount += amountToMove;
                        if (draggedFromType === 'inventory') {
                            inventory[draggedItem] = Math.max(0, (inventory[draggedItem] || 0) - amountToMove);
                            if (inventorySlotCounts[draggedFromSlot] !== null) {
                                inventorySlotCounts[draggedFromSlot] = Math.max(0, inventorySlotCounts[draggedFromSlot] - amountToMove);
                                if (inventorySlotCounts[draggedFromSlot] <= 0) { inventorySlotCounts[draggedFromSlot] = null; inventorySlots[draggedFromSlot] = null; }
                            } else if (inventory[draggedItem] <= 0) { inventorySlots[draggedFromSlot] = null; }
                        } else if (draggedFromType === 'hotbar') {
                            inventory[draggedItem] = Math.max(0, (inventory[draggedItem] || 0) - amountToMove);
                            if (inventory[draggedItem] <= 0) hotbar[draggedFromSlot].item = null;
                        }
                        updateSmeltingDisplay('campfire');
                    }
                }
                updateInventoryDisplay();
                updateHotbar();
                draggedItem = null; draggedFromSlot = null; draggedFromType = null; draggedCtrl = false; draggedCount = 0;
            });
        })();

        // Drag-and-drop support for campfire input slot
        (function() {
            const cfSlot = document.getElementById('campfire-input-slot');
            cfSlot.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                cfSlot.classList.add('drag-over');
            });
            cfSlot.addEventListener('dragleave', () => cfSlot.classList.remove('drag-over'));
            cfSlot.addEventListener('drop', (e) => {
                e.preventDefault();
                cfSlot.classList.remove('drag-over');
                if (!draggedItem) return;
                if (!CAMPFIRE_VALID_FOODS.includes(draggedItem)) {
                    showMessage('\u26a0\ufe0f Only food items can be placed in the campfire!');
                    draggedItem = null; draggedFromSlot = null; draggedFromType = null; draggedCtrl = false;
                    return;
                }
                const amountToMove = draggedCount;
                const state = currentCampfire && currentCampfire.userData.smeltingState;
                if (state) {
                    if (state.inputItem && state.inputItem !== draggedItem) {
                        showMessage('\u26a0\ufe0f Remove existing food first!');
                    } else {
                        if (!state.inputItem) state.inputItem = draggedItem;
                        state.inputCount += amountToMove;
                        if (draggedFromType === 'inventory') {
                            inventory[draggedItem] = Math.max(0, (inventory[draggedItem] || 0) - amountToMove);
                            if (inventorySlotCounts[draggedFromSlot] !== null) {
                                inventorySlotCounts[draggedFromSlot] = Math.max(0, inventorySlotCounts[draggedFromSlot] - amountToMove);
                                if (inventorySlotCounts[draggedFromSlot] <= 0) { inventorySlotCounts[draggedFromSlot] = null; inventorySlots[draggedFromSlot] = null; }
                            } else if (inventory[draggedItem] <= 0) { inventorySlots[draggedFromSlot] = null; }
                        } else if (draggedFromType === 'hotbar') {
                            inventory[draggedItem] = Math.max(0, (inventory[draggedItem] || 0) - amountToMove);
                            if (inventory[draggedItem] <= 0) hotbar[draggedFromSlot].item = null;
                        }
                        updateSmeltingDisplay('campfire');
                    }
                }
                updateInventoryDisplay();
                updateHotbar();
                draggedItem = null; draggedFromSlot = null; draggedFromType = null; draggedCtrl = false; draggedCount = 0;
            });
        })();
        
        document.getElementById('close-furnace').addEventListener('click', closeFurnaceMenu);
        document.getElementById('close-campfire').addEventListener('click', closeCampfireMenu);
        document.getElementById('close-cooking-station').addEventListener('click', closeCookingStationMenu);

        // Cooking station click handlers
        for (let i = 0; i < 5; i++) {
            document.getElementById(`cs-input-${i}`).addEventListener('click', () => addToCookingSlot('input', i));
        }
        document.getElementById('cs-output-slot').addEventListener('click', () => addToCookingSlot('output', 0));
        document.getElementById('cs-waste-slot').addEventListener('click', () => addToCookingSlot('waste', 0));

        // Cook button
        document.getElementById('cs-cook-btn').addEventListener('click', () => {
            const station = currentCookingStation;
            if (!station || !station.userData.cookingState) return;
            const state = station.userData.cookingState;
            if (state.isProcessing) return;
            const recipe = _csMatchRecipe(state);
            if (!recipe) { showMessage(' No valid recipe in the cooking station!'); return; }
            state.isProcessing = true;
            state.progress = 0;
            state.currentRecipe = recipe;
            startCookingSound();
            showMessage(' Cooking started!');
            updateCookingStationDisplay();
        });

        // Drag-and-drop for cooking station input slots
        for (let i = 0; i < 5; i++) {
            (function(idx) {
                const el = document.getElementById(`cs-input-${idx}`);
                el.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; el.classList.add('drag-over'); });
                el.addEventListener('dragleave', () => el.classList.remove('drag-over'));
                el.addEventListener('drop', (e) => {
                    e.preventDefault(); el.classList.remove('drag-over');
                    if (!draggedItem) return;
                    _csDragDropToInputSlot(idx, draggedItem, draggedCount);
                    draggedItem = null; draggedFromSlot = null; draggedFromType = null; draggedCtrl = false; draggedCount = 0;
                });
            })(i);
        }
        document.getElementById('close-recycler').addEventListener('click', closeRecyclerMenu);
        
        // Well close & slot handlers (drag to inventory + click to collect)
        document.getElementById('close-water-catcher').addEventListener('click', closeWaterCatcherMenu);
        document.querySelectorAll('.wc-slot').forEach(slot => {
            // Click to collect (existing behaviour)
            slot.addEventListener('click', () => {
                const idx = parseInt(slot.getAttribute('data-wc-slot'));
                const slotData = waterCatcherState.outputSlots[idx];
                if (!slotData) return;
                inventory.water_bottle = (inventory.water_bottle || 0) + slotData.count;
                waterCatcherState.outputSlots[idx] = null;
                showMessage(` Collected ${slotData.count} water bottle(s)!`);
                updateInventoryDisplay();
                updateWaterCatcherDisplay();
                updateUI();
                updateHotbar();
            });

            // Drag start  set up as a water-catcher source
            slot.addEventListener('dragstart', (e) => {
                const idx = parseInt(slot.getAttribute('data-wc-slot'));
                const slotData = waterCatcherState.outputSlots[idx];
                if (!slotData) { e.preventDefault(); return; }
                draggedItem = slotData.item;
                draggedFromSlot = idx;
                draggedFromType = 'water-catcher';
                draggedCount = slotData.count;
                draggedCtrl = false;
                e.dataTransfer.effectAllowed = 'move';
                slot.classList.add('dragging');
            });
            slot.addEventListener('dragend', () => {
                slot.classList.remove('dragging');
                draggedItem = null; draggedFromSlot = null; draggedFromType = null; draggedCount = 0;
            });
        });

        // Patch handleDrop to handle 'water-catcher' source  inventory/hotbar
        const _origHandleDrop = handleDrop;
        handleDrop = function(e) {
            if (draggedFromType === 'water-catcher') {
                e.preventDefault();
                e.currentTarget.classList.remove('drag-over');
                const dropSlotType = e.currentTarget.dataset.slotType;
                const dropSlotIndex = parseInt(e.currentTarget.dataset.slotIndex);
                const idx = draggedFromSlot;
                const slotData = waterCatcherState.outputSlots[idx];
                if (!slotData) return;
                if (dropSlotType === 'inventory' || dropSlotType === 'hotbar') {
                    inventory[slotData.item] = (inventory[slotData.item] || 0) + slotData.count;
                    waterCatcherState.outputSlots[idx] = null;
                    if (dropSlotType === 'inventory') {
                        // Place into the dropped slot if empty, else auto-add
                        if (!inventorySlots[dropSlotIndex]) {
                            inventorySlots[dropSlotIndex] = slotData.item;
                        }
                    } else {
                        if (!hotbar[dropSlotIndex].item) hotbar[dropSlotIndex].item = slotData.item;
                    }
                    showMessage(` Collected ${slotData.count} water bottle(s)!`);
                    updateInventoryDisplay();
                    updateWaterCatcherDisplay();
                    updateUI();
                    updateHotbar();
                }
                draggedItem = null; draggedFromSlot = null; draggedFromType = null; draggedCount = 0;
                return;
            }
            _origHandleDrop.call(this, e);
        };
        document.getElementById('recycler-start-btn').addEventListener('click', startRecycling);
        
        // Recycler slot click handlers
        document.querySelectorAll('.recycler-slot').forEach(slot => {
            slot.addEventListener('click', () => {
                const slotType = slot.getAttribute('data-slot');
                const slotIndex = parseInt(slot.getAttribute('data-index'));
                addToRecyclerSlot(slotType, slotIndex);
            });
        });
        
        // ===== ADMIN MENU =====
        let isPaused = false;
        
        function openAdminMenu() {
            document.getElementById('admin-menu').style.display = 'block';
            uiOpen();
            populateAdminItems();
        }
        
        function closeAdminMenu() {
            closeAllUI();
        }
        
        function populateAdminItems() {
            const grid = document.getElementById('admin-items-grid');
            grid.innerHTML = '';
            
            // Auto-collect all items from various sources
            const allItems = new Set();
            
            // Add items from crafting recipes
            Object.keys(craftingRecipes).forEach(item => allItems.add(item));
            
            // Add items from workbench recipes
            Object.keys(workbenchRecipes).forEach(item => allItems.add(item));
            
            // Add items from building bench recipes
            Object.keys(buildingBenchRecipes).forEach(item => allItems.add(item));
            
            // Add items from furnace recipes
            Object.keys(furnaceRecipes).forEach(item => allItems.add(item));
            
            // Add items from buildingTypes
            Object.keys(buildingTypes).forEach(item => allItems.add(item));
            
            // Add base resources and items from inventory
            Object.keys(inventory).forEach(item => allItems.add(item));
            
            // Add any items that have icons but aren't in the above
            Object.keys(itemIcons).forEach(item => allItems.add(item));
            
            // Convert to array and sort for consistent ordering
            const adminItems = Array.from(allItems).sort();
            
            // Organize into categories for better display
            const categories = {
                'Resources': ['wood', 'stone', 'iron_ore', 'iron_ingot', 'coal', 'ash', 'sticks', 'fiber', 'cloth', 'berries', 'meat', 'cooked_meat', 'sulfur_ore', 'smelted_sulfur', 'gunpowder'],
                'Tools & Weapons': ['sharp_stone', 'axe', 'pickaxe', 'sword', 'spear', 'bow', 'arrows', 'pistol', 'pistol_ammo', 'building_hammer'],
                'Consumables': ['bandage', 'medkit'],
                'Seeds': ['pumpkin_seed','wheat_seed','cabbage_seed','cucumber_seed','potato_seed','carrot_seed','hemp_seed','corn_seed','mushroom_seed','red_berry_seed','black_berry_seed','strawberry_seed','tomato_seed'],
                'Produce': ['pumpkin','wheat','cabbage','cucumber','potato','carrot','hemp_fiber','corn','mushroom_crop','red_berries','black_berries','strawberry','tomato'],
                'Building Structures': ['wall', 'window_wall', 'floor', 'ceiling', 'ladder_ceiling', 'stairs', 'corner_stairs_left', 'corner_stairs_right', 'ladder', 'door_frame', 'door', 'single_door_wall', 'double_door_wall', 'double_door_frame'],
                'Building Objects': ['campfire', 'workbench', 'building_bench', 'sewing_table', 'furnace', 'recycler', 'water_catcher', 'storage_box', 'small_storage_box', 'storage_shelf', 'wall_shelf', 'sleeping_bag', 'planter_box', 'large_planter', 'cooking_station'],
                'Decorations': ['floor_rug_red', 'floor_rug_blue', 'floor_rug_green', 'curtain_red', 'curtain_blue', 'curtain_green', 'curtain_white', 'curtain_beige']
            };
            
            // Display items by category
            Object.entries(categories).forEach(([categoryName, categoryItems]) => {
                // Add category header
                const header = document.createElement('div');
                header.style.gridColumn = '1 / -1';
                header.style.fontSize = '14px';
                header.style.fontWeight = 'bold';
                header.style.color = '#fff';
                header.style.marginTop = '10px';
                header.style.marginBottom = '5px';
                header.style.borderBottom = '2px solid rgba(255,255,255,0.3)';
                header.style.paddingBottom = '5px';
                header.textContent = categoryName;
                grid.appendChild(header);
                
                // Add items in this category
                categoryItems.forEach(item => {
                    if (allItems.has(item)) {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'admin-item';
                        
                        // Get icon using helper function
                        let icon = getItemIcon(item);
                        let displayName = getItemDisplayName(item);
                        
                        itemDiv.innerHTML = `
                            <div class="admin-item-icon">${icon}</div>
                            <div class="admin-item-name">${displayName}</div>
                        `;
                        itemDiv.onclick = () => {
                            inventory[item] = (inventory[item] || 0) + 10;
                            showMessage(`+10 ${item}`);
                            updateUI();
                            updateHotbar();
                        };
                        grid.appendChild(itemDiv);
                    }
                });
            });
            
            // Add "Other Items" category for anything not categorized
            const categorizedItems = new Set();
            Object.values(categories).forEach(items => items.forEach(item => categorizedItems.add(item)));
            const uncategorizedItems = Array.from(allItems).filter(item => !categorizedItems.has(item)).sort();
            
            if (uncategorizedItems.length > 0) {
                const header = document.createElement('div');
                header.style.gridColumn = '1 / -1';
                header.style.fontSize = '14px';
                header.style.fontWeight = 'bold';
                header.style.color = '#fff';
                header.style.marginTop = '10px';
                header.style.marginBottom = '5px';
                header.style.borderBottom = '2px solid rgba(255,255,255,0.3)';
                header.style.paddingBottom = '5px';
                header.textContent = 'Other Items';
                grid.appendChild(header);
                
                uncategorizedItems.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'admin-item';
                    
                    let icon = getItemIcon(item);
                    let displayName = getItemDisplayName(item);
                    
                    itemDiv.innerHTML = `
                        <div class="admin-item-icon">${icon}</div>
                        <div class="admin-item-name">${displayName}</div>
                    `;
                    itemDiv.onclick = () => {
                        inventory[item] = (inventory[item] || 0) + 10;
                        showMessage(`+10 ${item}`);
                        updateUI();
                        updateHotbar();
                    };
                    grid.appendChild(itemDiv);
                });
            }
        }
        
        // ===== PAUSE MENU =====
        function togglePause() {
            isPaused = !isPaused;
            const pauseMenu = document.getElementById('pause-menu');
            
            if (isPaused) {
                pauseMenu.style.display = 'flex';
                uiOpen();
            } else {
                pauseMenu.style.display = 'none';
                uiClose();
            }
        }
        
        // ===== SAVE/LOAD SYSTEM =====
        // 
        // SAVE / LOAD   versioned, forward-compatible localStorage system
        // Key stays 'crustSaveData' forever.  The `saveVersion` field lets
        // loadGame() migrate older layouts so saves survive updates.
        // 
        const SAVE_KEY     = 'crustSaveData';
        const SAVE_VERSION = 3;          // bump this whenever the schema changes

        //  helpers 
        function _safeNum(val, fallback) {
            const n = Number(val);
            return (isFinite(n) ? n : fallback);
        }
        function _safeArr(val, fallback) { return Array.isArray(val) ? val : fallback; }
        function _safeObj(val, fallback) { return (val && typeof val === 'object' && !Array.isArray(val)) ? val : fallback; }

        // Migrate a raw parsed object up to the current SAVE_VERSION.
        // Add a new `case` whenever SAVE_VERSION is bumped.
        function _migrateSave(data) {
            let v = _safeNum(data.saveVersion, 1);

            if (v < 2) {
                // v1  v2: saveVersion field was called "version" (string "1.0")
                data.saveVersion = 2;
                data.gameTime    = data.gameTime ?? 0;
                data.stamina     = data.stamina  ?? 100;
                v = 2;
            }
            if (v < 3) {
                // v2  v3: armorSlots may be absent; waterCatcherState may be absent
                data.saveVersion     = 3;
                data.armorSlots      = data.armorSlots ?? {};
                data.waterCatcherState = data.waterCatcherState ?? { outputSlots: [], progress: 0 };
                v = 3;
            }
            // Future migrations go here:
            // if (v < 4) { ... }

            data.saveVersion = SAVE_VERSION;
            return data;
        }

        function _buildSaveData() {
            return {
                saveVersion: SAVE_VERSION,
                timestamp:   Date.now(),

                //  vitals 
                health,
                hunger,
                thirst,
                stamina,
                day,
                time,
                gameTime,

                //  player gear 
                inventory,
                hotbar,
                selectedHotbarSlot,
                armorSlots,

                //  equipment state 
                pistolState: { currentClip: pistolState.currentClip },
                recyclerState: {
                    inputSlots:    recyclerState.inputSlots  || [null,null,null,null,null],
                    outputSlots:   recyclerState.outputSlots || [null,null,null,null,null],
                    isProcessing:  recyclerState.isProcessing  || false,
                    currentSlot:   recyclerState.currentSlot   || 0,
                    progress:      recyclerState.progress       || 0,
                    isPaused:      recyclerState.isPaused       || false,
                    pauseProgress: recyclerState.pauseProgress  || 0
                },
                waterCatcherState: {
                    outputSlots: waterCatcherState.outputSlots || [],
                    progress:    waterCatcherState.progress    || 0
                },

                //  world 
                cameraPosition: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
                cameraRotation: { x: camera.rotation.x, y: camera.rotation.y },

                buildings: buildings.map(b => {
                    const ss = b.userData.smeltingState;
                    return {
                        type:            b.userData.buildingType,
                        position:        { x: b.position.x, y: b.position.y, z: b.position.z },
                        rotation:        { x: b.rotation.x, y: b.rotation.y, z: b.rotation.z },
                        isDoor:          b.userData.isDoor          || false,
                        isOpen:          b.userData.isOpen          || false,
                        initialRotation: b.userData.initialRotation || null,
                        hasCodeLock:     b.userData.hasCodeLock     || false,
                        codeLock:        b.userData.codeLock        || null,
                        smeltingState: ss ? {
                            inputSlots:      (ss.inputSlots  || []).map(s => s ? { item: s.item, count: s.count } : null),
                            currentInputSlot: ss.currentInputSlot || 0,
                            inputItem:       ss.inputItem   || null,
                            inputCount:      ss.inputCount  || 0,
                            fuelItem:        ss.fuelItem    || null,
                            fuelCount:       ss.fuelCount   || 0,
                            outputSlots:     (ss.outputSlots || []).map(s => ({ item: s.item, count: s.count || 0 })),
                            outputItem:      ss.outputItem  || null,
                            outputCount:     ss.outputCount || 0,
                            wasteCount:      ss.wasteCount  || 0,
                            progress:        ss.progress    || 0,
                            isProcessing:    ss.isProcessing || false
                        } : null,
                        storageInventory: b.userData.storageInventory ? [...b.userData.storageInventory] : null
                    };
                })
            };
        }

        //  autosave (every 2 minutes while game is running) 
        let _autoSaveTimer = 0;
        const AUTO_SAVE_INTERVAL = 120; // seconds

        function _tickAutoSave(dt) {
            if (isPaused) return;
            _autoSaveTimer += dt;
            if (_autoSaveTimer >= AUTO_SAVE_INTERVAL) {
                _autoSaveTimer = 0;
                try {
                    localStorage.setItem(SAVE_KEY, JSON.stringify(_buildSaveData()));
                    console.log(' Auto-saved');
                } catch(e) {
                    console.warn(' Auto-save failed:', e);
                }
            }
        }

        //  manual save 
        function saveGame() {
            const _showStatus = (msg, color, ms = 3000) => {
                const el = document.getElementById('save-status');
                if (!el) return;
                el.textContent  = msg;
                el.style.color  = color;
                setTimeout(() => { el.textContent = ''; }, ms);
            };

            try {
                const payload = JSON.stringify(_buildSaveData());
                localStorage.setItem(SAVE_KEY, payload);
                _autoSaveTimer = 0; // reset autosave clock after a manual save
                _showStatus(' Game saved!', '#2ecc71');
            } catch(e) {
                console.error('Save error:', e);
                _showStatus(' Save failed  storage may be full.', '#e74c3c');
            }
        }
        
        //  load 
        function loadGame() {
            const _showStatus = (msg, color, ms = 3000) => {
                const el = document.getElementById('save-status');
                if (!el) return;
                el.textContent  = msg;
                el.style.color  = color;
                setTimeout(() => { el.textContent = ''; }, ms);
            };

            const raw = localStorage.getItem(SAVE_KEY);
            if (!raw) {
                _showStatus(' No save data found!', '#e74c3c');
                return;
            }

            try {
                const data = _migrateSave(JSON.parse(raw));

                //  vitals (all guarded so new fields default safely) 
                health  = _safeNum(data.health,  100);
                hunger  = _safeNum(data.hunger,  100);
                thirst  = _safeNum(data.thirst,  100);
                stamina = _safeNum(data.stamina, 100);
                day     = _safeNum(data.day,       1);
                time    = _safeNum(data.time,      0);
                gameTime= _safeNum(data.gameTime,  0);

                //  inventory  only restore keys that exist in current game 
                if (_safeObj(data.inventory, null)) {
                    Object.keys(inventory).forEach(key => {
                        if (key in data.inventory) {
                            inventory[key] = _safeNum(data.inventory[key], 0);
                        }
                        // keys NOT in save stay at their default (0)  new items are safe
                    });
                }

                //  hotbar 
                if (Array.isArray(data.hotbar)) {
                    hotbar.forEach((slot, i) => {
                        const saved = data.hotbar[i];
                        slot.item = saved?.item ?? null;
                        slot.type = saved?.type ?? null;
                    });
                }
                selectedHotbarSlot = _safeNum(data.selectedHotbarSlot, 0);

                //  armor 
                if (_safeObj(data.armorSlots, null)) {
                    Object.keys(armorSlots).forEach(slot => {
                        armorSlots[slot] = data.armorSlots[slot] ?? null;
                    });
                }

                //  pistol 
                if (data.pistolState) {
                    pistolState.currentClip = _safeNum(data.pistolState.currentClip, pistolState.currentClip);
                }

                //  recycler 
                if (data.recyclerState) {
                    const rs = data.recyclerState;
                    recyclerState.inputSlots    = _safeArr(rs.inputSlots,  [null,null,null,null,null]);
                    recyclerState.outputSlots   = _safeArr(rs.outputSlots, [null,null,null,null,null]);
                    recyclerState.isProcessing  = rs.isProcessing  || false;
                    recyclerState.currentSlot   = _safeNum(rs.currentSlot,   0);
                    recyclerState.progress      = _safeNum(rs.progress,      0);
                    recyclerState.isPaused      = rs.isPaused      || false;
                    recyclerState.pauseProgress = _safeNum(rs.pauseProgress, 0);
                    if (recyclerState.isProcessing) startRecyclerSound();
                }

                //  water catcher 
                if (data.waterCatcherState) {
                    waterCatcherState.outputSlots = _safeArr(data.waterCatcherState.outputSlots, []);
                    waterCatcherState.progress    = _safeNum(data.waterCatcherState.progress, 0);
                }

                //  camera 
                if (data.cameraPosition) {
                    camera.position.set(
                        _safeNum(data.cameraPosition.x, 0),
                        _safeNum(data.cameraPosition.y, 2),
                        _safeNum(data.cameraPosition.z, 0)
                    );
                }
                if (data.cameraRotation) {
                    camera.rotation.x = _safeNum(data.cameraRotation.x, 0);
                    camera.rotation.y = _safeNum(data.cameraRotation.y, 0);
                }

                //  buildings 
                if (Array.isArray(data.buildings)) {
                    buildings.forEach(b => scene.remove(b));
                    buildings.length = 0;

                    data.buildings.forEach(bd => {
                        // Skip unknown building types gracefully (future-proofing)
                        if (!buildingTypes[bd.type]) {
                            console.warn(' Unknown building type in save (skipped):', bd.type);
                            return;
                        }

                        let building;
                        try { building = buildingTypes[bd.type].create(); }
                        catch(e) { console.warn(' Failed to create building:', bd.type, e); return; }

                        building.position.set(
                            _safeNum(bd.position?.x, 0),
                            _safeNum(bd.position?.y, 0),
                            _safeNum(bd.position?.z, 0)
                        );
                        building.rotation.set(
                            _safeNum(bd.rotation?.x, 0),
                            _safeNum(bd.rotation?.y, 0),
                            _safeNum(bd.rotation?.z, 0)
                        );
                        building.userData.type         = 'building';
                        building.userData.buildingType = bd.type;
                        building.userData.collisionBox = new THREE.Box3().setFromObject(building);

                        //  per-type flags 
                        const _restoreSmelt = (ss) => {
                            if (!ss || !building.userData.smeltingState) return;
                            const dst = building.userData.smeltingState;
                            if (Array.isArray(ss.inputSlots)) {
                                dst.inputSlots = ss.inputSlots.map(s => s ? { item: s.item, count: s.count } : null);
                            } else if (ss.inputItem) {
                                dst.inputSlots = dst.inputSlots || [];
                                dst.inputSlots[0] = { item: ss.inputItem, count: ss.inputCount || 0 };
                            }
                            dst.currentInputSlot = _safeNum(ss.currentInputSlot, 0);
                            dst.fuelItem   = ss.fuelItem  ?? null;
                            dst.fuelCount  = _safeNum(ss.fuelCount, 0);
                            if (Array.isArray(ss.outputSlots)) {
                                dst.outputSlots = ss.outputSlots.map(s => ({ item: s.item, count: _safeNum(s.count, 0) }));
                            } else if (ss.outputItem && ss.outputCount > 0) {
                                const oi = ss.outputItem === 'smelted_sulfur' ? 1 : 0;
                                if (dst.outputSlots && dst.outputSlots[oi]) dst.outputSlots[oi].count = ss.outputCount;
                            }
                            dst.wasteCount   = _safeNum(ss.wasteCount, 0);
                            dst.progress     = _safeNum(ss.progress, 0);
                            dst.isProcessing = ss.isProcessing || false;
                        };

                        if (bd.type === 'campfire') {
                            building.userData.isCampfire = true;
                            _restoreSmelt(bd.smeltingState);
                        } else if (bd.type === 'furnace') {
                            building.userData.isFurnace = true;
                            _restoreSmelt(bd.smeltingState);
                        } else if (bd.type === 'workbench')         { building.userData.isWorkbench    = true; }
                        else if (bd.type === 'building_bench')      { building.userData.isBuildingBench= true; }
                        else if (bd.type === 'sewing_table')        { building.userData.isSewingTable  = true; }
                        else if (bd.type === 'recycler')            { building.userData.isRecycler     = true; }
                        else if (bd.type === 'water_catcher')       { building.userData.isWaterCatcher = true; }
                        else if (bd.type === 'wall_shelf')          { building.userData.isWallShelf = true; }
                        else if (bd.type === 'planter')             { building.userData.isPlanter      = true; }
                        else if (bd.type === 'ladder')              { building.userData.isLadder       = true; }
                        else if (bd.type === 'ladder_ceiling')      { building.userData.isLadderCeiling= true; }
                        else if (bd.type === 'stairs' || bd.type === 'corner_stairs_left' || bd.type === 'corner_stairs_right') {
                            building.userData.isStairs = true;
                            if (bd.type !== 'stairs') building.userData.isCornerStairs = true;
                        }
                        else if (bd.type === 'storage_box' || bd.type === 'small_storage_box') {
                            building.userData.isStorageBox = true;
                            if (bd.type === 'small_storage_box') building.userData.isSmallStorage = true;
                            if (Array.isArray(bd.storageInventory)) building.userData.storageInventory = [...bd.storageInventory];
                        }
                        else if (bd.type === 'door') {
                            building.userData.isDoor           = true;
                            building.userData.isOpen           = bd.isOpen || false;
                            building.userData.initialRotation  = bd.initialRotation ?? bd.rotation?.y ?? 0;
                        }
                        else if (bd.type === 'single_door_wall') {
                            building.userData.isDoor     = true;
                            building.userData.isOpen     = bd.isOpen || false;
                            building.userData.doorType   = 'single';
                            if (building.userData.isOpen && building.userData.doorGroup)
                                building.userData.doorGroup.rotation.y = -Math.PI / 2;
                        }
                        else if (bd.type === 'double_door_wall') {
                            building.userData.isDoor   = true;
                            building.userData.isOpen   = bd.isOpen || false;
                            building.userData.doorType = 'double';
                            if (building.userData.isOpen) {
                                if (building.userData.leftDoorGroup)  building.userData.leftDoorGroup.rotation.y  = -Math.PI / 2;
                                if (building.userData.rightDoorGroup) building.userData.rightDoorGroup.rotation.y =  Math.PI / 2;
                            }
                        }
                        else if (bd.type === 'door_frame' || bd.type === 'double_door_frame') {
                            building.userData.isDoorFrame = true;
                        }

                        //  code lock 
                        if (bd.hasCodeLock && bd.codeLock) {
                            building.userData.hasCodeLock = true;
                            building.userData.codeLock    = bd.codeLock;
                            createCodeLockModel(building);
                        }

                        buildings.push(building);
                        scene.add(building);
                    });

                    // Re-link recycler status light if it was processing
                    if (recyclerState.isProcessing) {
                        const rec = buildings.find(b => b.userData.isRecycler);
                        if (rec) {
                            currentRecycler = rec;
                            if (rec.userData.statusLight) rec.userData.statusLight.visible = true;
                        }
                    }
                }

                updateUI();
                updateHotbar();
                updateHeldItem();

                const savedDate = new Date(data.timestamp).toLocaleTimeString();
                _showStatus(` Loaded! (saved at ${savedDate})`, '#2ecc71', 4000);

                // Close pause menu
                togglePause();

            } catch(err) {
                console.error('Load error:', err);
                _showStatus(' Error loading save  data may be corrupted.', '#e74c3c');
            }
        }
                
        // ===== EVENT LISTENERS FOR MENUS =====
        document.getElementById('close-admin').addEventListener('click', closeAdminMenu);

        document.getElementById('sync-icon-fallbacks').addEventListener('click', () => {
            // Escape helper
            function esc(str) {
                return [...str].map(c => {
                    const cp = c.codePointAt(0);
                    if (cp <= 0x7F) return c;
                    if (cp <= 0xFFFF) return '\\u' + cp.toString(16).padStart(4,'0');
                    const hi = Math.floor((cp - 0x10000) / 0x400) + 0xD800;
                    const lo = ((cp - 0x10000) % 0x400) + 0xDC00;
                    return '\\u' + hi.toString(16).padStart(4,'0') + '\\u' + lo.toString(16).padStart(4,'0');
                }).join('');
            }

            // 1. Merge all current itemIcons into _iconFallbacks in memory
            let updated = 0;
            for (const key in itemIcons) {
                const val = itemIcons[key];
                if (!val || val.includes('\ufffd') || val.trim() === '') continue;
                const escaped = esc(val);
                if (_iconFallbacks[key] !== escaped) {
                    _iconFallbacks[key] = escaped;
                    updated++;
                }
            }

            // 2. Rebuild the _iconFallbacks literal from the now-complete in-memory object
            const entries = Object.entries(_iconFallbacks)
                .map(([k, v]) => "            '" + k + "':'" + v + "'")
                .join(',\n');
            const newBlock = '        const _iconFallbacks = {\n' + entries + '\n        };';

            // 3. Find the script tag that contains _iconFallbacks and patch it in-place
            const scripts = document.querySelectorAll('script');
            let patched = false;
            for (const script of scripts) {
                if (!script.textContent.includes('const _iconFallbacks')) continue;
                const oldSrc = script.textContent;
                const newSrc = oldSrc.replace(
                    /const _iconFallbacks\s*=\s*\{[\s\S]*?\};/,
                    newBlock
                );
                if (newSrc !== oldSrc) {
                    // Replace script content in the DOM  survives Ctrl+S / FileSave
                    script.textContent = newSrc;
                    patched = true;
                }
                break;
            }

            // 4. Auto-download the patched page so it's saved immediately
            if (patched) {
                const blob = new Blob([document.documentElement.outerHTML], { type: 'text/html' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'Crust_v24_haze.html';
                a.click();
                URL.revokeObjectURL(a.href);
            }

            // 5. Show result in the output box
            const output = document.getElementById('icon-sync-output');
            const textarea = document.getElementById('icon-sync-text');
            output.style.display = 'block';

            if (!patched) {
                textarea.value = '\u274c Could not patch source  copy manually:\n\n' + newBlock;
            } else if (updated === 0) {
                textarea.value = '\u2705 All ' + Object.keys(_iconFallbacks).length + ' icons already in sync. No changes needed.';
            } else {
                textarea.value = '\u2705 Done! ' + updated + ' icon(s) added/updated in _iconFallbacks.\n\nThe updated file is downloading automatically.';
                console.log('\ud83d\udee1\ufe0f Icon fallbacks auto-patched: ' + updated + ' updated.');
            }
        });

        document.getElementById('icon-sync-copy').addEventListener('click', () => {
            const textarea = document.getElementById('icon-sync-text');
            textarea.select();
            document.execCommand('copy');
            const btn = document.getElementById('icon-sync-copy');
            btn.textContent = '\u2705 Copied!';
            setTimeout(() => { btn.textContent = '\ud83d\udccb Copy to Clipboard'; }, 1500);
        });
        
        // Set to day instantly
        document.getElementById('set-day').addEventListener('click', () => {
            time = 12; // Set to noon (12:00)
            timeIsPaused = false; // Unfreeze if it was frozen
            document.getElementById('freeze-time').textContent = '\u2744\ufe0f Freeze Time';
        });
        
        // Set to night instantly
        document.getElementById('set-night').addEventListener('click', () => {
            time = 0; // Set to midnight (00:00)
            timeIsPaused = false; // Unfreeze if it was frozen
            document.getElementById('freeze-time').textContent = '\u2744\ufe0f Freeze Time';
        });
        
        // Freeze/unfreeze time
        let timeIsPaused = false;
        let savedTime = 12;
        document.getElementById('freeze-time').addEventListener('click', () => {
            timeIsPaused = !timeIsPaused;
            if (timeIsPaused) {
                savedTime = time; // Save current time
                document.getElementById('freeze-time').textContent = '\u25b6\ufe0f Unfreeze Time';
            } else {
                time = savedTime; // Restore time and resume cycle
                document.getElementById('freeze-time').textContent = '\u2744\ufe0f Freeze Time';
            }
        });
        
        // Toggle rain on/off
        document.getElementById('toggle-rain').addEventListener('click', () => {
            if (isRaining) {
                stopRain();
                document.getElementById('toggle-rain').textContent = '\ud83c\udf27\ufe0f Toggle Rain (OFF)';
            } else {
                startRain();
                document.getElementById('toggle-rain').textContent = '\ud83c\udf27\ufe0f Toggle Rain (ON)';
            }
        });
        
        document.getElementById('resume-button').addEventListener('click', togglePause);
        document.getElementById('save-button').addEventListener('click', saveGame);
        document.getElementById('load-button').addEventListener('click', loadGame);
        document.getElementById('controls-button').addEventListener('click', () => {
            document.getElementById('instructions').style.display = 'block';
            document.getElementById('pause-menu').style.display = 'none';
        });
        document.getElementById('close-controls').addEventListener('click', () => {
            document.getElementById('instructions').style.display = 'none';
            document.getElementById('pause-menu').style.display = 'flex';
        });
        document.getElementById('settings-button').addEventListener('click', () => {
            document.getElementById('settings-menu').style.display = 'block';
            document.getElementById('pause-menu').style.display = 'none';
        });
        
        document.getElementById('close-settings').addEventListener('click', () => {
            const sm = document.getElementById('settings-menu');
            sm.style.display = 'none';
            // If settings was opened from the pre-game main menu, return there
            if (sm.dataset.calledFromMenu === '1') {
                sm.dataset.calledFromMenu = '';
                const menuOverlay = document.getElementById('crust-main-overlay');
                if (menuOverlay) menuOverlay.style.display = 'flex';
            } else {
                document.getElementById('pause-menu').style.display = 'flex';
            }
        });
        
        // Volume slider handlers
        // Save volume settings to localStorage
        function saveVolumeSettings() {
            localStorage.setItem('crustVolumeSettings', JSON.stringify({
                forest: volumeSettings.forest,
                wind: volumeSettings.wind,
                animals: volumeSettings.animals,
                enemies: volumeSettings.enemies,
                rain: volumeSettings.rain,
                footsteps: volumeSettings.footsteps
            }));
        }

        // Load saved volume settings
        (function loadVolumeSettings() {
            const saved = localStorage.getItem('crustVolumeSettings');
            if (!saved) return;
            try {
                const s = JSON.parse(saved);
                if (s.forest    !== undefined) { volumeSettings.forest    = s.forest;    document.getElementById('forest-volume').value    = Math.round(s.forest * 100);    document.getElementById('forest-value').textContent    = Math.round(s.forest * 100) + '%'; }
                if (s.wind      !== undefined) { volumeSettings.wind      = s.wind;      document.getElementById('wind-volume').value      = Math.round(s.wind * 100);      document.getElementById('wind-value').textContent      = Math.round(s.wind * 100) + '%'; }
                if (s.rain      !== undefined) { volumeSettings.rain      = s.rain;      document.getElementById('rain-volume').value      = Math.round(s.rain * 100);      document.getElementById('rain-value').textContent      = Math.round(s.rain * 100) + '%'; }
                if (s.animals   !== undefined) { volumeSettings.animals   = s.animals;   document.getElementById('animal-volume').value    = Math.round(s.animals * 100);   document.getElementById('animal-value').textContent    = Math.round(s.animals * 100) + '%'; }
                if (s.enemies   !== undefined) { volumeSettings.enemies   = s.enemies;   document.getElementById('enemy-volume').value     = Math.round(s.enemies * 100);   document.getElementById('enemy-value').textContent     = Math.round(s.enemies * 100) + '%'; }
                if (s.footsteps !== undefined) { volumeSettings.footsteps = s.footsteps; document.getElementById('footstep-volume').value  = Math.round(s.footsteps * 100); document.getElementById('footstep-value').textContent  = Math.round(s.footsteps * 100) + '%'; }
            } catch(e) {}
        })();

        document.getElementById('forest-volume').addEventListener('input', (e) => {
            const value = e.target.value;
            volumeSettings.forest = value / 100;
            document.getElementById('forest-value').textContent = value + '%';
            updateAmbientVolume();
            saveVolumeSettings();
        });

        document.getElementById('wind-volume').addEventListener('input', (e) => {
            const value = e.target.value;
            volumeSettings.wind = value / 100;
            document.getElementById('wind-value').textContent = value + '%';
            updateAmbientVolume();
            saveVolumeSettings();
        });
        
        document.getElementById('animal-volume').addEventListener('input', (e) => {
            const value = e.target.value;
            volumeSettings.animals = value / 100;
            document.getElementById('animal-value').textContent = value + '%';
            saveVolumeSettings();
        });
        
        document.getElementById('enemy-volume').addEventListener('input', (e) => {
            const value = e.target.value;
            volumeSettings.enemies = value / 100;
            document.getElementById('enemy-value').textContent = value + '%';
            saveVolumeSettings();
        });

        document.getElementById('footstep-volume').addEventListener('input', (e) => {
            const value = e.target.value;
            volumeSettings.footsteps = value / 100;
            document.getElementById('footstep-value').textContent = value + '%';
            saveVolumeSettings();
        });

        document.getElementById('rain-volume').addEventListener('input', (e) => {
            const value = e.target.value;
            volumeSettings.rain = value / 100;
            document.getElementById('rain-value').textContent = value + '%';
            if (rainGainNode && isRaining) rainGainNode.gain.setValueAtTime(volumeSettings.rain, audioContext.currentTime);
            saveVolumeSettings();
        });
        
        // Code lock UI event listeners
        document.querySelectorAll('.code-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const digit = btn.getAttribute('data-num');
                handleCodeEntry(digit);
            });
        });
        
        document.getElementById('code-clear').addEventListener('click', clearCode);
        document.getElementById('code-enter').addEventListener('click', submitCode);
        document.getElementById('code-cancel').addEventListener('click', closeCodeLockUI);
        
        // ===== INITIALIZATION =====
        // 
        // PERFORMANCE SYSTEM  Material Cache  Geometry Cache  Model Cache  Shader Compiler
        // 

        //  1. MATERIAL CACHE 
        // Every unique material is created ONCE and reused forever.
        // This is the #1 cause of placement stalls: each new MeshStandardMaterial
        // with unique params triggers a GLSL shader compile on the GPU (~20-80ms each).
        const _matCache = new Map();

        function cachedMat(params) {
            // Build a stable string key from the params object
            const key = JSON.stringify(params, (k, v) =>
                (v && v.isTexture) ? ('tex_' + (v.uuid || v.id)) : v
            );
            if (_matCache.has(key)) return _matCache.get(key);
            let mat;
            if (params._basic) {
                const p = Object.assign({}, params); delete p._basic;
                mat = new THREE.MeshBasicMaterial(p);
            } else {
                const p = Object.assign({}, params);
                mat = new THREE.MeshStandardMaterial(p);
            }
            _matCache.set(key, mat);
            return mat;
        }

        //  2. GEOMETRY CACHE 
        // Shared BufferGeometry instances  zero extra GPU memory per placement.
        const _geoCache = new Map();

        function cachedGeo(type, ...args) {
            const key = type + '|' + args.join(',');
            if (_geoCache.has(key)) return _geoCache.get(key);
            let geo;
            switch(type) {
                case 'Box':      geo = new THREE.BoxGeometry(...args); break;
                case 'Cylinder': geo = new THREE.CylinderGeometry(...args); break;
                case 'Sphere':   geo = new THREE.SphereGeometry(...args); break;
                case 'Plane':    geo = new THREE.PlaneGeometry(...args); break;
                case 'Torus':    geo = new THREE.TorusGeometry(...args); break;
                case 'Cone':     geo = new THREE.ConeGeometry(...args); break;
                case 'Dodeca':   geo = new THREE.DodecahedronGeometry(...args); break;
                default:         geo = new THREE.BoxGeometry(...args);
            }
            _geoCache.set(key, geo);
            return geo;
        }

        //  3. MODEL CACHE 
        // Stores one fully-built Group per placeable type.
        // Placement calls _cloneModel() which does clone(true)  this shares the
        // exact same geometry and material objects, so the GPU never recompiles.
        const _modelCache = new Map();

        function _tagUserDataRefs(group) {
            // Tag object refs in userData so they can be reconnected after clone
            // Also snapshot original material colours so upgrade/reset can restore them
            group.traverse(child => {
                if (child.userData._refKey) return;
                for (const [k, v] of Object.entries(group.userData)) {
                    if (v === child) {
                        child.userData._refKey = k;
                    }
                }
                if (child.isMesh && child.material) {
                    const mats = Array.isArray(child.material) ? child.material : [child.material];
                    mats.forEach(mat => {
                        if (mat && mat.userData._origColor === undefined) {
                            mat.userData._origColor      = mat.color ? mat.color.getHex() : 0xffffff;
                            mat.userData._origTransparent = mat.transparent;
                            mat.userData._origOpacity    = mat.opacity;
                        }
                    });
                }
            });
        }

        function _cloneModel(type) {
            if (!_modelCache.has(type)) return null;
            const src   = _modelCache.get(type);
            const clone = src.clone(true);

            // Copy primitive userData values
            for (const [k, v] of Object.entries(src.userData)) {
                if (v === null || typeof v !== 'object') clone.userData[k] = v;
            }

            // Reconnect object refs (lights, glows, mesh refs) by matching _refKey tags
            clone.traverse(child => {
                if (child.userData._refKey) {
                    clone.userData[child.userData._refKey] = child;
                }
            });

            // smeltingState must be a fresh instance per furnace/campfire
            if (typeof createSmeltingState === 'function') {
                if (src.userData._smeltMs) {
                    clone.userData.smeltingState = createSmeltingState(src.userData._smeltMs);
                }
            }
            return clone;
        }

        async function _buildAndCache(type) {
            if (_modelCache.has(type) || !buildingTypes[type]) return;
            try {
                const group = await buildingTypes[type].create();
                _tagUserDataRefs(group);
                _modelCache.set(type, group);
            } catch(e) {
                console.warn(`Model cache build failed for ${type}:`, e);
            }
        }

        //  4. SHADER COMPILER 
        // Forces the GPU to compile every shader variant BEFORE the player
        // can place anything, during the loading bar.
        // Builds a dummy offscreen scene with one mesh per cached material,
        // calls renderer.compile() which blocks until all GLSL programs are linked.
        function compileShaders() {
            if (_matCache.size === 0) return;
            console.log(` Compiling ${_matCache.size} shader variants...`);
            const dummyScene  = new THREE.Scene();
            const dummyGeo    = new THREE.BoxGeometry(0.01, 0.01, 0.01);
            for (const mat of _matCache.values()) {
                const mesh = new THREE.Mesh(dummyGeo, mat);
                mesh.position.set(0, -9999, 0); // far offscreen
                dummyScene.add(mesh);
            }
            try {
                renderer.compile(dummyScene, camera);
                console.log(` Shaders compiled  ${_matCache.size} programs ready`);
            } catch(e) {
                console.warn('Shader compile step failed (non-fatal):', e);
            }
            // Clean up dummy scene
            dummyScene.clear();
        }

        //  5. PREWARM 
        async function prewarmModels() {
            const types = [
                'workbench','campfire','furnace','cooking_station','building_bench','sewing_table',
                'sleeping_bag','storage_box','small_storage_box','storage_shelf','wall_shelf','recycler','water_catcher','planter_box','large_planter'
            ];
            const labels = {
                workbench:'Building workbench...', campfire:'Building campfire...',
                furnace:'Building furnace...', building_bench:'Building construction bench...',
                sewing_table:'Building sewing table...', sleeping_bag:'Building sleeping bag...',
                storage_box:'Building storage box...', small_storage_box:'Building small storage...',
                storage_shelf:'Building storage shelf...', wall_shelf:'Building wall shelf...', recycler:'Building recycler...', planter_box:'Building planter box...', large_planter:'Building large planter...'
            };
            const modelShare = 75;
            const total = types.length;
            console.log(' Pre-warming models...');
            for (let i = 0; i < types.length; i++) {
                const type = types[i];
                if (_modelCache.has(type) || !buildingTypes[type]) continue;
                setLoadingProgress(10 + Math.round((i / total) * modelShare), labels[type] || `Building ${type}...`);
                // Yield to let the progress bar repaint, then build synchronously
                await new Promise(r => setTimeout(r, 0));
                await _buildAndCache(type);
            }
            setLoadingProgress(88, 'Compiling shaders...');
            await new Promise(r => setTimeout(r, 0));
            compileShaders();
            console.log(' Pre-warm complete  placement will be instant');
        }

        //  6. PLACEMENT 
        // Returns a model instantly from cache (clone), or builds fresh if not cached.
        async function buildAndPlaceModel(type) {
            const cached = _cloneModel(type);
            if (cached) return cached;
            // Not cached yet  build fresh, cache for next time, yield first
            await new Promise(r => setTimeout(r, 0));
            const group = await buildingTypes[type].create();
            _tagUserDataRefs(group);
            _modelCache.set(type, group);
            compileShaders(); // compile any new shaders from this build
            // Return a clone so the cached template stays clean
            return _cloneModel(type) || group;
        }

        async function init() {
            setLoadingProgress(2, 'Initializing...');
            console.log('\u2699\ufe0f Initializing texture cache...');
            await textureCache.init();
            setLoadingProgress(8, 'Starting engine...');
            updateUI();
            animate();
            // startAmbientSounds deferred to click-to-play to avoid AudioContext suspension issues
            validateAllItemsHaveIcons();
            await prewarmModels();
            const stats = textureCache.getStats();
            console.log('\ud83d\udcca Texture Cache Stats:', stats);
            if (stats.hits > 0) console.log(`\u26a1 Speed boost! ${stats.hits} textures loaded from cache instantly!`);
            if (stats.generated > 0) console.log(`\u2705 ${stats.generated} textures generated and cached for next time.`);
            finishLoading();
        }

        // Wait for THREE.js to be available then init
        init();
        } // end startGame
    </script>
</body>
</html>
